function _slicedToArray(e, t) {
    return _arrayWithHoles(e) || _iterableToArrayLimit(e, t) || _unsupportedIterableToArray(e, t) || _nonIterableRest()
}

function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(e, t) {
    if (e) {
        if ("string" == typeof e) return _arrayLikeToArray(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(e, t) : void 0
    }
}

function _arrayLikeToArray(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function _iterableToArrayLimit(e, t) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) {
        var n = [],
            r = !0,
            i = !1,
            a = void 0;
        try {
            for (var o, s = e[Symbol.iterator](); !(r = (o = s.next()).done) && (n.push(o.value), !t || n.length !== t); r = !0);
        } catch (e) {
            i = !0, a = e
        } finally {
            try {
                r || null == s.return || s.return()
            } finally {
                if (i) throw a
            }
        }
        return n
    }
}

function _arrayWithHoles(e) {
    if (Array.isArray(e)) return e
}

function _readOnlyError(e) {
    throw new TypeError('"' + e + '" is read-only')
}

function _defineProperty(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function _get(e, t, n) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
        e = _superPropBase(e, t);
        if (e) {
            t = Object.getOwnPropertyDescriptor(e, t);
            return t.get ? t.get.call(n) : t.value
        }
    })(e, t, n || e)
}

function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)););
    return e
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t)
}

function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
        return e.__proto__ = t, e
    })(e, t)
}

function _createSuper(n) {
    var r = _isNativeReflectConstruct();
    return function() {
        var e, t = _getPrototypeOf(n);
        return _possibleConstructorReturn(this, r ? (e = _getPrototypeOf(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments))
    }
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" != typeof t && "function" != typeof t ? _assertThisInitialized(e) : t
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function _isNativeReflectConstruct() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
    } catch (e) {
        return !1
    }
}

function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    })(e)
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
    }
}

function _createClass(e, t, n) {
    return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e
}! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).v3d = {})
}(this, function(t) {
    "use strict";

    function n() {}
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : 0 < e ? 1 : +e
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null != r)
                for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
        }
        return t
    }), void 0 === Object.values && (Object.values = function(e) {
        var t, n = [];
        for (t in e) e.hasOwnProperty(t) && n.push(e[t]);
        return n
    }), void 0 === Float32Array.prototype.slice && (Float32Array.prototype.slice = function(e, t) {
        return new this.constructor(this.subarray(e, t))
    }), String.prototype.endsWith || (String.prototype.endsWith = function(e, t) {
        return (void 0 === t || t > this.length) && (t = this.length), this.substring(t - e.length, t) === e
    }), Object.assign(n.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            void 0 !== this._listeners && (void 0 === (e = this._listeners[e]) || -1 !== (t = e.indexOf(t)) && e.splice(t, 1))
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e)
                }
            }
        }
    });
    for (var Pe = "3.6.1", de = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }, G = 0, j = 1, W = 2, K = 0, J = 1, $ = 2, ee = 3, te = 4, ne = 5, re = 6, ie = 0, ae = 1, oe = 2, se = 0, H = 1, X = 2, Y = 3, q = 4, Z = 5, Q = 100, le = 101, ce = 102, ue = 103, he = 104, fe = 200, pe = 201, me = 202, ve = 203, ge = 204, _e = 205, ye = 206, xe = 207, be = 208, Me = 209, we = 210, Se = 0, Ae = 1, Te = 2, Ee = 3, Ce = 4, Le = 5, Re = 6, De = 7, T = 0, E = 1, C = 2, L = 0, Oe = 1, P = 2, R = 3, D = 4, Ne = 6, Ie = 7, O = 8, o = 300, N = 301, I = 302, F = 303, k = 304, B = 306, z = 307, U = 1e3, V = 1001, Fe = 1002, ke = 1003, Be = 1004, ze = 1005, Ue = 1006, Ve = 1007, Ge = 1008, je = 1009, i = 1010, a = 1011, We = 1012, s = 1013, He = 1014, Xe = 1015, Ye = 1016, l = 1017, c = 1018, u = 1019, qe = 1020, d = 1021, Ze = 1022, Qe = 1023, h = 1024, f = 1025, w = Qe, Ke = 1026, Je = 1027, $e = 1028, p = 1029, m = 1030, v = 1031, g = 1032, _ = 1033, y = 33776, x = 33777, b = 33778, M = 33779, S = 35840, A = 35841, et = 35842, tt = 35843, nt = 36196, rt = 37492, it = 37496, at = 37808, ot = 37809, st = 37810, lt = 37811, ct = 37812, ut = 37813, dt = 37814, ht = 37815, ft = 37816, pt = 37817, mt = 37818, vt = 37819, gt = 37820, _t = 37821, yt = 36492, xt = 37840, bt = 37841, Mt = 37842, wt = 37843, St = 37844, At = 37845, Tt = 37846, Et = 37847, Ct = 37848, Lt = 37849, Pt = 37850, Rt = 37851, Dt = 37852, Ot = 37853, Nt = 2201, It = 2300, Ft = 2301, kt = 2302, Bt = 2400, zt = 2401, Ut = 2402, Vt = 3e3, Gt = 3001, r = 3007, jt = 3002, Wt = 3003, Ht = 3004, Xt = 3005, Yt = 3006, qt = 3200, Zt = 3201, Qt = 3301, Kt = 3302, Jt = 0, $t = 1, en = 7680, tn = 519, nn = 35044, rn = 35048, an = "300 es", on = "BLENDER", sn = "__V3DL__bddf7a835a", ln = 0, cn = 0, un = 0, dn = [], hn = 0; hn < 256; hn++) dn[hn] = (hn < 16 ? "0" : "") + hn.toString(16);
    var fn, pn = 1234567,
        mn = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (dn[255 & e] + dn[e >> 8 & 255] + dn[e >> 16 & 255] + dn[e >> 24 & 255] + "-" + dn[255 & t] + dn[t >> 8 & 255] + "-" + dn[t >> 16 & 15 | 64] + dn[t >> 24 & 255] + "-" + dn[63 & n | 128] + dn[n >> 8 & 255] + "-" + dn[n >> 16 & 255] + dn[n >> 24 & 255] + dn[255 & r] + dn[r >> 8 & 255] + dn[r >> 16 & 255] + dn[r >> 24 & 255]).toUpperCase()
            },
            clamp: function(e, t, n) {
                return Math.max(t, Math.min(n, e))
            },
            euclideanModulo: function(e, t) {
                return (e % t + t) % t
            },
            mapLinear: function(e, t, n, r, i) {
                return r + (e - t) * (i - r) / (n - t)
            },
            lerp: function(e, t, n) {
                return (1 - n) * e + n * t
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                return void 0 !== e && (pn = e % 2147483647), ((pn = 16807 * pn % 2147483647) - 1) / 2147483646
            },
            degToRad: function(e) {
                return e * mn.DEG2RAD
            },
            radToDeg: function(e) {
                return e * mn.RAD2DEG
            },
            isPowerOfTwo: function(e) {
                return 0 == (e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(e, t, n, r, i) {
                var a = Math.cos,
                    o = Math.sin,
                    s = a(n / 2),
                    l = o(n / 2),
                    c = a((t + r) / 2),
                    u = o((t + r) / 2),
                    d = a((t - r) / 2),
                    h = o((t - r) / 2),
                    f = a((r - t) / 2),
                    p = o((r - t) / 2);
                switch (i) {
                    case "XYX":
                        e.set(s * u, l * d, l * h, s * c);
                        break;
                    case "YZY":
                        e.set(l * h, s * u, l * d, s * c);
                        break;
                    case "ZXZ":
                        e.set(l * d, l * h, s * u, s * c);
                        break;
                    case "XZX":
                        e.set(s * u, l * p, l * f, s * c);
                        break;
                    case "YXY":
                        e.set(l * f, s * u, l * p, s * c);
                        break;
                    case "ZYZ":
                        e.set(l * p, l * f, s * u, s * c);
                        break;
                    default:
                        console.warn("v3d.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            },
            hashString: function(e) {
                for (var t = 5381, n = e.length; n;) t = 33 * t ^ e.charCodeAt(--n);
                return t >>> 0
            },
            expAverage: function(e, t, n, r) {
                r = Math.exp(-n / r);
                return e * r + (1 - r) * t
            },
            expAverageClamp: function(e, t, n, r, i) {
                r = this.expAverage(e, t, n, r);
                return Math.abs(e - t) < i && (r = t), r
            },
            angleToRange_0_2Pi: function(e) {
                return this.clamp(e - 2 * Math.PI * Math.floor(e / (2 * Math.PI)), 0, 2 * Math.PI)
            },
            angleToRange_mPi_Pi: function(e) {
                e += Math.PI;
                return e %= 2 * Math.PI, e += 2 * Math.PI, e %= 2 * Math.PI, e -= Math.PI
            },
            clampAngle: function(e, t, n) {
                e = this.angleToRange_0_2Pi(e - t), n = this.angleToRange_0_2Pi(n - t);
                return n < e && (e = e < n / 2 + Math.PI ? n : 0), e + t
            }
        },
        vn = function() {
            function n() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, n), Object.defineProperty(this, "isVector2", {
                    value: !0
                }), this.x = e, this.y = t
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.x = e, this.y = t, this
                }
            }, {
                key: "setScalar",
                value: function(e) {
                    return this.x = e, this.y = e, this
                }
            }, {
                key: "setX",
                value: function(e) {
                    return this.x = e, this
                }
            }, {
                key: "setY",
                value: function(e) {
                    return this.y = e, this
                }
            }, {
                key: "setComponent",
                value: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
            }, {
                key: "getComponent",
                value: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this.x, this.y)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.x = e.x, this.y = e.y, this
                }
            }, {
                key: "add",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector2: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                }
            }, {
                key: "addScalar",
                value: function(e) {
                    return this.x += e, this.y += e, this
                }
            }, {
                key: "addVectors",
                value: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
            }, {
                key: "addScaledVector",
                value: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
            }, {
                key: "sub",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector2: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                }
            }, {
                key: "subScalar",
                value: function(e) {
                    return this.x -= e, this.y -= e, this
                }
            }, {
                key: "subVectors",
                value: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
            }, {
                key: "multiply",
                value: function(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
            }, {
                key: "multiplyScalar",
                value: function(e) {
                    return this.x *= e, this.y *= e, this
                }
            }, {
                key: "divide",
                value: function(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
            }, {
                key: "divideScalar",
                value: function(e) {
                    return this.multiplyScalar(1 / e)
                }
            }, {
                key: "applyMatrix3",
                value: function(e) {
                    var t = this.x,
                        n = this.y,
                        e = e.elements;
                    return this.x = e[0] * t + e[3] * n + e[6], this.y = e[1] * t + e[4] * n + e[7], this
                }
            }, {
                key: "min",
                value: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
            }, {
                key: "max",
                value: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
            }, {
                key: "clamp",
                value: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
            }, {
                key: "clampScalar",
                value: function(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
            }, {
                key: "clampLength",
                value: function(e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
            }, {
                key: "floor",
                value: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
            }, {
                key: "ceil",
                value: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
            }, {
                key: "round",
                value: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
            }, {
                key: "roundToZero",
                value: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
            }, {
                key: "negate",
                value: function() {
                    return this.x = -this.x, this.y = -this.y, this
                }
            }, {
                key: "dot",
                value: function(e) {
                    return this.x * e.x + this.y * e.y
                }
            }, {
                key: "cross",
                value: function(e) {
                    return this.x * e.y - this.y * e.x
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this.x * this.x + this.y * this.y
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
            }, {
                key: "manhattanLength",
                value: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
            }, {
                key: "normalize",
                value: function() {
                    return this.divideScalar(this.length() || 1)
                }
            }, {
                key: "angle",
                value: function() {
                    var e = Math.atan2(-this.y, -this.x) + Math.PI;
                    return e
                }
            }, {
                key: "distanceTo",
                value: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
            }, {
                key: "distanceToSquared",
                value: function(e) {
                    var t = this.x - e.x,
                        e = this.y - e.y;
                    return t * t + e * e
                }
            }, {
                key: "manhattanDistanceTo",
                value: function(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
            }, {
                key: "setLength",
                value: function(e) {
                    return this.normalize().multiplyScalar(e)
                }
            }, {
                key: "lerp",
                value: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
            }, {
                key: "lerpVectors",
                value: function(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.x === this.x && e.y === this.y
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return this.x = e[t], this.y = e[t + 1], this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
            }, {
                key: "fromBufferAttribute",
                value: function(e, t, n) {
                    return void 0 !== n && console.warn("v3d.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                }
            }, {
                key: "rotateAround",
                value: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        t = this.y - e.y;
                    return this.x = i * n - t * r + e.x, this.y = i * r + t * n + e.y, this
                }
            }, {
                key: "random",
                value: function() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }, {
                key: "width",
                get: function() {
                    return this.x
                },
                set: function(e) {
                    this.x = e
                }
            }, {
                key: "height",
                get: function() {
                    return this.y
                },
                set: function(e) {
                    this.y = e
                }
            }]), n
        }(),
        gn = function() {
            function e() {
                _classCallCheck(this, e), Object.defineProperty(this, "isMatrix3", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("v3d.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            return _createClass(e, [{
                key: "set",
                value: function(e, t, n, r, i, a, o, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }, {
                key: "copy",
                value: function(e) {
                    var t = this.elements,
                        e = e.elements;
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
                }
            }, {
                key: "extractBasis",
                value: function(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
            }, {
                key: "setFromMatrix4",
                value: function(e) {
                    e = e.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
            }, {
                key: "multiply",
                value: function(e) {
                    return this.multiplyMatrices(this, e)
                }
            }, {
                key: "premultiply",
                value: function(e) {
                    return this.multiplyMatrices(e, this)
                }
            }, {
                key: "multiplyMatrices",
                value: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        d = n[2],
                        h = n[5],
                        f = n[8],
                        p = r[0],
                        m = r[3],
                        v = r[6],
                        g = r[1],
                        _ = r[4],
                        e = r[7],
                        t = r[2],
                        n = r[5],
                        r = r[8];
                    return i[0] = a * p + o * g + s * t, i[3] = a * m + o * _ + s * n, i[6] = a * v + o * e + s * r, i[1] = l * p + c * g + u * t, i[4] = l * m + c * _ + u * n, i[7] = l * v + c * e + u * r, i[2] = d * p + h * g + f * t, i[5] = d * m + h * _ + f * n, i[8] = d * v + h * e + f * r, this
                }
            }, {
                key: "multiplyScalar",
                value: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
            }, {
                key: "determinant",
                value: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        e = e[8];
                    return t * a * e - t * o * l - n * i * e + n * o * s + r * i * l - r * a * s
                }
            }, {
                key: "invert",
                value: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8],
                        u = c * a - o * l,
                        d = o * s - c * i,
                        h = l * i - a * s,
                        f = t * u + n * d + r * h;
                    if (0 == f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    f = 1 / f;
                    return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * a) * f, e[3] = d * f, e[4] = (c * t - r * s) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * s - l * t) * f, e[8] = (a * t - n * i) * f, this
                }
            }, {
                key: "transpose",
                value: function() {
                    var e = this.elements,
                        t = e[1];
                    return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
            }, {
                key: "getNormalMatrix",
                value: function(e) {
                    return this.setFromMatrix4(e).copy(this).invert().transpose()
                }
            }, {
                key: "transposeIntoArray",
                value: function(e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
            }, {
                key: "setUvTransform",
                value: function(e, t, n, r, i, a, o) {
                    var s = Math.cos(i),
                        i = Math.sin(i);
                    return this.set(n * s, n * i, -n * (s * a + i * o) + a + e, -r * i, r * s, -r * (-i * a + s * o) + o + t, 0, 0, 1), this
                }
            }, {
                key: "scale",
                value: function(e, t) {
                    var n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                }
            }, {
                key: "rotate",
                value: function(e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        r = this.elements,
                        i = r[0],
                        a = r[3],
                        o = r[6],
                        s = r[1],
                        l = r[4],
                        e = r[7];
                    return r[0] = t * i + n * s, r[3] = t * a + n * l, r[6] = t * o + n * e, r[1] = -n * i + t * s, r[4] = -n * a + t * l, r[7] = -n * o + t * e, this
                }
            }, {
                key: "translate",
                value: function(e, t) {
                    var n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                }
            }, {
                key: "equals",
                value: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            }]), e
        }(),
        _n = {
            getDataURL: function(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                var t, e = e instanceof HTMLCanvasElement ? e : (void 0 === fn && (fn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), fn.width = e.width, fn.height = e.height, t = fn.getContext("2d"), e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), fn);
                return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        yn = 0;

    function xn() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : xn.DEFAULT_IMAGE,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : xn.DEFAULT_MAPPING,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : V,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : V,
            i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : Ue,
            a = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : Ge,
            o = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : Qe,
            s = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : je,
            l = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 1,
            c = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : Vt;
        Object.defineProperty(this, "id", {
            value: yn++
        }), this.uuid = mn.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new vn(0, 0), this.repeat = new vn(1, 1), this.center = new vn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new gn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null
    }

    function bn(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? _n.getDataURL(e) : e.data ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : (console.warn("v3d.Texture: Unable to serialize Texture."), {})
    }
    xn.DEFAULT_IMAGE = void 0, xn.DEFAULT_MAPPING = o, xn.prototype = Object.assign(Object.create(n.prototype), {
        constructor: xn,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var r, i = this.image;
                if (void 0 === i.uuid && (i.uuid = mn.generateUUID()), !t && void 0 === e.images[i.uuid]) {
                    if (Array.isArray(i)) {
                        r = [];
                        for (var a = 0, o = i.length; a < o; a++) i[a].isDataTexture ? r.push(bn(i[a].image)) : r.push(bn(i[a]))
                    } else r = bn(i);
                    e.images[i.uuid] = {
                        uuid: i.uuid,
                        url: r
                    }
                }
                n.image = i.uuid
            }
            return t || (e.textures[this.uuid] = n), n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (this.mapping !== o) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                case U:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case V:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case Fe:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                case U:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case V:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case Fe:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(xn.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    });
    var Mn = function() {
        function i() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, i), Object.defineProperty(this, "isVector4", {
                value: !0
            }), this.x = e, this.y = t, this.z = n, this.w = r
        }
        return _createClass(i, [{
            key: "set",
            value: function(e, t, n, r) {
                return this.x = e, this.y = t, this.z = n, this.w = r, this
            }
        }, {
            key: "setScalar",
            value: function(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
        }, {
            key: "setX",
            value: function(e) {
                return this.x = e, this
            }
        }, {
            key: "setY",
            value: function(e) {
                return this.y = e, this
            }
        }, {
            key: "setZ",
            value: function(e) {
                return this.z = e, this
            }
        }, {
            key: "setW",
            value: function(e) {
                return this.w = e, this
            }
        }, {
            key: "setComponent",
            value: function(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
        }, {
            key: "getComponent",
            value: function(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
        }, {
            key: "clone",
            value: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
        }, {
            key: "copy",
            value: function(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            }
        }, {
            key: "add",
            value: function(e, t) {
                return void 0 !== t ? (console.warn("v3d.Vector4: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            }
        }, {
            key: "addScalar",
            value: function(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
        }, {
            key: "addVectors",
            value: function(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            }
        }, {
            key: "addScaledVector",
            value: function(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            }
        }, {
            key: "sub",
            value: function(e, t) {
                return void 0 !== t ? (console.warn("v3d.Vector4: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            }
        }, {
            key: "subScalar",
            value: function(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
        }, {
            key: "subVectors",
            value: function(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            }
        }, {
            key: "multiplyScalar",
            value: function(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
        }, {
            key: "applyMatrix4",
            value: function(e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    e = e.elements;
                return this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, this
            }
        }, {
            key: "divideScalar",
            value: function(e) {
                return this.multiplyScalar(1 / e)
            }
        }, {
            key: "setAxisAngleFromQuaternion",
            value: function(e) {
                this.w = 2 * Math.acos(e.w);
                var t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            }
        }, {
            key: "setAxisAngleFromRotationMatrix",
            value: function(e) {
                var t, n, r, i = e.elements,
                    a = i[0],
                    o = i[4],
                    s = i[8],
                    l = i[1],
                    c = i[5],
                    u = i[9],
                    d = i[2],
                    h = i[6],
                    f = i[10];
                if (Math.abs(o - l) < .01 && Math.abs(s - d) < .01 && Math.abs(u - h) < .01) {
                    if (Math.abs(o + l) < .1 && Math.abs(s + d) < .1 && Math.abs(u + h) < .1 && Math.abs(a + c + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                    _ = Math.PI;
                    var p = (a + 1) / 2,
                        m = (c + 1) / 2,
                        v = (f + 1) / 2,
                        g = (o + l) / 4,
                        e = (s + d) / 4,
                        i = (u + h) / 4;
                    return m < p && v < p ? r = p < .01 ? (t = 0, n = .707106781) : (n = g / (t = Math.sqrt(p)), e / t) : v < m ? r = m < .01 ? (n = 0, t = .707106781) : (t = g / (n = Math.sqrt(m)), i / n) : v < .01 ? (n = t = .707106781, r = 0) : (t = e / (r = Math.sqrt(v)), n = i / r), this.set(t, n, r, _), this
                }
                var _ = Math.sqrt((h - u) * (h - u) + (s - d) * (s - d) + (l - o) * (l - o));
                return Math.abs(_) < .001 && (_ = 1), this.x = (h - u) / _, this.y = (s - d) / _, this.z = (l - o) / _, this.w = Math.acos((a + c + f - 1) / 2), this
            }
        }, {
            key: "min",
            value: function(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
        }, {
            key: "max",
            value: function(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
        }, {
            key: "clamp",
            value: function(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            }
        }, {
            key: "clampScalar",
            value: function(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            }
        }, {
            key: "clampLength",
            value: function(e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
        }, {
            key: "floor",
            value: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
        }, {
            key: "ceil",
            value: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
        }, {
            key: "round",
            value: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
        }, {
            key: "roundToZero",
            value: function() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            }
        }, {
            key: "negate",
            value: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
        }, {
            key: "dot",
            value: function(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
        }, {
            key: "lengthSq",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
        }, {
            key: "manhattanLength",
            value: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
        }, {
            key: "normalize",
            value: function() {
                return this.divideScalar(this.length() || 1)
            }
        }, {
            key: "setLength",
            value: function(e) {
                return this.normalize().multiplyScalar(e)
            }
        }, {
            key: "lerp",
            value: function(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            }
        }, {
            key: "lerpVectors",
            value: function(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
            }
        }, {
            key: "equals",
            value: function(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            }
        }, {
            key: "toArray",
            value: function() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            }
        }, {
            key: "fromBufferAttribute",
            value: function(e, t, n) {
                return void 0 !== n && console.warn("v3d.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
        }, {
            key: "random",
            value: function() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }
        }, {
            key: "width",
            get: function() {
                return this.z
            },
            set: function(e) {
                this.z = e
            }
        }, {
            key: "height",
            get: function() {
                return this.w
            },
            set: function(e) {
                this.w = e
            }
        }]), i
    }();

    function wn(e, t, n) {
        this.width = e, this.height = t, this.scissor = new Mn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Mn(0, 0, e, t), n = n || {}, this.texture = new xn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ue, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function Sn(e, t, n) {
        wn.call(this, e, t, n), this.samples = 4
    }
    wn.prototype = Object.assign(Object.create(n.prototype), {
        constructor: wn,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Sn.prototype = Object.assign(Object.create(wn.prototype), {
        constructor: Sn,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return wn.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    });
    var An = function() {
            function i() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                _classCallCheck(this, i), Object.defineProperty(this, "isQuaternion", {
                    value: !0
                }), this._x = e, this._y = t, this._z = n, this._w = r
            }
            return _createClass(i, [{
                key: "set",
                value: function(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
            }, {
                key: "setFromEuler",
                value: function(e, t) {
                    if (!e || !e.isEuler) throw new Error("v3d.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        a = e._order,
                        o = Math.cos,
                        e = Math.sin,
                        s = o(n / 2),
                        l = o(r / 2),
                        c = o(i / 2),
                        u = e(n / 2),
                        d = e(r / 2),
                        h = e(i / 2);
                    switch (a) {
                        case "XYZ":
                            this._x = u * l * c + s * d * h, this._y = s * d * c - u * l * h, this._z = s * l * h + u * d * c, this._w = s * l * c - u * d * h;
                            break;
                        case "YXZ":
                            this._x = u * l * c + s * d * h, this._y = s * d * c - u * l * h, this._z = s * l * h - u * d * c, this._w = s * l * c + u * d * h;
                            break;
                        case "ZXY":
                            this._x = u * l * c - s * d * h, this._y = s * d * c + u * l * h, this._z = s * l * h + u * d * c, this._w = s * l * c - u * d * h;
                            break;
                        case "ZYX":
                            this._x = u * l * c - s * d * h, this._y = s * d * c + u * l * h, this._z = s * l * h - u * d * c, this._w = s * l * c + u * d * h;
                            break;
                        case "YZX":
                            this._x = u * l * c + s * d * h, this._y = s * d * c + u * l * h, this._z = s * l * h - u * d * c, this._w = s * l * c - u * d * h;
                            break;
                        case "XZY":
                            this._x = u * l * c - s * d * h, this._y = s * d * c - u * l * h, this._z = s * l * h + u * d * c, this._w = s * l * c + u * d * h;
                            break;
                        default:
                            console.warn("v3d.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
            }, {
                key: "setFromAxisAngle",
                value: function(e, t) {
                    var n = t / 2,
                        t = Math.sin(n);
                    return this._x = e.x * t, this._y = e.y * t, this._z = e.z * t, this._w = Math.cos(n), this._onChangeCallback(), this
                }
            }, {
                key: "setFromRotationMatrix",
                value: function(e) {
                    var t, n = e.elements,
                        r = n[0],
                        i = n[4],
                        a = n[8],
                        o = n[1],
                        s = n[5],
                        l = n[9],
                        c = n[2],
                        u = n[6],
                        e = n[10],
                        n = r + s + e;
                    return 0 < n ? (n = .5 / Math.sqrt(n + 1), this._w = .25 / n, this._x = (u - l) * n, this._y = (a - c) * n, this._z = (o - i) * n) : s < r && e < r ? (t = 2 * Math.sqrt(1 + r - s - e), this._w = (u - l) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (a + c) / t) : e < s ? (t = 2 * Math.sqrt(1 + s - r - e), this._w = (a - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (l + u) / t) : (s = 2 * Math.sqrt(1 + e - r - s), this._w = (o - i) / s, this._x = (a + c) / s, this._y = (l + u) / s, this._z = .25 * s), this._onChangeCallback(), this
                }
            }, {
                key: "setFromUnitVectors",
                value: function(e, t) {
                    var n = e.dot(t) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize()
                }
            }, {
                key: "angleTo",
                value: function(e) {
                    return 2 * Math.acos(Math.abs(mn.clamp(this.dot(e), -1, 1)))
                }
            }, {
                key: "rotateTowards",
                value: function(e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    n = Math.min(1, t / n);
                    return this.slerp(e, n), this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(0, 0, 0, 1)
                }
            }, {
                key: "invert",
                value: function() {
                    return this.conjugate()
                }
            }, {
                key: "conjugate",
                value: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
            }, {
                key: "dot",
                value: function(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
            }, {
                key: "normalize",
                value: function() {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
            }, {
                key: "multiply",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions(a, b) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                }
            }, {
                key: "premultiply",
                value: function(e) {
                    return this.multiplyQuaternions(e, this)
                }
            }, {
                key: "multiplyQuaternions",
                value: function(e, t) {
                    var n = e._x,
                        r = e._y,
                        i = e._z,
                        a = e._w,
                        o = t._x,
                        s = t._y,
                        e = t._z,
                        t = t._w;
                    return this._x = n * t + a * o + r * e - i * s, this._y = r * t + a * s + i * o - n * e, this._z = i * t + a * e + n * s - r * o, this._w = a * t - n * o - r * s - i * e, this._onChangeCallback(), this
                }
            }, {
                key: "slerp",
                value: function(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        r = this._y,
                        i = this._z,
                        a = this._w,
                        o = a * e._w + n * e._x + r * e._y + i * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                    e = 1 - o * o;
                    if (e <= Number.EPSILON) {
                        var s = 1 - t;
                        return this._w = s * a + t * this._w, this._x = s * n + t * this._x, this._y = s * r + t * this._y, this._z = s * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    s = Math.sqrt(e), e = Math.atan2(s, o), o = Math.sin((1 - t) * e) / s, s = Math.sin(t * e) / s;
                    return this._w = a * o + this._w * s, this._x = n * o + this._x * s, this._y = r * o + this._y * s, this._z = i * o + this._z * s, this._onChangeCallback(), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
            }, {
                key: "fromBufferAttribute",
                value: function(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
            }, {
                key: "_onChange",
                value: function(e) {
                    return this._onChangeCallback = e, this
                }
            }, {
                key: "_onChangeCallback",
                value: function() {}
            }, {
                key: "x",
                get: function() {
                    return this._x
                },
                set: function(e) {
                    this._x = e, this._onChangeCallback()
                }
            }, {
                key: "y",
                get: function() {
                    return this._y
                },
                set: function(e) {
                    this._y = e, this._onChangeCallback()
                }
            }, {
                key: "z",
                get: function() {
                    return this._z
                },
                set: function(e) {
                    this._z = e, this._onChangeCallback()
                }
            }, {
                key: "w",
                get: function() {
                    return this._w
                },
                set: function(e) {
                    this._w = e, this._onChangeCallback()
                }
            }], [{
                key: "slerp",
                value: function(e, t, n, r) {
                    return n.copy(e).slerp(t, r)
                }
            }, {
                key: "slerpFlat",
                value: function(e, t, n, r, i, a, o) {
                    var s = n[r + 0],
                        l = n[r + 1],
                        c = n[r + 2],
                        u = n[r + 3],
                        d = i[a + 0],
                        h = i[a + 1],
                        f = i[a + 2],
                        p = i[a + 3];
                    u === p && s === d && l === h && c === f || (n = 1 - o, i = 0 <= (r = s * d + l * h + c * f + u * p) ? 1 : -1, (a = 1 - r * r) > Number.EPSILON && (a = Math.sqrt(a), r = Math.atan2(a, r * i), n = Math.sin(n * r) / a, o = Math.sin(o * r) / a), s = s * n + d * (i = o * i), l = l * n + h * i, c = c * n + f * i, u = u * n + p * i, n === 1 - o && (s *= o = 1 / Math.sqrt(s * s + l * l + c * c + u * u), l *= o, c *= o, u *= o)), e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
            }, {
                key: "multiplyQuaternionsFlat",
                value: function(e, t, n, r, i, a) {
                    var o = n[r],
                        s = n[r + 1],
                        l = n[r + 2],
                        c = n[r + 3],
                        u = i[a],
                        n = i[a + 1],
                        r = i[a + 2],
                        a = i[a + 3];
                    return e[t] = o * a + c * u + s * r - l * n, e[t + 1] = s * a + c * n + l * u - o * r, e[t + 2] = l * a + c * r + o * n - s * u, e[t + 3] = c * a - o * u - s * n - l * r, e
                }
            }]), i
        }(),
        Tn = function() {
            function r() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                _classCallCheck(this, r), Object.defineProperty(this, "isVector3", {
                    value: !0
                }), this.x = e, this.y = t, this.z = n
            }
            return _createClass(r, [{
                key: "set",
                value: function(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
            }, {
                key: "setScalar",
                value: function(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
            }, {
                key: "setX",
                value: function(e) {
                    return this.x = e, this
                }
            }, {
                key: "setY",
                value: function(e) {
                    return this.y = e, this
                }
            }, {
                key: "setZ",
                value: function(e) {
                    return this.z = e, this
                }
            }, {
                key: "setComponent",
                value: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
            }, {
                key: "getComponent",
                value: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this.x, this.y, this.z)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
            }, {
                key: "add",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector3: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                }
            }, {
                key: "addScalar",
                value: function(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
            }, {
                key: "addVectors",
                value: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
            }, {
                key: "addScaledVector",
                value: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
            }, {
                key: "sub",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector3: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                }
            }, {
                key: "subScalar",
                value: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
            }, {
                key: "subVectors",
                value: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
            }, {
                key: "multiply",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors(a, b) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                }
            }, {
                key: "multiplyScalar",
                value: function(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
            }, {
                key: "multiplyVectors",
                value: function(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
            }, {
                key: "applyEuler",
                value: function(e) {
                    return e && e.isEuler || console.error("v3d.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Cn.setFromEuler(e))
                }
            }, {
                key: "applyAxisAngle",
                value: function(e, t) {
                    return this.applyQuaternion(Cn.setFromAxisAngle(e, t))
                }
            }, {
                key: "applyMatrix3",
                value: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        e = e.elements;
                    return this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, this.z = e[2] * t + e[5] * n + e[8] * r, this
                }
            }, {
                key: "applyNormalMatrix",
                value: function(e) {
                    return this.applyMatrix3(e).normalize()
                }
            }, {
                key: "applyMatrix4",
                value: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        e = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * e, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * e, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * e, this
                }
            }, {
                key: "applyQuaternion",
                value: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = s * t + a * r - o * n,
                        c = s * n + o * t - i * r,
                        e = s * r + i * n - a * t,
                        r = -i * t - a * n - o * r;
                    return this.x = l * s + r * -i + c * -o - e * -a, this.y = c * s + r * -a + e * -i - l * -o, this.z = e * s + r * -o + l * -a - c * -i, this
                }
            }, {
                key: "project",
                value: function(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
            }, {
                key: "unproject",
                value: function(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
            }, {
                key: "transformDirection",
                value: function(e) {
                    var t = this.x,
                        n = this.y,
                        r = this.z,
                        e = e.elements;
                    return this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize()
                }
            }, {
                key: "divide",
                value: function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
            }, {
                key: "divideScalar",
                value: function(e) {
                    return this.multiplyScalar(1 / e)
                }
            }, {
                key: "min",
                value: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
            }, {
                key: "max",
                value: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
            }, {
                key: "clamp",
                value: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
            }, {
                key: "clampScalar",
                value: function(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
            }, {
                key: "clampLength",
                value: function(e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
            }, {
                key: "floor",
                value: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
            }, {
                key: "ceil",
                value: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
            }, {
                key: "round",
                value: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
            }, {
                key: "roundToZero",
                value: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
            }, {
                key: "negate",
                value: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
            }, {
                key: "dot",
                value: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
            }, {
                key: "lengthSq",
                value: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
            }, {
                key: "length",
                value: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
            }, {
                key: "manhattanLength",
                value: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
            }, {
                key: "normalize",
                value: function() {
                    return this.divideScalar(this.length() || 1)
                }
            }, {
                key: "setLength",
                value: function(e) {
                    return this.normalize().multiplyScalar(e)
                }
            }, {
                key: "lerp",
                value: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
            }, {
                key: "lerpVectors",
                value: function(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
            }, {
                key: "cross",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Vector3: .cross() now only accepts one argument. Use .crossVectors(a, b) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                }
            }, {
                key: "crossVectors",
                value: function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = e.z,
                        a = t.x,
                        e = t.y,
                        t = t.z;
                    return this.x = r * t - i * e, this.y = i * a - n * t, this.z = n * e - r * a, this
                }
            }, {
                key: "projectOnVector",
                value: function(e) {
                    var t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    t = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(t)
                }
            }, {
                key: "projectOnPlane",
                value: function(e) {
                    return En.copy(this).projectOnVector(e), this.sub(En)
                }
            }, {
                key: "reflect",
                value: function(e) {
                    return this.sub(En.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }, {
                key: "angleTo",
                value: function(e) {
                    var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    t = this.dot(e) / t;
                    return Math.acos(mn.clamp(t, -1, 1))
                }
            }, {
                key: "distanceTo",
                value: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
            }, {
                key: "distanceToSquared",
                value: function(e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        e = this.z - e.z;
                    return t * t + n * n + e * e
                }
            }, {
                key: "manhattanDistanceTo",
                value: function(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
            }, {
                key: "setFromSpherical",
                value: function(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
            }, {
                key: "setFromSphericalCoords",
                value: function(e, t, n) {
                    var r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                }
            }, {
                key: "setFromCylindrical",
                value: function(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
            }, {
                key: "setFromCylindricalCoords",
                value: function(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
            }, {
                key: "setFromMatrixPosition",
                value: function(e) {
                    e = e.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
            }, {
                key: "setFromMatrixScale",
                value: function(e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        e = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = e, this
                }
            }, {
                key: "setFromMatrixColumn",
                value: function(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
            }, {
                key: "setFromMatrix3Column",
                value: function(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
            }, {
                key: "fromBufferAttribute",
                value: function(e, t, n) {
                    return void 0 !== n && console.warn("v3d.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
            }, {
                key: "random",
                value: function() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }]), r
        }(),
        En = new Tn,
        Cn = new An,
        Ln = function() {
            function n(e, t) {
                _classCallCheck(this, n), Object.defineProperty(this, "isBox3", {
                    value: !0
                }), this.min = void 0 !== e ? e : new Tn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Tn(-1 / 0, -1 / 0, -1 / 0)
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
            }, {
                key: "setFromArray",
                value: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                        var c = e[s],
                            u = e[s + 1],
                            d = e[s + 2];
                        c < t && (t = c), u < n && (n = u), d < r && (r = d), i < c && (i = c), a < u && (a = u), o < d && (o = d)
                    }
                    return this.min.set(t, n, r), this.max.set(i, a, o), this
                }
            }, {
                key: "setFromBufferAttribute",
                value: function(e) {
                    for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) {
                        var c = e.getX(s),
                            u = e.getY(s),
                            d = e.getZ(s);
                        c < t && (t = c), u < n && (n = u), d < r && (r = d), i < c && (i = c), a < u && (a = u), o < d && (o = d)
                    }
                    return this.min.set(t, n, r), this.max.set(i, a, o), this
                }
            }, {
                key: "setFromPoints",
                value: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
            }, {
                key: "setFromCenterAndSize",
                value: function(e, t) {
                    t = Dn.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(t), this.max.copy(e).add(t), this
                }
            }, {
                key: "setFromObject",
                value: function(e) {
                    return this.makeEmpty(), this.expandByObject(e)
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
            }, {
                key: "makeEmpty",
                value: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
            }, {
                key: "isEmpty",
                value: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
            }, {
                key: "getCenter",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Box3: .getCenter() target is now required"), e = new Tn), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
            }, {
                key: "getSize",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Box3: .getSize() target is now required"), e = new Tn), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
            }, {
                key: "expandByPoint",
                value: function(e) {
                    return this.min.min(e), this.max.max(e), this
                }
            }, {
                key: "expandByVector",
                value: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
            }, {
                key: "expandByScalar",
                value: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
            }, {
                key: "expandByObject",
                value: function(e) {
                    e.updateWorldMatrix(!1, !1);
                    var t = e.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), On.copy(t.boundingBox), On.applyMatrix4(e.matrixWorld), this.union(On));
                    for (var n = e.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
                    return this
                }
            }, {
                key: "containsPoint",
                value: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
            }, {
                key: "containsBox",
                value: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
            }, {
                key: "getParameter",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Box3: .getParameter() target is now required"), t = new Tn), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
            }, {
                key: "intersectsSphere",
                value: function(e) {
                    return this.clampPoint(e.center, Dn), Dn.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }, {
                key: "intersectsPlane",
                value: function(e) {
                    var t, n = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x);
                    return 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
            }, {
                key: "intersectsTriangle",
                value: function(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Un), Vn.subVectors(this.max, Un), Nn.subVectors(e.a, Un), In.subVectors(e.b, Un), Fn.subVectors(e.c, Un), kn.subVectors(In, Nn), Bn.subVectors(Fn, In), zn.subVectors(Nn, Fn);
                    e = [0, -kn.z, kn.y, 0, -Bn.z, Bn.y, 0, -zn.z, zn.y, kn.z, 0, -kn.x, Bn.z, 0, -Bn.x, zn.z, 0, -zn.x, -kn.y, kn.x, 0, -Bn.y, Bn.x, 0, -zn.y, zn.x, 0];
                    return !!Pn(e, Nn, In, Fn, Vn) && (!!Pn(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Nn, In, Fn, Vn) && (Gn.crossVectors(kn, Bn), Pn(e = [Gn.x, Gn.y, Gn.z], Nn, In, Fn, Vn)))
                }
            }, {
                key: "clampPoint",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Box3: .clampPoint() target is now required"), t = new Tn), t.copy(e).clamp(this.min, this.max)
                }
            }, {
                key: "distanceToPoint",
                value: function(e) {
                    return Dn.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }, {
                key: "getBoundingSphere",
                value: function(e) {
                    return void 0 === e && console.error("v3d.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(Dn).length(), e
                }
            }, {
                key: "intersect",
                value: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
            }, {
                key: "union",
                value: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
            }, {
                key: "applyMatrix4",
                value: function(e) {
                    return this.isEmpty() || (Rn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Rn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Rn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Rn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Rn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Rn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Rn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Rn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Rn)), this
                }
            }, {
                key: "translate",
                value: function(e) {
                    return this.min.add(e), this.max.add(e), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }]), n
        }();

    function Pn(e, t, n, r, i) {
        for (var a = 0, o = e.length - 3; a <= o; a += 3) {
            jn.fromArray(e, a);
            var s = i.x * Math.abs(jn.x) + i.y * Math.abs(jn.y) + i.z * Math.abs(jn.z),
                l = t.dot(jn),
                c = n.dot(jn),
                u = r.dot(jn);
            if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1
        }
        return !0
    }
    var Rn = [new Tn, new Tn, new Tn, new Tn, new Tn, new Tn, new Tn, new Tn],
        Dn = new Tn,
        On = new Ln,
        Nn = new Tn,
        In = new Tn,
        Fn = new Tn,
        kn = new Tn,
        Bn = new Tn,
        zn = new Tn,
        Un = new Tn,
        Vn = new Tn,
        Gn = new Tn,
        jn = new Tn,
        Wn = new Ln,
        Hn = new Tn,
        Xn = new Tn,
        Yn = function() {
            function n(e, t) {
                _classCallCheck(this, n), this.center = void 0 !== e ? e : new Tn, this.radius = void 0 !== t ? t : -1
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
            }, {
                key: "setFromPoints",
                value: function(e, t) {
                    var n = this.center;
                    void 0 !== t ? n.copy(t) : Wn.setFromPoints(e).getCenter(n);
                    for (var r = 0, i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                    return this.radius = Math.sqrt(r), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
            }, {
                key: "isEmpty",
                value: function() {
                    return this.radius < 0
                }
            }, {
                key: "makeEmpty",
                value: function() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
            }, {
                key: "containsPoint",
                value: function(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
            }, {
                key: "distanceToPoint",
                value: function(e) {
                    return e.distanceTo(this.center) - this.radius
                }
            }, {
                key: "intersectsSphere",
                value: function(e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return e.intersectsSphere(this)
                }
            }, {
                key: "intersectsPlane",
                value: function(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
            }, {
                key: "clampPoint",
                value: function(e, t) {
                    var n = this.center.distanceToSquared(e);
                    return void 0 === t && (console.warn("v3d.Sphere: .clampPoint() target is now required"), t = new Tn), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
            }, {
                key: "getBoundingBox",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Sphere: .getBoundingBox() target is now required"), e = new Ln), this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e
                }
            }, {
                key: "applyMatrix4",
                value: function(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
            }, {
                key: "translate",
                value: function(e) {
                    return this.center.add(e), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }, {
                key: "union",
                value: function(e) {
                    var t = this.center,
                        n = this.radius,
                        r = e.center,
                        i = e.radius;
                    Hn.subVectors(r, t);
                    r = Hn.length();
                    if (r + i <= n) return this;
                    if (r + n <= i) return this.copy(e), this;
                    i = .5 * (n + r + i);
                    return Xn.copy(Hn).multiplyScalar((i - n) / r), Xn.add(t), this.center.copy(Xn), this.radius = i, this
                }
            }]), n
        }(),
        qn = new Tn,
        Zn = new Tn,
        Qn = new Tn,
        Kn = new Tn,
        Jn = new Tn,
        $n = new Tn,
        er = new Tn,
        tr = function() {
            function n(e, t) {
                _classCallCheck(this, n), this.origin = void 0 !== e ? e : new Tn, this.direction = void 0 !== t ? t : new Tn(0, 0, -1)
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
            }, {
                key: "at",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Ray: .at() target is now required"), t = new Tn), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
            }, {
                key: "lookAt",
                value: function(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
            }, {
                key: "recast",
                value: function(e) {
                    return this.origin.copy(this.at(e, qn)), this
                }
            }, {
                key: "closestPointToPoint",
                value: function(e, t) {
                    void 0 === t && (console.warn("v3d.Ray: .closestPointToPoint() target is now required"), t = new Tn), t.subVectors(e, this.origin);
                    e = t.dot(this.direction);
                    return e < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
            }, {
                key: "distanceToPoint",
                value: function(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
            }, {
                key: "distanceSqToPoint",
                value: function(e) {
                    var t = qn.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (qn.copy(this.direction).multiplyScalar(t).add(this.origin), qn.distanceToSquared(e))
                }
            }, {
                key: "distanceSqToSegment",
                value: function(e, t, n, r) {
                    Zn.copy(e).add(t).multiplyScalar(.5), Qn.copy(t).sub(e).normalize(), Kn.copy(this.origin).sub(Zn);
                    var i, a, o = .5 * e.distanceTo(t),
                        s = -this.direction.dot(Qn),
                        l = Kn.dot(this.direction),
                        c = -Kn.dot(Qn),
                        u = Kn.lengthSq(),
                        e = Math.abs(1 - s * s);
                    return u = 0 < e ? (a = s * l - c, t = o * e, 0 <= (i = s * c - l) ? -t <= a ? a <= t ? (i *= e = 1 / e) * (i + s * (a *= e) + 2 * l) + a * (s * i + a + 2 * c) + u : (a = o, -(i = Math.max(0, -(s * a + l))) * i + a * (a + 2 * c) + u) : (a = -o, -(i = Math.max(0, -(s * a + l))) * i + a * (a + 2 * c) + u) : a <= -t ? -(i = Math.max(0, -(-s * o + l))) * i + (a = 0 < i ? -o : Math.min(Math.max(-o, -c), o)) * (a + 2 * c) + u : a <= t ? (i = 0, (a = Math.min(Math.max(-o, -c), o)) * (a + 2 * c) + u) : -(i = Math.max(0, -(s * o + l))) * i + (a = 0 < i ? o : Math.min(Math.max(-o, -c), o)) * (a + 2 * c) + u) : (a = 0 < s ? -o : o, -(i = Math.max(0, -(s * a + l))) * i + a * (a + 2 * c) + u), n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(Qn).multiplyScalar(a).add(Zn), u
                }
            }, {
                key: "intersectSphere",
                value: function(e, t) {
                    qn.subVectors(e.center, this.origin);
                    var n = qn.dot(this.direction),
                        r = qn.dot(qn) - n * n,
                        e = e.radius * e.radius;
                    if (e < r) return null;
                    e = Math.sqrt(e - r), r = n - e, e = n + e;
                    return r < 0 && e < 0 ? null : r < 0 ? this.at(e, t) : this.at(r, t)
                }
            }, {
                key: "intersectsSphere",
                value: function(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
            }, {
                key: "distanceToPlane",
                value: function(e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    t = -(this.origin.dot(e.normal) + e.constant) / t;
                    return 0 <= t ? t : null
                }
            }, {
                key: "intersectPlane",
                value: function(e, t) {
                    e = this.distanceToPlane(e);
                    return null === e ? null : this.at(e, t)
                }
            }, {
                key: "intersectsPlane",
                value: function(e) {
                    var t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                }
            }, {
                key: "intersectBox",
                value: function(e, t) {
                    var n, r, i, a = 1 / this.direction.x,
                        o = 1 / this.direction.y,
                        s = 1 / this.direction.z,
                        l = this.origin,
                        a = 0 <= a ? (n = (e.min.x - l.x) * a, (e.max.x - l.x) * a) : (n = (e.max.x - l.x) * a, (e.min.x - l.x) * a),
                        o = 0 <= o ? (r = (e.min.y - l.y) * o, (e.max.y - l.y) * o) : (r = (e.max.y - l.y) * o, (e.min.y - l.y) * o);
                    return o < n || a < r ? null : ((n < r || n != n) && (n = r), (o < a || a != a) && (a = o), (s = 0 <= s ? (i = (e.min.z - l.z) * s, (e.max.z - l.z) * s) : (i = (e.max.z - l.z) * s, (e.min.z - l.z) * s)) < n || a < i ? null : ((n < i || n != n) && (n = i), (s < a || a != a) && (a = s), a < 0 ? null : this.at(0 <= n ? n : a, t)))
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return null !== this.intersectBox(e, qn)
                }
            }, {
                key: "intersectTriangle",
                value: function(e, t, n, r, i) {
                    Jn.subVectors(t, e), $n.subVectors(n, e), er.crossVectors(Jn, $n);
                    n = this.direction.dot(er);
                    if (0 < n) {
                        if (r) return null;
                        a = 1
                    } else {
                        if (!(n < 0)) return null;
                        a = -1, n = -n
                    }
                    Kn.subVectors(this.origin, e);
                    r = a * this.direction.dot($n.crossVectors(Kn, $n));
                    if (r < 0) return null;
                    e = a * this.direction.dot(Jn.cross(Kn));
                    if (e < 0) return null;
                    if (n < r + e) return null;
                    var a = -a * Kn.dot(er);
                    return a < 0 ? null : this.at(a / n, i)
                }
            }, {
                key: "applyMatrix4",
                value: function(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }]), n
        }(),
        nr = function() {
            function e() {
                _classCallCheck(this, e), Object.defineProperty(this, "isMatrix4", {
                    value: !0
                }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("v3d.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            return _createClass(e, [{
                key: "set",
                value: function(e, t, n, r, i, a, o, s, l, c, u, d, h, f, p, m) {
                    var v = this.elements;
                    return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = d, v[3] = h, v[7] = f, v[11] = p, v[15] = m, this
                }
            }, {
                key: "identity",
                value: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new e).fromArray(this.elements)
                }
            }, {
                key: "copy",
                value: function(e) {
                    var t = this.elements,
                        e = e.elements;
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
                }
            }, {
                key: "copyPosition",
                value: function(e) {
                    var t = this.elements,
                        e = e.elements;
                    return t[12] = e[12], t[13] = e[13], t[14] = e[14], this
                }
            }, {
                key: "extractBasis",
                value: function(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
            }, {
                key: "makeBasis",
                value: function(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "extractRotation",
                value: function(e) {
                    var t = this.elements,
                        n = e.elements,
                        r = 1 / rr.setFromMatrixColumn(e, 0).length(),
                        i = 1 / rr.setFromMatrixColumn(e, 1).length(),
                        e = 1 / rr.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * e, t[9] = n[9] * e, t[10] = n[10] * e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
            }, {
                key: "makeRotationFromEuler",
                value: function(e) {
                    e && e.isEuler || console.error("v3d.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t, n, r, i, a, o, s, l, c, u, d, h = this.elements,
                        f = e.x,
                        p = e.y,
                        m = e.z,
                        v = Math.cos(f),
                        g = Math.sin(f),
                        _ = Math.cos(p),
                        y = Math.sin(p),
                        f = Math.cos(m),
                        p = Math.sin(m);
                    return "XYZ" === e.order ? (t = v * f, r = v * p, n = g * f, m = g * p, h[0] = _ * f, h[4] = -_ * p, h[8] = y, h[1] = r + n * y, h[5] = t - m * y, h[9] = -g * _, h[2] = m - t * y, h[6] = n + r * y, h[10] = v * _) : "YXZ" === e.order ? (i = _ * f, t = _ * p, n = y * f, r = y * p, h[0] = i + r * g, h[4] = n * g - t, h[8] = v * y, h[1] = v * p, h[5] = v * f, h[9] = -g, h[2] = t * g - n, h[6] = r + i * g, h[10] = v * _) : "ZXY" === e.order ? (s = _ * f, i = _ * p, a = y * f, o = y * p, h[0] = s - o * g, h[4] = -v * p, h[8] = a + i * g, h[1] = i + a * g, h[5] = v * f, h[9] = o - s * g, h[2] = -v * y, h[6] = g, h[10] = v * _) : "ZYX" === e.order ? (a = v * f, o = v * p, l = g * f, s = g * p, h[0] = _ * f, h[4] = l * y - o, h[8] = a * y + s, h[1] = _ * p, h[5] = s * y + a, h[9] = o * y - l, h[2] = -y, h[6] = g * _, h[10] = v * _) : "YZX" === e.order ? (u = v * _, l = v * y, c = g * _, d = g * y, h[0] = _ * f, h[4] = d - u * p, h[8] = c * p + l, h[1] = p, h[5] = v * f, h[9] = -g * f, h[2] = -y * f, h[6] = l * p + c, h[10] = u - d * p) : "XZY" === e.order && (c = v * _, u = v * y, d = g * _, e = g * y, h[0] = _ * f, h[4] = -p, h[8] = y * f, h[1] = c * p + e, h[5] = v * f, h[9] = u * p - d, h[2] = d * p - u, h[6] = g * f, h[10] = e * p + c), h[3] = 0, h[7] = 0, h[11] = 0, h[12] = 0, h[13] = 0, h[14] = 0, h[15] = 1, this
                }
            }, {
                key: "makeRotationFromQuaternion",
                value: function(e) {
                    return this.compose(ar, e, or)
                }
            }, {
                key: "lookAt",
                value: function(e, t, n) {
                    var r = this.elements;
                    return cr.subVectors(e, t), 0 === cr.lengthSq() && (cr.z = 1), cr.normalize(), sr.crossVectors(n, cr), 0 === sr.lengthSq() && (1 === Math.abs(n.z) ? cr.x += 1e-4 : cr.z += 1e-4, cr.normalize(), sr.crossVectors(n, cr)), sr.normalize(), lr.crossVectors(cr, sr), r[0] = sr.x, r[4] = lr.x, r[8] = cr.x, r[1] = sr.y, r[5] = lr.y, r[9] = cr.y, r[2] = sr.z, r[6] = lr.z, r[10] = cr.z, this
                }
            }, {
                key: "multiply",
                value: function(e, t) {
                    return void 0 !== t ? (console.warn("v3d.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices(a, b) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                }
            }, {
                key: "premultiply",
                value: function(e) {
                    return this.multiplyMatrices(e, this)
                }
            }, {
                key: "multiplyMatrices",
                value: function(e, t) {
                    var n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        d = n[9],
                        h = n[13],
                        f = n[2],
                        p = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        _ = n[7],
                        y = n[11],
                        x = n[15],
                        b = r[0],
                        M = r[4],
                        w = r[8],
                        S = r[12],
                        A = r[1],
                        T = r[5],
                        E = r[9],
                        C = r[13],
                        L = r[2],
                        P = r[6],
                        R = r[10],
                        D = r[14],
                        e = r[3],
                        t = r[7],
                        n = r[11],
                        r = r[15];
                    return i[0] = a * b + o * A + s * L + l * e, i[4] = a * M + o * T + s * P + l * t, i[8] = a * w + o * E + s * R + l * n, i[12] = a * S + o * C + s * D + l * r, i[1] = c * b + u * A + d * L + h * e, i[5] = c * M + u * T + d * P + h * t, i[9] = c * w + u * E + d * R + h * n, i[13] = c * S + u * C + d * D + h * r, i[2] = f * b + p * A + m * L + v * e, i[6] = f * M + p * T + m * P + v * t, i[10] = f * w + p * E + m * R + v * n, i[14] = f * S + p * C + m * D + v * r, i[3] = g * b + _ * A + y * L + x * e, i[7] = g * M + _ * T + y * P + x * t, i[11] = g * w + _ * E + y * R + x * n, i[15] = g * S + _ * C + y * D + x * r, this
                }
            }, {
                key: "multiplyScalar",
                value: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
            }, {
                key: "determinant",
                value: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        d = e[10],
                        h = e[14];
                    return e[3] * (+i * s * u - r * l * u - i * o * d + n * l * d + r * o * h - n * s * h) + e[7] * (+t * s * h - t * l * d + i * a * d - r * a * h + r * l * c - i * s * c) + e[11] * (+t * l * u - t * o * h - i * a * u + n * a * h + i * o * c - n * l * c) + e[15] * (-r * o * c - t * s * u + t * o * d + r * a * u - n * a * d + n * s * c)
                }
            }, {
                key: "transpose",
                value: function() {
                    var e = this.elements,
                        t = e[1];
                    return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
            }, {
                key: "setPosition",
                value: function(e, t, n) {
                    var r = this.elements;
                    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                }
            }, {
                key: "invert",
                value: function() {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8],
                        u = e[9],
                        d = e[10],
                        h = e[11],
                        f = e[12],
                        p = e[13],
                        m = e[14],
                        v = e[15],
                        g = u * m * l - p * d * l + p * s * h - o * m * h - u * s * v + o * d * v,
                        _ = f * d * l - c * m * l - f * s * h + a * m * h + c * s * v - a * d * v,
                        y = c * p * l - f * u * l + f * o * h - a * p * h - c * o * v + a * u * v,
                        x = f * u * s - c * p * s - f * o * d + a * p * d + c * o * m - a * u * m,
                        b = t * g + n * _ + r * y + i * x;
                    if (0 == b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    b = 1 / b;
                    return e[0] = g * b, e[1] = (p * d * i - u * m * i - p * r * h + n * m * h + u * r * v - n * d * v) * b, e[2] = (o * m * i - p * s * i + p * r * l - n * m * l - o * r * v + n * s * v) * b, e[3] = (u * s * i - o * d * i - u * r * l + n * d * l + o * r * h - n * s * h) * b, e[4] = _ * b, e[5] = (c * m * i - f * d * i + f * r * h - t * m * h - c * r * v + t * d * v) * b, e[6] = (f * s * i - a * m * i - f * r * l + t * m * l + a * r * v - t * s * v) * b, e[7] = (a * d * i - c * s * i + c * r * l - t * d * l - a * r * h + t * s * h) * b, e[8] = y * b, e[9] = (f * u * i - c * p * i - f * n * h + t * p * h + c * n * v - t * u * v) * b, e[10] = (a * p * i - f * o * i + f * n * l - t * p * l - a * n * v + t * o * v) * b, e[11] = (c * o * i - a * u * i - c * n * l + t * u * l + a * n * h - t * o * h) * b, e[12] = x * b, e[13] = (c * p * r - f * u * r + f * n * d - t * p * d - c * n * m + t * u * m) * b, e[14] = (f * o * r - a * p * r - f * n * s + t * p * s + a * n * m - t * o * m) * b, e[15] = (a * u * r - c * o * r + c * n * s - t * u * s - a * n * d + t * o * d) * b, this
                }
            }, {
                key: "scale",
                value: function(e) {
                    var t = this.elements,
                        n = e.x,
                        r = e.y,
                        e = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= e, t[1] *= n, t[5] *= r, t[9] *= e, t[2] *= n, t[6] *= r, t[10] *= e, t[3] *= n, t[7] *= r, t[11] *= e, this
                }
            }, {
                key: "getMaxScaleOnAxis",
                value: function() {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        e = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, e))
                }
            }, {
                key: "makeTranslation",
                value: function(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationX",
                value: function(e) {
                    var t = Math.cos(e),
                        e = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationY",
                value: function(e) {
                    var t = Math.cos(e),
                        e = Math.sin(e);
                    return this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationZ",
                value: function(e) {
                    var t = Math.cos(e),
                        e = Math.sin(e);
                    return this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeRotationAxis",
                value: function(e, t) {
                    var n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        a = e.x,
                        o = e.y,
                        s = e.z,
                        t = i * a,
                        e = i * o;
                    return this.set(t * a + n, t * o - r * s, t * s + r * o, 0, t * o + r * s, e * o + n, e * s - r * a, 0, t * s - r * o, e * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeScale",
                value: function(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "makeShear",
                value: function(e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                }
            }, {
                key: "compose",
                value: function(e, t, n) {
                    var r = this.elements,
                        i = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        l = i + i,
                        c = a + a,
                        u = o + o,
                        d = i * l,
                        h = i * c,
                        f = i * u,
                        t = a * c,
                        i = a * u,
                        a = o * u,
                        o = s * l,
                        l = s * c,
                        c = s * u,
                        s = n.x,
                        u = n.y,
                        n = n.z;
                    return r[0] = (1 - (t + a)) * s, r[1] = (h + c) * s, r[2] = (f - l) * s, r[3] = 0, r[4] = (h - c) * u, r[5] = (1 - (d + a)) * u, r[6] = (i + o) * u, r[7] = 0, r[8] = (f + l) * n, r[9] = (i - o) * n, r[10] = (1 - (d + t)) * n, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                }
            }, {
                key: "decompose",
                value: function(e, t, n) {
                    var r = this.elements,
                        i = rr.set(r[0], r[1], r[2]).length(),
                        a = rr.set(r[4], r[5], r[6]).length(),
                        o = rr.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], ir.copy(this);
                    var s = 1 / i,
                        e = 1 / a,
                        r = 1 / o;
                    return ir.elements[0] *= s, ir.elements[1] *= s, ir.elements[2] *= s, ir.elements[4] *= e, ir.elements[5] *= e, ir.elements[6] *= e, ir.elements[8] *= r, ir.elements[9] *= r, ir.elements[10] *= r, t.setFromRotationMatrix(ir), n.x = i, n.y = a, n.z = o, this
                }
            }, {
                key: "makePerspective",
                value: function(e, t, n, r, i, a) {
                    void 0 === a && console.warn("v3d.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var o = this.elements,
                        s = 2 * i / (t - e),
                        l = 2 * i / (n - r),
                        e = (t + e) / (t - e),
                        n = (n + r) / (n - r),
                        r = -(a + i) / (a - i),
                        i = -2 * a * i / (a - i);
                    return o[0] = s, o[4] = 0, o[8] = e, o[12] = 0, o[1] = 0, o[5] = l, o[9] = n, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = r, o[14] = i, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                }
            }, {
                key: "makeOrthographic",
                value: function(e, t, n, r, i, a) {
                    var o = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (n - r),
                        c = 1 / (a - i),
                        e = (t + e) * s,
                        r = (n + r) * l,
                        i = (a + i) * c;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -e, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -r, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -i, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                }
            }, {
                key: "equals",
                value: function(e) {
                    for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                        if (t[r] !== n[r]) return !1;
                    return !0
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }]), e
        }(),
        rr = new Tn,
        ir = new nr,
        ar = new Tn(0, 0, 0),
        or = new Tn(1, 1, 1),
        sr = new Tn,
        lr = new Tn,
        cr = new Tn,
        ur = function() {
            function i() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : i.DefaultOrder;
                _classCallCheck(this, i), Object.defineProperty(this, "isEuler", {
                    value: !0
                }), this._x = e, this._y = t, this._z = n, this._order = r
            }
            return _createClass(i, [{
                key: "set",
                value: function(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
                }
            }, {
                key: "clone",
                value: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
            }, {
                key: "setFromRotationMatrix",
                value: function(e, t, n) {
                    var r = mn.clamp,
                        e = e.elements,
                        i = e[0],
                        a = e[4],
                        o = e[8],
                        s = e[1],
                        l = e[5],
                        c = e[9],
                        u = e[2],
                        d = e[6],
                        h = e[10];
                    switch (t = t || this._order) {
                        case "XYZ":
                            this._y = Math.asin(r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(d, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, h), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, h));
                            break;
                        case "XZY":
                            this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, h), this._y = 0);
                            break;
                        default:
                            console.warn("v3d.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !1 !== n && this._onChangeCallback(), this
                }
            }, {
                key: "setFromQuaternion",
                value: function(e, t, n) {
                    return dr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(dr, t, n)
                }
            }, {
                key: "setFromVector3",
                value: function(e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                }
            }, {
                key: "reorder",
                value: function(e) {
                    return hr.setFromEuler(this), this.setFromQuaternion(hr, e)
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
            }, {
                key: "fromArray",
                value: function(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                        t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
            }, {
                key: "toVector3",
                value: function(e) {
                    return e ? e.set(this._x, this._y, this._z) : new Tn(this._x, this._y, this._z)
                }
            }, {
                key: "_onChange",
                value: function(e) {
                    return this._onChangeCallback = e, this
                }
            }, {
                key: "_onChangeCallback",
                value: function() {}
            }, {
                key: "makeAlternative",
                value: function() {
                    var e = "X" === this._order[1] ? -1 : 1,
                        t = "Y" === this._order[1] ? -1 : 1,
                        n = "Z" === this._order[1] ? -1 : 1;
                    return this._x = mn.angleToRange_mPi_Pi(e * (this._x + Math.PI)), this._y = mn.angleToRange_mPi_Pi(t * (this._y + Math.PI)), this._z = mn.angleToRange_mPi_Pi(n * (this._z + Math.PI)), this
                }
            }, {
                key: "equalsEps",
                value: function(e, t) {
                    return Math.abs(this._x - e._x) < t && Math.abs(this._y - e._y) < t && Math.abs(this._z - e._z) < t && this._order === e._order
                }
            }, {
                key: "x",
                get: function() {
                    return this._x
                },
                set: function(e) {
                    this._x = e, this._onChangeCallback()
                }
            }, {
                key: "y",
                get: function() {
                    return this._y
                },
                set: function(e) {
                    this._y = e, this._onChangeCallback()
                }
            }, {
                key: "z",
                get: function() {
                    return this._z
                },
                set: function(e) {
                    this._z = e, this._onChangeCallback()
                }
            }, {
                key: "order",
                get: function() {
                    return this._order
                },
                set: function(e) {
                    this._order = e, this._onChangeCallback()
                }
            }]), i
        }();
    ur.DefaultOrder = "XYZ", ur.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    var dr = new nr,
        hr = new An,
        fr = function() {
            function e() {
                _classCallCheck(this, e), this.mask = 1
            }
            return _createClass(e, [{
                key: "set",
                value: function(e) {
                    this.mask = 1 << e | 0
                }
            }, {
                key: "enable",
                value: function(e) {
                    this.mask |= 1 << e | 0
                }
            }, {
                key: "enableAll",
                value: function() {
                    this.mask = -1
                }
            }, {
                key: "toggle",
                value: function(e) {
                    this.mask ^= 1 << e | 0
                }
            }, {
                key: "disable",
                value: function(e) {
                    this.mask &= ~(1 << e | 0)
                }
            }, {
                key: "disableAll",
                value: function() {
                    this.mask = 0
                }
            }, {
                key: "test",
                value: function(e) {
                    return 0 != (this.mask & e.mask)
                }
            }]), e
        }(),
        pr = 0,
        mr = new Tn,
        vr = new An,
        gr = new nr,
        _r = new Tn,
        yr = new Tn,
        xr = new Tn,
        br = new An,
        Mr = new Tn(1, 0, 0),
        wr = new Tn(0, 1, 0),
        Sr = new Tn(0, 0, 1),
        Ar = {
            type: "added"
        },
        Tr = {
            type: "removed"
        };

    function Er() {
        Object.defineProperty(this, "id", {
            value: pr++
        }), this.uuid = mn.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Er.DefaultUp.clone();
        var e = new Tn,
            t = new ur,
            n = new An,
            r = new Tn(1, 1, 1);
        t._onChange(function() {
            n.setFromEuler(t, !1)
        }), n._onChange(function() {
            t.setFromQuaternion(n, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new nr
            },
            normalMatrix: {
                value: new gn
            }
        }), this.matrix = new nr, this.matrixWorld = new nr, this.matrixAutoUpdate = Er.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new fr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {
            v3d: {}
        }, this.constraints = [], this.disableChildRendering = !1
    }
    Er.DefaultUp = new Tn(0, 1, 0), Er.DefaultMatrixAutoUpdate = !0, Er.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Er,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function(e, t) {
            return vr.setFromAxisAngle(e, t), this.quaternion.multiply(vr), this
        },
        rotateOnWorldAxis: function(e, t) {
            return vr.setFromAxisAngle(e, t), this.quaternion.premultiply(vr), this
        },
        rotateX: function(e) {
            return this.rotateOnAxis(Mr, e)
        },
        rotateY: function(e) {
            return this.rotateOnAxis(wr, e)
        },
        rotateZ: function(e) {
            return this.rotateOnAxis(Sr, e)
        },
        translateOnAxis: function(e, t) {
            return mr.copy(e).applyQuaternion(this.quaternion), this.position.add(mr.multiplyScalar(t)), this
        },
        translateX: function(e) {
            return this.translateOnAxis(Mr, e)
        },
        translateY: function(e) {
            return this.translateOnAxis(wr, e)
        },
        translateZ: function(e) {
            return this.translateOnAxis(Sr, e)
        },
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(e) {
            return e.applyMatrix4(gr.copy(this.matrixWorld).invert())
        },
        lookAt: function(e, t, n) {
            e.isVector3 ? _r.copy(e) : _r.set(e, t, n);
            n = this.parent;
            this.updateWorldMatrix(!0, !1), yr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? gr.lookAt(yr, _r, this.up) : gr.lookAt(_r, yr, this.up), this.quaternion.setFromRotationMatrix(gr), n && (gr.extractRotation(n.matrixWorld), vr.setFromRotationMatrix(gr), this.quaternion.premultiply(vr.invert()))
        },
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? console.error("v3d.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this).children.push(e), e.dispatchEvent(Ar)) : console.error("v3d.Object3D.add: object not an instance of v3d.Object3D.", e), this
        },
        remove: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            var n = this.children.indexOf(e);
            return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Tr)), this
        },
        clear: function() {
            for (var e = 0; e < this.children.length; e++) {
                var t = this.children[e];
                t.parent = null, t.dispatchEvent(Tr)
            }
            return this.children.length = 0, this
        },
        attach: function(e) {
            return this.updateWorldMatrix(!0, !1), gr.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), gr.multiply(e.parent.matrixWorld)), e.applyMatrix4(gr), e.updateWorldMatrix(!1, !1), this.add(e), this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldPosition() target is now required"), e = new Tn), this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldQuaternion() target is now required"), e = new An), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yr, e, xr), e
        },
        getWorldScale: function(e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldScale() target is now required"), e = new Tn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(yr, br, e), e
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("v3d.Object3D: .getWorldDirection() target is now required"), e = new Tn), this.updateWorldMatrix(!0, !1);
            var t = this.matrixWorld.elements;
            return e.set(t[4], t[5], t[6]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.updateConstraints(), this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (var r = this.children, i = 0, a = r.length; i < a; i++) r[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function(n) {
            var e = void 0 === n || "string" == typeof n,
                t = {};
            e && (n = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            }, t.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r, i, a, o, s, l = {};

            function c(e, t) {
                return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid
            }
            if (l.uuid = this.uuid, l.type = this.type, "" !== this.name && (l.name = this.name), !0 === this.castShadow && (l.castShadow = !0), !0 === this.receiveShadow && (l.receiveShadow = !0), !1 === this.visible && (l.visible = !1), !1 === this.frustumCulled && (l.frustumCulled = !1), 0 !== this.renderOrder && (l.renderOrder = this.renderOrder), !1 === this.disableChildRendering && (l.disableChildRendering = !1), "{}" !== JSON.stringify(this.userData) && (l.userData = this.userData), l.layers = this.layers.mask, l.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (l.matrixAutoUpdate = !1), this.isInstancedMesh && (l.type = "InstancedMesh", l.count = this.count, l.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                l.geometry = c(n.geometries, this.geometry);
                var u = this.geometry.parameters;
                if (void 0 !== u && void 0 !== u.shapes) {
                    var d = u.shapes;
                    if (Array.isArray(d))
                        for (var h = 0, f = d.length; h < f; h++) {
                            var p = d[h];
                            c(n.shapes, p)
                        } else c(n.shapes, d)
                }
            }
            if (this.isSkinnedMesh && (l.bindMode = this.bindMode, l.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (c(n.skeletons, this.skeleton), l.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var m = [], v = 0, g = this.material.length; v < g; v++) m.push(c(n.materials, this.material[v]));
                    l.material = m
                } else l.material = c(n.materials, this.material);
            if (0 < this.children.length) {
                l.children = [];
                for (var _ = 0; _ < this.children.length; _++) l.children.push(this.children[_].toJSON(n).object)
            }
            if (0 < this.animations.length) {
                l.animations = [];
                for (var y = 0; y < this.animations.length; y++) {
                    var x = this.animations[y];
                    l.animations.push(c(n.animations, x))
                }
            }
            return e && (r = b(n.geometries), i = b(n.materials), a = b(n.textures), o = b(n.images), s = b(n.shapes), u = b(n.skeletons), e = b(n.animations), 0 < r.length && (t.geometries = r), 0 < i.length && (t.materials = i), 0 < a.length && (t.textures = a), 0 < o.length && (t.images = o), 0 < s.length && (t.shapes = s), 0 < u.length && (t.skeletons = u), 0 < e.length && (t.animations = e)), t.object = l, t;

            function b(e) {
                var t, n = [];
                for (t in e) {
                    var r = e[t];
                    delete r.metadata, n.push(r)
                }
                return n
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.disableChildRendering = e.disableChildRendering, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.add(r.clone())
                }
            return this
        },
        copyTransform: function(e) {
            this.matrix.copy(e.matrixWorld), this.parent && this.matrix.multiplyMatrices(gr.copy(this.parent.matrixWorld).invert(), this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        isVisible: function() {
            return this.visible
        },
        updateConstraints: function() {
            for (var e = 0; e < this.constraints.length; e++) this.constraints[e].update(this)
        },
        getWorldPositionNU: function(e) {
            return e.setFromMatrixPosition(this.matrixWorld)
        },
        getLocalDirection: function(e) {
            var t = this.matrix.elements;
            return (this.isCamera || this.isLight ? e.set(-t[8], -t[9], -t[10]) : e.set(t[8], t[9], t[10])).normalize()
        },
        lookAtLocal: function(e, t, n) {
            e.isVector3 ? _r.copy(e) : _r.set(e, t, n), yr.setFromMatrixPosition(this.matrix), this.isCamera || this.isLight ? gr.lookAt(yr, _r, this.up) : gr.lookAt(_r, yr, this.up), this.quaternion.setFromRotationMatrix(gr)
        },
        findRoot: function() {
            var t = this;
            return this.traverseAncestors(function(e) {
                t = e
            }), t
        },
        resolveMultiMaterial: function() {
            for (var e = [], t = 0; t < this.children.length; t++) {
                var n = this.children[t];
                n.isMesh && n.isMaterialGeneratedMesh && e.push(n)
            }
            return e.length || e.push(this), e
        }
    });
    var Cr = new Tn,
        Lr = new Tn,
        Pr = new gn,
        Rr = function() {
            function n(e, t) {
                _classCallCheck(this, n), Object.defineProperty(this, "isPlane", {
                    value: !0
                }), this.normal = void 0 !== e ? e : new Tn(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
            }, {
                key: "setComponents",
                value: function(e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                }
            }, {
                key: "setFromNormalAndCoplanarPoint",
                value: function(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
            }, {
                key: "setFromCoplanarPoints",
                value: function(e, t, n) {
                    t = Cr.subVectors(n, t).cross(Lr.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(t, e), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
            }, {
                key: "normalize",
                value: function() {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
            }, {
                key: "negate",
                value: function() {
                    return this.constant *= -1, this.normal.negate(), this
                }
            }, {
                key: "distanceToPoint",
                value: function(e) {
                    return this.normal.dot(e) + this.constant
                }
            }, {
                key: "distanceToSphere",
                value: function(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
            }, {
                key: "projectPoint",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Plane: .projectPoint() target is now required"), t = new Tn), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
            }, {
                key: "intersectLine",
                value: function(e, t) {
                    void 0 === t && (console.warn("v3d.Plane: .intersectLine() target is now required"), t = new Tn);
                    var n = e.delta(Cr),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                    r = -(e.start.dot(this.normal) + this.constant) / r;
                    return r < 0 || 1 < r ? void 0 : t.copy(n).multiplyScalar(r).add(e.start)
                }
            }, {
                key: "intersectsLine",
                value: function(e) {
                    var t = this.distanceToPoint(e.start),
                        e = this.distanceToPoint(e.end);
                    return t < 0 && 0 < e || e < 0 && 0 < t
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return e.intersectsPlane(this)
                }
            }, {
                key: "intersectsSphere",
                value: function(e) {
                    return e.intersectsPlane(this)
                }
            }, {
                key: "coplanarPoint",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Plane: .coplanarPoint() target is now required"), e = new Tn), e.copy(this.normal).multiplyScalar(-this.constant)
                }
            }, {
                key: "applyMatrix4",
                value: function(e, t) {
                    t = t || Pr.getNormalMatrix(e), e = this.coplanarPoint(Cr).applyMatrix4(e), t = this.normal.applyMatrix3(t).normalize();
                    return this.constant = -e.dot(t), this
                }
            }, {
                key: "translate",
                value: function(e) {
                    return this.constant -= e.dot(this.normal), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }]), n
        }(),
        Dr = new Tn,
        Or = new Tn,
        Nr = new Tn,
        Ir = new Tn,
        Fr = new Tn,
        kr = new Tn,
        Br = new Tn,
        zr = new Tn,
        Ur = new Tn,
        Vr = new Tn,
        Gr = function() {
            function a(e, t, n) {
                _classCallCheck(this, a), this.a = void 0 !== e ? e : new Tn, this.b = void 0 !== t ? t : new Tn, this.c = void 0 !== n ? n : new Tn
            }
            return _createClass(a, [{
                key: "set",
                value: function(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
            }, {
                key: "setFromPointsAndIndices",
                value: function(e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
            }, {
                key: "getArea",
                value: function() {
                    return Dr.subVectors(this.c, this.b), Or.subVectors(this.a, this.b), .5 * Dr.cross(Or).length()
                }
            }, {
                key: "getMidpoint",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Triangle: .getMidpoint() target is now required"), e = new Tn), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
            }, {
                key: "getNormal",
                value: function(e) {
                    return a.getNormal(this.a, this.b, this.c, e)
                }
            }, {
                key: "getPlane",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Triangle: .getPlane() target is now required"), e = new Rr), e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
            }, {
                key: "getBarycoord",
                value: function(e, t) {
                    return a.getBarycoord(e, this.a, this.b, this.c, t)
                }
            }, {
                key: "getUV",
                value: function(e, t, n, r, i) {
                    return a.getUV(e, this.a, this.b, this.c, t, n, r, i)
                }
            }, {
                key: "containsPoint",
                value: function(e) {
                    return a.containsPoint(e, this.a, this.b, this.c)
                }
            }, {
                key: "isFrontFacing",
                value: function(e) {
                    return a.isFrontFacing(this.a, this.b, this.c, e)
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return e.intersectsTriangle(this)
                }
            }, {
                key: "closestPointToPoint",
                value: function(e, t) {
                    void 0 === t && (console.warn("v3d.Triangle: .closestPointToPoint() target is now required"), t = new Tn);
                    var n = this.a,
                        r = this.b,
                        i = this.c;
                    Fr.subVectors(r, n), kr.subVectors(i, n), zr.subVectors(e, n);
                    var a = Fr.dot(zr),
                        o = kr.dot(zr);
                    if (a <= 0 && o <= 0) return t.copy(n);
                    Ur.subVectors(e, r);
                    var s = Fr.dot(Ur),
                        l = kr.dot(Ur);
                    if (0 <= s && l <= s) return t.copy(r);
                    var c = a * l - s * o;
                    if (c <= 0 && 0 <= a && s <= 0) return d = a / (a - s), t.copy(n).addScaledVector(Fr, d);
                    Vr.subVectors(e, i);
                    var u = Fr.dot(Vr),
                        e = kr.dot(Vr);
                    if (0 <= e && u <= e) return t.copy(i);
                    a = u * o - a * e;
                    if (a <= 0 && 0 <= o && e <= 0) return h = o / (o - e), t.copy(n).addScaledVector(kr, h);
                    o = s * e - u * l;
                    if (o <= 0 && 0 <= l - s && 0 <= u - e) return Br.subVectors(i, r), h = (l - s) / (l - s + (u - e)), t.copy(r).addScaledVector(Br, h);
                    var o = 1 / (o + a + c),
                        d = a * o,
                        h = c * o;
                    return t.copy(n).addScaledVector(Fr, d).addScaledVector(kr, h)
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }], [{
                key: "getNormal",
                value: function(e, t, n, r) {
                    void 0 === r && (console.warn("v3d.Triangle: .getNormal() target is now required"), r = new Tn), r.subVectors(n, t), Dr.subVectors(e, t), r.cross(Dr);
                    t = r.lengthSq();
                    return 0 < t ? r.multiplyScalar(1 / Math.sqrt(t)) : r.set(0, 0, 0)
                }
            }, {
                key: "getBarycoord",
                value: function(e, t, n, r, i) {
                    Dr.subVectors(r, t), Or.subVectors(n, t), Nr.subVectors(e, t);
                    var a = Dr.dot(Dr),
                        o = Dr.dot(Or),
                        r = Dr.dot(Nr),
                        n = Or.dot(Or),
                        e = Or.dot(Nr),
                        t = a * n - o * o;
                    if (void 0 === i && (console.warn("v3d.Triangle: .getBarycoord() target is now required"), i = new Tn), 0 == t) return i.set(-2, -1, -1);
                    t = 1 / t, n = (n * r - o * e) * t, t *= a * e - o * r;
                    return i.set(1 - n - t, t, n)
                }
            }, {
                key: "containsPoint",
                value: function(e, t, n, r) {
                    return this.getBarycoord(e, t, n, r, Ir), 0 <= Ir.x && 0 <= Ir.y && Ir.x + Ir.y <= 1
                }
            }, {
                key: "getUV",
                value: function(e, t, n, r, i, a, o, s) {
                    return this.getBarycoord(e, t, n, r, Ir), s.set(0, 0), s.addScaledVector(i, Ir.x), s.addScaledVector(a, Ir.y), s.addScaledVector(o, Ir.z), s
                }
            }, {
                key: "isFrontFacing",
                value: function(e, t, n, r) {
                    return Dr.subVectors(n, t), Or.subVectors(e, t), Dr.cross(Or).dot(r) < 0
                }
            }]), a
        }(),
        jr = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Wr = {
            h: 0,
            s: 0,
            l: 0
        },
        Hr = {
            h: 0,
            s: 0,
            l: 0
        };

    function Xr(e, t, n) {
        return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function Yr(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function qr(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }

    function Zr(e, t) {
        return e * Math.pow(2, 255 * t - 128)
    }
    var Qr = function() {
        function r(e, t, n) {
            return _classCallCheck(this, r), Object.defineProperty(this, "isColor", {
                value: !0
            }), void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }
        return _createClass(r, [{
            key: "set",
            value: function(e) {
                return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
            }
        }, {
            key: "setScalar",
            value: function(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
        }, {
            key: "setHex",
            value: function(e) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
            }
        }, {
            key: "setRGB",
            value: function(e, t, n) {
                return this.r = e, this.g = t, this.b = n, this
            }
        }, {
            key: "setHSL",
            value: function(e, t, n) {
                return e = mn.euclideanModulo(e, 1), t = mn.clamp(t, 0, 1), n = mn.clamp(n, 0, 1), 0 === t ? this.r = this.g = this.b = n : (t = 2 * n - (n = n <= .5 ? n * (1 + t) : n + t - n * t), this.r = Xr(t, n, e + 1 / 3), this.g = Xr(t, n, e), this.b = Xr(t, n, e - 1 / 3)), this
            }
        }, {
            key: "setStyle",
            value: function(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("v3d.Color: Alpha component of " + t + " will be ignored.")
                }
                if (l = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n, r = l[1],
                        i = l[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[4]), this;
                            if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (n = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                                var a = parseFloat(n[1]) / 360,
                                    o = parseInt(n[2], 10) / 100,
                                    s = parseInt(n[3], 10) / 100;
                                return e(n[4]), this.setHSL(a, o, s)
                            }
                    }
                } else if (l = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    var r = l[1],
                        l = r.length;
                    if (3 === l) return this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255, this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255, this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255, this;
                    if (6 === l) return this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255, this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255, this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255, this
                }
                return t && 0 < t.length ? this.setColorName(t) : this
            }
        }, {
            key: "setColorName",
            value: function(e) {
                var t = jr[e];
                return void 0 !== t ? this.setHex(t) : console.warn("v3d.Color: Unknown color " + e), this
            }
        }, {
            key: "clone",
            value: function() {
                return new this.constructor(this.r, this.g, this.b)
            }
        }, {
            key: "copy",
            value: function(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
        }, {
            key: "copyGammaToLinear",
            value: function(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 2;
                return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
            }
        }, {
            key: "copyLinearToGamma",
            value: function(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 2,
                    t = 0 < t ? 1 / t : 1;
                return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
            }
        }, {
            key: "convertGammaToLinear",
            value: function(e) {
                return this.copyGammaToLinear(this, e), this
            }
        }, {
            key: "convertLinearToGamma",
            value: function(e) {
                return this.copyLinearToGamma(this, e), this
            }
        }, {
            key: "copySRGBToLinear",
            value: function(e) {
                return this.r = Yr(e.r), this.g = Yr(e.g), this.b = Yr(e.b), this
            }
        }, {
            key: "copyLinearToSRGB",
            value: function(e) {
                return this.r = qr(e.r), this.g = qr(e.g), this.b = qr(e.b), this
            }
        }, {
            key: "convertSRGBToLinear",
            value: function() {
                return this.copySRGBToLinear(this), this
            }
        }, {
            key: "convertLinearToSRGB",
            value: function() {
                return this.copyLinearToSRGB(this), this
            }
        }, {
            key: "getHex",
            value: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
        }, {
            key: "getHexString",
            value: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
        }, {
            key: "getHSL",
            value: function(e) {
                void 0 === e && (console.warn("v3d.Color: .getHSL() target is now required"), e = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var t, n = this.r,
                    r = this.g,
                    i = this.b,
                    a = Math.max(n, r, i),
                    o = Math.min(n, r, i),
                    s = (o + a) / 2;
                if (o === a) c = t = 0;
                else {
                    var l = a - o,
                        c = s <= .5 ? l / (a + o) : l / (2 - a - o);
                    switch (a) {
                        case n:
                            t = (r - i) / l + (r < i ? 6 : 0);
                            break;
                        case r:
                            t = (i - n) / l + 2;
                            break;
                        case i:
                            t = (n - r) / l + 4
                    }
                    t /= 6
                }
                return e.h = t, e.s = c, e.l = s, e
            }
        }, {
            key: "getStyle",
            value: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
        }, {
            key: "offsetHSL",
            value: function(e, t, n) {
                return this.getHSL(Wr), Wr.h += e, Wr.s += t, Wr.l += n, this.setHSL(Wr.h, Wr.s, Wr.l), this
            }
        }, {
            key: "add",
            value: function(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
        }, {
            key: "addColors",
            value: function(e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            }
        }, {
            key: "addScalar",
            value: function(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
        }, {
            key: "sub",
            value: function(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
        }, {
            key: "multiply",
            value: function(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
        }, {
            key: "multiplyScalar",
            value: function(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
        }, {
            key: "lerp",
            value: function(e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            }
        }, {
            key: "lerpHSL",
            value: function(e, t) {
                this.getHSL(Wr), e.getHSL(Hr);
                var n = mn.lerp(Wr.h, Hr.h, t),
                    e = mn.lerp(Wr.s, Hr.s, t),
                    t = mn.lerp(Wr.l, Hr.l, t);
                return this.setHSL(n, e, t), this
            }
        }, {
            key: "equals",
            value: function(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            }
        }, {
            key: "toArray",
            value: function() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            }
        }, {
            key: "fromBufferAttribute",
            value: function(e, t) {
                return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
            }
        }, {
            key: "toJSON",
            value: function() {
                return this.getHex()
            }
        }, {
            key: "copyRGBEToLinear",
            value: function(e, t) {
                return this.r = Zr(e.r, t), this.g = Zr(e.g, t), this.b = Zr(e.b, t), this
            }
        }, {
            key: "convertRGBEToLinear",
            value: function(e) {
                return this.copyRGBEToLinear(this, e), this
            }
        }]), r
    }();
    Qr.NAMES = jr, Qr.prototype.r = 1, Qr.prototype.g = 1, Qr.prototype.b = 1;
    var Kr = function() {
            function o(e, t, n, r, i) {
                var a = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
                _classCallCheck(this, o), this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Tn, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new Qr, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = a
            }
            return _createClass(o, [{
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (var r = 0, i = e.vertexColors.length; r < i; r++) this.vertexColors[r] = e.vertexColors[r].clone();
                    return this
                }
            }]), o
        }(),
        Jr = 0;

    function $r() {
        Object.defineProperty(this, "id", {
            value: Jr++
        }), this.uuid = mn.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = H, this.side = ie, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = ge, this.blendDst = _e, this.blendEquation = Q, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Ee, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = tn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = en, this.stencilZFail = en, this.stencilZPass = en, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this.receiveShadow = !1, this.castShadow = !1, this.useHDR = !1, this.profile = ""
    }

    function ei(e) {
        $r.call(this), this.type = "MeshBasicMaterial", this.color = new Qr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = T, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
    }
    $r.prototype = Object.assign(Object.create(n.prototype), {
        constructor: $r,
        isMaterial: !0,
        onBeforeCompile: function() {},
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString()
        },
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var n, r = e[t];
                    void 0 !== r ? "shading" !== t ? void 0 !== (n = this[t]) ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r : console.warn("v3d." + this.type + ": '" + t + "' is not a property of this material.") : (console.warn("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === r) : console.warn("v3d.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function r(e) {
                var t, n = [];
                for (t in e) {
                    var r = e[t];
                    delete r.metadata, n.push(r)
                }
                return n
            }
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && !this.isMeshNodeMaterial && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== H && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== ie && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t && (t = r(e.textures), e = r(e.images), 0 < t.length && (n.textures = t), 0 < e.length && (n.images = e)), n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            var t = e.clippingPlanes,
                n = null;
            if (null !== t)
                for (var r = t.length, n = new Array(r), i = 0; i !== r; ++i) n[i] = t[i].clone();
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this.receiveShadow = e.receiveShadow, this.castShadow = e.castShadow, this.useHDR = e.useHDR, this.profile = e.profile, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty($r.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        },
        get: function() {
            return 0 != this.version
        }
    }), ((ei.prototype = Object.create($r.prototype)).constructor = ei).prototype.isMeshBasicMaterial = !0, ei.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    };
    var ti = new Tn,
        ni = new vn;

    function ri(e, t, n) {
        if (Array.isArray(e)) throw new TypeError("v3d.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = nn, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function ii(e, t, n) {
        ri.call(this, new Int8Array(e), t, n)
    }

    function ai(e, t, n) {
        ri.call(this, new Uint8Array(e), t, n)
    }

    function oi(e, t, n) {
        ri.call(this, new Uint8ClampedArray(e), t, n)
    }

    function si(e, t, n) {
        ri.call(this, new Int16Array(e), t, n)
    }

    function li(e, t, n) {
        ri.call(this, new Uint16Array(e), t, n)
    }

    function ci(e, t, n) {
        ri.call(this, new Int32Array(e), t, n)
    }

    function ui(e, t, n) {
        ri.call(this, new Uint32Array(e), t, n)
    }

    function di(e, t, n) {
        ri.call(this, new Uint16Array(e), t, n)
    }

    function hi(e, t, n) {
        ri.call(this, new Float32Array(e), t, n)
    }

    function fi(e, t, n) {
        ri.call(this, new Float64Array(e), t, n)
    }
    Object.defineProperty(ri.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(ri.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e, this
        },
        copy: function(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
        },
        copyAt: function(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e), this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyColorsArray(): color is undefined", r), a = new Qr), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new vn), t[n++] = a.x, t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new Tn), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new Mn), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
            }
            return this
        },
        applyMatrix3: function(e) {
            if (2 === this.itemSize)
                for (var t = 0, n = this.count; t < n; t++) ni.fromBufferAttribute(this, t), ni.applyMatrix3(e), this.setXY(t, ni.x, ni.y);
            else if (3 === this.itemSize)
                for (var r = 0, i = this.count; r < i; r++) ti.fromBufferAttribute(this, r), ti.applyMatrix3(e), this.setXYZ(r, ti.x, ti.y, ti.z);
            return this
        },
        applyMatrix4: function(e) {
            for (var t = 0, n = this.count; t < n; t++) ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.applyMatrix4(e), this.setXYZ(t, ti.x, ti.y, ti.z);
            return this
        },
        applyNormalMatrix: function(e) {
            for (var t = 0, n = this.count; t < n; t++) ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.applyNormalMatrix(e), this.setXYZ(t, ti.x, ti.y, ti.z);
            return this
        },
        transformDirection: function(e) {
            for (var t = 0, n = this.count; t < n; t++) ti.x = this.getX(t), ti.y = this.getY(t), ti.z = this.getZ(t), ti.transformDirection(e), this.setXYZ(t, ti.x, ti.y, ti.z);
            return this
        },
        set: function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.array.set(e, t), this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function(e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        },
        setXYZ: function(e, t, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
        },
        setXYZW: function(e, t, n, r, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), (ii.prototype = Object.create(ri.prototype)).constructor = ii, (ai.prototype = Object.create(ri.prototype)).constructor = ai, (oi.prototype = Object.create(ri.prototype)).constructor = oi, (si.prototype = Object.create(ri.prototype)).constructor = si, (li.prototype = Object.create(ri.prototype)).constructor = li, (ci.prototype = Object.create(ri.prototype)).constructor = ci, (ui.prototype = Object.create(ri.prototype)).constructor = ui, ((di.prototype = Object.create(ri.prototype)).constructor = di).prototype.isFloat16BufferAttribute = !0, (hi.prototype = Object.create(ri.prototype)).constructor = hi, (fi.prototype = Object.create(ri.prototype)).constructor = fi;
    var pi = function() {
        function e() {
            _classCallCheck(this, e), this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        return _createClass(e, [{
            key: "computeGroups",
            value: function(e) {
                for (var t, n = [], r = void 0, i = e.faces, a = 0; a < i.length; a++) {
                    var o = i[a];
                    o.materialIndex !== r && (r = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), t = {
                        start: 3 * a,
                        materialIndex: r
                    })
                }
                void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), this.groups = n
            }
        }, {
            key: "fromGeometry",
            value: function(e) {
                var t, n = e.faces,
                    r = e.vertices,
                    i = e.faceVertexUvs,
                    a = i[0] && 0 < i[0].length,
                    o = i[1] && 0 < i[1].length,
                    s = e.morphTargets,
                    l = s.length;
                if (0 < l) {
                    t = [];
                    for (var c = 0; c < l; c++) t[c] = {
                        name: s[c].name,
                        data: []
                    };
                    this.morphTargets.position = t
                }
                var u, d = e.morphNormals,
                    h = d.length;
                if (0 < h) {
                    u = [];
                    for (var f = 0; f < h; f++) u[f] = {
                        name: d[f].name,
                        data: []
                    };
                    this.morphTargets.normal = u
                }
                var p = e.skinIndices,
                    m = e.skinWeights,
                    v = p.length === r.length,
                    g = m.length === r.length;
                0 < r.length && 0 === n.length && console.error("v3d.DirectGeometry: Faceless geometries are not supported.");
                for (var _ = 0; _ < n.length; _++) {
                    var y = n[_];
                    this.vertices.push(r[y.a], r[y.b], r[y.c]);
                    var x = y.vertexNormals;
                    3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (M = y.normal, this.normals.push(M, M, M));
                    var b, M = y.vertexColors;
                    3 === M.length ? this.colors.push(M[0], M[1], M[2]) : (M = y.color, this.colors.push(M, M, M)), !0 === a && (void 0 !== (b = i[0][_]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("v3d.DirectGeometry.fromGeometry(): Undefined vertexUv ", _), this.uvs.push(new vn, new vn, new vn))), !0 === o && (void 0 !== (b = i[1][_]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("v3d.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", _), this.uvs2.push(new vn, new vn, new vn)));
                    for (var w = 0; w < l; w++) {
                        var S = s[w].vertices;
                        t[w].data.push(S[y.a], S[y.b], S[y.c])
                    }
                    for (var A = 0; A < h; A++) {
                        var T = d[A].vertexNormals[_];
                        u[A].data.push(T.a, T.b, T.c)
                    }
                    v && this.skinIndices.push(p[y.a], p[y.b], p[y.c]), g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
            }
        }]), e
    }();

    function mi(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
        return t
    }
    var vi = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function gi(e, t) {
        return new vi[e](t)
    }

    function _i(e) {
        return void 0 !== e
    }

    function yi(e, t, n) {
        for (var r = 0; r < e.length; r++) e[r] = mn.clamp(e[r], t, n);
        return e
    }

    function xi() {
        switch (on) {
            case "BLENDER":
                return "for Blender";
            case "MAX":
                return "for 3ds Max";
            case "MAYA":
                return "for Maya";
            case "ALL":
                return "Ultimate";
            default:
                return "Unknown"
        }
    }

    function bi(e) {
        return "".concat(e % 1 ? e : "".concat(e, ".0"))
    }

    function Mi() {
        return "undefined" != typeof window ? window : self
    }
    var wi = {};

    function Si(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : function(e) {},
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : function(e) {};
        wi[e] = wi[e] || {
            status: 0,
            loadCallbacks: [],
            errorCallbacks: []
        };
        var r = wi[e];
        if (4 != r.status) {
            if (r.loadCallbacks.push(t), r.errorCallbacks.push(n), !(0 < r.status)) {
                for (var i = document.getElementsByTagName("script"), a = e, o = i.length - 1; 0 <= o; --o) {
                    var s = i[o].src,
                        l = s.search(/\/v3d[\w.]+js/); - 1 < l && (a = s.substr(0, l) + "/" + e)
                }
                var c, u = document.createElement("script");
                u.type = "text/javascript", u.src = a, c = e, u.onload = function() {
                    wi[c].loadCallbacks.forEach(function(e) {
                        e(c)
                    }), wi[c].status = 4
                }, u.onerror = function() {
                    wi[c].errorCallbacks.forEach(function(e) {
                        e(c)
                    }), wi[c].status = 0
                }, document.getElementsByTagName("head")[0].appendChild(u), r.status = 3
            }
        } else t(e)
    }

    function Ai(e, a, t) {
        var o = 2 < arguments.length && void 0 !== t ? t : 0,
            r = Promise.resolve(performance.now());
        return e.forEach(function(e, t, n) {
            r = r.then(function(e, t, n, r) {
                var i = performance.now();
                return a(e, t, n), o < i - r ? (r = i, new Promise(function(e) {
                    setTimeout(function() {
                        e(r)
                    }, 1)
                })) : r
            }.bind(null, e, t, n))
        }), r
    }
    var Ti = 1,
        Ei = new nr,
        Ci = new Er,
        Li = new Tn,
        Pi = new Ln,
        Ri = new Ln,
        Di = new Tn;

    function Oi() {
        Object.defineProperty(this, "id", {
            value: Ti += 2
        }), this.uuid = mn.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    Oi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Oi,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            return Array.isArray(e) ? this.index = new(65535 < mi(e) ? ui : li)(e, 1) : this.index = e, this
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        setAttribute: function(e, t) {
            return this.attributes[e] = t, this
        },
        deleteAttribute: function(e) {
            return delete this.attributes[e], this
        },
        hasAttribute: function(e) {
            return void 0 !== this.attributes[e]
        },
        addGroup: function(e, t) {
            var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix4: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
            var n = this.attributes.normal;
            void 0 !== n && (t = (new gn).getNormalMatrix(e), n.applyNormalMatrix(t), n.needsUpdate = !0);
            n = this.attributes.tangent;
            return void 0 !== n && (n.transformDirection(e), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function(e) {
            return Ei.makeRotationX(e), this.applyMatrix4(Ei), this
        },
        rotateY: function(e) {
            return Ei.makeRotationY(e), this.applyMatrix4(Ei), this
        },
        rotateZ: function(e) {
            return Ei.makeRotationZ(e), this.applyMatrix4(Ei), this
        },
        translate: function(e, t, n) {
            return Ei.makeTranslation(e, t, n), this.applyMatrix4(Ei), this
        },
        scale: function(e, t, n) {
            return Ei.makeScale(e, t, n), this.applyMatrix4(Ei), this
        },
        lookAt: function(e) {
            return Ci.lookAt(e), Ci.updateMatrix(), this.applyMatrix4(Ci.matrix), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Li).negate(), this.translate(Li.x, Li.y, Li.z), this
        },
        setFromObject: function(e) {
            var t, n, r = e.geometry;
            return e.isPoints || e.isLine ? (t = new hi(3 * r.vertices.length, 3), n = new hi(3 * r.colors.length, 3), this.setAttribute("position", t.copyVector3sArray(r.vertices)), this.setAttribute("color", n.copyColorsArray(r.colors)), r.lineDistances && r.lineDistances.length === r.vertices.length && (n = new hi(r.lineDistances.length, 1), this.setAttribute("lineDistance", n.copyArray(r.lineDistances))), null !== r.boundingSphere && (this.boundingSphere = r.boundingSphere.clone()), null !== r.boundingBox && (this.boundingBox = r.boundingBox.clone())) : e.isMesh && r && r.isGeometry && this.fromGeometry(r), this
        },
        setFromPoints: function(e) {
            for (var t = [], n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new hi(t, 3)), this
        },
        updateFromObject: function(e) {
            var t, n, r = e.geometry;
            if (e.isMesh) {
                var i = r.__directGeometry;
                if (!0 === r.elementsNeedUpdate && (i = void 0, r.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(r);
                i.verticesNeedUpdate = r.verticesNeedUpdate, i.normalsNeedUpdate = r.normalsNeedUpdate, i.colorsNeedUpdate = r.colorsNeedUpdate, i.uvsNeedUpdate = r.uvsNeedUpdate, i.groupsNeedUpdate = r.groupsNeedUpdate, r.verticesNeedUpdate = !1, r.normalsNeedUpdate = !1, r.colorsNeedUpdate = !1, r.uvsNeedUpdate = !1, r.groupsNeedUpdate = !1, r = i
            }
            return !0 === r.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(r.vertices), i.needsUpdate = !0), r.verticesNeedUpdate = !1), !0 === r.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(r.normals), t.needsUpdate = !0), r.normalsNeedUpdate = !1), !0 === r.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(r.colors), t.needsUpdate = !0), r.colorsNeedUpdate = !1), r.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(r.uvs), n.needsUpdate = !0), r.uvsNeedUpdate = !1), r.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(r.lineDistances), n.needsUpdate = !0), r.lineDistancesNeedUpdate = !1), r.groupsNeedUpdate && (r.computeGroups(e.geometry), this.groups = r.groups, r.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new pi).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t, n, r, i, a = new Float32Array(3 * e.vertices.length);
            for (r in this.setAttribute("position", new ri(a, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.setAttribute("normal", new ri(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.setAttribute("color", new ri(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (n = new Float32Array(2 * e.uvs.length), this.setAttribute("uv", new ri(n, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (n = new Float32Array(2 * e.uvs2.length), this.setAttribute("uv2", new ri(n, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) {
                for (var o = [], s = e.morphTargets[r], l = 0, c = s.length; l < c; l++) {
                    var u = s[l],
                        d = new hi(3 * u.data.length, 3);
                    d.name = u.name, o.push(d.copyVector3sArray(u.data))
                }
                this.morphAttributes[r] = o
            }
            return 0 < e.skinIndices.length && (i = new hi(4 * e.skinIndices.length, 4), this.setAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new hi(4 * e.skinWeights.length, 4), this.setAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ln);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('v3d.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Tn(-1 / 0, -1 / 0, -1 / 0), new Tn(1 / 0, 1 / 0, 1 / 0));
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (var n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        Pi.setFromBufferAttribute(i), this.morphTargetsRelative ? (Di.addVectors(this.boundingBox.min, Pi.min), this.boundingBox.expandByPoint(Di), Di.addVectors(this.boundingBox.max, Pi.max), this.boundingBox.expandByPoint(Di)) : (this.boundingBox.expandByPoint(Pi.min), this.boundingBox.expandByPoint(Pi.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('v3d.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Yn);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) return console.error('v3d.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Tn, 1 / 0);
            if (e) {
                var n = this.boundingSphere.center;
                if (Pi.setFromBufferAttribute(e), t)
                    for (var r = 0, i = t.length; r < i; r++) {
                        var a = t[r];
                        Ri.setFromBufferAttribute(a), this.morphTargetsRelative ? (Di.addVectors(Pi.min, Ri.min), Pi.expandByPoint(Di), Di.addVectors(Pi.max, Ri.max), Pi.expandByPoint(Di)) : (Pi.expandByPoint(Ri.min), Pi.expandByPoint(Ri.max))
                    }
                Pi.getCenter(n);
                for (var o = 0, s = 0, l = e.count; s < l; s++) Di.fromBufferAttribute(e, s), o = Math.max(o, n.distanceToSquared(Di));
                if (t)
                    for (var c = 0, u = t.length; c < u; c++)
                        for (var d = t[c], h = this.morphTargetsRelative, f = 0, p = d.count; f < p; f++) Di.fromBufferAttribute(d, f), h && (Li.fromBufferAttribute(e, f), Di.add(Li)), o = Math.max(o, n.distanceToSquared(Di));
                this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('v3d.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index,
                t = this.getAttribute("position");
            if (void 0 !== t) {
                var n = this.getAttribute("normal");
                if (void 0 === n) n = new ri(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                else
                    for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
                var a = new Tn,
                    o = new Tn,
                    s = new Tn,
                    l = new Tn,
                    c = new Tn,
                    u = new Tn,
                    d = new Tn,
                    h = new Tn;
                if (e)
                    for (var f = 0, p = e.count; f < p; f += 3) {
                        var m = e.getX(f + 0),
                            v = e.getX(f + 1),
                            g = e.getX(f + 2);
                        a.fromBufferAttribute(t, m), o.fromBufferAttribute(t, v), s.fromBufferAttribute(t, g), d.subVectors(s, o), h.subVectors(a, o), d.cross(h), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, v), u.fromBufferAttribute(n, g), l.add(d), c.add(d), u.add(d), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, c.x, c.y, c.z), n.setXYZ(g, u.x, u.y, u.z)
                    } else
                        for (var _ = 0, y = t.count; _ < y; _ += 3) a.fromBufferAttribute(t, _ + 0), o.fromBufferAttribute(t, _ + 1), s.fromBufferAttribute(t, _ + 2), d.subVectors(s, o), h.subVectors(a, o), d.cross(h), n.setXYZ(_ + 0, d.x, d.y, d.z), n.setXYZ(_ + 1, d.x, d.y, d.z), n.setXYZ(_ + 2, d.x, d.y, d.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("v3d.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n, r = this.attributes;
                for (n in r)
                    if (void 0 !== e.attributes[n])
                        for (var i = r[n].array, a = e.attributes[n], o = a.array, a = a.itemSize * t, s = Math.min(o.length, i.length - a), l = 0, c = a; l < s; l++, c++) i[c] = o[l];
                return this
            }
            console.error("v3d.BufferGeometry.merge(): geometry not an instance of v3d.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) Di.fromBufferAttribute(e, t), Di.normalize(), e.setXYZ(t, Di.x, Di.y, Di.z)
        },
        toNonIndexed: function() {
            function e(e, t) {
                for (var n = e.array, r = e.itemSize, e = e.normalized, i = new n.constructor(t.length * r), a = 0, o = 0, s = 0, l = t.length; s < l; s++) {
                    a = t[s] * r;
                    for (var c = 0; c < r; c++) i[o++] = n[a++]
                }
                return new ri(i, r, e)
            }
            if (null === this.index) return console.warn("v3d.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t, n = new Oi,
                r = this.index.array,
                i = this.attributes;
            for (t in i) {
                var a = e(i[t], r);
                n.setAttribute(t, a)
            }
            var o, s = this.morphAttributes;
            for (o in s) {
                for (var l = [], c = s[o], u = 0, d = c.length; u < d; u++) {
                    var h = e(c[u], r);
                    l.push(h)
                }
                n.morphAttributes[o] = l
            }
            n.morphTargetsRelative = this.morphTargetsRelative;
            for (var f = this.groups, p = 0, m = f.length; p < m; p++) {
                var v = f[p];
                n.addGroup(v.start, v.count, v.materialIndex)
            }
            return n
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t, n = this.parameters;
                for (t in n) void 0 !== n[t] && (e[t] = n[t]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var r = this.index;
            null !== r && (e.data.index = {
                type: r.array.constructor.name,
                array: Array.prototype.slice.call(r.array)
            });
            var i, a = this.attributes;
            for (i in a) {
                var o = a[i],
                    s = o.toJSON(e.data);
                "" !== o.name && (s.name = o.name), e.data.attributes[i] = s
            }
            var l, c = {},
                u = !1;
            for (l in this.morphAttributes) {
                for (var d = this.morphAttributes[l], h = [], f = 0, p = d.length; f < p; f++) {
                    var m = d[f],
                        v = m.toJSON(e.data);
                    "" !== m.name && (v.name = m.name), h.push(v)
                }
                0 < h.length && (c[l] = h, u = !0)
            }
            u && (e.data.morphAttributes = c, e.data.morphTargetsRelative = this.morphTargetsRelative);
            r = this.groups;
            0 < r.length && (e.data.groups = JSON.parse(JSON.stringify(r)));
            r = this.boundingSphere;
            return null !== r && (e.data.boundingSphere = {
                center: r.center.toArray(),
                radius: r.radius
            }), e
        },
        clone: function() {
            return (new Oi).copy(this)
        },
        copy: function(e) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            var t = {};
            this.name = e.name;
            var n = e.index;
            null !== n && this.setIndex(n.clone(t));
            var r, i = e.attributes;
            for (r in i) {
                var a = i[r];
                this.setAttribute(r, a.clone(t))
            }
            var o, s = e.morphAttributes;
            for (o in s) {
                for (var l = [], c = s[o], u = 0, d = c.length; u < d; u++) l.push(c[u].clone(t));
                this.morphAttributes[o] = l
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            for (var h = e.groups, f = 0, p = h.length; f < p; f++) {
                var m = h[f];
                this.addGroup(m.start, m.count, m.materialIndex)
            }
            n = e.boundingBox;
            null !== n && (this.boundingBox = n.clone());
            n = e.boundingSphere;
            return null !== n && (this.boundingSphere = n.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Ni = new nr,
        Ii = new tr,
        Fi = new Yn,
        ki = new Tn,
        Bi = new Tn,
        zi = new Tn,
        Ui = new Tn,
        Vi = new Tn,
        Gi = new Tn,
        ji = new Tn,
        Wi = new Tn,
        Hi = new Tn,
        Xi = new vn,
        Yi = new vn,
        qi = new vn,
        Zi = new Tn,
        Qi = new Tn;

    function Ki() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Oi,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new ei;
        Er.call(this), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets(), this.isMaterialGeneratedMesh = !1
    }

    function Ji(e, t, n, r, i, a, o, s) {
        t = t.side === ae ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== oe, s);
        if (null === t) return null;
        Qi.copy(s), Qi.applyMatrix4(e.matrixWorld);
        s = n.ray.origin.distanceTo(Qi);
        return s < n.near || s > n.far ? null : {
            distance: s,
            point: Qi.clone(),
            object: e
        }
    }

    function $i(e, t, n, r, i, a, o, s, l, c, u, d) {
        ki.fromBufferAttribute(i, c), Bi.fromBufferAttribute(i, u), zi.fromBufferAttribute(i, d);
        var h = e.morphTargetInfluences;
        if (t.morphTargets && a && h) {
            ji.set(0, 0, 0), Wi.set(0, 0, 0), Hi.set(0, 0, 0);
            for (var f = 0, p = a.length; f < p; f++) {
                var m = h[f],
                    v = a[f];
                0 !== m && (Ui.fromBufferAttribute(v, c), Vi.fromBufferAttribute(v, u), Gi.fromBufferAttribute(v, d), o ? (ji.addScaledVector(Ui, m), Wi.addScaledVector(Vi, m), Hi.addScaledVector(Gi, m)) : (ji.addScaledVector(Ui.sub(ki), m), Wi.addScaledVector(Vi.sub(Bi), m), Hi.addScaledVector(Gi.sub(zi), m)))
            }
            ki.add(ji), Bi.add(Wi), zi.add(Hi)
        }
        r = Ji(e, t, n, r, ki, Bi, zi, Zi);
        return r && (s && (Xi.fromBufferAttribute(s, c), Yi.fromBufferAttribute(s, u), qi.fromBufferAttribute(s, d), r.uv = Gr.getUV(Zi, ki, Bi, zi, Xi, Yi, qi, new vn)), l && (Xi.fromBufferAttribute(l, c), Yi.fromBufferAttribute(l, u), qi.fromBufferAttribute(l, d), r.uv2 = Gr.getUV(Zi, ki, Bi, zi, Xi, Yi, qi, new vn)), l = new Kr(c, u, d), Gr.getNormal(ki, Bi, zi, l.normal), r.face = l), r
    }
    Ki.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Ki,
        isMesh: !0,
        copy: function(e) {
            return Er.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this.isMaterialGeneratedMesh = e.isMaterialGeneratedMesh, this
        },
        updateMorphTargets: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes,
                    n = Object.keys(t);
                if (0 < n.length) {
                    var r = t[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, a = r.length; i < a; i++) {
                            var o = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                        }
                    }
                }
            } else {
                e = e.morphTargets;
                void 0 !== e && 0 < e.length && console.error("v3d.Mesh.updateMorphTargets() no longer supports v3d.Geometry. Use v3d.BufferGeometry instead.")
            }
        },
        raycast: function(e, t) {
            var n = this.geometry,
                r = this.material,
                i = this.matrixWorld;
            if (void 0 !== r && (null === n.boundingSphere && n.computeBoundingSphere(), Fi.copy(n.boundingSphere), Fi.applyMatrix4(i), !1 !== e.ray.intersectsSphere(Fi) && (Ni.copy(i).invert(), Ii.copy(e.ray).applyMatrix4(Ni), null === n.boundingBox || !1 !== Ii.intersectsBox(n.boundingBox))))
                if (n.isBufferGeometry) {
                    var a = n.index,
                        o = n.attributes.position,
                        s = n.morphAttributes.position,
                        l = n.morphTargetsRelative,
                        c = n.attributes.uv,
                        u = n.attributes.uv2,
                        d = n.groups,
                        h = n.drawRange;
                    if (null !== a)
                        if (Array.isArray(r))
                            for (var f = 0, p = d.length; f < p; f++)
                                for (var m = d[f], v = r[m.materialIndex], g = Math.max(m.start, h.start), _ = Math.min(m.start + m.count, h.start + h.count); g < _; g += 3) {
                                    var y, x = a.getX(g),
                                        b = a.getX(g + 1),
                                        M = a.getX(g + 2);
                                    (y = $i(this, v, e, Ii, o, s, l, c, u, x, b, M)) && (y.faceIndex = Math.floor(g / 3), y.face.materialIndex = m.materialIndex, t.push(y))
                                } else
                                    for (var w = Math.max(0, h.start), S = Math.min(a.count, h.start + h.count); w < S; w += 3) {
                                        var A = a.getX(w),
                                            T = a.getX(w + 1),
                                            E = a.getX(w + 2);
                                        (y = $i(this, r, e, Ii, o, s, l, c, u, A, T, E)) && (y.faceIndex = Math.floor(w / 3), t.push(y))
                                    } else if (void 0 !== o)
                                        if (Array.isArray(r))
                                            for (var C = 0, L = d.length; C < L; C++)
                                                for (var P = d[C], R = r[P.materialIndex], D = Math.max(P.start, h.start), O = Math.min(P.start + P.count, h.start + h.count); D < O; D += 3)(y = $i(this, R, e, Ii, o, s, l, c, u, D, D + 1, D + 2)) && (y.faceIndex = Math.floor(D / 3), y.face.materialIndex = P.materialIndex, t.push(y));
                                        else
                                            for (var N = Math.max(0, h.start), I = Math.min(o.count, h.start + h.count); N < I; N += 3)(y = $i(this, r, e, Ii, o, s, l, c, u, N, N + 1, N + 2)) && (y.faceIndex = Math.floor(N / 3), t.push(y))
                } else if (n.isGeometry) {
                var F, k = Array.isArray(r),
                    B = n.vertices,
                    z = n.faces,
                    n = n.faceVertexUvs[0];
                0 < n.length && (F = n);
                for (var U = 0, V = z.length; U < V; U++) {
                    var G, j, W, H = z[U],
                        X = k ? r[H.materialIndex] : r;
                    void 0 !== X && (G = B[H.a], j = B[H.b], W = B[H.c], (y = Ji(this, X, e, Ii, G, j, W, Zi)) && (F && F[U] && (X = F[U], Xi.copy(X[0]), Yi.copy(X[1]), qi.copy(X[2]), y.uv = Gr.getUV(Zi, G, j, W, Xi, Yi, qi, new vn)), y.face = H, y.faceIndex = U, t.push(y)))
                }
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        },
        getWorldDirection: function(e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        isVisible: function() {
            return this.isMaterialGeneratedMesh && this.parent ? this.visible && this.parent.visible : this.visible
        }
    });
    var ea = function() {
        _inherits(c, Oi);
        var l = _createSuper(c);

        function c() {
            var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1,
                a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1,
                o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 1;
            _classCallCheck(this, c), (e = l.call(this)).type = "BoxBufferGeometry", e.parameters = {
                width: t,
                height: n,
                depth: r,
                widthSegments: i,
                heightSegments: a,
                depthSegments: o
            };
            var R = _assertThisInitialized(e),
                i = Math.floor(i),
                a = Math.floor(a),
                o = Math.floor(o),
                D = [],
                O = [],
                N = [],
                I = [],
                F = 0,
                k = 0;

            function s(e, t, n, r, i, a, o, s, l, c, u) {
                for (var d = a / l, h = o / c, f = a / 2, p = o / 2, m = s / 2, v = l + 1, g = c + 1, _ = 0, y = 0, x = new Tn, b = 0; b < g; b++)
                    for (var M = b * h - p, w = 0; w < v; w++) {
                        var S = w * d - f;
                        x[e] = S * r, x[t] = M * i, x[n] = m, O.push(x.x, x.y, x.z), x[e] = 0, x[t] = 0, x[n] = 0 < s ? 1 : -1, N.push(x.x, x.y, x.z), I.push(w / l), I.push(1 - b / c), _ += 1
                    }
                for (var A = 0; A < c; A++)
                    for (var T = 0; T < l; T++) {
                        var E = F + T + v * A,
                            C = F + T + v * (A + 1),
                            L = F + (T + 1) + v * (A + 1),
                            P = F + (T + 1) + v * A;
                        D.push(E, C, P), D.push(C, L, P), y += 6
                    }
                R.addGroup(k, y, u), k += y, F += _
            }
            return s("z", "y", "x", -1, -1, r, n, t, o, a, 0), s("z", "y", "x", 1, -1, r, n, -t, o, a, 1), s("x", "z", "y", 1, 1, t, r, n, i, o, 2), s("x", "z", "y", 1, -1, t, r, -n, i, o, 3), s("x", "y", "z", 1, -1, t, n, r, i, a, 4), s("x", "y", "z", -1, -1, t, n, -r, i, a, 5), e.setIndex(D), e.setAttribute("position", new hi(O, 3)), e.setAttribute("normal", new hi(N, 3)), e.setAttribute("uv", new hi(I, 2)), e
        }
        return c
    }();

    function ta(e) {
        var t, n = {};
        for (t in e)
            for (var r in n[t] = {}, e[t]) {
                var i = e[t][r];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? n[t][r] = i.clone() : Array.isArray(i) ? n[t][r] = i.slice() : n[t][r] = i
            }
        return n
    }

    function na(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
            var r, i = ta(e[n]);
            for (r in i) t[r] = i[r]
        }
        return t
    }
    var ra = {
            clone: ta,
            merge: na
        },
        ia = "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        aa = "void main() {\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}";

    function oa(e) {
        $r.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.customPrepTokens = {}, this.vertexShader = ia, this.fragmentShader = aa, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("v3d.ShaderMaterial: attributes should now be defined in v3d.BufferGeometry instead."), this.setValues(e))
    }

    function sa() {
        Er.call(this), this.type = "Camera", this.matrixWorldInverse = new nr, this.projectionMatrix = new nr, this.projectionMatrixInverse = new nr, this.controls = null, this.viewportFit = {
            type: ln,
            initialAspect: 1
        }
    }

    function la() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 50,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : .1,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 2e3;
        sa.call(this), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }((oa.prototype = Object.create($r.prototype)).constructor = oa).prototype.isShaderMaterial = !0, oa.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ta(e.uniforms), this.defines = Object.assign({}, e.defines), this.customPrepTokens = Object.assign({}, e.customPrepTokens), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }, oa.prototype.toJSON = function(e) {
        var t, n = $r.prototype.toJSON.call(this, e);
        for (t in n.glslVersion = this.glslVersion, n.uniforms = {}, this.uniforms) {
            var r = this.uniforms[t].value;
            r && r.isTexture ? n.uniforms[t] = {
                type: "t",
                value: r.toJSON(e).uuid
            } : r && r.isColor ? n.uniforms[t] = {
                type: "c",
                value: r.getHex()
            } : r && r.isVector2 ? n.uniforms[t] = {
                type: "v2",
                value: r.toArray()
            } : r && r.isVector3 ? n.uniforms[t] = {
                type: "v3",
                value: r.toArray()
            } : r && r.isVector4 ? n.uniforms[t] = {
                type: "v4",
                value: r.toArray()
            } : r && r.isMatrix3 ? n.uniforms[t] = {
                type: "m3",
                value: r.toArray()
            } : r && r.isMatrix4 ? n.uniforms[t] = {
                type: "m4",
                value: r.toArray()
            } : n.uniforms[t] = {
                value: r
            }
        }
        0 < Object.keys(this.defines).length && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader;
        var i, a = {};
        for (i in this.extensions) !0 === this.extensions[i] && (a[i] = !0);
        return 0 < Object.keys(a).length && (n.extensions = a), n
    }, sa.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: sa,
        isCamera: !0,
        copy: function(e, t) {
            return Er.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), e.controls && (this.controls = {
                type: e.controls.type,
                enablePan: e.controls.enablePan,
                rotateSpeed: e.controls.rotateSpeed,
                moveSpeed: e.controls.moveSpeed,
                orbitMinDistance: e.controls.orbitMinDistance,
                orbitMaxDistance: e.controls.orbitMaxDistance,
                orbitMinPolarAngle: e.controls.orbitMinPolarAngle,
                orbitMaxPolarAngle: e.controls.orbitMaxPolarAngle,
                orbitMinAzimuthAngle: e.controls.orbitMinAzimuthAngle,
                orbitMaxAzimuthAngle: e.controls.orbitMaxAzimuthAngle
            }, e.controls.orbitTarget && (this.controls.orbitTarget = e.controls.orbitTarget)), this.viewportFit.type = e.viewportFit.type, this.viewportFit.initialAspect = e.viewportFit.initialAspect, this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("v3d.Camera: .getWorldDirection() target is now required"), e = new Tn), this.updateWorldMatrix(!0, !1);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            Er.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        updateWorldMatrix: function(e, t) {
            Er.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        }
    }), la.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: la,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return sa.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function(e) {
            e = .5 * this.getFilmHeight() / e;
            this.fov = 2 * mn.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * mn.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * mn.RAD2DEG * Math.atan(Math.tan(.5 * mn.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, n, r, i, a) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e, t = this.near,
                n = t * Math.tan(.5 * mn.DEG2RAD * this.fov) / this.zoom,
                r = 2 * n,
                i = this.aspect * r,
                a = -.5 * i,
                o = this.view;
            null !== this.view && this.view.enabled && (e = o.fullWidth, s = o.fullHeight, a += o.offsetX * i / e, n -= o.offsetY * r / s, i *= o.width / e, r *= o.height / s);
            var s = this.filmOffset;
            0 !== s && (a += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, n, n - r, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        },
        toJSON: function(e) {
            e = Er.prototype.toJSON.call(this, e);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    });

    function ca(e, t, a) {
        var o, s, l, c, u, d;
        Er.call(this), this.type = "CubeCamera", !0 === a.isWebGLCubeRenderTarget ? (this.renderTarget = a, (o = new la(90, 1, e, t)).layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Tn(1, 0, 0)), this.add(o), (s = new la(90, 1, e, t)).layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Tn(-1, 0, 0)), this.add(s), (l = new la(90, 1, e, t)).layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new Tn(0, 1, 0)), this.add(l), (c = new la(90, 1, e, t)).layers = this.layers, c.up.set(0, 0, -1), c.lookAt(new Tn(0, -1, 0)), this.add(c), (u = new la(90, 1, e, t)).layers = this.layers, u.up.set(0, -1, 0), u.lookAt(new Tn(0, 0, 1)), this.add(u), (d = new la(90, 1, e, t)).layers = this.layers, d.up.set(0, -1, 0), d.lookAt(new Tn(0, 0, -1)), this.add(d), this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var n = e.xr.enabled,
                r = e.getRenderTarget();
            e.xr.enabled = !1;
            var i = a.texture.generateMipmaps;
            a.texture.generateMipmaps = !1, e.setRenderTarget(a, 0), e.render(t, o), e.setRenderTarget(a, 1), e.render(t, s), e.setRenderTarget(a, 2), e.render(t, l), e.setRenderTarget(a, 3), e.render(t, c), e.setRenderTarget(a, 4), e.render(t, u), a.texture.generateMipmaps = i, e.setRenderTarget(a, 5), e.render(t, d), e.setRenderTarget(r), e.xr.enabled = n
        }) : console.error("v3d.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.")
    }

    function ua(e, t, n, r, i, a, o, s, l, c) {
        xn.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : N, n, r, i, a, o = void 0 !== o ? o : Ze, s, l, c), this.flipY = !1, this._needsFlipEnvMap = !0
    }

    function da(e, t, n) {
        Number.isInteger(t) && (console.warn("v3d.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget(size, options)"), t = n), wn.call(this, e, e, t), t = t || {}, this.texture = new ua(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture._needsFlipEnvMap = !1
    }

    function ha(e, t, n, r, i, a, o, s, l, c, u, d) {
        xn.call(this, null, a, o, s, l, c, r, i, u, d), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1
        }, this.magFilter = void 0 !== l ? l : ke, this.minFilter = void 0 !== c ? c : ke, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }(ca.prototype = Object.create(Er.prototype)).constructor = ca, ((ua.prototype = Object.create(xn.prototype)).constructor = ua).prototype.isCubeTexture = !0, Object.defineProperty(ua.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }), ((da.prototype = Object.create(wn.prototype)).constructor = da).prototype.isWebGLCubeRenderTarget = !0, da.prototype.fromEquirectangularTexture = function(e, t) {
        this.texture.type = t.type, this.texture.format = Qe, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        var n = {
                tEquirect: {
                    value: null
                }
            },
            r = "\n\n            varying vec3 vWorldDirection;\n\n            vec3 transformDirection(in vec3 dir, in mat4 matrix) {\n\n                return normalize((matrix * vec4(dir, 0.0)).xyz);\n\n            }\n\n            void main() {\n\n                vWorldDirection = transformDirection(position, modelMatrix);\n\n                #include <begin_vertex>\n                #include <project_vertex>\n\n            }\n        ",
            i = "\n\n            uniform sampler2D tEquirect;\n\n            varying vec3 vWorldDirection;\n\n            #include <common>\n\n            void main() {\n\n                vec3 direction = normalize(vWorldDirection);\n\n                vec2 sampleUV = equirectUv(direction);\n\n                gl_FragColor = texture2D(tEquirect, sampleUV);\n\n            }\n        ",
            a = new ea(5, 5, 5),
            i = new oa({
                name: "CubemapFromEquirect",
                uniforms: ta(n),
                vertexShader: r,
                fragmentShader: i,
                side: ae,
                blending: se
            });
        i.uniforms.tEquirect.value = t;
        a = new Ki(a, i), i = t.minFilter;
        return t.minFilter === Ge && (t.minFilter = Ue), new ca(1, 10, this).update(e, a), t.minFilter = i, a.geometry.dispose(), a.material.dispose(), this
    }, da.prototype.clear = function(e, t, n, r) {
        for (var i = e.getRenderTarget(), a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, r);
        e.setRenderTarget(i)
    }, ((ha.prototype = Object.create(xn.prototype)).constructor = ha).prototype.isDataTexture = !0;
    var fa = new Yn,
        pa = new Tn,
        ma = function() {
            function o(e, t, n, r, i, a) {
                _classCallCheck(this, o), this.planes = [void 0 !== e ? e : new Rr, void 0 !== t ? t : new Rr, void 0 !== n ? n : new Rr, void 0 !== r ? r : new Rr, void 0 !== i ? i : new Rr, void 0 !== a ? a : new Rr]
            }
            return _createClass(o, [{
                key: "set",
                value: function(e, t, n, r, i, a) {
                    var o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
            }, {
                key: "setFromProjectionMatrix",
                value: function(e) {
                    var t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        d = n[8],
                        h = n[9],
                        f = n[10],
                        p = n[11],
                        m = n[12],
                        v = n[13],
                        e = n[14],
                        n = n[15];
                    return t[0].setComponents(o - r, u - s, p - d, n - m).normalize(), t[1].setComponents(o + r, u + s, p + d, n + m).normalize(), t[2].setComponents(o + i, u + l, p + h, n + v).normalize(), t[3].setComponents(o - i, u - l, p - h, n - v).normalize(), t[4].setComponents(o - a, u - c, p - f, n - e).normalize(), t[5].setComponents(o + a, u + c, p + f, n + e).normalize(), this
                }
            }, {
                key: "intersectsObject",
                value: function(e) {
                    var t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), fa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(fa)
                }
            }, {
                key: "intersectsSprite",
                value: function(e) {
                    return fa.center.set(0, 0, 0), fa.radius = .7071067811865476, fa.applyMatrix4(e.matrixWorld), this.intersectsSphere(fa)
                }
            }, {
                key: "intersectsSphere",
                value: function(e) {
                    for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++)
                        if (t[i].distanceToPoint(n) < r) return !1;
                    return !0
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++) {
                        var r = t[n];
                        if (pa.x = (0 < r.normal.x ? e.max : e.min).x, pa.y = (0 < r.normal.y ? e.max : e.min).y, pa.z = (0 < r.normal.z ? e.max : e.min).z, r.distanceToPoint(pa) < 0) return !1
                    }
                    return !0
                }
            }, {
                key: "containsPoint",
                value: function(e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            }]), o
        }(),
        va = {
            common: {
                diffuse: {
                    value: new Qr(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                },
                uv2Transform: {
                    value: new gn
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new vn(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Qr(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        maxDistance: {},
                        shadowCameraNear: {},
                        expBias: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadow: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {},
                        expBias: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {},
                        expBias: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Qr(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                }
            },
            sprite: {
                diffuse: {
                    value: new Qr(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new vn(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                }
            },
            mask: {
                depthTexture: {
                    value: null
                },
                cameraNearFar: {
                    value: new vn(.5, .5)
                },
                textureMatrix: {
                    value: new nr
                }
            },
            node: {
                nodeRGB: {
                    value: []
                },
                nodeValue: {
                    value: []
                },
                flipCubeMap: {
                    value: -1
                }
            },
            ssr: {
                invProjectionMatrix: {
                    value: new nr
                },
                ssrSourceBuffer: {
                    value: null
                },
                ssrDepthBuffer: {
                    value: null
                },
                ssrBackfaceDepthBuffer: {
                    value: null
                },
                ssrStride: {
                    value: 20
                },
                ssrResolution: {
                    value: new vn
                },
                ssrThickness: {
                    value: .01
                },
                ssrJitter: {
                    value: 1
                },
                ssrMaxDistance: {
                    value: 100
                }
            }
        };

    function ga() {
        var c = {};
        return {
            get: function(e, t, n, r) {
                if (void 0 !== c[r.id]) var i = c[r.id];
                else {
                    for (var i = [r], a = 1; a < 4; a++) {
                        var o = 0 != (1 & a),
                            s = 0 != (2 & a),
                            l = r.clone();
                        l.morphTargets = o, l.skinning = s, i[a] = l
                    }
                    c[r.id] = i
                }
                o = !1;
                n.morphTargets && (t && t.isBufferGeometry ? o = t.morphAttributes && t.morphAttributes.position && 0 < t.morphAttributes.position.length : t && t.isGeometry && (o = t.morphTargets && 0 < t.morphTargets.length)), e.isSkinnedMesh && !1 === n.skinning && console.warn("v3d.OverrideMatVariants: v3d.SkinnedMesh with material.skinning set to false:", e);
                t = 0;
                o && (t |= 1), (s = e.isSkinnedMesh && n.skinning) && (t |= 2);
                t = i[t];
                return t.visible = n.visible, t.wireframe = n.wireframe, t.wireframeLinewidth = n.wireframeLinewidth, t.side = n.side, t.linewidth = n.linewidth, t.clipShadows = n.clipShadows, t.clippingPlanes = n.clippingPlanes, t.clipIntersection = n.clipIntersection, t.isMeshMaskMaterial && (r.cameraNearFar && t.cameraNearFar.copy(r.cameraNearFar), r.textureMatrix && t.textureMatrix.copy(r.textureMatrix), r.depthTexture && (t.depthTexture = r.depthTexture)), t
            },
            update: function(e) {
                delete c[e.id]
            },
            dispose: function() {
                c = {}
            }
        }
    }
    var _a = function() {
        _inherits(n, Er);
        var t = _createSuper(n);

        function n() {
            var e;
            return _classCallCheck(this, n), e = t.call(this), Object.defineProperty(_assertThisInitialized(e), "isScene", {
                value: !0
            }), e.type = "Scene", e.background = null, e.environment = null, e.fog = null, e.overrideMaterial = null, e.autoUpdate = !0, e.postprocessing = [], "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: _assertThisInitialized(e)
            })), e
        }
        return _createClass(n, [{
            key: "copy",
            value: function(e, t) {
                return _get(_getPrototypeOf(n.prototype), "copy", this).call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
        }, {
            key: "toJSON",
            value: function(e) {
                var t = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this, e);
                return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
            }
        }, {
            key: "dispose",
            value: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }]), n
    }();

    function ya() {
        var n = null,
            e = !1,
            r = null,
            i = null;

        function a(e, t) {
            r(e, t), i = n.requestAnimationFrame(a)
        }
        return {
            start: function() {
                !0 !== e && null !== r && (i = n.requestAnimationFrame(a), e = !0)
            },
            stop: function() {
                n.cancelAnimationFrame(i), e = !1
            },
            setAnimationLoop: function(e) {
                r = e
            },
            setContext: function(e) {
                n = e
            }
        }
    }

    function xa(l, e) {
        var c = e.isWebGL2,
            u = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), u.get(e)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var t = u.get(e);
                t && (l.deleteBuffer(t.buffer), u.delete(e))
            },
            update: function(e, t) {
                var n, r, i, a, o, s;
                e.isGLBufferAttribute ? (!(s = u.get(e)) || s.version < e.version) && u.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version
                }) : (e.isInterleavedBufferAttribute && (e = e.data), void 0 === (n = u.get(e)) ? u.set(e, (i = t, a = (r = e).array, o = r.usage, s = l.createBuffer(), l.bindBuffer(i, s), l.bufferData(i, a, o), r.onUploadCallback(), o = 5126, a instanceof Float32Array ? o = 5126 : a instanceof Float64Array ? console.warn("v3d.WebGLAttributes: Unsupported data buffer format: Float64Array.") : a instanceof Uint16Array ? r.isFloat16BufferAttribute ? c ? o = 5131 : console.warn("v3d.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : a instanceof Int16Array ? o = 5122 : a instanceof Uint32Array ? o = 5125 : a instanceof Int32Array ? o = 5124 : a instanceof Int8Array ? o = 5120 : a instanceof Uint8Array && (o = 5121), {
                    buffer: s,
                    type: o,
                    bytesPerElement: a.BYTES_PER_ELEMENT,
                    version: r.version
                })) : n.version < e.version && (o = n.buffer, a = t, t = (r = e).array, r = r.updateRange, l.bindBuffer(a, o), -1 === r.count ? l.bufferSubData(a, 0, t) : (c ? l.bufferSubData(a, r.offset * t.BYTES_PER_ELEMENT, t, r.offset, r.count) : l.bufferSubData(a, r.offset * t.BYTES_PER_ELEMENT, t.subarray(r.offset, r.offset + r.count)), r.count = -1), n.version = e.version))
            },
            dispose: function() {
                u = new WeakMap
            }
        }
    }
    var ba = function() {
            _inherits(C, Oi);
            var E = _createSuper(C);

            function C() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
                _classCallCheck(this, C), (e = E.call(this)).type = "PlaneBufferGeometry", e.parameters = {
                    width: t,
                    height: n,
                    widthSegments: r,
                    heightSegments: i
                };
                for (var a = t / 2, o = n / 2, s = Math.floor(r), l = Math.floor(i), c = s + 1, u = l + 1, d = t / s, h = n / l, f = [], p = [], m = [], v = [], g = 0; g < u; g++)
                    for (var _ = g * h - o, y = 0; y < c; y++) {
                        var x = y * d - a;
                        p.push(x, -_, 0), m.push(0, 0, 1), v.push(y / s), v.push(1 - g / l)
                    }
                for (var b = 0; b < l; b++)
                    for (var M = 0; M < s; M++) {
                        var w = M + c * b,
                            S = M + c * (b + 1),
                            A = M + 1 + c * (b + 1),
                            T = M + 1 + c * b;
                        f.push(w, S, T), f.push(S, A, T)
                    }
                return e.setIndex(f), e.setAttribute("position", new hi(p, 3)), e.setAttribute("normal", new hi(m, 3)), e.setAttribute("uv", new hi(v, 2)), e
            }
            return C
        }(),
        Ma = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, vUv).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\nif (diffuseColor.a < ALPHATEST)\ndiscard;\nelse\ndiffuseColor.a = 1.0;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\nfloat ambientOcclusion = (texture2D(aoMap, vUv2).r - 1.0) * aoMapIntensity + 1.0;\nreflectedLight.indirectDiffuse *= ambientOcclusion;\n#if defined(USE_ENVMAP) && defined(STANDARD)\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nreflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\nuniform sampler2D aoMap;\nuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3(position);",
            beginnormal_vertex: "vec3 objectNormal = vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent = vec3(tangent.xyz);\n#endif",
            bsdfs: "\nvec2 integrateSpecularBRDF(const in float dotNV, const in float roughness) {\nconst vec4 c0 = vec4(- 1, - 0.0275, - 0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, - 0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;\nreturn vec2(-1.04, 1.04) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor(float lightDistance, const in float cutoffDistance, const in float decayExponent) {\n#if defined (PHYSICALLY_CORRECT_LIGHTS)\nlightDistance = UNITS_SCALE_FACTOR * lightDistance;\n#ifdef MT_MAYA\nfloat distanceFalloff = 1.0 / pow(lightDistance + 1.0, decayExponent);\n#else\nfloat distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);\n#endif\nif(cutoffDistance > 0.0) {\ndistanceFalloff *= pow2(saturate(1.0 - pow4(lightDistance / cutoffDistance)));\n}\nreturn distanceFalloff;\n#else\nif(cutoffDistance > 0.0 && decayExponent > 0.0) {\nreturn pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);\n}\nreturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {\nreturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {\nfloat fresnel = exp2((-5.55473 * dotLH - 6.98316) * dotLH);\nreturn (1.0 - specularColor) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent(const in vec3 F0, const in float dotNV, const in float roughness) {\nfloat fresnel = exp2((-5.55473 * dotNV - 6.98316) * dotNV);\nvec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\nreturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {\nfloat a2 = pow2(alpha);\nfloat gl = dotNL + sqrt(a2 + (1.0 - a2) * pow2(dotNL));\nfloat gv = dotNV + sqrt(a2 + (1.0 - a2) * pow2(dotNV));\nreturn 1.0 / (gl * gv);\n}\nfloat G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\nfloat a2 = pow2(alpha);\nfloat gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\nfloat gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\nreturn 0.5 / max(gv + gl, EPSILON);\n}\nfloat D_GGX(const in float alpha, const in float dotNH) {\nfloat a2 = pow2(alpha);\nfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\nreturn RECIPROCAL_PI * a2 / pow2(denom);\n}\nvec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness) {\nfloat alpha = pow2(clamp(roughness, 0.04, 1.0));\nvec3 halfDir = normalize(incidentLight.direction + viewDir);\nfloat dotNL = saturate(dot(normal, incidentLight.direction));\nfloat dotNV = saturate(dot(normal, viewDir));\nfloat dotNH = saturate(dot(normal, halfDir));\nfloat dotLH = saturate(dot(incidentLight.direction, halfDir));\nvec3 F = F_Schlick(specularColor, dotLH);\nfloat G = G_GGX_SmithCorrelated(alpha, dotNL, dotNV);\nfloat D = D_GGX(alpha, dotNH);\nreturn F * (G * D);\n}\nvec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {\nconst float LUT_SIZE = 64.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\nconst float LUT_BIAS = 0.5 / LUT_SIZE;\nfloat dotNV = saturate(dot(N, V));\nvec2 uv = vec2(roughness, sqrt(1.0 - dotNV));\nuv = uv * LUT_SCALE + LUT_BIAS;\nreturn uv;\n}\nfloat LTC_ClippedSphereFormFactor(const in vec3 f) {\nfloat l = length(f);\nreturn max((l * l + f.z) / (l + 1.0), 0.0);\n}\nvec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {\nfloat x = dot(v1, v2);\nfloat y = abs(x);\nfloat a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;\nfloat b = 3.4175940 + (4.1616724 + y) * y;\nfloat v = a / b;\nfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;\nreturn cross(v1, v2) * theta_sintheta;\n}\nvec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {\nvec3 v1 = rectCoords[1] - rectCoords[0];\nvec3 v2 = rectCoords[3] - rectCoords[0];\nvec3 lightNormal = cross(v1, v2);\nif(dot(lightNormal, P - rectCoords[0]) < 0.0) return vec3(0.0);\nvec3 T1, T2;\nT1 = normalize(V - N * dot(V, N));\nT2 = - cross(N, T1);\nmat3 mat = mInv * transposeMat3(mat3(T1, T2, N));\nvec3 coords[4];\ncoords[0] = mat * (rectCoords[0] - P);\ncoords[1] = mat * (rectCoords[1] - P);\ncoords[2] = mat * (rectCoords[2] - P);\ncoords[3] = mat * (rectCoords[3] - P);\ncoords[0] = normalize(coords[0]);\ncoords[1] = normalize(coords[1]);\ncoords[2] = normalize(coords[2]);\ncoords[3] = normalize(coords[3]);\nvec3 vectorFormFactor = vec3(0.0);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);\nfloat result = LTC_ClippedSphereFormFactor(vectorFormFactor);\nreturn vec3(result);\n}\nvec2 get_BRDF_SpecCoeffsBlender(float x, float y) {\nvec3 xyFactors0 = vec3(x * x, y * y, x * y);\nvec3 xyFactors1 = vec3(x, y, 1);\nvec3 a0a1a2 = vec3(0.33749372, 0.15167605, 1.09684597);\nvec3 a3a4a5 = vec3(-1.26123466, -0.927699, 0.9199188);\nvec3 b0b1b2 = vec3(0.41699717, 0.44675109, 0.79947684);\nvec3 b3b4b5 = vec3(-1.19307849, -0.89813958, 0.89305222);\nvec3 c0c1c2 = vec3(0.29920727, 0.09505591, -0.9136233);\nvec3 c3c4c5 = vec3(0.77055201, 0.13006674, -0.23085581);\nvec3 d0d1d2 = vec3(15.05004149, 7.98517355, 13.30473726);\nvec3 d3d4d5 = vec3(-32.00353547, -12.97743434, 17.83646751);\nfloat coeff0 = (dot(xyFactors0, a0a1a2) + dot(xyFactors1, a3a4a5))\n/ (dot(xyFactors0, b0b1b2) + dot(xyFactors1, b3b4b5));\nfloat coeff1 = (dot(xyFactors0, c0c1c2) + dot(xyFactors1, c3c4c5))\n/ (dot(xyFactors0, d0d1d2) + dot(xyFactors1, d3d4d5));\ncoeff1 = clamp(coeff1, 0.0, 1.0);\nreturn vec2(coeff0, coeff1);\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness) {\nfloat dotNV = saturate(dot(normal, viewDir));\nvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\nreturn specularColor * brdf.x + brdf.y;\n}\nvec3 BRDF_Specular_GGX_Environment_Blender_Approx(const in GeometricContext geometry,\nconst in vec3 fresnelRefl0, const in vec3 fresnelRefl90,\nconst in float roughness, const int useCoat) {\nvec3 normal = geometry.normal;\n#ifdef CLEARCOAT\nif (useCoat == 1) {\nnormal = geometry.clearcoatNormal;\n}\n#endif\nfloat dotNV = saturate(dot(normal, geometry.viewDir));\nfloat angle = acos(abs(dotNV)) / PI_HALF;\nvec2 specCoeffs = get_BRDF_SpecCoeffsBlender(angle, roughness);\nvec3 specular = specCoeffs.x * fresnelRefl0\n+ specCoeffs.y * fresnelRefl90\n* vec3(saturate(50.0 * linearToRelativeLuminance(fresnelRefl0)));\n#if defined (COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX)\nspecular = saturate(specular);\n#endif\nreturn specular;\n}\nvoid BRDF_Specular_Multiscattering_Environment(const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 F = F_Schlick_RoughnessDependent(specularColor, dotNV, roughness);\nvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\nvec3 FssEss = F * brdf.x + brdf.y;\nfloat Ess = brdf.x + brdf.y;\nfloat Ems = 1.0 - Ess;\nvec3 Favg = specularColor + (1.0 - specularColor) * 0.047619;\nvec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);\nsingleScatter += FssEss;\nmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit() {\nreturn 0.25;\n}\nfloat D_BlinnPhong(const in float shininess, const in float dotNH) {\nreturn RECIPROCAL_PI * (shininess * 0.5 + 1.0) * pow(dotNH, shininess);\n}\nvec3 BRDF_Specular_BlinnPhong(const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess) {\nvec3 halfDir = normalize(incidentLight.direction + geometry.viewDir);\nfloat dotNH = saturate(dot(geometry.normal, halfDir));\nfloat dotLH = saturate(dot(incidentLight.direction, halfDir));\nvec3 F = F_Schlick(specularColor, dotLH);\nfloat G = G_BlinnPhong_Implicit();\nfloat D = D_BlinnPhong(shininess, dotNH);\nreturn F * (G * D);\n}\nfloat GGXRoughnessToBlinnExponent(const in float ggxRoughness) {\nreturn (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);\n}\nfloat BlinnExponentToGGXRoughness(const in float blinnExponent) {\nreturn sqrt(2.0 / (blinnExponent + 2.0));\n}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness, float NoH) {\nfloat invAlpha = 1.0 / roughness;\nfloat cos2h = NoH * NoH;\nfloat sin2h = max(1.0 - cos2h, 0.0078125);\nreturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\nreturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen(const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor) {\nvec3 N = geometry.normal;\nvec3 V = geometry.viewDir;\nvec3 H = normalize(V + L);\nfloat dotNH = saturate(dot(N, H));\nreturn specularColor * D_Charlie(roughness, dotNH) * V_Neubelt(dot(N, V), dot(N, L));\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx(vUv);\nvec2 dSTdy = dFdy(vUv);\nfloat Hll = bumpScale * texture2D(bumpMap, vUv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, vUv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, vUv + dSTdy).x - Hll;\nreturn vec2(dBx, dBy);\n}\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\nvec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\nvec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\nvec3 vN = surf_norm;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nfDet *= (float(gl_FrontFacing) * 2.0 - 1.0);\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nreturn normalize(abs(fDet) * surf_norm - vGrad);\n}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\nvec4 plane;\n#pragma unroll_loop_start\nfor (int i = 0; i < UNION_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nif (dot(vClipPosition, plane.xyz) > plane.w) discard;\n}\n#pragma unroll_loop_end\n#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\nbool clipped = true;\n#pragma unroll_loop_start\nfor (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nclipped = (dot(vClipPosition, plane.xyz) > plane.w) && clipped;\n}\n#pragma unroll_loop_end\nif (clipped) discard;\n#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\nvarying vec3 vClipPosition;\nuniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\nvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\nvClipPosition = -mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\ndiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)\nvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined(USE_COLOR) || defined(USE_INSTANCING_COLOR)\nvColor = vec3(1.0);\n#endif\n#ifdef USE_COLOR\nvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\nvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\n#define whiteComplement(a) (1.0 - saturate(a))\n#define RECIPROCAL_3 0.333333333333\nfloat pow2(const in float x) { return x*x; }\nfloat pow3(const in float x) { return x*x*x; }\nfloat pow4(const in float x) { float x2 = x*x; return x2*x2; }\nfloat average(const in vec3 color) { return dot(color, vec3(0.3333)); }\nhighp float rand(const in vec2 uv) {\nconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\nhighp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\nreturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v) { return length(v); }\n#else\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat precisionSafeLength(vec3 v) {\nfloat maxComponent = max3(abs(v));\nreturn length(v / maxComponent) * maxComponent;\n}\n#endif\nstruct IncidentLight {\nvec3 color;\nvec3 direction;\nbool visible;\n};\nstruct ReflectedLight {\nvec3 directDiffuse;\nvec3 directSpecular;\nvec3 indirectDiffuse;\nvec3 indirectSpecular;\n};\nstruct GeometricContext {\nvec3 position;\nvec3 normal;\nvec3 viewDir;\n#ifdef CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((matrix * vec4(dir, 0.0)).xyz);\n}\nvec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((vec4(dir, 0.0) * matrix).xyz);\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\nfloat distance = dot(planeNormal, point - pointOnPlane);\nreturn - distance * planeNormal + point;\n}\nfloat sideOfPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\nreturn sign(dot(point - pointOnPlane, planeNormal));\n}\nvec3 linePlaneIntersect(in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal) {\nreturn lineDirection * (dot(planeNormal, pointOnPlane - pointOnLine) / dot(planeNormal, lineDirection)) + pointOnLine;\n}\nmat3 transposeMat3(const in mat3 m) {\nmat3 tmp;\ntmp[0] = vec3(m[0].x, m[1].x, m[2].x);\ntmp[1] = vec3(m[0].y, m[1].y, m[2].y);\ntmp[2] = vec3(m[0].z, m[1].z, m[2].z);\nreturn tmp;\n}\nfloat linearToRelativeLuminance(const in vec3 color) {\nvec3 weights = vec3(0.2126, 0.7152, 0.0722);\nreturn dot(weights, color.rgb);\n}\nbool isPerspectiveMatrix(mat4 m) {\nreturn m[2][3] == - 1.0;\n}\nhighp vec3 rand3(const in vec3 v) {\nconst highp float c = 43758.5453;\nconst highp mat3 coeffs = mat3(\n165.15, 253.34, 323.22,\n241.49, 329.07, 147.79,\n376.31, 143.45, 281.63\n);\nhighp vec3 sn = mod(coeffs * v, PI);\nreturn fract(sin(sn) * c);\n}\nfloat powCompat(const in float val, const in float power) {\nif (power == 0.0)\nreturn 1.0;\nelse if (val < 0.0) {\nif (mod(-power, 2.0) == 0.0)\nreturn pow(abs(val), power);\nelse\nreturn -pow(abs(val), power);\n} else if (val == 0.0)\nreturn 0.0;\nreturn pow(abs(val), power);\n}\nfloat maxFromRGB(vec3 rgb) {\nreturn max(max(rgb.r, rgb.g), rgb.b);\n}\nbool isOrtho(const in mat4 m) {\nif (m[3][3] != 0.0)\nreturn true;\nelse\nreturn false;\n}\nvec3 swizzleUpZ(const vec3 vec) {\nreturn vec3(vec[0], -vec[2], vec[1]);\n}\nvec3 swizzleUpY(const vec3 vec) {\nreturn vec3(vec[0], vec[2], -vec[1]);\n}\nvec3 xyz_to_sRGB(vec3 xyz) {\nmat3 convMat = mat3(\n3.2406, -0.9689, 0.0557,\n-1.5372, 1.8758, -0.2040,\n-0.4986, 0.0415, 1.0570\n);\nreturn convMat * xyz;\n}\nvec3 xyY_to_XYZ(float x, float y, float Y) {\nfloat X = 0.0;\nfloat Z = 0.0;\nif (y != 0.0) {\nX = (Y / y) * x;\nZ = (Y / y) * (1.0 - x - y);\n}\nreturn vec3(X, Y, Z);\n}\nvec3 octUVToCubeVec(vec2 octUV, vec2 texelSize) {\noctUV = (1.0 + 2.0 * texelSize) * octUV - texelSize;\noctUV = octUV * 2.0 - 1.0;\nfloat x = octUV.x;\nfloat z = -octUV.y;\nfloat absX = abs(x);\nfloat absZ = abs(z);\nvec3 cubeVec = vec3(x, 1.0 - absX - absZ, z);\nif (absX + absZ > 1.0) {\ncubeVec.xz = -(vec2(absZ, absX) - 1.0) * sign(vec2(x, z));\n}\nreturn cubeVec;\n}\nvec2 cubeVecToOctUV(vec3 cubeVec, vec2 texelSize) {\ncubeVec /= dot(vec3(1.0), abs(cubeVec));\nvec2 octUV = vec2(cubeVec.x, -cubeVec.z);\nif (cubeVec.y < 0.0) {\noctUV = sign(octUV) * (1.0 - abs(octUV.ts));\n}\noctUV = (octUV + 1.0) / 2.0;\noctUV = (1.0 - 2.0 * texelSize) * octUV + texelSize;\nreturn octUV;\n}\n#if __VERSION__ == 100\nfloat cosh(float x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec2 cosh(vec2 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec3 cosh(vec3 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec4 cosh(vec4 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nfloat sinh(float x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec2 sinh(vec2 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec3 sinh(vec3 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec4 sinh(vec4 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nfloat tanh(float x) {\nfloat exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec2 tanh(vec2 x) {\nvec2 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec3 tanh(vec3 x) {\nvec3 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec4 tanh(vec4 x) {\nvec4 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nfloat trunc(float x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec2 trunc(vec2 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec3 trunc(vec3 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec4 trunc(vec4 x) {\nreturn floor(abs(x)) * sign(x);\n}\n#endif\nfloat getSmoothFactor(float a, float b, float smoothness) {\nreturn max(smoothness - abs(a - b), 0.0) / smoothness;\n}\nfloat smoothMin(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn min(a, b) - smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}\nfloat smoothMax(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn max(a, b) + smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}\nvec3 vec3RotateAxisAngle(vec3 vector, vec3 axis, float angle) {\nvec3 axisNorm = normalize(axis);\nfloat x = axisNorm.x, y = axisNorm.y, z = axisNorm.z;\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(\nx * x * (1.0 - c) + c,      x * y * (1.0 - c) + z * s,  x * z * (1.0 - c) - y * s,\nx * y * (1.0 - c) - z * s,  y * y * (1.0 - c) + c,      y * z * (1.0 - c) + x * s,\nx * z * (1.0 - c) + y * s,  y * z * (1.0 - c) - x * s,  z * z * (1.0 - c) + c\n) * vector;\n}\nvec3 vec3RotateXAngle(vec3 vector, float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(\n1.0, 0.0, 0.0,\n0.0, c,   s,\n0.0, -s,  c\n) * vector;\n}\nvec3 vec3RotateYAngle(vec3 vector, float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(\nc,   0.0, -s,\n0.0, 1.0, 0.0,\ns,   0.0, c\n) * vector;\n}\nvec3 vec3RotateZAngle(vec3 vector, float angle) {\nfloat s = sin(angle), c = cos(angle);\nreturn mat3(\nc,   s,   0.0,\n-s,  c,   0.0,\n0.0, 0.0, 1.0\n) * vector;\n}\nvec4 eulerToAxisAngle(vec3 euler) {\nfloat c1 = cos(euler.x / 2.0), c2 = cos(euler.y / 2.0), c3 = cos(euler.z / 2.0);\nfloat s1 = sin(euler.x / 2.0), s2 = sin(euler.y / 2.0), s3 = sin(euler.z / 2.0);\nvec4 axisAngle = vec4(\ns1 * c2 * c3 - c1 * s2 * s3,\nc1 * s2 * c3 + s1 * c2 * s3,\nc1 * c2 * s3 - s1 * s2 * c3,\n2.0 * acos(c1 * c2 * c3 + s1 * s2 * s3)\n);\naxisAngle.xyz = length(axisAngle.xyz) > 0.0 ? normalize(axisAngle.xyz) : vec3(1.0, 0.0, 0.0);\nreturn axisAngle;\n}\nfloat mat3GetDeterminant(mat3 mat) {\nreturn mat[0][0] * mat[1][1] * mat[2][2]\n+ mat[0][2] * mat[1][0] * mat[2][1]\n+ mat[0][1] * mat[1][2] * mat[2][0]\n- mat[0][2] * mat[1][1] * mat[2][0]\n- mat[0][0] * mat[1][2] * mat[2][1]\n- mat[0][1] * mat[1][0] * mat[2][2];\n}\nmat3 mat3GetInverseTransposed(mat3 mat) {\nfloat det = mat3GetDeterminant(mat);\nfloat a00 = (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) / det;\nfloat a01 = - (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) / det;\nfloat a02 = (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]) / det;\nfloat a10 = - (mat[0][1] * mat[2][2] - mat[0][2] * mat[2][1]) / det;\nfloat a11 = (mat[0][0] * mat[2][2] - mat[0][2] * mat[2][0]) / det;\nfloat a12 = - (mat[0][0] * mat[2][1] - mat[0][1] * mat[2][0]) / det;\nfloat a20 = (mat[0][1] * mat[1][2] - mat[0][2] * mat[1][1]) / det;\nfloat a21 = - (mat[0][0] * mat[1][2] - mat[0][2] * mat[1][0]) / det;\nfloat a22 = (mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0]) / det;\nreturn mat3(\na00, a01, a02,\na10, a11, a12,\na20, a21, a22\n);\n}\nmat3 toMat3(mat4 mat) {\nreturn mat3(\nmat[0][0], mat[0][1], mat[0][2],\nmat[1][0], mat[1][1], mat[1][2],\nmat[2][0], mat[2][1], mat[2][2]);\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\nfloat getFace(vec3 direction) {\nvec3 absDirection = abs(direction);\nfloat face = -1.0;\nif (absDirection.x > absDirection.z) {\nif (absDirection.x > absDirection.y) {\nface = direction.x > 0.0 ? 0.0 : 3.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n} else {\nif (absDirection.z > absDirection.y) {\nface = direction.z > 0.0 ? 2.0 : 5.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n}\nreturn face;\n}\nvec2 getUV(vec3 direction, float face) {\nvec2 uv;\nif (face == 0.0) {\nuv = vec2(-direction.z, direction.y) / abs(direction.x);\n} else if (face == 1.0) {\nuv = vec2(direction.x, -direction.z) / abs(direction.y);\n} else if (face == 2.0) {\nuv = direction.xy / abs(direction.z);\n} else if (face == 3.0) {\nuv = vec2(direction.z, direction.y) / abs(direction.x);\n} else if (face == 4.0) {\nuv = direction.xz / abs(direction.y);\n} else {\nuv = vec2(-direction.x, direction.y) / abs(direction.z);\n}\nreturn 0.5 * (uv + 1.0);\n}\n#ifndef cubeUV_maxTileSize\n#define cubeUV_maxTileSize 256.0\n#endif\n#define cubeUV_lodIdxMin 0.0\n#define cubeUV_lodIdxLastDownscaled 4.0\n#define cubeUV_lodIdxMax 10.0\n#define cubeUV_minTileSize (cubeUV_maxTileSize / exp2(cubeUV_lodIdxLastDownscaled))\nfloat getLodTileSize(float lodIdx) {\nreturn cubeUV_maxTileSize / exp2(min(lodIdx, cubeUV_lodIdxLastDownscaled));\n}\nfloat getLodFilterLevel(float lodIdx) {\nreturn max(lodIdx - cubeUV_lodIdxLastDownscaled, 0.0);\n}\nvec2 fixCubeUVSeams(vec2 uv, float faceSize) {\nfloat BORDER_WIDTH_PX = max(cubeUV_maxTileSize / 256.0 - 1.0, 0.0);\nfloat scale = (faceSize - BORDER_WIDTH_PX) / faceSize;\nfloat offset = 0.5 * BORDER_WIDTH_PX / faceSize;\nreturn uv * scale + offset;\n}\nvec2 getUVPixels(vec3 direction, float lodIdx) {\nfloat face = getFace(direction);\nfloat faceSize = getLodTileSize(lodIdx);\nfloat filterLevel = getLodFilterLevel(lodIdx);\nvec2 uv = getUV(direction, face);\nuv = fixCubeUVSeams(uv, faceSize);\nuv *= (faceSize - 1.0);\nif (face > 2.0) {\nuv.y += faceSize;\nface -= 3.0;\n}\nuv.x += face * faceSize;\nif (lodIdx > 0.0) {\nuv.y += 2.0 * cubeUV_maxTileSize;\n}\nuv.y += filterLevel * 2.0 * cubeUV_minTileSize;\nuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\nreturn uv;\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {\nfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\nvec2 uv = getUVPixels(direction, lodIdx);\nvec2 f = fract(uv);\nuv += 0.5 - f;\nuv *= texelSize;\nvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.x += texelSize;\nvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.y += texelSize;\nvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.x -= texelSize;\nvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nvec3 tm = mix(tl, tr, f.x);\nvec3 bm = mix(bl, br, f.x);\nreturn mix(tm, bm, f.y);\n}\nvec3 sampleCubeUV(sampler2D envMap, vec3 direction, float lodIdx) {\nfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\nvec2 uv = getUVPixels(direction, lodIdx);\nuv += 0.5;\nuv *= texelSize;\nreturn envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n}\n#define cubeUV_r0 1.0\n#define cubeUV_v0 0.339\n#define cubeUV_m0 -2.0\n#define cubeUV_r1 0.8\n#define cubeUV_v1 0.276\n#define cubeUV_m1 -1.0\n#define cubeUV_r4 0.4\n#define cubeUV_v4 0.046\n#define cubeUV_m4 2.0\n#define cubeUV_r5 0.305\n#define cubeUV_v5 0.016\n#define cubeUV_m5 3.0\n#define cubeUV_r6 0.21\n#define cubeUV_v6 0.0038\n#define cubeUV_m6 4.0\nfloat roughnessToMip(float roughness) {\nfloat r = roughness;\nfloat r2 = r * r;\nfloat r3 = r2 * r;\nroughness = -1.20278049 * r3 + 1.86860137 * r2 + 0.32478081 * r + 0.0098139;\nreturn  roughness * (cubeUV_lodIdxMax - cubeUV_lodIdxMin);\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\nfloat lodIdx = clamp(roughnessToMip(roughness), cubeUV_lodIdxMin,\ncubeUV_lodIdxMax);\nfloat lodIdxF = fract(lodIdx);\nfloat lodIdxI = floor(lodIdx);\nvec3 color0 = sampleCubeUV(envMap, sampleDir, lodIdxI);\nif (lodIdxF == 0.0) {\nreturn vec4(color0, 1.0);\n} else {\nvec3 color1 = sampleCubeUV(envMap, sampleDir, lodIdxI + 1.0);\nreturn vec4(mix(color0, color1, lodIdxF), 1.0);\n}\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\nmat3 m = mat3(instanceMatrix);\ntransformedNormal /= vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2]));\ntransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent = (modelViewMatrix * vec4(objectTangent, 0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent = - transformedTangent;\n#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\nuniform float displacementScale;\nuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\ntransformed += normalize(objectNormal) * (texture2D(displacementMap, vUv).x * displacementScale + displacementBias);\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor = texture2D(emissiveMap, vUv);\nemissiveColor.rgb = emissiveMapTexelToLinear(emissiveColor).rgb;\ntotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel(gl_FragColor);",
            encodings_pars_fragment: "\nvec4 LinearToLinear(in vec4 value) {\nreturn value;\n}\nvec4 GammaToLinear(in vec4 value, in float gammaFactor) {\nvalue = max(value, vec4(0.0));\nreturn vec4(pow(value.rgb, vec3(gammaFactor)), value.a);\n}\nvec4 LinearToGamma(in vec4 value, in float gammaFactor) {\nvalue = max(value, vec4(0.0));\nreturn vec4(pow(value.rgb, vec3(1.0 / gammaFactor)), value.a);\n}\nvec4 sRGBToLinear(in vec4 value) {\nvalue = max(value, vec4(0.0));\nreturn vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.a);\n}\nvec4 LinearTosRGB(in vec4 value) {\nvalue = max(value, vec4(0.0));\nreturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);\n}\nvec4 RGBEToLinear(in vec4 value) {\nreturn vec4(value.rgb * exp2(value.a * 255.0 - 128.0), 1.0);\n}\nvec4 LinearToRGBE(in vec4 value) {\nfloat maxComponent = max(max(value.r, value.g), value.b);\nfloat fExp = clamp(ceil(log2(maxComponent)), -128.0, 127.0);\nreturn vec4(value.rgb / exp2(fExp), (fExp + 128.0) / 255.0);\n}\nvec4 RGBMToLinear(in vec4 value, in float maxRange) {\nreturn vec4(value.rgb * value.a * maxRange, 1.0);\n}\nvec4 LinearToRGBM(in vec4 value, in float maxRange) {\nfloat maxRGB = max(value.r, max(value.g, value.b));\nfloat M = clamp(maxRGB / maxRange, 0.0, 1.0);\nM = ceil(M * 255.0) / 255.0;\nreturn vec4(value.rgb / (M * maxRange), M);\n}\nvec4 RGBDToLinear(in vec4 value, in float maxRange) {\nreturn vec4(value.rgb * ((maxRange / 255.0) / value.a), 1.0);\n}\nvec4 LinearToRGBD(in vec4 value, in float maxRange) {\nfloat maxRGB = max(value.r, max(value.g, value.b));\nfloat D = max(maxRange / maxRGB, 1.0);\nD = clamp(floor(D) / 255.0, 0.0, 1.0);\nreturn vec4(value.rgb * (D * (255.0 / maxRange)), D);\n}\nconst mat3 cLogLuvM = mat3(0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969);\nvec4 LinearToLogLuv(in vec4 value) {\nvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\nXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\nvec4 vResult;\nvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\nfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\nvResult.w = fract(Le);\nvResult.z = (Le - (floor(vResult.w * 255.0)) / 255.0) / 255.0;\nreturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3(6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268);\nvec4 LogLuvToLinear(in vec4 value) {\nfloat Le = value.z * 255.0 + value.w;\nvec3 Xp_Y_XYZp;\nXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\nXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\nXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\nvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\nreturn vec4(max(vRGB, 0.0), 1.0);\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;\nif (isOrthographic) {\ncameraToFrag = normalize(vec3(- viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n} else {\ncameraToFrag = normalize(vWorldPosition - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec = reflect(cameraToFrag, worldNormal);\n#else\nvec3 reflectVec = refract(cameraToFrag, worldNormal, refractionRatio);\n#endif\n#else\nvec3 reflectVec = vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor = textureCube(envMap, vec3(flipEnvMap * reflectVec.x, reflectVec.yz));\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 envColor = textureCubeUV(envMap, reflectVec, 0.0);\n#elif defined(ENVMAP_TYPE_EQUIREC)\nvec2 sampleUV;\nreflectVec = normalize(reflectVec);\nsampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(reflectVec.z, reflectVec.x) * RECIPROCAL_PI2 + 0.5;\nvec4 envColor = texture2D(envMap, sampleUV);\n#else\nvec4 envColor = vec4(0.0);\n#endif\n#ifndef ENVMAP_TYPE_CUBE_UV\nenvColor = envMapTexelToLinear(envColor);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight = mix(outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight = mix(outgoingLight, envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight += envColor.xyz * specularStrength * reflectivity;\n#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\nuniform float envMapIntensity;\nuniform float flipEnvMap;\nuniform int maxMipLevel;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#if defined(ENVMAP_TYPE_CUBE) && defined(NODE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat calcGeometryRoughness(vec3 geometryNormal) {\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nreturn max(max(dxy.x, dxy.y), dxy.z);\n}\nfloat calcCubeUVAdjustedRoughness(float origRoughness, float geomRoughness) {\nreturn min(max(origRoughness, 0.0525) + geomRoughness, 1.0);\n}\n#endif\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) ||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\n\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;\nuniform float refractionRatio;\n#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined(USE_ENVMAP)\n#ifdef ENVMAP_MODE_REFRACTION\nuniform float refractionRatio;\n#endif\nvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel) {\nvec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT(envMap, queryVec, float(maxMIPLevel));\n#else\nvec4 envMapColor = textureCube(envMap, queryVec, float(maxMIPLevel));\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\nvec4 envMapColor = textureCubeUV(envMap, queryVec, 1.0);\n#else\nvec4 envMapColor = vec4(0.0);\n#endif\nreturn PI * envMapColor.rgb * envMapIntensity;\n}\nfloat getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {\nfloat maxMIPLevelScalar = float(maxMIPLevel);\nfloat clapmedBlinnShininessExponent = min(blinnShininessExponent, 30000.0);\nfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248\n- 0.5 * log2(pow2(clapmedBlinnShininessExponent) + 1.0);\nreturn clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);\n}\nvec3 _getLightProbeIndirect(const float blinnShininessExponent,\nconst int maxMIPLevel, vec3 directionVec) {\nfloat specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryVec = vec3(flipEnvMap * directionVec.x, directionVec.yz);\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT(envMap, queryVec, specularMIPLevel);\n#else\nvec4 envMapColor = textureCube(envMap, queryVec, specularMIPLevel);\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec3 queryVec = vec3(flipEnvMap * directionVec.x, directionVec.yz);\nvec4 envMapColor = textureCubeUV(envMap, queryVec,\nBlinnExponentToGGXRoughness(blinnShininessExponent));\n#elif defined(ENVMAP_TYPE_EQUIREC)\nvec2 sampleUV;\nsampleUV.y = asin(clamp(directionVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(directionVec.z, directionVec.x) * RECIPROCAL_PI2 + 0.5;\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = texture2DLodEXT(envMap, sampleUV, specularMIPLevel);\n#else\nvec4 envMapColor = texture2D(envMap, sampleUV, specularMIPLevel);\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#endif\nreturn envMapColor.rgb * envMapIntensity;\n}\nvec3 getLightProbeIndirectRadiance(\nconst GeometricContext geometry, const float blinnShininessExponent,\nconst int maxMIPLevel, const int useCoat) {\nvec3 normal = geometry.normal;\n#ifdef CLEARCOAT\nif (useCoat == 1) {\nnormal = geometry.clearcoatNormal;\n}\n#endif\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 directionVec = reflect(-geometry.viewDir, normal);\n#else\nvec3 directionVec = refract(-geometry.viewDir, normal, refractionRatio);\n#endif\ndirectionVec = inverseTransformDirection(directionVec, viewMatrix);\nreturn _getLightProbeIndirect(blinnShininessExponent, maxMIPLevel,\ndirectionVec);\n}\nvec3 getLightProbeIndirectRefraction(\nconst GeometricContext geometry, const float blinnShininessExponent,\nconst int maxMIPLevel, const float refrRatio) {\nvec3 directionVec = refract(-geometry.viewDir, geometry.normal, refrRatio);\ndirectionVec = inverseTransformDirection(directionVec, viewMatrix);\nreturn _getLightProbeIndirect(blinnShininessExponent, maxMIPLevel,\ndirectionVec);\n}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition = worldPosition.xyz;\n#else\nvec3 cameraToVertex;\nif (isOrthographic) {\ncameraToVertex = normalize(vec3(- viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n} else {\ncameraToVertex = normalize(worldPosition.xyz - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(transformedNormal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect = reflect(cameraToVertex, worldNormal);\n#else\nvReflect = refract(cameraToVertex, worldNormal, refractionRatio);\n#endif\n#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\nvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor = 1.0 - exp(- fogDensity * fogDensity * fogDepth * fogDepth);\n#else\nfloat fogFactor = smoothstep(fogNear, fogFar, fogDepth);\n#endif\ngl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\nvarying float fogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\nuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance(vec3 normal, vec3 lightDirection) {\nfloat dotNL = dot(normal, lightDirection);\nvec2 coord = vec2(dotNL * 0.5 + 0.5, 0.0);\n#ifdef USE_GRADIENTMAP\nreturn texture2D(gradientMap, coord).rgb;\n#else\nreturn (coord.x < 0.7) ? vec3(0.7) : vec3(1.0);\n#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nreflectedLight.indirectDiffuse += PI * lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;\nuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3(1.0);\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize(transformedNormal);\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(-mvPosition.xyz);\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3(0.0);\nvIndirectFront = vec3(0.0);\n#ifdef DOUBLE_SIDED\nvLightBack = vec3(0.0);\nvIndirectBack = vec3(0.0);\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\ngetPointDirectLightIrradiance(pointLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\ngetSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ngetDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\nvIndirectFront += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n#ifdef DOUBLE_SIDED\nvIndirectBack += getHemisphereLightIrradiance(hemisphereLights[i], backGeometry);\n#endif\n}\n#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[9];\nvec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {\nfloat x = normal.x, y = normal.y, z = normal.z;\nvec3 result = shCoefficients[0] * 0.886227;\nresult += shCoefficients[1] * 2.0 * 0.511664 * y;\nresult += shCoefficients[2] * 2.0 * 0.511664 * z;\nresult += shCoefficients[3] * 2.0 * 0.511664 * x;\nresult += shCoefficients[4] * 2.0 * 0.429043 * x * y;\nresult += shCoefficients[5] * 2.0 * 0.429043 * y * z;\nresult += shCoefficients[6] * (0.743125 * z * z - 0.247708);\nresult += shCoefficients[7] * 2.0 * 0.429043 * x * z;\nresult += shCoefficients[8] * 0.429043 * (x * x - y * y);\nreturn result;\n}\nvec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in GeometricContext geometry) {\nvec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\nvec3 irradiance = shGetIrradianceAt(worldNormal, lightProbe);\nreturn irradiance;\n}\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {\nvec3 irradiance = ambientLightColor;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\nvec3 direction;\nvec3 color;\n};\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\nvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {\ndirectLight.color = directionalLight.color;\ndirectLight.direction = directionalLight.direction;\ndirectLight.visible = true;\n}\n#endif\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight {\nvec3 position;\nvec3 color;\nfloat distance;\nfloat decay;\n};\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\nvoid getPointDirectLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {\nvec3 lVector = pointLight.position - geometry.position;\ndirectLight.direction = normalize(lVector);\nfloat lightDistance = length(lVector);\ndirectLight.color = pointLight.color;\ndirectLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.decay);\ndirectLight.visible = (directLight.color != vec3(0.0));\n}\n#endif\n#if NUM_SPOT_LIGHTS > 0\nstruct SpotLight {\nvec3 position;\nvec3 direction;\nvec3 color;\nfloat distance;\nfloat decay;\nfloat coneCos;\nfloat penumbraCos;\n};\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {\nvec3 lVector = spotLight.position - geometry.position;\ndirectLight.direction = normalize(lVector);\nfloat lightDistance = length(lVector);\nfloat angleCos = dot(directLight.direction, spotLight.direction);\n#if defined(MT_MAX) && defined(PHYSICALLY_CORRECT_LIGHTS)\nfloat coneCosDecayed = 2.0 * spotLight.coneCos - spotLight.penumbraCos;\nif (angleCos > coneCosDecayed) {\nfloat spotEffect = pow(max(angleCos, 0.0), log(0.5) / log(spotLight.penumbraCos) - 1.0);\nif (angleCos < spotLight.coneCos) {\nfloat decayFac = 1.0 + (spotLight.coneCos - angleCos)\n/ (spotLight.coneCos - spotLight.penumbraCos);\nspotEffect *= pow2(decayFac) * (3.0 - 2.0 * decayFac);\n}\ndirectLight.color = spotLight.color * spotEffect\n* punctualLightIntensityToIrradianceFactor(lightDistance,\nspotLight.distance, spotLight.decay);\ndirectLight.visible = true;\n} else {\ndirectLight.color = vec3(0.0);\ndirectLight.visible = false;\n}\n#else\nif (angleCos > spotLight.coneCos) {\nfloat spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\ndirectLight.color = spotLight.color * spotEffect\n* punctualLightIntensityToIrradianceFactor(lightDistance,\nspotLight.distance, spotLight.decay);\ndirectLight.visible = true;\n} else {\ndirectLight.color = vec3(0.0);\ndirectLight.visible = false;\n}\n#endif\n}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\nstruct RectAreaLight {\nvec3 color;\nvec3 position;\nvec3 halfWidth;\nvec3 halfHeight;\n};\nuniform sampler2D ltc_1;\nuniform sampler2D ltc_2;\nuniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS > 0\nstruct HemisphereLight {\nvec3 direction;\nvec3 skyColor;\nvec3 groundColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\nvec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in GeometricContext geometry) {\nfloat dotNL = dot(geometry.normal, hemiLight.direction);\nfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\nvec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreturn irradiance;\n}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\nvec3 diffuseColor;\n};\nvoid RE_Direct_Toon(const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight) {\nvec3 irradiance = getGradientIrradiance(geometry.normal, directLight.direction) * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\nreflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(directLight, geometry, material.specularColor, material.specularShininess) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon(const in vec3 irradiance, const in vec3 iblIrradiance,\nconst in GeometricContext geometry, const in ToonMaterial material,\ninout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#define RE_Direct                RE_Direct_Toon\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD(material)    (0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\nvec3 diffuseColor;\nvec3 specularColor;\nfloat specularShininess;\nfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong(const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\nreflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(directLight, geometry, material.specularColor, material.specularShininess) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance, const in vec3 iblIrradiance,\nconst in GeometricContext geometry, const in BlinnPhongMaterial material,\ninout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#define RE_Direct                RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD(material)    (0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * (1.0 - metalnessFactor);\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.specularRoughness = max(roughnessFactor, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\n#ifdef REFLECTIVITY\nmaterial.specularColor = mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT * pow2(reflectivity)), diffuseColor.rgb, metalnessFactor);\n#else\nmaterial.specularColor = mix(vec3(DEFAULT_SPECULAR_COEFFICIENT), diffuseColor.rgb, metalnessFactor);\n#endif\n#ifdef CLEARCOAT\nmaterial.clearcoat = clearcoat;\nmaterial.clearcoatRoughness = clearcoatRoughness;\n#ifdef USE_CLEARCOATMAP\nmaterial.clearcoat *= texture2D(clearcoatMap, vUv).x;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nmaterial.clearcoatRoughness *= texture2D(clearcoatRoughnessMap, vUv).y;\n#endif\nmaterial.clearcoat = saturate(material.clearcoat);\nmaterial.clearcoatRoughness = max(material.clearcoatRoughness, 0.0525);\nmaterial.clearcoatRoughness += geometryRoughness;\nmaterial.clearcoatRoughness = min(material.clearcoatRoughness, 1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\nvec3 diffuseColor;\nfloat specularRoughness;\nvec3 specularColor;\n#ifdef CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox(const in float roughness, const in float dotNL) {\nreturn DEFAULT_SPECULAR_COEFFICIENT + (1.0 - DEFAULT_SPECULAR_COEFFICIENT) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.specularRoughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3(   0, 1,    0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = ccDotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nccIrradiance *= PI;\n#endif\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\nreflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\n#ifdef USE_SHEEN\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_Sheen(\nmaterial.specularRoughness,\ndirectLight.direction,\ngeometry,\nmaterial.sheenColor\n);\n#else\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n#endif\nreflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in vec3 iblIrradiance,\nconst in GeometricContext geometry, const in PhysicalMaterial material,\ninout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Physical(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n#ifdef CLEARCOAT\nfloat ccDotNV = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));\nreflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\nfloat ccDotNL = ccDotNV;\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\nfloat clearcoatInv = 1.0 - clearcoatDHR;\nvec3 singleScattering = vec3(0.0);\nvec3 multiScattering = vec3(0.0);\nvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\nBRDF_Specular_Multiscattering_Environment(geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering);\nvec3 diffuse = material.diffuseColor * (1.0 - (singleScattering + multiScattering));\nreflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\nreflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\nreflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct                RE_Direct_Physical\n#define RE_Direct_RectArea        RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular        RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_ClearCoat_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.clearcoatRoughness)\nfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\nreturn saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);\n#ifdef CLEARCOAT\ngeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS > 0) && (defined(RE_Direct) || defined(RE_DirectDiffuse) || defined(RE_DirectSpecular))\nPointLight pointLight;\n#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\npointLight = pointLights[i];\ngetPointDirectLightIrradiance(pointLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)\npointLightShadow = pointLightShadows[i];\ndirectLight.color *= all(bvec2(directLight.visible, receiveShadow)) ?\ngetPointShadow(pointLightShadow, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n#endif\n#if defined(RE_Direct)\nRE_Direct(directLight, geometry, material, reflectedLight);\n#else\n#if defined(RE_DirectDiffuse)\nRE_DirectDiffuse(directLight, geometry, material, reflectedLight);\n#endif\n#if defined(RE_DirectSpecular)\nRE_DirectSpecular(directLight, geometry, material, reflectedLight);\n#endif\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if (NUM_SPOT_LIGHTS > 0) && (defined(RE_Direct) || defined(RE_DirectDiffuse) || defined(RE_DirectSpecular))\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\nspotLight = spotLights[i];\ngetSpotDirectLightIrradiance(spotLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)\n\nspotLightShadow = spotLightShadows[i];\nif (all(bvec2(directLight.visible, receiveShadow))) {\nif (spotLightShadow.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= getSpotShadow(spotLightShadow, spotShadowMap[i],\nvSpotShadowCoord[i], distWorld);\n} else if (spotLightShadow.shadow == 2) {\ndirectLight.color *= getSpotOmniShadow(spotLightShadow,\nspotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n#endif\n#if defined(RE_Direct)\nRE_Direct(directLight, geometry, material, reflectedLight);\n#else\n#if defined(RE_DirectDiffuse)\nRE_DirectDiffuse(directLight, geometry, material, reflectedLight);\n#endif\n#if defined(RE_DirectSpecular)\nRE_DirectSpecular(directLight, geometry, material, reflectedLight);\n#endif\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if (NUM_DIR_LIGHTS > 0) && (defined(RE_Direct) || defined(RE_DirectDiffuse) || defined(RE_DirectSpecular))\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ndirectionalLight = directionalLights[i];\ngetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_DIR_LIGHT_SHADOWS)\ndirectionalLightShadow = directionalLightShadows[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLightShadow.position\n- directionalLight.direction * directionalLightShadow.shadowCameraNear\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= all(bvec3(directLight.visible, receiveShadow,\nvViewPosition.z < directionalLightShadow.maxDistance))\n? getDirShadow(directionalLightShadow, directionalShadowMap[i],\nvDirectionalShadowCoord[i], distWorld) : 1.0;\n#endif\n#if defined(RE_Direct)\nRE_Direct(directLight, geometry, material, reflectedLight);\n#else\n#if defined(RE_DirectDiffuse)\nRE_DirectDiffuse(directLight, geometry, material, reflectedLight);\n#endif\n#if defined(RE_DirectSpecular)\nRE_DirectSpecular(directLight, geometry, material, reflectedLight);\n#endif\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\nrectAreaLight = rectAreaLights[i];\nRE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);\n}\n#pragma unroll_loop_end\n#endif\n#if defined(RE_IndirectDiffuse) || defined(RE_IndirectSpecular)\nvec3 iblIrradiance = vec3(0.0);\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 irradiance = getAmbientLightIrradiance(ambientLightColor);\nirradiance += getLightProbeIrradiance(lightProbe, geometry);\n#if (NUM_HEMI_LIGHTS > 0)\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\nirradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n}\n#pragma unroll_loop_end\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance = vec3(0.0);\nvec3 clearcoatRadiance = vec3(0.0);\n#endif\n#if defined(RE_Refraction)\nvec3 refraction = vec3(0.0);\n#endif",
            lights_fragment_maps: "#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nvec3 lightMapIrradiance = lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance *= PI;\n#endif\nirradiance += lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP) && defined(STANDARD) && defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel);\n#endif\n#endif\n#if defined(USE_ENVMAP) && (defined(STANDARD) || defined(PHYSICAL)) && defined(RE_IndirectSpecular)\nradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent(material), maxMipLevel, 0);\n#if defined(USE_SSR) && !defined(USE_SSR_REFRACT)\nradiance = computeSSR(radiance, geometry.normal, 0.0);\n#endif\n#ifdef CLEARCOAT\nclearcoatRadiance += getLightProbeIndirectRadiance(geometry, Material_ClearCoat_BlinnShininessExponent(material), maxMipLevel, 1);\n#endif\n#endif\n#if defined(USE_ENVMAP) && defined(RE_Refraction)\nrefraction += getLightProbeIndirectRefraction(geometry,\nMaterial_Refraction_BlinnShininessExponent(material), maxMipLevel,\n1.0 / material.refractionIOR);\n#ifdef USE_SSR_REFRACT\nrefraction = computeSSR(refraction, geometry.normal, material.refractionIOR);\n#endif\n#endif",
            lights_fragment_end: "#if defined(RE_IndirectDiffuse)\nRE_IndirectDiffuse(irradiance, iblIrradiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_Refraction)\nRE_Refraction(refraction, material, refractedLight);\n#endif",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + gl_Position.w;\nvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\n#else\nif (isPerspectiveMatrix(projectionMatrix)) {\ngl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC - 1.0;\ngl_Position.z *= gl_Position.w;\n}\n#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D(map, vUv);\ntexelColor = mapTexelToLinear(texelColor);\ndiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nvec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy;\n#endif\n#ifdef USE_MAP\nvec4 mapTexel = texture2D(map, uv);\ndiffuseColor *= mapTexelToLinear(mapTexel);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, uv).g;\n#endif",
            map_particle_pars_fragment: "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness = texture2D(metalnessMap, vUv);\nmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n#if NUM_MORPH_TARGETS > 0\nobjectNormal += (morphNormal0 - normal) * morphTargetInfluences[0];\n#endif\n#if NUM_MORPH_TARGETS > 1\nobjectNormal += (morphNormal1 - normal) * morphTargetInfluences[1];\n#endif\n#if NUM_MORPH_TARGETS > 2\nobjectNormal += (morphNormal2 - normal) * morphTargetInfluences[2];\n#endif\n#if NUM_MORPH_TARGETS > 3\nobjectNormal += (morphNormal3 - normal) * morphTargetInfluences[3];\n#endif\n#if NUM_MORPH_TARGETS > 4\nobjectNormal += (morphNormal4 - normal) * morphTargetInfluences[4];\n#endif\n#if NUM_MORPH_TARGETS > 5\nobjectNormal += (morphNormal5 - normal) * morphTargetInfluences[5];\n#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[12];\n#else\nuniform float morphTargetInfluences[6];\n#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\ntransformed *= morphTargetBaseInfluence;\n#if NUM_MORPH_TARGETS > 0\ntransformed += morphTarget0 * morphTargetInfluences[0];\n#endif\n#if NUM_MORPH_TARGETS > 1\ntransformed += morphTarget1 * morphTargetInfluences[1];\n#endif\n#if NUM_MORPH_TARGETS > 2\ntransformed += morphTarget2 * morphTargetInfluences[2];\n#endif\n#if NUM_MORPH_TARGETS > 3\ntransformed += morphTarget3 * morphTargetInfluences[3];\n#endif\n#if NUM_MORPH_TARGETS > 4\ntransformed += morphTarget4 * morphTargetInfluences[4];\n#endif\n#if NUM_MORPH_TARGETS > 5\ntransformed += morphTarget5 * morphTargetInfluences[5];\n#endif\n#ifndef USE_MORPHNORMALS\n#if NUM_MORPH_TARGETS > 6\ntransformed += morphTarget6 * morphTargetInfluences[6];\n#endif\n#if NUM_MORPH_TARGETS > 7\ntransformed += morphTarget7 * morphTargetInfluences[7];\n#endif\n#if NUM_MORPH_TARGETS > 8\ntransformed += morphTarget8 * morphTargetInfluences[8];\n#endif\n#if NUM_MORPH_TARGETS > 9\ntransformed += morphTarget9 * morphTargetInfluences[9];\n#endif\n#if NUM_MORPH_TARGETS > 10\ntransformed += morphTarget10 * morphTargetInfluences[10];\n#endif\n#if NUM_MORPH_TARGETS > 11\ntransformed += morphTarget1 * morphTargetInfluences[11];\n#endif\n#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\nvec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\nvec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\nvec3 normal = normalize(cross(fdx, fdy));\n#else\nvec3 normal = normalize(vNormal);\n#ifdef DOUBLE_SIDED\n#ifdef FRONT_FACING_VALUE\nbool frontFacing = FRONT_FACING_VALUE;\n#else\nbool frontFacing = gl_FrontFacing;\n#endif\nnormal = normal * (float(frontFacing) * 2.0 - 1.0);\n#endif\n#ifdef USE_TANGENT\nvec3 tangent = normalize(vTangent);\nvec3 bitangent = normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\nbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\n#if defined(TANGENTSPACE_NORMALMAP) || defined(USE_CLEARCOAT_NORMALMAP)\nmat3 vTBN = mat3(tangent, bitangent, normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\nnormal = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n#ifdef FLIP_SIDED\nnormal = - normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nnormal = normalize(normalMatrix * normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\nmapN.xy *= normalScale;\n#ifdef USE_TANGENT\nnormal = normalize(vTBN * mapN);\n#else\nnormal = perturbNormal2Arb(-vViewPosition, normal, mapN);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd());\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined (USE_TANGENT) && (defined (TANGENTSPACE_NORMALMAP) || defined (USE_CLEARCOAT_NORMALMAP))\nvec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm, vec3 mapN) {\nvec3 q0 = vec3(dFdx(eye_pos.x), dFdx(eye_pos.y), dFdx(eye_pos.z));\nvec3 q1 = vec3(dFdy(eye_pos.x), dFdy(eye_pos.y), dFdy(eye_pos.z));\nvec2 st0 = dFdx(vUv.st);\nvec2 st1 = dFdy(vUv.st);\nfloat scale = sign(st1.t * st0.s - st0.t * st1.s);\nvec3 S = normalize((q0 * st1.t - q1 * st0.t) * scale);\nvec3 T = normalize((- q0 * st1.s + q1 * st0.s) * scale);\nvec3 N = normalize(surf_norm);\nmat3 tsn = mat3(S, T, N);\nmapN.xy *= (float(gl_FrontFacing) * 2.0 - 1.0);\nreturn normalize(tsn * mapN);\n}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\nvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\nvec3 clearcoatMapN = texture2D(clearcoatNormalMap, vUv).xyz * 2.0 - 1.0;\nclearcoatMapN.xy *= clearcoatNormalScale;\n#ifdef USE_TANGENT\nclearcoatNormal = normalize(vTBN * clearcoatMapN);\n#else\nclearcoatNormal = perturbNormal2Arb(- vViewPosition, clearcoatNormal, clearcoatMapN);\n#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\nuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\nuniform sampler2D clearcoatNormalMap;\nuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB(const in vec3 normal) {\nreturn normalize(normal) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal(const in vec3 rgb) {\nreturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256., 256.);\nconst vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA(const in float v) {\nvec4 r = vec4(fract(v * PackFactors), v);\nr.yzw -= r.xyz * ShiftRight8;\nreturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth(const in vec4 v) {\nreturn dot(v, UnpackFactors);\n}\nvec4 pack2HalfToRGBA(vec2 v) {\nvec4 r = vec4(v.x, fract(v.x * 255.0), v.y, fract(v.y * 255.0));\nreturn vec4(r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half(vec4 v) {\nreturn vec2(v.x + (v.y / 255.0), v.z + (v.w / 255.0));\n}\nfloat viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {\nreturn (viewZ + near) / (near - far);\n}\nfloat orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {\nreturn linearClipZ * (near - far) - near;\n}\nfloat viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far) {\nreturn ((near + viewZ) * far) / ((far - near) * viewZ);\n}\nfloat perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {\nreturn (near * far) / ((far - near) * invClipZ - far);\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if defined(BACKGROUND_DEPTH)\ngl_Position.z = gl_Position.w;\n#endif",
            dithering_fragment: "#ifdef DITHERING\ngl_FragColor.rgb = dithering(gl_FragColor.rgb);\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\nvec3 dithering(vec3 color) {\nfloat grid_position = rand(gl_FragCoord.xy);\nvec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);\ndither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);\nreturn color + dither_shift_RGB;\n}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness = texture2D(roughnessMap, vUv);\nroughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "\n#define BIAS_FRUSTUM_SCALE_COEFF 30.0\n#define ESM_SPOT_SINGLE_BLUR_COEFF 0.25\n#define PCF_POISSON_SPOT_OMNI_BLUR_COEFF 4.0\n#define PCF_POISSON_POINT_BLUR_COEFF 2.5\n#define PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF 0.5\n#define ESM_BIAS_COEFF 100.0\n#ifndef ESM_DISTANCE_SCALE\n#define ESM_DISTANCE_SCALE 1.0\n#endif\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\nstruct DirectionalLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nvec3 position;\nfloat shadowCameraNear;\nfloat maxDistance;\nfloat expBias;\n};\nuniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\nconst vec3 PERMUTE_DIR_X = vec3(1.0, 0.0, 0.0);\nconst vec3 PERMUTE_DIR_Y = vec3(0.0, 1.0, 0.0);\nconst vec3 PERMUTE_DIR_Z = vec3(0.0, 0.0, 1.0);\nconst mat4 POISSON_DISK_0 = mat4(\n0.954845, 0.242214, -0.623893, -0.235473,\n-0.173288, 0.799228, 0.605969, -0.548050,\n-0.560406, 0.327647, -0.448307, -0.774344,\n0.308258, 0.417332, -0.125623, -0.056098\n);\nconst mat4 POISSON_DISK_1 = mat4(\n0.145585, -0.305634, 0.264060, -0.661648,\n0.617942, 0.652121, -0.041412, -0.893582,\n0.463911, 0.039752, 0.212664, 0.810727,\n-0.955989, -0.014390, -0.652588, 0.671204\n);\nfloat texture2DCompare(sampler2D depths, vec2 uv, float compare) {\nreturn step(compare, unpackRGBAToDepth(texture2D(depths, uv)));\n}\nvec2 texture2DDistribution(sampler2D shadow, vec2 uv) {\nreturn unpackRGBATo2Half(texture2D(shadow, uv));\n}\nfloat VSMShadow (sampler2D shadow, vec2 uv, float compare){\nfloat occlusion = 1.0;\nvec2 distribution = texture2DDistribution(shadow, uv);\nfloat hard_shadow = step(compare , distribution.x);\nif (hard_shadow != 1.0) {\nfloat distance = compare - distribution.x ;\nfloat variance = max(0.00000, distribution.y * distribution.y);\nfloat softness_probability = variance / (variance + distance * distance);\nsoftness_probability = clamp((softness_probability - 0.3) / (0.95 - 0.3), 0.0, 1.0);\nocclusion = clamp(max(hard_shadow, softness_probability), 0.0, 1.0);\n}\nreturn occlusion;\n}\nfloat texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {\nconst vec2 offset = vec2(0.0, 1.0);\nvec2 texelSize = vec2(1.0) / size;\nvec2 centroidUV = floor(uv * size + 0.5) / size;\nfloat lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);\nfloat lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);\nfloat rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);\nfloat rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);\nvec2 f = fract(uv * size + 0.5);\nfloat a = mix(lb, lt, f.y);\nfloat b = mix(rb, rt, f.y);\nfloat c = mix(a, b, f.x);\nreturn c;\n}\nvec2 cubeToUV(vec3 v, float texelSizeY) {\nvec3 absV = abs(v);\nfloat scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));\nabsV *= scaleToCube;\nv *= scaleToCube * (1.0 - 2.0 * texelSizeY);\nvec2 planar = v.xy;\nfloat almostATexel = 1.5 * texelSizeY;\nfloat almostOne = 1.0 - almostATexel;\nif (absV.z >= almostOne) {\nif (v.z > 0.0)\nplanar.x = 4.0 - v.x;\n} else if (absV.x >= almostOne) {\nfloat signX = sign(v.x);\nplanar.x = v.z * signX + 2.0 * signX;\n} else if (absV.y >= almostOne) {\nfloat signY = sign(v.y);\nplanar.x = v.x + 2.0 * signY + 2.0;\nplanar.y = v.z * signY - 2.0;\n}\nreturn vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);\n}\nfloat texture2DShadowAvgCube(sampler2D depths, vec2 size, vec3 bd3D, float compare) {\nvec2 texelSize = vec2(1.0) / size;\nvec3 dirX = normalize(abs(bd3D.y) < 0.99999 ? vec3(bd3D.z, 0.0, -bd3D.x)\n: vec3(0.0, -bd3D.z, bd3D.y));\nvec3 dirY = cross(bd3D, dirX);\nfloat theta = PI_HALF * texelSize.y;\nvec3 sX = sin(theta) * dirX;\nvec3 sY = sin(theta) * dirY;\nfloat cosT = cos(theta);\nvec3 sampleVec[4];\nsampleVec[0] = bd3D;\nsampleVec[1] = bd3D * cosT + sY;\nsampleVec[2] = bd3D * cosT + sX;\nsampleVec[3] = sampleVec[2] * cosT + sY;\nfloat avg = 0.0;\nfor (int i = 0; i < 4; i++) {\navg += texture2DCompare(depths, cubeToUV(sampleVec[i], texelSize.y), compare);\n}\navg /= 4.0;\nreturn avg;\n}\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord,\nfloat expBias, float distWorld) {\nfloat shadow = 1.0;\nshadowCoord.xyz /= shadowCoord.w;\nbvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\nbool inFrustum = all(inFrustumVec);\nbvec3 frustumTestVec = bvec3(inFrustum, shadowCoord.z <= 1.0, shadowCoord.z >= 0.0);\nbool frustumTest = all(frustumTestVec);\nif (frustumTest) {\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadowCoord.z += shadowBias;\nshadow = texture2DShadowLerp(shadowMap, shadowMapSize,\nshadowCoord.xy, shadowCoord.z);\n#elif defined(SHADOWMAP_TYPE_PCF)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nvec2 offsetVec[9];\noffsetVec[0] = vec2(dx0, dy0);\noffsetVec[1] = vec2(0.0, dy0);\noffsetVec[2] = vec2(dx1, dy0);\noffsetVec[3] = vec2(dx0, 0.0);\noffsetVec[4] = vec2(0.0);\noffsetVec[5] = vec2(dx1, 0.0);\noffsetVec[6] = vec2(dx0, dy1);\noffsetVec[7] = vec2(0.0, dy1);\noffsetVec[8] = vec2(dx1, dy1);\nshadow = 0.0;\nfor (int i = 0; i < 9; i++) {\nshadow += texture2DCompare(shadowMap, shadowCoord.xy + offsetVec[i], shadowCoord.z);\n}\nshadow /= 9.0;\n#elif defined(SHADOWMAP_TYPE_PCF_SOFT)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nvec2 offsetVec[9];\noffsetVec[0] = vec2(dx0, dy0);\noffsetVec[1] = vec2(0.0, dy0);\noffsetVec[2] = vec2(dx1, dy0);\noffsetVec[3] = vec2(dx0, 0.0);\noffsetVec[4] = vec2(0.0);\noffsetVec[5] = vec2(dx1, 0.0);\noffsetVec[6] = vec2(dx0, dy1);\noffsetVec[7] = vec2(0.0, dy1);\noffsetVec[8] = vec2(dx1, dy1);\nshadow = 0.0;\nfor (int i = 0; i < 9; i++) {\nshadow += texture2DShadowLerp(shadowMap, shadowMapSize,\nshadowCoord.xy + offsetVec[i], shadowCoord.z);\n}\nshadow /= 9.0;\n#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.x, 0.0, 0.0, shadowRadius * texelSize.y);\nvec2 sampleVec[16];\nsampleVec[0] = POISSON_DISK_0[0].xy;\nsampleVec[1] = POISSON_DISK_0[0].zw;\nsampleVec[2] = POISSON_DISK_0[1].xy;\nsampleVec[3] = POISSON_DISK_0[1].zw;\nsampleVec[4] = POISSON_DISK_0[2].xy;\nsampleVec[5] = POISSON_DISK_0[2].zw;\nsampleVec[6] = POISSON_DISK_0[3].xy;\nsampleVec[7] = POISSON_DISK_0[3].zw;\nsampleVec[8] = POISSON_DISK_1[0].xy;\nsampleVec[9] = POISSON_DISK_1[0].zw;\nsampleVec[10] = POISSON_DISK_1[1].xy;\nsampleVec[11] = POISSON_DISK_1[1].zw;\nsampleVec[12] = POISSON_DISK_1[2].xy;\nsampleVec[13] = POISSON_DISK_1[2].zw;\nsampleVec[14] = POISSON_DISK_1[3].xy;\nsampleVec[15] = POISSON_DISK_1[3].zw;\nshadow = 0.0;\nfor (int i = 0; i < 16; i++) {\nshadow += texture2DCompare(shadowMap, shadowCoord.xy\n+ sampleMat * sampleVec[i], shadowCoord.z);\n}\nshadow /= 16.0;\n#elif defined(SHADOWMAP_TYPE_VSM)\nshadow = VSMShadow(shadowMap, shadowCoord.xy, shadowCoord.z);\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap, shadowCoord.xy).x\n- length(distWorld) * ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF * shadowBias)));\n#else\nshadowCoord.z += shadowBias;\nshadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);\n#endif\n}\nreturn shadow;\n}\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord) {\nreturn getShadow(shadowMap, shadowMapSize, shadowBias, shadowRadius, shadowCoord, 0.0, 0.0);\n}\nfloat getOmniShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias,\nfloat expBias, float shadowRadius, vec4 shadowCoord,\nfloat shadowCameraNear, float shadowCameraFar) {\nfloat shadow = 1.0;\nvec3 lightToPosition = shadowCoord.xyz;\nfloat dp = (length(lightToPosition) - shadowCameraNear)\n/ (shadowCameraFar - shadowCameraNear);\nbvec2 frustumTestVec = bvec2(dp <= 1.0, dp >= 0.0);\nbool frustumTest = all(frustumTestVec);\nif (frustumTest) {\nfloat biasScaleCoeff = BIAS_FRUSTUM_SCALE_COEFF\n/ (shadowCameraFar - shadowCameraNear);\ndp += shadowBias * biasScaleCoeff;\nvec3 bd3D = normalize(lightToPosition);\nvec2 texelSize = 1.0 / shadowMapSize;\n#if defined(SHADOWMAP_TYPE_BILINEAR)\nshadow = texture2DShadowAvgCube(shadowMap, shadowMapSize, bd3D, dp);\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap,\ncubeVecToOctUV(bd3D, texelSize)).x\n- length(lightToPosition) * ESM_DISTANCE_SCALE\n- ESM_BIAS_COEFF * shadowBias)));\n#elif defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)\nvec2 offset = vec2(-1, 1) * shadowRadius * texelSize.y;\nvec3 offsetVec[9];\noffsetVec[0] = offset.xyy;\noffsetVec[1] = offset.yyy;\noffsetVec[2] = offset.xyx;\noffsetVec[3] = offset.yyx;\noffsetVec[4] = vec3(0.0);\noffsetVec[5] = offset.xxy;\noffsetVec[6] = offset.yxy;\noffsetVec[7] = offset.xxx;\noffsetVec[8] = offset.yxx;\nshadow = 0.0;\nfor (int i = 0; i < 9; i++) {\nshadow += texture2DCompare(shadowMap, cubeToUV(bd3D + offsetVec[i], texelSize.y), dp);\n}\nshadow /= 9.0;\n#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.y, 0.0, 0.0, shadowRadius * texelSize.y);\nvec3 absBd3D = abs(bd3D);\nabsBd3D /= max(absBd3D.x, max(absBd3D.y, absBd3D.z));\nbvec2 isPointingCubeFace = greaterThan(absBd3D.xy, vec2(0.999));\nmat3 permuteMat = mat3(\nisPointingCubeFace.x ? PERMUTE_DIR_Y : PERMUTE_DIR_X,\nisPointingCubeFace.x || isPointingCubeFace.y ? PERMUTE_DIR_Z : PERMUTE_DIR_Y,\nisPointingCubeFace.x ? PERMUTE_DIR_X : isPointingCubeFace.y ? PERMUTE_DIR_Y : PERMUTE_DIR_Z\n);\nvec2 sampleVec[16];\nsampleVec[0] = POISSON_DISK_0[0].xy;\nsampleVec[1] = POISSON_DISK_0[0].zw;\nsampleVec[2] = POISSON_DISK_0[1].xy;\nsampleVec[3] = POISSON_DISK_0[1].zw;\nsampleVec[4] = POISSON_DISK_0[2].xy;\nsampleVec[5] = POISSON_DISK_0[2].zw;\nsampleVec[6] = POISSON_DISK_0[3].xy;\nsampleVec[7] = POISSON_DISK_0[3].zw;\nsampleVec[8] = POISSON_DISK_1[0].xy;\nsampleVec[9] = POISSON_DISK_1[0].zw;\nsampleVec[10] = POISSON_DISK_1[1].xy;\nsampleVec[11] = POISSON_DISK_1[1].zw;\nsampleVec[12] = POISSON_DISK_1[2].xy;\nsampleVec[13] = POISSON_DISK_1[2].zw;\nsampleVec[14] = POISSON_DISK_1[3].xy;\nsampleVec[15] = POISSON_DISK_1[3].zw;\nshadow = 0.0;\nfor (int i = 0; i < 16; i++) {\nshadow += texture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * sampleVec[i], 0.0), texelSize.y), dp);\n}\nshadow /= 16.0;\n#else\nshadow = texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);\n#endif\n}\nreturn shadow;\n}\n#if NUM_DIR_LIGHT_SHADOWS > 0\nfloat getDirShadow(DirectionalLightShadow light, sampler2D shadowMap,\nvec4 shadowCoord, float distWorld) {\nfloat shadowRadius = light.shadowRadius;\n#if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)\nshadowRadius *= PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF;\n#endif\nreturn getShadow(shadowMap, light.shadowMapSize, light.shadowBias, shadowRadius, shadowCoord, \nlight.expBias, distWorld);\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nfloat getPointShadow(PointLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize *= 2.0;\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowRadius *= PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nfloat getSpotOmniShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowRadius *= PCF_POISSON_SPOT_OMNI_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\nfloat biasLinearNormalizedToNonlinear(float bias, float near, float far,\nfloat projZ, float projW) {\nreturn (bias * (far + near) + 2.0 * projZ) / (bias * (far - near) + 2.0 * projW)\n- projZ / projW;\n}\nfloat getSpotShadow(SpotLightShadow light, sampler2D shadowMap, vec4 shadowCoord,\nfloat distWorld) {\nfloat shadowRadius = light.shadowRadius;\nfloat shadowBias = light.shadowBias;\n#if defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)\nshadowRadius *= PCF_PCF_SOFT_DIR_SPOT_BLUR_COEFF;\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadowRadius *= ESM_SPOT_SINGLE_BLUR_COEFF;\n#endif\nshadowBias *= BIAS_FRUSTUM_SCALE_COEFF\n/ (light.shadowCameraFar - light.shadowCameraNear);\n#if defined(SHADOWMAP_TYPE_BASIC) || defined(SHADOWMAP_TYPE_BILINEAR) || defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT) || defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowBias = biasLinearNormalizedToNonlinear(shadowBias,\nlight.shadowCameraNear, light.shadowCameraFar, shadowCoord.z,\nshadowCoord.w);\n#endif\nreturn getShadow(shadowMap, light.shadowMapSize, shadowBias, shadowRadius, shadowCoord,\nlight.expBias, distWorld);\n}\n#endif\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\nstruct DirectionalLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nvec3 position;\nfloat shadowCameraNear;\nfloat maxDistance;\nfloat expBias;\n};\nuniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\nstruct SpotLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nint shadow;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\nstruct PointLightShadow {\nfloat shadowBias;\nfloat shadowNormalBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\nvec3 shadowWorldNormal = inverseTransformDirection(transformedNormal, viewMatrix);\nvec4 shadowWorldPosition;\n#endif\n#if NUM_DIR_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * directionalLightShadows[i].shadowNormalBias, 0);\nvDirectionalShadowCoord[i] = directionalShadowMatrix[i] * shadowWorldPosition;\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * spotLightShadows[i].shadowNormalBias, 0);\nvSpotShadowCoord[i] = spotShadowMatrix[i] * shadowWorldPosition;\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\nshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * pointLightShadows[i].shadowNormalBias, 0);\nvPointShadowCoord[i] = pointShadowMatrix[i] * shadowWorldPosition;\n}\n#pragma unroll_loop_end\n#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\nfloat shadow = 1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLight;\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i++) {\ndirectionalLight = directionalLightShadows[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLight.position\n- directionalLight.direction * directionalLight.shadowCameraNear\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= all(bvec2(vViewPosition.z < directionalLight.maxDistance,\nreceiveShadow)) ? getDirShadow(directionalLight,\ndirectionalShadowMap[i], vDirectionalShadowCoord[i], distWorld)\n: 1.0;\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLight;\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nspotLight = spotLightShadows[i];\nif (receiveShadow) {\nif (spotLight.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= getSpotShadow(spotLight, spotShadowMap[i], vSpotShadowCoord[i],\ndistWorld);\n} else if (spotLight.shadow == 2) {\nshadow *= getSpotOmniShadow(spotLight, spotShadowMap[i],\nvSpotShadowCoord[i]);\n}\n}\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLight;\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\npointLight = pointLightShadows[i];\nshadow *= receiveShadow ? getPointShadow(pointLight, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n}\n#pragma unroll_loop_end\n#endif\n#endif\nreturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix(skinIndex.x);\nmat4 boneMatY = getBoneMatrix(skinIndex.y);\nmat4 boneMatZ = getBoneMatrix(skinIndex.z);\nmat4 boneMatW = getBoneMatrix(skinIndex.w);\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\nuniform mat4 bindMatrix;\nuniform mat4 bindMatrixInverse;\n#ifdef BONE_TEXTURE\nuniform highp sampler2D boneTexture;\nuniform int boneTextureSize;\nmat4 getBoneMatrix(const in float i) {\nfloat j = i * 4.0;\nfloat x = mod(j, float(boneTextureSize));\nfloat y = floor(j / float(boneTextureSize));\nfloat dx = 1.0 / float(boneTextureSize);\nfloat dy = 1.0 / float(boneTextureSize);\ny = dy * (y + 0.5);\nvec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));\nvec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));\nvec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));\nvec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));\nmat4 bone = mat4(v1, v2, v3, v4);\nreturn bone;\n}\n#else\nuniform mat4 boneMatrices[MAX_BONES];\nmat4 getBoneMatrix(const in float i) {\nmat4 bone = boneMatrices[int(i)];\nreturn bone;\n}\n#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\nvec4 skinVertex = bindMatrix * vec4(transformed, 1.0);\nvec4 skinned = vec4(0.0);\nskinned += boneMatX * skinVertex * skinWeight.x;\nskinned += boneMatY * skinVertex * skinWeight.y;\nskinned += boneMatZ * skinVertex * skinWeight.z;\nskinned += boneMatW * skinVertex * skinWeight.w;\ntransformed = (bindMatrixInverse * skinned).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = mat4(0.0);\nskinMatrix += skinWeight.x * boneMatX;\nskinMatrix += skinWeight.y * boneMatY;\nskinMatrix += skinWeight.z * boneMatZ;\nskinMatrix += skinWeight.w * boneMatW;\nskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\nobjectNormal = vec4(skinMatrix * vec4(objectNormal, 0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent = vec4(skinMatrix * vec4(objectTangent, 0.0)).xyz;\n#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D(specularMap, vUv);\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined(TONE_MAPPING)\ngl_FragColor.rgb = toneMapping(gl_FragColor.rgb);\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\n#ifndef PI\n#define PI 3.14159265359\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingMidTones;\nuniform float toneMappingPhysicalScale;\nuniform float toneMappingBrightness;\nuniform float toneMappingContrast;\nuniform bool toneMappingChromaticAdaptation;\nuniform vec3 toneMappingWhiteColor;\nuniform bool toneMappingColorDifferentiation;\nuniform bool toneMappingExteriorDaylight;\nuniform vec3 toneMappingWhiteBalance;\nuniform float toneMappingHighlights;\nuniform float toneMappingShadows;\nuniform float toneMappingSaturation;\nuniform float toneMappingAperture;\nuniform float toneMappingShutter;\nuniform float toneMappingISO;\nuniform float toneMappingVignetting;\nuniform vec2 toneMappingResolution;\nconst float FILMIC_BLENDER_LOG_MIN = -12.473931188;\nconst float FILMIC_BLENDER_LOG_MAX = 12.526068812;\nconst float FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO = 0.66;\nvec3 LinearToneMapping(vec3 color) {\nreturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\nreturn saturate(color / (vec3(1.0) + color));\n}\nvec3 OptimizedCineonToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(vec3(0.0), color - 0.004);\nreturn pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n}\nvec3 RRTAndODTFit(vec3 v) {\nvec3 a = v * (v + 0.0245786) - 0.000090537;\nvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\nreturn a / b;\n}\nvec3 ACESFilmicToneMapping(vec3 color) {\nconst mat3 ACESInputMat = mat3(\nvec3(0.59719, 0.07600, 0.02840),\nvec3(0.35458, 0.90834, 0.13383),\nvec3(0.04823, 0.01566, 0.83777)\n);\nconst mat3 ACESOutputMat = mat3(\nvec3( 1.60475, -0.10208, -0.00327),\nvec3(-0.53108,  1.10813, -0.07276),\nvec3(-0.07367, -0.00605,  1.07602)\n);\ncolor *= toneMappingExposure / 0.6;\ncolor = ACESInputMat * color;\ncolor = RRTAndODTFit(color);\ncolor = ACESOutputMat * color;\nreturn saturate(color);\n}\nvec3 CustomToneMapping(vec3 color) { return color; }\n#define ORDERS_OF_MAG 5.0\nfloat toneCalcBrightness(in vec3 color)\n{\nreturn (abs(color.r) * 0.263 + abs(color.g) * 0.655 + abs(color.b) * 0.082);\n}\nfloat toneApproximateScotopicLuminance(vec3 color)\n{\nreturn (0.062 * color.r + 0.608 * color.g + 0.330 * color.b);\n}\nvec3 LogarithmicMaxToneMapping(vec3 color) {\nfloat inputScaleFactor = toneMappingPhysicalScale / PI;\nfloat brightness = (toneMappingBrightness < 0.0) ? 0.0 : (toneMappingBrightness * 0.7);\nfloat powerBot = toneMappingExteriorDaylight ? 4.0 : 2.0;\nfloat res = 100.0 / ORDERS_OF_MAG;\nfloat mag = floor((50.0 / res));\nfloat power = ((brightness / 20.0 - ORDERS_OF_MAG) - powerBot) + mag;\nfloat stepsize = 9.0 / res;\nfloat step = 50.0 - (mag * res);\nfloat param_c = (0.02 * toneMappingContrast) * 2.0;\nfloat param_b = pow(10.0, power) * (1.0 + (stepsize * step));\nfloat param_a = param_b * (1.0 + param_c);\nparam_c /= pow(2.0, toneMappingMidTones - 1.0);\nparam_b *= PI;\nvec3 whiteConstancyFactor = toneMappingWhiteColor;\nif (toneMappingChromaticAdaptation) {\nfloat luminance = toneCalcBrightness(whiteConstancyFactor);\nwhiteConstancyFactor.r = (whiteConstancyFactor.r > 0.001) ? luminance / whiteConstancyFactor.r : luminance / 0.001;\nwhiteConstancyFactor.g = (whiteConstancyFactor.g > 0.001) ? luminance / whiteConstancyFactor.g : luminance / 0.001;\nwhiteConstancyFactor.b = (whiteConstancyFactor.b > 0.001) ? luminance / whiteConstancyFactor.b : luminance / 0.001;\n}\nvec3 outColor = inputScaleFactor * color;\nif (toneMappingChromaticAdaptation) {\noutColor *= whiteConstancyFactor.rgb;\n}\nfloat luminance = toneCalcBrightness(outColor);\nif (toneMappingColorDifferentiation && (luminance < 5.62)) {\nfloat sLuminance = toneApproximateScotopicLuminance(outColor);\nif (luminance <= 5.62e-3) {\noutColor = vec3(sLuminance);\n} else {\nfloat w = (luminance - 5.62e-3) / 5.61438;\noutColor = outColor * w + sLuminance * (1.0 - w);\n}\n}\noutColor = outColor * (param_a / (param_b * outColor + param_c));\nreturn outColor;\n}\nfloat maxExposurePhotographic(in vec4 color1, in vec4 color2)\n{\nreturn ((color1.r * color2.r) + (color1.g * color2.g)) + (color1.b * color2.b);\n}\nvec3 PhysicalMaxToneMapping(vec3 color) {\nfloat vignettingInfluence = 1.0;\nif (toneMappingVignetting > 0.0) {\nvec3 vignettingCoords = vec3(0.0, 0.0, 0.0);\nfloat aspect = toneMappingResolution.x / toneMappingResolution.y;\nvignettingCoords.x = gl_FragCoord.x / toneMappingResolution.x - 0.5;\nvignettingCoords.y = (gl_FragCoord.y / toneMappingResolution.y - 0.5) / aspect;\nvignettingCoords.z = 1.0;\nvignettingCoords = normalize(vignettingCoords);\nvignettingInfluence = pow(vignettingCoords.z, toneMappingVignetting);\n}\nfloat inputScaleFactor = toneMappingPhysicalScale / PI;\nfloat filmISO = toneMappingISO;\nfloat camShutter = 1.0 / toneMappingShutter;\nfloat fNumber = toneMappingAperture;\nfloat cm2 = 1.0;\nfloat burnHighlights = toneMappingHighlights;\nfloat crushBlacks = toneMappingShadows;\nfloat saturation = toneMappingSaturation;\nvec3 whitePointInfluence = toneMappingWhiteBalance;\nif (whitePointInfluence.r > 0.0) {\nwhitePointInfluence.r = 1.0 / whitePointInfluence.r;\n} else {\nwhitePointInfluence.r = 1.0;\n}\nif (whitePointInfluence.g > 0.0) {\nwhitePointInfluence.g = 1.0 / whitePointInfluence.g;\n} else {\nwhitePointInfluence.g = 1.0;\n}\nif (whitePointInfluence.b > 0.0) {\nwhitePointInfluence.b = 1.0 / whitePointInfluence.b;\n} else {\nwhitePointInfluence.b = 1.0;\n}\nvec4 lumFactor = vec4(0.212671, 0.715160, 0.072169, 0.0);\nfloat whiteLumFactor = maxExposurePhotographic(lumFactor, vec4(whitePointInfluence, 0.0));\nwhitePointInfluence.r /= whiteLumFactor;\nwhitePointInfluence.g /= whiteLumFactor;\nwhitePointInfluence.b /= whiteLumFactor;\nfloat isoInfluence = 0.0;\nfloat camShutterInv = 1.0 / camShutter;\nif (filmISO > 0.0) {\nisoInfluence = ((cm2 * 0.169811) * (filmISO * camShutterInv)) / ((15.4 * fNumber) * fNumber);\n} else {\nisoInfluence = cm2;\n}\nvec3 outColor = inputScaleFactor * color;\noutColor.r = outColor.r * whitePointInfluence.r * isoInfluence * vignettingInfluence;\noutColor.g = outColor.g * whitePointInfluence.g * isoInfluence * vignettingInfluence;\noutColor.b = outColor.b * whitePointInfluence.b * isoInfluence * vignettingInfluence;\noutColor.r = (outColor.r * (1.0 + (outColor.r * burnHighlights))) / (1.0 + outColor.r);\noutColor.g = (outColor.g * (1.0 + (outColor.g * burnHighlights))) / (1.0 + outColor.g);\noutColor.b = (outColor.b * (1.0 + (outColor.b * burnHighlights))) / (1.0 + outColor.b);\nfloat lumFactor2 = maxExposurePhotographic(lumFactor, vec4(outColor, 0.0));\nfloat tmpFloat = 1.0 - saturation;\noutColor.r = outColor.r * saturation + lumFactor2 * tmpFloat;\noutColor.g = outColor.g * saturation + lumFactor2 * tmpFloat;\noutColor.b = outColor.b * saturation + lumFactor2 * tmpFloat;\noutColor = max(vec3(0.0), outColor);\nfloat crushBlacksFac = crushBlacks * 2.0 + 1.0;\nfloat crushBlacksFac2 = pow(maxExposurePhotographic(lumFactor, vec4(outColor, 0.0)), 0.5);\ntmpFloat = (1.0 - crushBlacksFac2);\nif (crushBlacksFac2 < 1.0) {\noutColor.r = outColor.r * crushBlacksFac2 + pow(outColor.r, crushBlacksFac) * tmpFloat;\noutColor.g = outColor.g * crushBlacksFac2 + pow(outColor.g, crushBlacksFac) * tmpFloat;\noutColor.b = outColor.b * crushBlacksFac2 + pow(outColor.b, crushBlacksFac) * tmpFloat;\n}\nreturn outColor;\n}\nfloat filmicBlenderDesaturationMinIntensity(vec3 color) {\nfloat maxChannel = max(color.r, max(color.g, color.b));\nfloat x = max(maxChannel, 0.6251);\nreturn (1.2192868 * x - 0.63221059)\n* ((x - 0.65069831) / (abs(x - 0.65069831) + 0.00952982) + 0.73015231);\n}\nvec3 filmicBlenderDesaturationTransform(vec3 color) {\nconst float CURVE_SMOOTHNESS = 0.03;\nfloat minIntensity = filmicBlenderDesaturationMinIntensity(color);\nvec4 x = vec4(color, 1.0) - minIntensity;\nx = pow(x, vec4(2.0)) / (abs(x) + CURVE_SMOOTHNESS);\nreturn (x.rgb - x.a + color + 1.0) / 2.0;\n}\nvec3 filmicBlenderDynamicRangeTransform(vec3 color) {\nreturn pow(\n(0.28882259 * color - 0.15880336)\n/ (pow(color - 0.6229693, vec3(2.0)) + 0.16965022)\n+ 0.20453365 * color + 0.37847142,\nvec3(3.0)\n);\n}\nvec3 FilmicBlenderToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(color, 0.000175);\ncolor = clamp((log2(color) - FILMIC_BLENDER_LOG_MIN)\n/ (FILMIC_BLENDER_LOG_MAX - FILMIC_BLENDER_LOG_MIN), 0.0, 1.0);\ncolor = filmicBlenderDesaturationTransform(color);\ncolor = clamp(color / FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO, 0.0, 1.0);\ncolor = filmicBlenderDynamicRangeTransform(color);\nreturn color;\n}",
            transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\ntotalTransmission *= texture2D(transmissionMap, vUv).r;\n#endif",
            transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\nuniform sampler2D transmissionMap;\n#endif",
            uv_pars_fragment: "#if (defined(USE_UV) && !defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\nvUv = (uvTransform * vec3(uv, 1)).xy;\n#endif",
            uv2_pars_fragment: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nattribute vec2 uv2;\nvarying vec2 vUv2;\nuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvUv2 = (uv2Transform * vec3(uv2, 1)).xy;\n#endif",
            worldpos_vertex: "#if defined(USE_ENVMAP) || defined(DISTANCE) || defined (USE_SHADOWMAP) || defined(MASK) || defined(NODE)\nvec4 worldPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nworldPosition = instanceMatrix * worldPosition;\n#endif\nworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\nvec4 texColor = texture2D(t2D, vUv);\ngl_FragColor = mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\nvUv = (uvTransform * vec3(uv, 1)).xy;\ngl_Position = vec4(position.xy, 1.0, 1.0);\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\nvec3 vReflect = vWorldDirection;\n#include <envmap_fragment>\ngl_FragColor = envColor;\ngl_FragColor.a *= opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z = gl_Position.w;\n}",
            depth_frag: "#define DEPTH\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\n#if DEPTH_PACKING == 3200\nuniform float opacity;\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#if DEPTH_PACKING == 3200\ndiffuseColor.a = opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\n#if DEPTH_PACKING != 3202\nfloat depth = vProjectedPosZW.x / vProjectedPosZW.y;\ndepth = (depth + 1.0) / 2.0;\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(depth), dFdy(depth)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndepth = clamp(depth + max(bias, 1e-6), 0.0, ONE_MINUS_EPS);\n#endif\n#if DEPTH_PACKING == 3200\ngl_FragColor = vec4(vec3(1.0 - depth), opacity);\n#elif DEPTH_PACKING == 3201\ngl_FragColor = packDepthToRGBA(depth);\n#endif\n#else\ngl_FragColor = vec4(vViewPosition.z);\n#endif\n}",
            depth_vert: "#define DEPTH\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = mvPosition.xyz;\nvProjectedPosZW = mat2(\nprojectionMatrix[2][2], projectionMatrix[2][3],\nprojectionMatrix[3][2], projectionMatrix[3][3]\n) * mvPosition.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#ifndef DISTANCE_SCALE\n#define DISTANCE_SCALE 1.0\n#endif\nvoid main () {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist = length(vWorldPosition - referencePosition);\n#if DISTANCE_PACKING == 3301\ndist = (dist - nearDistance) / (farDistance - nearDistance);\ndist = saturate(dist);\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndist = clamp(dist + bias, 0.0, ONE_MINUS_EPS);\n#endif\ngl_FragColor = packDepthToRGBA(dist);\n#elif DISTANCE_PACKING == 3302\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));\ndist += slopeScaledBias * max(dxdy.x, dxdy.y);\n#endif\ngl_FragColor = vec4(dist * DISTANCE_SCALE, 0.0, 0.0, 1.0);\n#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nuniform bool invertU;\nuniform float offsetU;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvec3 direction = normalize(vWorldDirection);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\n\nif (invertU) {\nsampleUV.x = 1.0 - sampleUV.x;\n}\n\nsampleUV.x += offsetU;\nvec4 texColor = texture2D(tEquirect, sampleUV);\ngl_FragColor = mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nif (mod(vLineDistance, totalSize) > dashSize) {\ndiscard;\n}\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\nvLineDistance = scale * lineDistance;\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_LIGHTMAP\n\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nreflectedLight.indirectDiffuse += lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#else\nreflectedLight.indirectDiffuse += vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse *= diffuseColor.rgb;\nvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <skinbase_vertex>\n#ifdef USE_ENVMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\nvarying vec3 vIndirectBack;\n#endif\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <emissivemap_fragment>\n#ifdef DOUBLE_SIDED\nreflectedLight.indirectDiffuse += (gl_FrontFacing) ? vIndirectFront : vIndirectBack;\n#else\nreflectedLight.indirectDiffuse += vIndirectFront;\n#endif\n#include <lightmap_fragment>\nreflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb);\n#ifdef DOUBLE_SIDED\nreflectedLight.directDiffuse = (gl_FrontFacing) ? vLightFront : vLightBack;\n#else\nreflectedLight.directDiffuse = vLightFront;\n#endif\nreflectedLight.directDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb) * getShadowMask();\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\nvarying vec3 vIndirectBack;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <lights_lambert_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\nvec3 viewDir = normalize(vViewPosition);\nvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\nvec3 y = cross(viewDir, x);\nvec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5;\n#ifdef USE_MATCAP\nvec4 matcapColor = texture2D(matcap, uv);\nmatcapColor = matcapTexelToLinear(matcapColor);\n#else\nvec4 matcapColor = vec4(1.0);\n#endif\nvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\nvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_toon_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\nuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#ifdef TRANSMISSION\nfloat totalTransmission = transmission;\n#endif\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <transmissionmap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef TRANSMISSION\ndiffuseColor.a *= mix(saturate(1. - totalTransmission + linearToRelativeLuminance(reflectedLight.directSpecular + reflectedLight.indirectSpecular)), 1.0, metalness);\n#endif\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent = normalize(transformedTangent);\nvBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n#endif\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor = vec4(packNormalToRGB(normal), opacity);\n}",
            normal_vert: "#define NORMAL\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent = normalize(transformedTangent);\nvBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n#endif\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize = size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) gl_PointSize *= (scale / - mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\ngl_FragColor = vec4(color, opacity * (1.0 - getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
            shadow_vert: "#include <common>\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#endif\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#ifdef USE_SHADOWMAP\nvViewPosition = - mvPosition.xyz;\n#endif\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\nvec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\nvec2 scale;\nscale.x = length(vec3(modelMatrix[0].x, modelMatrix[0].y, modelMatrix[0].z));\nscale.y = length(vec3(modelMatrix[1].x, modelMatrix[1].y, modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) scale *= - mvPosition.z;\n#endif\nvec2 alignedPosition = (position.xy - (center - vec2(0.5))) * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\nmvPosition.xy += rotatedPosition;\ngl_Position = projectionMatrix * mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
            equicube_frag: "uniform sampler2D tEquirect;\nuniform int faceIndex;\nuniform bool invertU;\nuniform float offsetU;\nvarying vec2 vUv;\n#include <common>\nvoid main() {\nvec3 direction;\nvec2 uv = vUv * 2.0 - 1.0;\nif (faceIndex==0) {\ndirection = vec3(1.0, -uv.y, -uv.x);\n} else if (faceIndex==1) {\ndirection = vec3(-1.0, -uv.y, uv.x);\n} else if (faceIndex==2) {\ndirection = vec3(uv.x, 1.0, uv.y);\n} else if (faceIndex==3) {\ndirection = vec3(uv.x, -1.0, -uv.y);\n} else if (faceIndex==4) {\ndirection = vec3(uv.x, -uv.y, 1.0);\n} else {\ndirection = vec3(-uv.x, -uv.y, -1.0);\n}\ndirection = normalize(direction);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\nif (invertU) {\nsampleUV.x = 1.0 - sampleUV.x;\n}\n\nsampleUV.x += offsetU;\ngl_FragColor = texture2D(tEquirect, sampleUV);\n}",
            equicube_vert: "varying vec2 vUv;\n#include <common>\nvoid main() {\nvUv = uv;\n#include <begin_vertex>\n#include <project_vertex>\n}",
            mask_frag: "#define MASK\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform mat4 projectionMatrix;\nuniform float opacity;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\ndiffuseColor.a = opacity;\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat depth = unpackRGBAToDepth(texture2DProj(depthTexture, projTexCoord));\nfloat viewZ;\nif (isOrtho(projectionMatrix))\nviewZ = -orthographicDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nelse\nviewZ = -perspectiveDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nfloat depthTest = (vViewPosition.z > viewZ) ? 1.0 : 0.0;\ngl_FragColor = vec4(0.0, depthTest, 1.0, 0.0);\n}",
            mask_vert: "#define MASK\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform mat4 textureMatrix;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\nprojTexCoord = textureMatrix * worldPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
            meshnode_frag: "#define NODE\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_node_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#if defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BUMP_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(NODE_TANGENT_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX) || defined(NODE_SAMPLER_INFO_MY) || defined(NODE_INCIDENT) || defined(NODE_POSITION) || defined(NODE_NORMAL) || defined(USE_OSL) || defined(SHADOWMAP_TYPE_ESM) && (defined(NODE_BSDF_DIFFUSE_BL) || defined(NODE_EEVEE_SPECULAR_BL) || defined(NODE_BSDF_GLOSSY_BL) || defined(NODE_BSDF_REFRACTION_BL) || defined(NODE_MATERIAL_MX) || defined(NODE_PHYSICAL_MX) || defined(NODE_AI_SHADOW_MATTE_MY))\nuniform mat4 invViewMatrix;\n#endif\n#if defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(USE_SSR) || (defined(NODE_NORMAL) && defined(MT_BLENDER)) || defined(USE_OSL)\nuniform mat4 projectionMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_NOISE_MX)  || defined(NODE_SAMPLER_INFO_MY) || defined(USE_OSL)\nuniform mat4 modelMatrix;\nuniform mat4 invModelMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_NORMAL_BUMP_MX) || defined(NODE_BUMP_2D_MY) || defined(NODE_SAMPLER_INFO_MY)\nuniform mat4 modelViewMatrix;\n#endif\n#if defined(NODE_TEX_IMAGE_BL)\nuniform mat3 normalMatrix;\n#endif\n#if defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_TANGENT_BL)\nuniform vec3 boundingBoxMin;\nuniform vec3 boundingBoxMax;\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY) || defined(NODE_ENV_SPHERE_MY)\nvarying vec3 vWorldPosition;\n#endif\n#if defined(NODE_TEX_COORD_BL)\nuniform vec2 viewWidthHeight;\n#endif\n#include <ssr_pars_fragment>\n#include <node_common_frag>\n#include <node_pars_fragment>\nvoid main() {\nbool _frontFacingValue = gl_FrontFacing;\n#define FRONT_FACING_VALUE _frontFacingValue\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\nvec4 outgoingLight = vec4(0.0);\n#include <node_fragment>\n#if WORLD_NODES == 1\noutgoingLight.a = 1.0;\n#endif\n#ifdef ALPHATEST\nif (outgoingLight.a < ALPHATEST)\ndiscard;\nelse\noutgoingLight.a = 1.0;\n#endif\ngl_FragColor = vec4(outgoingLight);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshnode_vert: "#define NODE\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY) || defined(NODE_ENV_SPHERE_MY)\nvarying vec3 vWorldPosition;\n#endif\n#include <node_pars_vertex>\nvoid main() {\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY) || defined(NODE_ENV_SPHERE_MY)\nvWorldPosition = worldPosition.xyz;\n#endif\n#include <node_vertex>\n}",
            lights_node_pars_fragment: "\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct NodeMaterial {\nvec3    diffuseColor;\nvec3    specularColor;\nvec3    refractionColor;\nfloat   refractionRoughness;\nfloat   refractionIOR;\n#ifdef CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\nfloat sheenRoughness;\n#endif\n#ifdef PHYSICAL\nvec3 fresnelRefl90;\nfloat specularRoughness;\n#else\nfloat   diffuseIntensity;\nfloat   specularIntensity;\nfloat   specularHardness;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define BLENDER_SPECULAR_COEFFICIENT 0.08\nfloat shadeSpecPhong(vec3 normal, vec3 lightDir, vec3 viewDir, float hard)\n{\nfloat specFac;\nvec3 h = normalize(lightDir + viewDir);\nfloat rslt = max(dot(h, normal), 0.0);\nspecFac = pow(rslt, hard);\nreturn specFac;\n}\nfloat clearcoatDHRApprox(const in float roughness, const in float dotNL) {\nreturn DEFAULT_SPECULAR_COEFFICIENT + (1.0 - DEFAULT_SPECULAR_COEFFICIENT) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Node(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.specularRoughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3(   0, 1,    0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_DirectDiffuse_Node(const in IncidentLight directLight,\nconst in GeometricContext geometry, const in NodeMaterial material,\ninout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\n#ifdef PHYSICAL\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\nreflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance\n* BRDF_Diffuse_Lambert(material.diffuseColor);\n#else\nreflectedLight.directDiffuse += irradiance * material.diffuseIntensity\n* BRDF_Diffuse_Lambert(material.diffuseColor);\n#endif\n}\nvoid RE_DirectSpecular_Node(const in IncidentLight directLight,\nconst in GeometricContext geometry, const in NodeMaterial material,\ninout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\n#ifdef PHYSICAL\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = ccDotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nccIrradiance *= PI;\n#endif\n#endif\n#ifdef CLEARCOAT\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance\n* BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.normal,\nmaterial.specularColor, material.specularRoughness);\n#ifdef CLEARCOAT\nreflectedLight.directSpecular += ccIrradiance * material.clearcoat\n* BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.clearcoatNormal,\nvec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_Sheen(\nmaterial.sheenRoughness,\ndirectLight.direction,\ngeometry,\nmaterial.sheenColor\n);\n#endif\n#else\nreflectedLight.directSpecular += material.specularIntensity *\nshadeSpecPhong(geometry.normal, directLight.direction,\ngeometry.viewDir, material.specularHardness) *\ndirectLight.color * material.specularColor;\n#endif\n}\nvoid RE_IndirectDiffuse_Node(const in vec3 irradiance, const in vec3 iblIrradiance,\nconst in GeometricContext geometry, const in NodeMaterial material,\ninout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += (irradiance + iblIrradiance)\n* BRDF_Diffuse_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Node(const in vec3 radiance, const in vec3 irradiance,\nconst in vec3 clearcoatRadiance, const in GeometricContext geometry,\nconst in NodeMaterial material, inout ReflectedLight reflectedLight) {\n#ifdef PHYSICAL\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(\nmaterial.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\n#ifdef MT_BLENDER\n#ifdef COMPAT_USE_SPEC_ENV_BLENDER_APPROX\nvec3 specEnv = BRDF_Specular_GGX_Environment_Blender_Approx(geometry,\nmaterial.specularColor, material.fresnelRefl90,\nmaterial.specularRoughness, 0);\n#else\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir,\ngeometry.normal, material.specularColor,\nmaterial.specularRoughness);\n#endif\n#elif defined(MT_MAX)\nfloat alphaEnv = pow2(pow2(material.specularRoughness));\nvec3 specEnv = material.specularColor / (1.0 - alphaEnv + PI * alphaEnv);\n#elif defined(MT_MAYA)\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n#else\nvec3 specEnv = vec3(1.0);\n#endif\nreflectedLight.indirectSpecular += (1.0 - clearcoatDHR) * radiance * specEnv;\n#ifdef CLEARCOAT\n#ifdef MT_BLENDER\nvec3 specEnvCC = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#elif defined(MT_MAX) || defined(MT_MAYA)\nvec3 specEnvCC = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#else\nvec3 specEnvCC = vec3(1.0);\n#endif\nreflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * specEnvCC;\n#endif\n#endif\n}\nvoid RE_Refraction_Node(const vec3 refraction, const NodeMaterial material,\ninout vec3 refractedLight) {\nrefractedLight += refraction * material.refractionColor;\n}\n#ifdef MT_BLENDER\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness)\n#elif defined(MT_MAX)\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness * exp(0.35*(1.0-pow2(material.specularRoughness))))\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness * exp(0.35*(1.0-pow2(material.refractionRoughness))))\n#else\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness)\n#endif\n#define Material_ClearCoat_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.clearcoatRoughness)\nfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\nreturn saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n}\n#define RE_Direct_RectArea RE_Direct_RectArea_Node",
            ssr_pars_fragment: "#ifdef USE_SSR\nuniform sampler2D ssrSourceBuffer;\nuniform sampler2D ssrDepthBuffer;\nuniform sampler2D ssrBackfaceDepthBuffer;\nuniform mat4 invProjectionMatrix;\nuniform vec2 ssrResolution;\nuniform float ssrThickness;\nuniform float ssrStride;\nuniform float ssrJitter;\nuniform float ssrMaxDistance;\n#ifdef USE_SSR_REFRACT\n#define STEPS_FADE_AMOUNT 0.1\n#define SCREEN_FADE_THRESHOLD 0.6\n#else\n#define STEPS_FADE_AMOUNT 1.0\n#define SCREEN_FADE_THRESHOLD 0.4\n#endif\nvec3 deproject(vec3 p) {\nvec4 res = invProjectionMatrix * vec4(p, 1);\nreturn res.xyz / res.w;\n}\nbool doesIntersect(float rayzmax, float rayzmin, vec2 uv) {\nfloat sceneZMin = texture2D(ssrDepthBuffer, uv).r;\n#ifdef USE_SSR_REFRACT\nreturn rayzmin >= (sceneZMin-ssrThickness) && rayzmax <= sceneZMin;\n#else\nfloat sceneZMax = texture2D(ssrBackfaceDepthBuffer, uv).r;\nreturn rayzmin >= sceneZMax && rayzmax <= sceneZMin;\n#endif\n}\nfloat distanceSquared(vec2 a, vec2 b) { a -= b; return dot(a, a); }\nvoid swapIfBigger(inout float a, inout float b) {\nif (a > b) {\nfloat t = a;\na = b;\nb = t;\n}\n}\nbool isOutsideUvBounds(float x) { return x < 0.0 || x > 1.0; }\nbool isOutsideUvBounds(vec2 uv) { return isOutsideUvBounds(uv.x) || isOutsideUvBounds(uv.y); }\nvec3 computeSSR(vec3 color, vec3 normal, float ior) {\nvec2 uv = gl_FragCoord.xy / ssrResolution;\nvec2 screenCoord = uv * 2.0 - vec2(1, 1);\nfloat nearClip = deproject(vec3(0, 0, -1)).z;\nvec3 ray = deproject(vec3(screenCoord, -1));\nray /= ray.z;\nfloat depthSample = -vViewPosition.z;\nvec3 vpos = depthSample * ray;\n#ifdef USE_SSR_REFRACT\nvec3 dir = normalize(refract(normalize(vpos), normalize(normal), 1.0/ior));\n#else\nvec3 dir = normalize(reflect(normalize(vpos), normalize(normal)));\n#endif\nfloat maxDist = ssrMaxDistance;\nfloat rayLength = (vpos.z + dir.z * maxDist) > nearClip ? (nearClip - vpos.z) / dir.z : maxDist;\nvec3 csOrig = vpos;\nvec3 csEndPoint = csOrig + dir * rayLength;\nvec4 H0 = projectionMatrix * vec4(csOrig, 1.0);\nvec4 H1 = projectionMatrix * vec4(csEndPoint, 1.0);\nfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\nvec3 Q0 = csOrig.xyz * k0, Q1 = csEndPoint.xyz * k1;\nvec2 P0 = H0.xy * k0, P1 = H1.xy * k1;\nP0 = P0 * 0.5 + vec2(0.5), P1 = P1 * 0.5 + vec2(0.5);\n#ifndef SSR_SIMPLE_REFRACT\nP0 *= ssrResolution, P1 *= ssrResolution;\nP1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);\nvec2 delta = P1 - P0;\nbool permute = false;\nif (abs(delta.x) < abs(delta.y)) {\npermute = true; delta = delta.yx; P0 = P0.yx; P1 = P1.yx;\n}\nfloat stepDir = sign(delta.x);\nfloat invdx = stepDir / delta.x;\nvec3 dQ = (Q1 - Q0) * invdx;\nfloat dk = (k1 - k0) * invdx;\nvec2 dP = vec2(stepDir, delta.y * invdx);\nfloat pixelStride = ssrStride;\nfloat jitterMod = (gl_FragCoord.x + gl_FragCoord.y) * 0.25;\nvec4 PQK = vec4(P0, Q0.z, k0);\nvec4 dPQK = vec4(dP, dQ.z, dk);\ndPQK *= pixelStride;\nPQK += dPQK * mod(jitterMod, 1.0) * ssrJitter;\nfloat end = P1.x * stepDir;\nfloat prevZMaxEstimate = PQK.z / PQK.w;\nfloat rayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfloat stepped = 0.0;\nvec2 hitUV;\nbool intersected = false;\nfor (float stepCount = 1.0; stepCount <= float(MAX_STEPS); stepCount ++) {\nPQK += dPQK;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\n\nstepped = stepCount;\nhitUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nif (isOutsideUvBounds(hitUV)) break;\nintersected = doesIntersect(rayZMax, rayZMin, hitUV);\nif (intersected || (P0.x * stepDir) > end) break;\n}\nif (intersected && pixelStride > 1.0) {\nPQK -= dPQK;\ndPQK /= ssrStride;\nfloat ogStride = pixelStride * 0.5;\nfloat currStride = pixelStride;\nprevZMaxEstimate = PQK.z / PQK.w;\nrayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfor(int j = 0; j < int(BINARY_SEARCH_ITERATIONS); j ++) {\nPQK += dPQK * currStride;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\nvec2 newUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nogStride *= 0.5;\nif (doesIntersect(rayZMax, rayZMin, newUV)) {\nhitUV = newUV;\ncurrStride = -ogStride;\n} else {\ncurrStride = ogStride;\n}\n}\n}\nvec3 result = color;\n#ifdef USE_SSR_REFRACT\n#endif\nif (intersected) {\nvec4 col = sRGBToLinear(texture2D(ssrSourceBuffer, hitUV));\nvec2 ndc = abs(hitUV * 2.0 - 1.0);\nfloat maxndc = max(ndc.x, ndc.y);\nfloat fadeVal =\n(1.0 - (max(0.0, maxndc - SCREEN_FADE_THRESHOLD) / (1.0 - SCREEN_FADE_THRESHOLD))) *\n(1.0 - STEPS_FADE_AMOUNT * (stepped / float(MAX_STEPS)));\ncol.a = fadeVal;\nresult = mix(result, col.rgb, col.a);\n}\n#else\nvec3 result = sRGBToLinear(texture2D(ssrSourceBuffer, P1)).xyz;\n#endif\nreturn result;\n}\n#endif",
            node_common_frag: "#define LUMENS_PER_WATT 683.0\n#define MAX_ENV_COORDS_DIR 0\n#define MAX_ENV_COORDS_REFLECT 1\n#define MAX_ENV_COORDS_REFRACT 2\nvec4 nodeTexelToLinear(in vec4 color, in int sourceType) {\nif (sourceType == 1)\nreturn sRGBToLinear(color);\nelse if (sourceType == 2)\nreturn RGBEToLinear(color);\nelse\nreturn color;\n}\n#if defined(NODE_COMBHSV_BL) || defined(NODE_SEPHSV_BL) || defined(NODE_HUE_SAT_BL) || defined(NODE_COLOR_CORRECTION_MX) || defined(NODE_COMPOSITE_LAYER_MX) || defined(USE_OSL)\n#define HSV_NODES\n#endif\n#if defined HSV_NODES\nvoid hsvToRGB(vec4 hsv, out vec4 outCol)\n{\nfloat i, f, p, q, t, h, s, v;\nvec3 rgb;\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\nif (s == 0.0)\nrgb = vec3(v, v, v);\nelse {\nif (h == 1.0)\nh = 0.0;\nh *= 6.0;\ni = floor(h);\nf = h - i;\nrgb = vec3(f, f, f);\np = v * (1.0 - s);\nq = v * (1.0 - (s * f));\nt = v * (1.0 - (s * (1.0 - f)));\nif (i == 0.0)\nrgb = vec3(v, t, p);\nelse if (i == 1.0)\nrgb = vec3(q, v, p);\nelse if (i == 2.0)\nrgb = vec3(p, v, t);\nelse if (i == 3.0)\nrgb = vec3(p, q, v);\nelse if (i == 4.0)\nrgb = vec3(t, p, v);\nelse\nrgb = vec3(v, p, q);\n}\noutCol = vec4(rgb, hsv.w);\n}\nvoid rgbToHSV(vec4 rgb, out vec4 outCol)\n{\nfloat cmax, cmin, h, s, v, cdelta;\nvec3 c;\ncmax = max(rgb[0], max(rgb[1], rgb[2]));\ncmin = min(rgb[0], min(rgb[1], rgb[2]));\ncdelta = cmax - cmin;\nv = cmax;\nif (cmax != 0.0)\ns = cdelta / cmax;\nelse {\ns = 0.0;\nh = 0.0;\n}\nif (s == 0.0)\nh = 0.0;\nelse {\nc = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;\nif (rgb.x == cmax) h = c[2] - c[1];\nelse if (rgb.y == cmax) h = 2.0 + c[0] -  c[2];\nelse h = 4.0 + c[1] - c[0];\nh /= 6.0;\nif (h < 0.0)\nh += 1.0;\n}\noutCol = vec4(h, s, v, rgb.w);\n}\n#endif\nbool isPerspective(const mat4 projMatrix)\n{\nreturn (projMatrix[3][3] == 0.0);\n}\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY) || defined(NODE_ENV_SPHERE_MY)\nvec4 sampleEquirectangular(sampler2D map, vec3 reflectVec, mat3 uvTransform, int encoding)\n{\nreflectVec = normalize(reflectVec);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(reflectVec.x, reflectVec.z) * RECIPROCAL_PI2 + 0.5;\nsampleUV.y *= -1.0;\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (reflectVec.x) / seamWidth) *\nclamp (1.0 - reflectVec.z / seamWidth, 0.0, 1.0);\nsampleUV = (uvTransform * vec3(sampleUV, 1.0)).xy;\nvec4 color = texture2D(map, sampleUV, seamBiasFactor * seam);\ncolor = nodeTexelToLinear(color, encoding);\nreturn color;\n}\n#endif\n#if defined(NODE_FRESNEL_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FALLOFF_MX) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL)\nfloat fresnelReflection(const vec3 dir, const vec3 normal, const float ior) {\nfloat cosTheta = clamp(abs(dot(dir, normal)), -1.0, 1.0);\nfloat gSquared = pow2(ior) + pow2(cosTheta) - 1.0;\nif (gSquared < 0.0) return 1.0;\nfloat g = sqrt(gSquared);\nreturn 0.5 * pow2((g - cosTheta) / (g + cosTheta))\n* (1.0 + pow2(\n((g + cosTheta) * cosTheta - 1.0) /\n((g - cosTheta) * cosTheta + 1.0)\n));\n}\n#endif\n#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_GRADIENT_RAMP_MX)\n#define MAPPING_EXPLICIT_MAP_CHANNEL 1\n#define MAPPING_VERTEX_COLOR_CHANNEL 2\n#define MAPPING_PLANAR_OBJECT_XYZ    3\n#define MAPPING_PLANAR_WORLD_XYZ     4\n#define AXIS_XY 1\n#define AXIS_YZ 2\n#define AXIS_ZX 3\n#endif\n#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_MX) || defined(NODE_GRADIENT_RAMP_MX) || defined(NODE_PLACE_2D_TEXTURE_MY)\nmat3 calcUvTransform(float uOffset, float vOffset, float uTiling, float vTiling, float wAngle)\n{\nif (abs(uOffset) < EPSILON && abs(vOffset) < EPSILON &&\n(abs(uTiling - 1.0)) < EPSILON && (abs(vTiling - 1.0)) < EPSILON &&\nabs(wAngle) < EPSILON)\nreturn mat3(1.0);\nfloat sx = uTiling;\nfloat sy = vTiling;\nfloat c = cos(-wAngle);\nfloat s = sin(-wAngle);\n#if defined(NODE_PLACE_2D_TEXTURE_MY)\nfloat tx = uOffset;\nfloat ty = vOffset;\nfloat cx = 0.5;\nfloat cy = 0.5;\nreturn mat3(c*sx,                       s*sx,                        0.0,\n-s*sy,                       c*sy,                        0.0,\ns*(ty+sy-cy)+c*(tx-cx)+cx, -c*(ty+sy-cy)+s*(tx-cx)-cy+1.0, 1.0);\n#else\nfloat tx = -uOffset;\nfloat ty = -vOffset;\nfloat cx = uOffset + 0.5;\nfloat cy = vOffset + 0.5;\nreturn mat3(sx * c,                           -sy * s,                             0.0,\nsx * s,                            sy * c,                             0.0,\n-sx * (c * cx + s * cy) + cx + tx, -sy * (- s * cx + c * cy) + cy + ty, 1.0);\n#endif\n}\n#endif\n#if defined(NODE_NOISE_MX)\nmat4 calcXYZTransform(vec3 offset, vec3 tiling, vec3 angle) {\nmat4 rot = mat4(\ncos(angle.y)*cos(angle.z), cos(angle.x)*sin(angle.z)+sin(angle.x)*sin(angle.y)*cos(angle.z), sin(angle.x)*sin(angle.z)-cos(angle.x)*sin(angle.y)*cos(angle.z), 0.0,\n-cos(angle.y)*sin(angle.z), cos(angle.x)*cos(angle.z)-sin(angle.x)*sin(angle.y)*sin(angle.z), cos(angle.x)*sin(angle.y)*sin(angle.z)+sin(angle.x)*cos(angle.z), 0.0,\nsin(angle.y), -sin(angle.x)*cos(angle.y), cos(angle.x)*cos(angle.y), 0.0,\n0.0,    0.0,    0.0,    1.0\n);\nmat4 til = mat4(\ntiling.x, 0.0,      0.0,      0.0,\n0.0,      tiling.y, 0.0,      0.0,\n0.0,      0.0,      tiling.z, 0.0,\n0.0,      0.0,      0.0,      1.0\n);\nmat4 off = mat4(\n1.0,      0.0,      0.0,      0.0,\n0.0,      1.0,      0.0,      0.0,\n0.0,      0.0,      1.0,      0.0,\noffset.x, offset.y, offset.z, 1.0\n);\nreturn (til * rot * off);\n}\n#endif\n#if defined(NODE_TEX_NOISE_BL) || defined(NODE_TEX_WAVE_BL) || defined(NODE_NOISE_MX) || defined(USE_OSL)\n#define NOISE_AMP_HACK 0.75\n#define NOISE_BLENDER_MEAN 0.78\n#define NOISE_SCALE_HACK 0.5\n#define noiseModulo(x) (x - floor(x * (1.0 / 289.0)) * 289.0)\nvec4 noisePermute(vec4 x) {\nreturn noiseModulo(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat taylorInvSqrt(float r) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat noisePerlin(vec3 v) {\nconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\nvec3 i = floor(v + dot(v, C.yyy));\nvec3 x0 = v - i + dot(i, C.xxx);\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min(g.xyz, l.zxy);\nvec3 i2 = max(g.xyz, l.zxy);\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy;\nvec3 x3 = x0 - D.yyy;\ni = noiseModulo(i);\nvec4 p = noisePermute(noisePermute(noisePermute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\nfloat n_ = 0.142857142857;\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_);\nvec4 x = x_ * ns.x + ns.yyyy;\nvec4 y = y_ * ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4(x.xy, y.xy);\nvec4 b1 = vec4(x.zw, y.zw);\nvec4 s0 = floor(b0) * 2.0 + 1.0;\nvec4 s1 = floor(b1) * 2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\nvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\nvec3 p0 = vec3(a0.xy, h.x);\nvec3 p1 = vec3(a0.zw, h.y);\nvec3 p2 = vec3(a1.xy, h.z);\nvec3 p3 = vec3(a1.zw, h.w);\nvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\nvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\ndot(p2, x2), dot(p3, x3)));\n}\nvec4 permute(vec4 x) {\nreturn mod(((x*34.0)+1.0)*x, 289.0);\n}\nfloat permute(float x) {\nreturn floor(mod(((x*34.0)+1.0)*x, 289.0));\n}\nvec4 grad4(float j, vec4 ip) {\nconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\nvec4 p,s;\np.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\np.w = 1.5 - dot(abs(p.xyz), ones.xyz);\ns = vec4(lessThan(p, vec4(0.0)));\np.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \nreturn p;\n}\nfloat snoise(vec4 v) {\nconst vec2 C = vec2(0.138196601125010504,\n0.309016994374947451);\nvec4 i  = floor(v + dot(v, C.yyyy) );\nvec4 x0 = v -   i + dot(i, C.xxxx);\nvec4 i0;\nvec3 isX = step( x0.yzw, x0.xxx );\nvec3 isYZ = step( x0.zww, x0.yyz );\ni0.x = isX.x + isX.y + isX.z;\ni0.yzw = 1.0 - isX;\ni0.y += isYZ.x + isYZ.y;\ni0.zw += 1.0 - isYZ.xy;\ni0.z += isYZ.z;\ni0.w += 1.0 - isYZ.z;\nvec4 i3 = clamp( i0, 0.0, 1.0 );\nvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\nvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\nvec4 x1 = x0 - i1 + 1.0 * C.xxxx;\nvec4 x2 = x0 - i2 + 2.0 * C.xxxx;\nvec4 x3 = x0 - i3 + 3.0 * C.xxxx;\nvec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\ni = mod(i, 289.0);\nfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\nvec4 j1 = permute( permute( permute( permute (\ni.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\nvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\nvec4 p0 = grad4(j0,   ip);\nvec4 p1 = grad4(j1.x, ip);\nvec4 p2 = grad4(j1.y, ip);\nvec4 p3 = grad4(j1.z, ip);\nvec4 p4 = grad4(j1.w, ip);\nvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\np4 *= taylorInvSqrt(dot(p4,p4));\nvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\nvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\nm0 = m0 * m0;\nm1 = m1 * m1;\nreturn 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat noiseBlender(vec3 p) {\nreturn 0.5 * NOISE_AMP_HACK * (noisePerlin(NOISE_SCALE_HACK * vec3(p.x, p.y, p.z))) + 0.5;\n}\nfloat noiseSmooth(vec3 p, float octaveLenPerPixel, float falloffFactor,\nfloat dispersionFactor) {\nfloat mixFac = mix(1.0, smoothstep(0.0, 1.0, octaveLenPerPixel) * falloffFactor,\ndispersionFactor);\nreturn mix(noiseBlender(p), NOISE_BLENDER_MEAN, mixFac);\n}\n#define MAX_OCTAVES_NUM 16\nfloat noiseTurbulence(vec3 p, float octaves, float octaveLenPerPixel,\nfloat falloffFactor, float dispersionFactor) {\nfloat fscale = 1.0;\nfloat amp = 1.0;\nfloat sum = 0.0;\noctaves = clamp(octaves, 0.0, 16.0);\nint octavesInt = int(octaves);\nfor (int i = 0; i <= MAX_OCTAVES_NUM; i++) {\n#if __VERSION__ == 300\nif (i <= octavesInt) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n} else {\ni = MAX_OCTAVES_NUM;\n}\n#else\nif (i > octavesInt) break;\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n#endif\n}\nfloat octavesFrac = fract(octaves);\nfloat octavesCoeff = pow(2.0, float(octavesInt));\nif (octavesFrac != 0.0) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nfloat sum2 = sum + t * amp;\nsum *= octavesCoeff / (2.0 * octavesCoeff - 1.0);\nsum2 *= 2.0 * octavesCoeff / (4.0 * octavesCoeff - 1.0);\nreturn mix(sum, sum2, octavesFrac);\n} else {\nreturn sum * octavesCoeff / (2.0 * octavesCoeff - 1.0);\n}\n}\n#endif\n#if (defined(USE_OSL) || defined(NODE_WAVELENGTH_BL)) && __VERSION__ == 300\nvec3 cieColorMatch[81] = vec3[](\nvec3(0.0014,0.0000,0.0065), vec3(0.0022,0.0001,0.0105), vec3(0.0042,0.0001,0.0201),\nvec3(0.0076,0.0002,0.0362), vec3(0.0143,0.0004,0.0679), vec3(0.0232,0.0006,0.1102),\nvec3(0.0435,0.0012,0.2074), vec3(0.0776,0.0022,0.3713), vec3(0.1344,0.0040,0.6456),\nvec3(0.2148,0.0073,1.0391), vec3(0.2839,0.0116,1.3856), vec3(0.3285,0.0168,1.6230),\nvec3(0.3483,0.0230,1.7471), vec3(0.3481,0.0298,1.7826), vec3(0.3362,0.0380,1.7721),\nvec3(0.3187,0.0480,1.7441), vec3(0.2908,0.0600,1.6692), vec3(0.2511,0.0739,1.5281),\nvec3(0.1954,0.0910,1.2876), vec3(0.1421,0.1126,1.0419), vec3(0.0956,0.1390,0.8130),\nvec3(0.0580,0.1693,0.6162), vec3(0.0320,0.2080,0.4652), vec3(0.0147,0.2586,0.3533),\nvec3(0.0049,0.3230,0.2720), vec3(0.0024,0.4073,0.2123), vec3(0.0093,0.5030,0.1582),\nvec3(0.0291,0.6082,0.1117), vec3(0.0633,0.7100,0.0782), vec3(0.1096,0.7932,0.0573),\nvec3(0.1655,0.8620,0.0422), vec3(0.2257,0.9149,0.0298), vec3(0.2904,0.9540,0.0203),\nvec3(0.3597,0.9803,0.0134), vec3(0.4334,0.9950,0.0087), vec3(0.5121,1.0000,0.0057),\nvec3(0.5945,0.9950,0.0039), vec3(0.6784,0.9786,0.0027), vec3(0.7621,0.9520,0.0021),\nvec3(0.8425,0.9154,0.0018), vec3(0.9163,0.8700,0.0017), vec3(0.9786,0.8163,0.0014),\nvec3(1.0263,0.7570,0.0011), vec3(1.0567,0.6949,0.0010), vec3(1.0622,0.6310,0.0008),\nvec3(1.0456,0.5668,0.0006), vec3(1.0026,0.5030,0.0003), vec3(0.9384,0.4412,0.0002),\nvec3(0.8544,0.3810,0.0002), vec3(0.7514,0.3210,0.0001), vec3(0.6424,0.2650,0.0000),\nvec3(0.5419,0.2170,0.0000), vec3(0.4479,0.1750,0.0000), vec3(0.3608,0.1382,0.0000),\nvec3(0.2835,0.1070,0.0000), vec3(0.2187,0.0816,0.0000), vec3(0.1649,0.0610,0.0000),\nvec3(0.1212,0.0446,0.0000), vec3(0.0874,0.0320,0.0000), vec3(0.0636,0.0232,0.0000),\nvec3(0.0468,0.0170,0.0000), vec3(0.0329,0.0119,0.0000), vec3(0.0227,0.0082,0.0000),\nvec3(0.0158,0.0057,0.0000), vec3(0.0114,0.0041,0.0000), vec3(0.0081,0.0029,0.0000),\nvec3(0.0058,0.0021,0.0000), vec3(0.0041,0.0015,0.0000), vec3(0.0029,0.0010,0.0000),\nvec3(0.0020,0.0007,0.0000), vec3(0.0014,0.0005,0.0000), vec3(0.0010,0.0004,0.0000),\nvec3(0.0007,0.0002,0.0000), vec3(0.0005,0.0002,0.0000), vec3(0.0003,0.0001,0.0000),\nvec3(0.0002,0.0001,0.0000), vec3(0.0002,0.0001,0.0000), vec3(0.0001,0.0000,0.0000),\nvec3(0.0001,0.0000,0.0000), vec3(0.0001,0.0000,0.0000), vec3(0.0000,0.0000,0.0000)\n);\n#endif\n#if defined(USE_OSL) || defined(NODE_BLACKBODY_BL)\nvec3 colorTempToRGB(float temp)\n{\nvec3 retColor;\n\ntemp = clamp(temp, 100.0, 40000.0) / 100.0;\nif (temp <= 66.0) {\nretColor.r = 1.0;\nretColor.g = saturate(0.390081578 * log(temp) - 0.631841443);\n} else {\nfloat t = temp - 60.0;\nretColor.r = saturate(1.292936186 * pow(t, -0.133204759));\nretColor.g = saturate(1.129890860 * pow(t, -0.075514849));\n}\n\nif (temp >= 66.0)\nretColor.b = 1.0;\nelse if (temp <= 19.0)\nretColor.b = 0.0;\nelse\nretColor.b = saturate(0.543206789 * log(temp - 10.0) - 1.196254089);\nreturn retColor;\n}\n#endif\n#ifdef USE_OSL\n#define M_PI PI\n#define M_PI_2 PI / 2.0\n#define M_PI_4 PI / 4.0\n#define M_2_PI 2.0 / PI\n#define M_2PI 2.0 * PI\n#define M_4PI 4.0 * PI\n#define M_2_SQRTPI 2.0 / sqrt(PI)\n#define M_E 2.718281828459\n#define M_LN2 0.69314718056\n#define M_LN10 2.30258509299\n#define M_LOG2E 1.4426950409\n#define M_LOG10E 0.43429448190\n#define M_SQRT2 sqrt(2.0)\n#define M_SQRT1_2 sqrt(0.5)\n#define OSL_ALPHA 33633\n#define OSL_ANISOTROPIC 40205\n#define OSL_AVERAGEALPHA 57701\n#define OSL_AVERAGECOLOR 46077\n#define OSL_BANDWIDTH 37485\n#define OSL_BEZIER 27645\n#define OSL_BLACK 62409\n#define OSL_BSPLINE 16959\n#define OSL_CAMERA 8198\n#define OSL_CAMERA_CLIP 34380\n#define OSL_CAMERA_CLIP_FAR 31933\n#define OSL_CAMERA_CLIP_NEAR 21485\n#define OSL_CAMERA_FOV 60706\n#define OSL_CAMERA_PIXELASPECT 4950\n#define OSL_CAMERA_PROJECTION 29369\n#define OSL_CAMERA_RESOLUTION 39679\n#define OSL_CAMERA_SCREEN_WINDOW 47009\n#define OSL_CAMERA_SHUTTER 7107\n#define OSL_CAMERA_SHUTTER_CLOSE 34406\n#define OSL_CAMERA_SHUTTER_OPEN 40085\n#define OSL_CATMULL_ROM 31642\n#define OSL_CELL 20984\n#define OSL_CHANNELS 8726\n#define OSL_CLAMP 20052\n#define OSL_COLOR 53753\n#define OSL_COMMON 49871\n#define OSL_CONSTANT 25144\n#define OSL_DATAWINDOW 54276\n#define OSL_DEFAULT 54870\n#define OSL_DIFFUSE 40389\n#define OSL_DIRECTION 42220\n#define OSL_DISPLAYWINDOW 30728\n#define OSL_DISTANCE 51337\n#define OSL_DO_FILTER 35765\n#define OSL_EMPTY 9314\n#define OSL_ERRORMESSAGE 38305\n#define OSL_EXISTS 41510\n#define OSL_FILL 39132\n#define OSL_FIRSTCHANNEL 48155\n#define OSL_GABOR 57764\n#define OSL_GEOM_NAME 63686\n#define OSL_GLOSSY 47998\n#define OSL_HASH 49390\n#define OSL_HERMITE 63643\n#define OSL_HIT 48491\n#define OSL_HITDIST 22029\n#define OSL_HSL 49898\n#define OSL_HSV 29073\n#define OSL_IMPULSES 56191\n#define OSL_INDEX 1731\n#define OSL_INTERP 10557\n#define OSL_LINEAR 2182\n#define OSL_MIRROR 64591\n#define OSL_MISSINGALPHA 39755\n#define OSL_MISSINGCOLOR 51667\n#define OSL_NDC 48899\n#define OSL_NORMAL 16520\n#define OSL_OBJECT 59084\n#define OSL_OSL_VERSION 47920\n#define OSL_PERIODIC 8749\n#define OSL_PERLIN 730\n#define OSL_POSITION 43041\n#define OSL_RASTER 2618\n#define OSL_REFLECTION 37621\n#define OSL_REFRACTION 37287\n#define OSL_RESOLUTION 48704\n#define OSL_RGB 26673\n#define OSL_RWRAP 47801\n#define OSL_SCREEN 55875\n#define OSL_SHADER 21066\n#define OSL_SHADER_GROUPNAME 62327\n#define OSL_SHADER_LAYERNAME 51796\n#define OSL_SHADER_SHADERNAME 65123\n#define OSL_SHADOW 60708\n#define OSL_SIMPLEX 61636\n#define OSL_SUBIMAGE 33526\n#define OSL_SUBIMAGES 2366\n#define OSL_SWRAP 4328\n#define OSL_TEXTUREFORMAT 17851\n#define OSL_TIME 52235\n#define OSL_TRACE 62908\n#define OSL_TWRAP 30524\n#define OSL_TYPE 64071\n#define OSL_UPERLIN 65308\n#define OSL_USIMPLEX 11314\n#define OSL_WIDTH 48751\n#define OSL_WORLD 9059\n#define OSL_WORLDTOCAMERA 32273\n#define OSL_WORLDTOSCREEN 33876\n#define OSL_WRAP 58300\n#define OSL_XYY 2228\n#define OSL_XYZ 47351\n#define OSL_YIQ 15839\nvec3 oslGetP(vec3 viewPos) {\n#if WORLD_NODES == 1\nreturn swizzleUpZ((invViewMatrix * vec4(-viewPos, 0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n#endif\n}\nvec3 oslGetI(vec3 viewPos) {\n#if WORLD_NODES == 1\nreturn swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);\n#else\nreturn swizzleUpZ((invViewMatrix * vec4(normalize(-viewPos), 0.0)).xyz);\n#endif\n}\nvec3 oslGetN(vec3 viewNorm) {\nreturn swizzleUpZ(normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz);\n}\nvec3 oslBlackbody(float temperatureK) {\nreturn sRGBToLinear(vec4(colorTempToRGB(temperatureK), 1.0)).rgb;\n}\nfloat oslDistance(vec3 p0, vec3 p1) {\nreturn distance(p0, p1);\n}\nfloat oslDistance(vec3 p0, vec3 p1, vec3 q) {\nvec3 d = p1 - p0;\nfloat dd = dot(d, d);\nif (dd == 0.0)\nreturn distance(q, p0);\nfloat t = dot(q - p0, d) / dd;\nreturn distance(q, p0 + clamp(t, 0.0, 1.0) * d);\n}\nint oslEndsWith(int name1, int name2) {\nreturn int(name1 == name2);\n}\nint oslFormat(int name1, int name2) {\nreturn name2;\n}\nint oslGetAttribute(int name, out int value) {\nvalue = 0;\nreturn 0;\n}\nint oslGetAttribute(int name, out float value) {\nvalue = 0.0;\nreturn 0;\n}\nint oslGetAttribute(int name, out vec3 vec) {\nvec = vec3(0.0, 0.0, 0.0);\nreturn 0;\n}\nvoid oslGetTextureInfo(int filename, int name, out int value) {\nvalue = 4;\n}\nvoid oslGetTextureInfo(int filename, int name, out int value[2]) {\nvalue[0] = 1024;\nvalue[1] = 1024;\n}\nvec3 oslHSV(float h, float s, float v) {\nvec4 outCol;\nhsvToRGB(vec4(h, s, v, 1.0), outCol);\nreturn outCol.rgb;\n}\nfloat oslHypot(float x, float y) {\nreturn sqrt(x*x + y*y);\n}\nfloat oslHypot(float x, float y, float z) {\nreturn sqrt(x*x + y*y + z*z);\n}\nfloat oslLog2(float x, float y) {\nreturn log(x) / log(y);\n}\nfloat oslLuminance(vec3 color) {\nreturn (abs(color.r) * 0.263 + abs(color.g) * 0.655 + abs(color.b) * 0.082);\n}\nfloat oslNoise(int type, vec3 vec, float phase) {\nfloat n = snoise(vec4(vec, phase));\nif (type == OSL_UPERLIN)\nn = n * 0.5 + 0.5;\nreturn n;\n}\nfloat oslNoise(int type, float value, float phase) {\nreturn oslNoise(type, vec3(value), phase);\n}\nfloat oslNoise(int type, vec3 vec) {\nreturn oslNoise(type, vec, 0.0);\n}\nfloat oslNoise(int type, float value) {\nreturn oslNoise(type, vec3(value), 0.0);\n}\nvec3 oslNoise3D(int type, vec3 vec, float phase) {\nfloat x = snoise(vec4(vec, phase));\nfloat y = snoise(vec4(vec.y, vec.x, vec.z, phase));\nfloat z = snoise(vec4(vec.y, vec.z, vec.x, phase));\nvec3 n = vec3(x, y, z);\nif (type == OSL_UPERLIN)\nn = n * 0.5 + 0.5;\nreturn n;\n}\nvec3 oslNoise3D(int type, float value, float phase) {\nreturn oslNoise3D(type, vec3(value), phase);\n}\nvec3 oslNoise3D(int type, vec3 vec) {\nreturn oslNoise3D(type, vec, 0.0);\n}\nvec3 oslNoise3D(int type, float value) {\nreturn oslNoise3D(type, vec3(value), 0.0);\n}\nfloat oslPow(float a, float b) {\nreturn pow(a, b);\n}\nvec3 oslPow(vec3 a, float b) {\nreturn pow(a, vec3(b));\n}\nint oslRayType(int name) {\nif (name == OSL_CAMERA)\n#if LIGHT_PATH_IS_CAM_RAY\nreturn 1;\n#else\nreturn 0;\n#endif\nelse\nreturn 0;\n}\nvec3 oslRotate(vec3 vec, float angle, vec3 p0, vec3 p1) {\nvec3 axis = normalize(p1 - p0);\nfloat c = cos(angle);\nfloat s = sin(angle);\nfloat x = axis[0];\nfloat y = axis[1];\nfloat z = axis[2];\nmat4 mat = mat4(\nx * x + (1.0 - x * x) * c, x * y * (1.0 - c) + z * s, x * z * (1.0 - c) - y * s, 0.0,\nx * y * (1.0 - c) - z * s, y * y + (1.0 - y * y) * c, y * z * (1.0 - c) + x * s, 0.0,\nx * z * (1.0 - c) + y * s, y * z * (1.0 - c) - x * s, z * z + (1.0 - z * z) * c, 0.0,\n0.0, 0.0, 0.0, 1.0\n);\nreturn (mat * vec4((vec - p0), 1.0) + vec4(p0, 1.0)).xyz;\n}\nvec3 oslRotate(vec3 vec, float angle, vec3 axis) {\nreturn oslRotate(vec, angle, vec3(0.0), axis);\n}\nint oslStartsWith(int name1, int name2) {\nreturn int(name1 == name2);\n}\nint oslStrLen(int name) {\nif (name == OSL_EMPTY)\nreturn 0;\nelse\nreturn 1;\n}\nint oslSubStr(int s, int start, int len) {\nreturn s;\n}\nint oslSubStr(int s, int start) {\nreturn s;\n}\nvec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode, int alphaFlag, out float alpha) {\nif (wrapMode == OSL_DEFAULT || wrapMode == OSL_BLACK) {\nif (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)\nreturn vec3(0.0);\n} else if (wrapMode == OSL_CLAMP) {\nu = clamp(u, 0.0, 1.0);\nv = clamp(v, 0.0, 1.0);\n} else if (wrapMode == OSL_PERIODIC) {\nu = mod(u, 1.0);\nv = mod(v, 1.0);\n} else if (wrapMode == OSL_MIRROR) {\nif (mod(floor(u), 2.0) == 0.0)\nu = u - floor(u);\nelse\nu = 1.0 - (u - floor(u));\nif (mod(floor(v), 2.0) == 0.0)\nv = v - floor(v);\nelse\nv = 1.0 - (v - floor(v));\n}\nvec4 colAlpha = texture2D(image, vec2(u, v));\nalpha = colAlpha.a;\nreturn colAlpha.rgb;\n}\nvec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha, int wrapModeFlag, int wrapMode) {\nreturn oslTexture(image, u, v, wrapModeFlag, wrapMode, alphaFlag, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v, int alphaFlag, out float alpha) {\nreturn oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, alphaFlag, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v, int wrapModeFlag, int wrapMode) {\nfloat alpha;\nreturn oslTexture(image, u, v, wrapModeFlag, wrapMode, OSL_ALPHA, alpha);\n}\nvec3 oslTexture(sampler2D image, float u, float v) {\nfloat alpha;\nreturn oslTexture(image, u, v, OSL_WRAP, OSL_DEFAULT, OSL_ALPHA, alpha);\n}\nvec3 oslTransform(int fromSpace, int toSpace, vec4 vec) {\nif (toSpace == OSL_WORLD || toSpace == OSL_SHADER || toSpace == OSL_COMMON) {\nreturn vec.xyz;\n} else if (toSpace == OSL_OBJECT) {\nvec = vec4(swizzleUpY(vec.xyz), vec.w);\nvec = invModelMatrix * vec;\nreturn swizzleUpZ(vec.xyz);\n} else if (toSpace == OSL_CAMERA) {\nvec = vec4(swizzleUpY(vec.xyz), vec.w);\nreturn (viewMatrix * vec).xyz;\n} else if (toSpace == OSL_SCREEN) {\nreturn vec.xyz;\n} else if (toSpace == OSL_RASTER) {\nreturn gl_FragCoord.xyz;\n} else if (toSpace == OSL_NDC) {\nreturn vec.xyz;\n} else {\nreturn vec.xyz;\n}\n}\nvec3 oslTransform(int fromSpace, int toSpace, vec3 vec) {\nreturn oslTransform(fromSpace, toSpace, vec4(vec, 1.0));\n}\nvec3 oslTransform(int toSpace, vec3 vec) {\nreturn oslTransform(OSL_COMMON, toSpace, vec4(vec, 1.0));\n}\nvec3 oslTransformDir(int fromSpace, int toSpace, vec3 vec) {\nreturn oslTransform(fromSpace, toSpace, vec4(vec, 0.0));\n}\nvec3 oslTransformDir(int toSpace, vec3 vec) {\nreturn oslTransform(OSL_COMMON, toSpace, vec4(vec, 0.0));\n}\nvec3 oslTransformC(int fromSpace, int toSpace, vec3 vec) {\nvec4 outVec = vec4(vec, 1.0);\nif (fromSpace == OSL_HSV && toSpace == OSL_RGB)\nhsvToRGB(vec4(vec, 1.0), outVec);\nelse if (fromSpace == OSL_RGB && toSpace == OSL_HSV)\nrgbToHSV(vec4(vec, 1.0), outVec);\nreturn outVec.rgb;\n}\nvec3 oslTransformC(int toSpace, vec3 vec) {\nreturn oslTransformC(OSL_RGB, toSpace, vec);\n}\nvoid oslError() {}\nvoid oslFPrintf() {}\nvoid oslPrintf() {}\nvoid oslWarning() {}\nvec3 oslWaveLengthColor(float lambdaNM) {\n#if __VERSION__ == 300\nvec3 xyz = vec3(0.0);\nfloat ii = (lambdaNM - 380.0) / 5.0;\nint i = int(ii);\nif (i < 0 || i >= 80)\nreturn xyz;\nii -= float(i);\nvec3 c1 = cieColorMatch[i];\nvec3 c2 = cieColorMatch[i+1];\nxyz = mix(c1, c2, ii);\nreturn xyz_to_sRGB(xyz);\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif",
            node_incident_frag: "void node_incident(vec3 viewPos, out vec3 incident)\n{\n\nvec4 viewDir = vec4(normalize(viewPos), 0.0);\nincident = -swizzleUpZ(viewDir.xyz);\n}",
            node_normal_frag: "void node_normal(vec3 norParam, out vec3 norOut)\n{\n#ifdef MT_BLENDER\n#if WORLD_NODES == 1\nvec4 viewDir = isOrtho(projectionMatrix) ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-vViewPosition), 0.0);\nviewDir = invViewMatrix * viewDir;\nnorOut = -swizzleUpZ(viewDir.xyz);\n#else\nnorOut = normalize(invViewMatrix * vec4(norParam, 0.0)).xyz;\nnorOut = swizzleUpZ(norOut);\n#endif\n#else\nnorOut = norParam;\n#endif\n}",
            node_position_frag: "void node_position(vec3 posParam, out vec3 posOut)\n{\n#if defined(MT_BLENDER) || defined(MT_MAX)\nposOut = swizzleUpZ(-posParam);\n#else\nposOut = -posParam;\n#endif\n}",
            node_rgb_alpha_frag: "\nuniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb_alpha(vec4 color, out vec3 outColor, out float outAlpha)\n{\noutColor = color.rgb;\noutAlpha = color.a;\n}",
            node_value_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_u_float_frag: "void node_u_float(vec2 inUv, out float u)\n{\nu = inUv.x;\n}",
            node_add_shader_bl_frag: "void node_add_shader(vec4 color1, vec4 color2, out vec4 outColor) {\noutColor.rgb = color1.rgb + color2.rgb;\noutColor.a = clamp(color1.a + color2.a, 0.0, 1.0);\n}",
            node_ambient_occlusion_bl_frag: "void node_ambient_occlusion(vec4 color, float distance, vec3 normal,\nout vec4 outColor, out float outAO) {\noutColor = color;\noutAO = 1.0;\n}",
            node_attribute_bl_frag: "void node_attribute(\nvec4 paramAttr,\nout vec4 outColor, out vec3 outVector, out float outFac,\nout float outAlpha) {\noutColor = vec4(paramAttr.xyz, 1.0);\noutVector = paramAttr.xyz;\noutFac = average(paramAttr.xyz);\noutAlpha = paramAttr.w;\n}\nvoid node_attribute(\nvec4 paramAttr,\nout vec4 outColor, out vec3 outVector, out float outFac) {\nfloat outAlpha;\nnode_attribute(paramAttr, outColor, outVector, outFac, outAlpha);\n}",
            node_background_bl_frag: "void node_background(vec4 color, float strength, out vec4 outColor)\n{\noutColor = strength * color;\n}",
            node_bevel_bl_frag: "void node_bevel(float radius, vec3 normal, out vec3 outNormal) {\noutNormal = normal;\n}",
            node_blackbody_bl_frag: "void node_blackbody(float temp, out vec4 outColor)\n{\noutColor = sRGBToLinear(vec4(colorTempToRGB(temp), 1.0));\n}",
            node_brightcontrast_bl_frag: "\nvoid node_brightcontrast(vec4 color, float bright, float contrast, out vec4 outColor)\n{\nfloat bminc = bright - contrast * 0.5;\noutColor.r = max((1.0 + contrast) * color.r + bminc, 0.0);\noutColor.g = max((1.0 + contrast) * color.g + bminc, 0.0);\noutColor.b = max((1.0 + contrast) * color.b + bminc, 0.0);\noutColor.a = color.a;\n}",
            node_bsdf_anisotropic_bl_frag: "void node_bsdf_anisotropic(\nvec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,\nout vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_diffuse_bl_frag: "\nvoid node_bsdf_diffuse(\nvec3 geometryNormal,\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}",
            node_bsdf_glass_bl_frag: "void node_bsdf_glass(\nvec3 geometryNormal,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = normalize(normal);\nnormal = swizzleUpY(normal);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\nmaterial.refractionColor = vec3(1.0);\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0),\nvec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectSpecular\n#undef RE_IndirectSpecular\n#undef RE_Refraction\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\nvec3 viewWorld;\nif (isPerspective(projectionMatrix))\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\noutColor = vec4(color.rgb * mix(refractedLight, reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular, fresnel), 1.0);\n}",
            node_bsdf_glossy_bl_frag: "\nvoid node_bsdf_glossy(\nvec3 geometryNormal,\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = normalize((viewMatrix * vec4(normal.xyz, 0.0)).xyz);\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectSpecular\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\noutColor = vec4(color.rgb * (reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular), 1.0);\n}",
            node_bsdf_hair_bl_frag: "void node_bsdf_hair(vec4 color, float offset, float roughnessU, float roughnessV, vec3 tangent, out vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_principled_bl_frag: "\nvec3 tintFromColor(vec3 color) {\n\tfloat lum = dot(color, vec3(0.3, 0.6, 0.1));\n\treturn lum > 0.0 ? color / lum : vec3(1.0);\n}\nvec3 fresnelBlend(float ior, float fresnel, vec3 fresnelColor) {\nfloat fresnelFac = fresnelReflection(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), ior);\n\tfloat mixFac = saturate((fresnel - fresnelFac) / max(1e-8, 1.0 - fresnelFac));\n\treturn mix(fresnelColor, vec3(1.0), mixFac);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,\nfloat metallic, float specular, float specularTint, float roughness,\nfloat anisotropic, float anisotropicRotation, float sheen, float sheenTint,\nfloat clearcoat, float clearcoatRoughness, float ior,\nfloat transmission, float transmissionRoughness, vec4 emission,\nfloat emissionStrength, float alpha, vec3 normal, vec3 clearcoatNormal,\nvec3 tangent,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat dielectric = 1.0 - metallic;\ntransmission *= dielectric;\nmaterial.diffuseColor = baseColor.rgb * dielectric;\n#ifndef CLEARCOAT\nfloat dielReflCoeff = BLENDER_SPECULAR_COEFFICIENT;\n#else\nfloat dielReflCoeff = MAXIMUM_SPECULAR_COEFFICIENT;\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = sheen * mix(vec3(0.1), baseColor.rgb, sheenTint);\nmaterial.sheenRoughness = 0.1;\n#endif\nvec3 dielRefl = dielReflCoeff * specular\n* mix(vec3(1.0), tintFromColor(baseColor.rgb), specularTint);\nmaterial.specularColor = mix(dielRefl, baseColor.rgb, metallic);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\nvec3 viewWorld;\nif (isPerspective(projectionMatrix))\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\nvec3 fresnelColor = mix(vec3(1.0), baseColor.rgb, specularTint);\nmaterial.specularColor = mix(material.specularColor,\nfresnelBlend(ior, fresnel, fresnelColor) * fresnel, transmission);\nfloat isStrictDielectric = step(0.0, -length(vec4(subsurface, clearcoat,\ntransmission, float(metallic == 1.0))));\nmaterial.fresnelRefl90 = mix(vec3(1.0), material.specularColor,\n(1.0 - specular) * metallic * (1.0 - isStrictDielectric));\nmaterial.refractionColor = baseColor.rgb;\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular\n+ refractedLight * transmission * (1.0 - fresnel)\n+ emission.rgb * emissionStrength;\noutColor = vec4(outColor3, alpha);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,\nfloat metallic, float specular, float specularTint, float roughness,\nfloat anisotropic, float anisotropicRotation, float sheen, float sheenTint,\nfloat clearcoat, float clearcoatRoughness, float ior,\nfloat transmission, float transmissionRoughness, vec4 emission, float alpha,\nvec3 normal, vec3 clearcoatNormal, vec3 tangent,\nout vec4 outColor) {\nnode_bsdf_principled(geometryNormal, baseColor, subsurface, subsurfaceRadius,\nsubsurfaceColor, metallic, specular, specularTint, roughness,\nanisotropic, anisotropicRotation, sheen, sheenTint, clearcoat,\nclearcoatRoughness, ior, transmission, transmissionRoughness,\nemission, 1.0, alpha, normal, clearcoatNormal, tangent, outColor);\n}",
            node_bsdf_refraction_bl_frag: "#define BSDF_REFRACTION_GGX 0\n#define BSDF_REFRACTION_BECKMANN 1\n#define BSDF_REFRACTION_SHARP 2\nvoid node_bsdf_refraction(\nvec3 geometryNormal, const int distribution,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = swizzleUpY(normal);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.refractionColor = color.rgb;\nmaterial.refractionIOR = ior;\nif (distribution == BSDF_REFRACTION_SHARP) {\nmaterial.refractionRoughness = 0.0;\n} else {\nmaterial.refractionRoughness = pow2(roughness);\n}\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_Refraction\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\noutColor = vec4(refractedLight, 1.0);\n}",
            node_bsdf_toon_bl_frag: "void node_bsdf_toon(\nvec4 color, float size, float smoothFac, vec3 normal,\nout vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_translucent_bl_frag: "void node_bsdf_translucent(vec4 color, vec3 normal, out vec4 outColor) {\nnormal = -vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}",
            node_bsdf_transparent_bl_frag: "\nvoid node_bsdf_transparent(vec4 color, out vec4 outColor)\n{\nfloat alpha = saturate(1.0 - dot(color.rgb, vec3(0.333333)));\noutColor = vec4(0.0, 0.0, 0.0, alpha);\n}",
            node_bsdf_velvet_bl_frag: "void node_bsdf_velvet(vec4 color, float sigma, vec3 normal, out vec4 outColor)\n{\noutColor = color;\n}",
            node_bump_bl_frag: "\nvoid node_bump(\nconst int invert,\nfloat strength, float bumpDist, float height, float height_dx,\nfloat height_dy, vec3 normal,\nout vec3 outNormal) {\nvec3 position = swizzleUpZ(vWorldPosition);\nif (invert == 1)\nbumpDist *= -1.0;\nvec3 dPdx = dFdx(position);\nvec3 dPdy = dFdy(position);\nfloat dHdx = dFdx(height);\nfloat dHdy = dFdy(height);\nvec3 tanX = cross(dPdy, normal);\nvec3 tanY = cross(normal, dPdx);\nvec3 surfaceGrad = dHdx * tanX + dHdy * tanY;\nfloat dotPosTanX = dot(dPdx, tanX);\noutNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * bumpDist * sign(dotPosTanX));\noutNormal = normalize(mix(normal, outNormal, max(0.0, strength)));\n}\nvoid node_bump(\nconst int invert,\nfloat strength, float bumpDist, float height, vec3 normal,\nout vec3 outNormal) {\nnode_bump(invert, strength, bumpDist, height, 0.0, 0.0, normal, outNormal);\n}",
            node_camera_bl_frag: "\nvoid node_camera(\nvec3 viewPos, const int invCamZ,\nout vec3 outViewVector, out float outViewZDepth, out float outViewDistance)\n{\nviewPos = -viewPos;\nif (invCamZ == 1)\nviewPos.z = -viewPos.z;\noutViewVector = normalize(viewPos);\noutViewZDepth = abs(viewPos.z);\noutViewDistance = length(viewPos);\n}",
            node_clamp_bl_frag: "void node_clamp(float value, float minVal, float maxVal, out float result) {\nresult = max(min(value, maxVal), minVal);\n}",
            node_combhsv_bl_frag: "\nvoid node_combhsv(float h, float s, float v, out vec4 col)\n{\nhsvToRGB(vec4(h, s, v, 1.0), col);\n}",
            node_combrgb_bl_frag: "\nvoid node_combrgb(float r, float g, float b, out vec4 col)\n{\ncol = vec4(r, g, b, 1.0);\n}",
            node_combxyz_bl_frag: "void node_combxyz(float x, float y, float z, out vec3 outVector)\n{\noutVector = vec3(x, y, z);\n}",
            node_curve_rgb_bl_frag: "\nvoid node_curve_rgb(sampler2D curveData, float fac, vec4 col, out vec4 outCol)\n{\noutCol.r = texture2D(curveData, vec2(texture2D(curveData, vec2(col.r, 0.0)).a, 0.0)).r;\noutCol.g = texture2D(curveData, vec2(texture2D(curveData, vec2(col.g, 0.0)).a, 0.0)).g;\noutCol.b = texture2D(curveData, vec2(texture2D(curveData, vec2(col.b, 0.0)).a, 0.0)).b;\noutCol = mix(col, outCol, fac);\noutCol.a = col.a;\n}",
            node_curve_vec_bl_frag: "\nvoid node_curve_vec(sampler2D curveData, float fac, vec3 vec, out vec3 outVec)\n{\noutVec.x = texture2D(curveData, vec2((vec.x + 1.0) * 0.5, 0.0)).x;\noutVec.y = texture2D(curveData, vec2((vec.y + 1.0) * 0.5, 0.0)).y;\noutVec.z = texture2D(curveData, vec2((vec.z + 1.0) * 0.5, 0.0)).z;\noutVec = mix(vec, outVec * 2.0 - vec3(1.0), fac);\n}",
            node_displacement_bl_frag: "void node_displacement(float height, float midlevel, float scale, vec3 normal, out vec3 outDisplacement) {\noutDisplacement = vec3(0.0);\n}",
            node_eevee_specular_bl_frag: "void node_eevee_specular(\nvec3 geometryNormal,\nvec4 baseColor, vec4 specular, float roughness, vec4 emissiveColor,\nfloat transparency, vec3 normal, float clearcoat, float clearcoatRoughness, \nvec3 clearcoatNormal, float ambientOcclusion,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = baseColor.rgb;\nmaterial.specularColor = specular.rgb;\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\n#ifdef CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\n#endif\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\n#ifdef CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular) * ambientOcclusion\n+ emissiveColor.rgb;\noutColor = vec4(outColor3, 1.0 - transparency);\n}",
            node_emission_bl_frag: "\nvoid node_emission(vec4 color, float strength, out vec4 outColor)\n{\noutColor = vec4(strength * color.rgb, 1.0);\n}",
            node_fresnel_bl_frag: "void node_fresnel(vec3 viewPos, float IOR, vec3 normal, out float fac)\n{\nvec3 worldDir;\nif (isPerspective(projectionMatrix))\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\n}",
            node_gamma_bl_frag: "\nvoid node_gamma(vec4 col, float gamma, out vec4 outCol)\n{\noutCol = col;\nif (col.r > 0.0)\noutCol.r = powCompat(col.r, gamma);\nif (col.g > 0.0)\noutCol.g = powCompat(col.g, gamma);\nif (col.b > 0.0)\noutCol.b = powCompat(col.b, gamma);\n}",
            node_hair_info_bl_frag: "void node_hair_info(out float isStrand, out float intercept, out float thickness,\nout vec3 tangentNormal, out float random) {\nisStrand = 0.0;\nintercept = 0.0;\nthickness = 0.0;\ntangentNormal = vec3(0.0);\nrandom = 0.0;\n}",
            node_holdout_bl_frag: "void node_holdout(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_hue_sat_bl_frag: "\nvoid node_hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outCol)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nhsv[0] += (fract(hue) - 0.5);\nif (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;\nhsv[1] *= sat;\nif (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;\nhsv[2] *= value;\nhsvToRGB(hsv, outCol);\noutCol = mix(col, outCol, fac);\n}",
            node_invert_bl_frag: "\nvoid node_invert(float fac, vec4 col, out vec4 outCol)\n{\noutCol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\noutCol.w = col.w;\n}",
            node_layer_weight_bl_frag: "\nvoid node_layer_weight(vec3 viewPos, float blend, vec3 normal, out float fresnel, out float facing)\n{\nvec3 worldDir;\nif (isPerspective(projectionMatrix))\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(1.0 - blend, EPSILON);\nfresnel = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? 1.0 / eta : eta);\nfacing = abs(dot(worldDir, normal));\nif (blend != 0.5) {\nblend = clamp(blend, 0.0, 1.0 - EPSILON);\nblend = (blend < 0.5) ? blend * 2.0 : 0.5 / (1.0 - blend);\nfacing = pow(facing, blend);\n}\nfacing = 1.0 - facing;\n}",
            node_light_falloff_bl_frag: "void node_light_falloff(\nfloat strength, float inSmooth,\nout float quadratic, out float linear, out float constant)\n{\nquadratic = 1.0;\nlinear = 1.0;\nconstant = 1.0;\n}",
            node_light_path_bl_frag: "void node_light_path(\nout float isCameraRay, out float isShadowRay, out float isDiffuseRay, \nout float isGlossyRay, out float isSingularRay, out float isReflectionRay,\nout float isTransmissionRay, out float rayLength, out float rayDepth, \nout float diffuseDepth, out float glossyDepth, out float transparentDepth, \nout float transmissionDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay = 1.0;\n#else\nisCameraRay = 0.0;\n#endif\nisShadowRay = 0.0;\nisDiffuseRay = 0.0;\nisGlossyRay = 0.0;\nisSingularRay = 0.0;\nisReflectionRay = 0.0;\nisTransmissionRay = 0.0;\nrayLength = 1.0;\nrayDepth = 1.0;\ndiffuseDepth = 1.0;\nglossyDepth = 1.0;\ntransparentDepth = 1.0; \ntransmissionDepth = 1.0;\n}",
            node_mapping_bl_frag: "\nvoid node_mapping(mat4 mat, vec3 minVec, vec3 maxVec, int useMin, int useMax, vec3 vec, out vec3 outVec)\n{\noutVec = (mat * vec4(vec, 1.0)).xyz;\nif (useMin == 1)\noutVec = max(outVec, minVec);\nif (useMax == 1)\noutVec = min(outVec, maxVec);\n}\nmat3 rotationMatrix(float angleX, float angleY, float angleZ) {\nfloat cx = cos(angleX);\nfloat sx = sin(angleX);\nfloat cy = cos(angleY);\nfloat sy = sin(angleY);\nfloat cz = cos(angleZ);\nfloat sz = sin(angleZ);\nmat3 mat;\nmat[0][0] = cy * cz;\nmat[0][1] = cy * sz;\nmat[0][2] = -sy;\nmat[1][0] = sy * sx * cz - cx * sz;\nmat[1][1] = sy * sx * sz + cx * cz;\nmat[1][2] = cy * sx;\nmat[2][0] = sy * cx * cz + sx * sz;\nmat[2][1] = sy * cx * sz - sx * cz;\nmat[2][2] = cy * cx;\nreturn mat;\n}\n#define NODE_MAPPING_POINT 1\n#define NODE_MAPPING_TEXTURE 2\n#define NODE_MAPPING_VECTOR 3\n#define NODE_MAPPING_NORMAL 4\nvoid node_mapping(int type, vec3 vec, vec3 loc, vec3 rot, vec3 scale, out vec3 outVec)\n{\nif (type == NODE_MAPPING_POINT)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale) + loc;\nelse if (type == NODE_MAPPING_TEXTURE)\noutVec = transposeMat3(rotationMatrix(rot.x, rot.y, rot.z)) * (vec - loc) / scale;\nelse if (type == NODE_MAPPING_VECTOR)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale);\nelse {\nmat3 rot = rotationMatrix(rot.x, rot.y, rot.z) * mat3(\nscale[0], 0.0, 0.0,\n0.0, scale[1], 0.0,\n0.0, 0.0, scale[2]\n);\noutVec = normalize(mat3GetInverseTransposed(rot) * vec);\n}\n}",
            node_map_range_bl_frag: "#define NODE_MAP_RANGE_INTERP_LINEAR           0\n#define NODE_MAP_RANGE_INTERP_STEPPED_LINEAR   1\n#define NODE_MAP_RANGE_INTERP_SMOOTHSTEP       2\n#define NODE_MAP_RANGE_INTERP_SMOOTHERSTEP     3\nvoid node_map_range(const int interpolation, int inClamp, float value, float fromMin, float fromMax,\nfloat toMin, float toMax, float steps, out float result) {\nif (fromMax == fromMin) {\nresult = 0.0;\n} else {\nresult = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;\n}\nif (inClamp == 1) {\nresult = clamp(result, toMin, toMax);\n}\n}\nvoid node_map_range(const int interpolation, int inClamp, float value,\nfloat fromMin, float fromMax, float toMin, float toMax, out float result) {\nnode_map_range(NODE_MAP_RANGE_INTERP_LINEAR, inClamp, value, fromMin,\nfromMax, toMin, toMax, 0.0, result);\n}",
            node_math_bl_frag: "\nvoid node_math_add(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 + val2;\n}\nvoid node_math_subtract(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 - val2;\n}\nvoid node_math_multiply(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 * val2;\n}\nvoid node_math_divide(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = val1 / val2;\n}\nvoid node_math_sine(float val, float val2, float val3, out float outVal)\n{\noutVal = sin(val);\n}\nvoid node_math_cosine(float val, float val2, float val3, out float outVal)\n{\noutVal = cos(val);\n}\nvoid node_math_tangent(float val, float val2, float val3, out float outVal)\n{\noutVal = tan(val);\n}\nvoid node_math_arcsine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = asin(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arccosine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = acos(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arctangent(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val);\n}\nvoid node_math_arctan2(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val, val2);\n}\nvoid node_math_power(float val1, float val2, float val3, out float outVal)\n{\nif (val1 >= 0.0)\noutVal = powCompat(val1, val2);\nelse {\nfloat val2_mod_1 = mod(abs(val2), 1.0);\nif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\noutVal = powCompat(val1, floor(val2 + 0.5));\nelse\noutVal = 0.0;\n}\n}\nvoid node_math_logarithm(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > 0.0  && val2 > 0.0)\noutVal = log2(val1) / log2(val2);\nelse\noutVal = 0.0;\n}\nvoid node_math_sqrt(float val1, float val2, float val3, out float outVal)\n{\noutVal = sqrt(val1);\n}\nvoid node_math_maximum(float val1, float val2, float val3, out float outVal)\n{\noutVal = max(val1, val2);\n}\nvoid node_math_minimum(float val1, float val2, float val3, out float outVal)\n{\noutVal = min(val1, val2);\n}\nvoid node_math_round(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1 + 0.5);\n}\nvoid node_math_floor(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1);\n}\nvoid node_math_ceil(float val1, float val2, float val3, out float outVal)\n{\noutVal = ceil(val1);\n}\nvoid node_math_fract(float val1, float val2, float val3, out float outVal)\n{\noutVal = fract(val1);\n}\nvoid node_math_less_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 < val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_greater_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_modulo(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = mod(val1, val2);\noutVal = (val1 > 0.0) ? outVal : outVal - val2;\n}\nvoid node_math_absolute(float val1, float val2, float val3, out float outVal)\n{\noutVal = abs(val1);\n}\nvoid node_math_compare(float val1, float val2, float val3, out float outVal) {\noutVal = step(abs(val1 - val2), val3);\n}\nvoid node_math_cosh(float val1, float val2, float val3, out float outVal) {\noutVal = cosh(val1);\n}\nvoid node_math_degrees(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / PI * 180.0;\n}\nvoid node_math_exponent(float val1, float val2, float val3, out float outVal) {\noutVal = exp(val1);\n}\nvoid node_math_inverse_sqrt(float val1, float val2, float val3, out float outVal) {\nif (val1 >= 0.0) {\noutVal = 1.0 / sqrt(val1);\n} else {\noutVal = 0.0;\n}\n}\nvoid node_math_multiply_add(float val1, float val2, float val3, out float outVal) {\noutVal = val1 * val2 + val3;\n}\nvoid node_math_pingpong(float val1, float val2, float val3, out float outVal) {\nif (val2 == 0.0) {\noutVal = 0.0;\n} else {\nfloat absVal2 = abs(val2);\nfloat rem = mod(val1, absVal2);\noutVal = mix(rem, absVal2 - rem, mod(floor(val1 / absVal2), 2.0));\n}\n}\nvoid node_math_radians(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / 180.0 * PI;\n}\nvoid node_math_sign(float val1, float val2, float val3, out float outVal) {\noutVal = sign(val1);\n}\nvoid node_math_sinh(float val1, float val2, float val3, out float outVal) {\noutVal = sinh(val1);\n}\nvoid node_math_smooth_max(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMax(val1, val2, val3);\n}\nvoid node_math_smooth_min(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMin(val1, val2, val3);\n}\nvoid node_math_snap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5 * sign(val2);\nfloat quot = val1 / val2;\noutVal = floor(quot) * val2;\n}\nvoid node_math_tanh(float val1, float val2, float val3, out float outVal) {\noutVal = tanh(val1);\n}\nvoid node_math_trunc(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = trunc(val1);\n}\nvoid node_math_wrap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = mod(val1 - val3, val2 - val3) + val3;\n}\nvoid node_math_add(float val1, float val2, out float outVal) {\nnode_math_add(val1, val2, 0.0, outVal);\n}\nvoid node_math_subtract(float val1, float val2, out float outVal) {\nnode_math_subtract(val1, val2, 0.0, outVal);\n}\nvoid node_math_multiply(float val1, float val2, out float outVal) {\nnode_math_multiply(val1, val2, 0.0, outVal);\n}\nvoid node_math_divide(float val1, float val2, out float outVal) {\nnode_math_divide(val1, val2, 0.0, outVal);\n}\nvoid node_math_sine(float val1, float val2, out float outVal) {\nnode_math_sine(val1, val2, 0.0, outVal);\n}\nvoid node_math_cosine(float val1, float val2, out float outVal) {\nnode_math_cosine(val1, val2, 0.0, outVal);\n}\nvoid node_math_tangent(float val1, float val2, out float outVal) {\nnode_math_tangent(val1, val2, 0.0, outVal);\n}\nvoid node_math_arcsine(float val1, float val2, out float outVal) {\nnode_math_arcsine(val1, val2, 0.0, outVal);\n}\nvoid node_math_arccosine(float val1, float val2, out float outVal) {\nnode_math_arccosine(val1, val2, 0.0, outVal);\n}\nvoid node_math_arctangent(float val1, float val2, out float outVal) {\nnode_math_arctangent(val1, val2, 0.0, outVal);\n}\nvoid node_math_arctan2(float val1, float val2, out float outVal) {\nnode_math_arctan2(val1, val2, 0.0, outVal);\n}\nvoid node_math_power(float val1, float val2, out float outVal) {\nnode_math_power(val1, val2, 0.0, outVal);\n}\nvoid node_math_logarithm(float val1, float val2, out float outVal) {\nnode_math_logarithm(val1, val2, 0.0, outVal);\n}\nvoid node_math_sqrt(float val1, float val2, out float outVal) {\nnode_math_sqrt(val1, val2, 0.0, outVal);\n}\nvoid node_math_maximum(float val1, float val2, out float outVal) {\nnode_math_maximum(val1, val2, 0.0, outVal);\n}\nvoid node_math_minimum(float val1, float val2, out float outVal) {\nnode_math_minimum(val1, val2, 0.0, outVal);\n}\nvoid node_math_round(float val1, float val2, out float outVal) {\nnode_math_round(val1, val2, 0.0, outVal);\n}\nvoid node_math_floor(float val1, float val2, out float outVal) {\nnode_math_floor(val1, val2, 0.0, outVal);\n}\nvoid node_math_ceil(float val1, float val2, out float outVal) {\nnode_math_ceil(val1, val2, 0.0, outVal);\n}\nvoid node_math_fract(float val1, float val2, out float outVal) {\nnode_math_fract(val1, val2, 0.0, outVal);\n}\nvoid node_math_less_than(float val1, float val2, out float outVal) {\nnode_math_less_than(val1, val2, 0.0, outVal);\n}\nvoid node_math_greater_than(float val1, float val2, out float outVal) {\nnode_math_greater_than(val1, val2, 0.0, outVal);\n}\nvoid node_math_modulo(float val1, float val2, out float outVal) {\nnode_math_modulo(val1, val2, 0.0, outVal);\n}\nvoid node_math_absolute(float val1, float val2, out float outVal) {\nnode_math_absolute(val1, val2, 0.0, outVal);\n}",
            node_mix_rgb_bl_frag: "\nvoid node_mix_rgb_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 + col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 * col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (outCol.r < 0.5)\noutCol.r *= facm + 2.0 * fac * col2.r;\nelse\noutCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);\nif (outCol.g < 0.5)\noutCol.g *= facm + 2.0 * fac * col2.g;\nelse\noutCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);\nif (outCol.b < 0.5)\noutCol.b *= facm + 2.0 * fac * col2.b;\nelse\noutCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);\n}\nvoid node_mix_rgb_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 - col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;\nif (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;\nif (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;\n}\nvoid node_mix_rgb_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, abs(col1 - col2), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = min(col1.rgb, col2.rgb * fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = max(col1.rgb, col2.rgb * fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1;\nif (outCol.r != 0.0) {\nfloat tmp = 1.0 - fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 1.0;\nelse if ((tmp = outCol.r / tmp) > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\n}\nif (outCol.g != 0.0) {\nfloat tmp = 1.0 - fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 1.0;\nelse if ((tmp = outCol.g / tmp) > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\n}\nif (outCol.b != 0.0) {\nfloat tmp = 1.0 - fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 1.0;\nelse if ((tmp = outCol.b / tmp) > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n}\nvoid node_mix_rgb_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat tmp, facm = 1.0 - fac;\noutCol = col1;\ntmp = facm + fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)\noutCol.r = 0.0;\nelse if (tmp > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\ntmp = facm + fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)\noutCol.g = 0.0;\nelse if (tmp > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\ntmp = facm + fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)\noutCol.b = 0.0;\nelse if (tmp > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n#ifdef HSV_NODES\nvoid node_mix_rgb_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\nvoid node_mix_rgb_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2;\nrgbToHSV(outCol, hsv);\nif (hsv.y != 0.0) {\nrgbToHSV(col2, hsv2);\nhsv.y = facm * hsv.y + fac * hsv2.y;\nhsvToRGB(hsv, outCol);\n}\n}\nvoid node_mix_rgb_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 hsv, hsv2;\nrgbToHSV(col1, hsv);\nrgbToHSV(col2, hsv2);\nhsv.z = facm * hsv.z + fac * hsv2.z;\nhsvToRGB(hsv, outCol);\n}\nvoid node_mix_rgb_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsv.y = hsv2.y;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\n#endif\nvoid node_mix_rgb_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 one = vec4(1.0);\nvec4 scr = one - (one - col2) * (one - col1);\noutCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\nvoid node_mix_rgb_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}",
            node_mix_shader_bl_frag: "\nvoid node_mix_shader(int transpShaderNum,\nfloat fac, vec4 color1, vec4 color2, out vec4 outColor)\n{\nif (transpShaderNum == 0)\ncolor1.rgb = color2.rgb;\nelse if (transpShaderNum == 1)\ncolor2.rgb = color1.rgb;\noutColor = mix(color1, color2, fac);\n}",
            node_new_geometry_bl_frag: "void node_new_geometry(\nbool frontFacing, vec3 viewPos, vec3 viewNorm,\nout vec3 position, out vec3 normal, out vec3 tangent,\nout vec3 trueNormal, out vec3 incoming, out vec3 parametric,\nout float backfacing, out float pointiness, out float randomPerIsland)\n{\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nposition = swizzleUpZ(posWorld.xyz);\nvec4 viewDir = isOrtho(projectionMatrix) ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-viewPos), 0.0);\nviewDir = invViewMatrix * viewDir;\nvec3 incomingVec = -swizzleUpZ(viewDir.xyz);\n#if WORLD_NODES == 1\nnormal = incomingVec;\ntangent = vec3(0.0);\n#else\nvec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;\nnormal = swizzleUpZ(norWorld);\nvec4 posLocal = invModelMatrix * posWorld;\nvec3 posLocalDelta = posLocal.xyz - boundingBoxMin;\nvec3 bbDelta = boundingBoxMax - boundingBoxMin;\nvec3 posOrco = vec3(\nbbDelta.x < 1e-5 ? -sign(posLocal.y) : posLocalDelta.x / bbDelta.x,\n0.0,\nbbDelta.z < 1e-5 ? sign(posLocal.y) : posLocalDelta.z / bbDelta.z\n);\nposOrco -= 0.5;\nvec3 tangWorld = (modelMatrix * vec4(posOrco.z, 0.0, -posOrco.x, 0.0)).xyz;\ntangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));\ntangent = swizzleUpZ(tangWorld);\n#endif\ntrueNormal = normal;\nincoming = incomingVec;\nparametric = vec3(0.0);\nbackfacing = (frontFacing) ? 0.0 : 1.0;\n#if WORLD_NODES == 1\npointiness = 0.0;\n#else\npointiness = 0.5;\n#endif\nrandomPerIsland = 0.0;\n}\nvoid node_new_geometry(\nbool frontFacing, vec3 viewPos, vec3 viewNorm,\nout vec3 position, out vec3 normal, out vec3 tangent,\nout vec3 trueNormal, out vec3 incoming, out vec3 parametric,\nout float backfacing, out float pointiness) {\nfloat randomPerIsland;\nnode_new_geometry(frontFacing, viewPos, viewNorm, position, normal, tangent,\ntrueNormal, incoming, parametric, backfacing, pointiness, randomPerIsland);\n}",
            node_normal_bl_frag: "\nvoid node_normal(vec3 norParam, vec3 norIn, out vec3 norOut, out float dotOut)\n{\nnorOut = norParam;\ndotOut = dot(normalize(norIn), norParam);\n}",
            node_normal_map_bl_frag: "\nvoid node_normal_map(vec4 tangent, vec3 normal, float strength, vec4 normalColor, out vec3 normalOut)\n{\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, strength);\nnormalOut = normalize((invViewMatrix * vec4(normalOut, 0.0)).xyz);\nnormalOut = swizzleUpZ(normalOut);\n}",
            node_object_info_bl_frag: "\nvoid node_object_info(out vec3 location, out vec4 color, out float objIndex,\nout float matIndex, out float random) {\n#if WORLD_NODES == 1\nlocation = vec3(0.0);\ncolor = vec4(1.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.0;\n#else\nlocation = vec3(0.0);\ncolor = vec4(1.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.5;\n#endif\n}\nvoid node_object_info(out vec3 location, out float objIndex, out float matIndex, out float random) {\n#if WORLD_NODES == 1\nlocation = vec3(0.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.0;\n#else\nlocation = vec3(0.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.5;\n#endif\n}",
            node_output_lamp_bl_frag: "void node_output_lamp(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_output_material_bl_frag: "\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}\nvoid node_output_material(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}",
            node_output_world_bl_frag: "void node_output_world(vec4 surface, vec4 volume, out vec4 outgoingLight)\n{\noutgoingLight = surface;\n}",
            node_particle_info_bl_frag: "\nvoid node_particle_info(out float index, out float random, out float age,\nout float lifeTime, out vec3 location, out float size, out vec3 velocity,\nout vec3 angularVelocity) {\n#if WORLD_NODES == 1\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#else\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#endif\n}",
            node_principled_volume_bl_frag: "void node_principled_volume(vec4 color, float colorAttribute, float density,\nfloat densityAttribute, float anisotropy, vec4 absorptionColor,\nfloat emissionStrength, vec4 emissionColor, float blackbodyIntensity,\nvec4 blackbodyTint, float temperature, float temperatureAttribute,\nout vec4 volume) {\nvolume = vec4(0.0);\n}",
            node_rgb_bl_frag: "\nuniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_rgbtobw_bl_frag: "\nvoid node_rgbtobw(vec4 color, out float outVal) {\noutVal = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n}",
            node_script_bl_frag: "void node_script(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_sephsv_bl_frag: "\nvoid node_sephsv(vec4 col, out float h, out float s, out float v)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\n}",
            node_seprgb_bl_frag: "\nvoid node_seprgb(vec4 col, out float r, out float g, out float b)\n{\nr = col.r;\ng = col.g;\nb = col.b;\n}",
            node_sepxyz_bl_frag: "void node_sepxyz(vec3 vector, out float x, out float y, out float z)\n{\nx = vector.x;\ny = vector.y;\nz = vector.z;\n}",
            node_shadertorgb_bl_frag: "void node_shadertorgb(vec4 shader, out vec4 color, out float alpha) {\ncolor = vec4(shader.rgb, 1.0);\nalpha = shader.a;\n}",
            node_squeeze_bl_frag: "\nvoid node_squeeze(float val, float width, float center, out float outVal)\n{\noutVal = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));\n}",
            node_subsurface_scattering_bl_frag: "void node_subsurface_scattering(\nvec4 color, float scale, vec3 radius, float sharpen, float textureBlur, vec3 normal,\nout vec4 outColor)\n{\noutColor = color;\n}",
            node_tangent_bl_frag: "#define TANGENT_AXIS_X 0\n#define TANGENT_AXIS_Y 1\n#define TANGENT_AXIS_Z 2\nvoid node_tangent(int axis, vec3 viewPos, vec3 viewNorm, out vec3 outTangent) {\noutTangent = vec3(0.0);\n#if WORLD_NODES == 0\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nvec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;\nvec3 posLocal = (invModelMatrix * posWorld).xyz;\nvec3 posOrco = (posLocal - boundingBoxMin)\n/ (boundingBoxMax - boundingBoxMin) - 0.5;\nvec4 posOrcoPermuted;\nif (axis == TANGENT_AXIS_X) {\nposOrcoPermuted = vec4(0.0, -posOrco.z, posOrco.y, 0.0);\n} else if (axis == TANGENT_AXIS_Y) {\nposOrcoPermuted = vec4(-posOrco.y, posOrco.x, 0.0, 0.0);\n} else if (axis == TANGENT_AXIS_Z) {\nposOrcoPermuted = vec4(posOrco.z, 0.0, -posOrco.x, 0.0);\n}\nvec3 tangWorld = (modelMatrix * posOrcoPermuted).xyz;\ntangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));\noutTangent = swizzleUpZ(tangWorld);\n#endif\n}\nvoid node_tangent(vec4 tangent, out vec3 outTangent) {\n#if WORLD_NODES == 0\noutTangent = normalize((modelMatrix * vec4(tangent.xyz, 0.0)).xyz);\noutTangent = swizzleUpZ(outTangent);\n#endif\n}",
            node_tex_brick_bl_frag: "void node_tex_brick(\nvec3 vector, vec4 color1, vec4 color2, vec4 mortar, float scale,\nfloat mortarSize, float mortarSmooth, float bias, float brickWidth,\nfloat rowHeight,\nout vec4 outColor, out float fac)\n{\noutColor = color1;\n}",
            node_tex_checker_bl_frag: "void node_tex_checker(vec3 vector, vec4 color1, vec4 color2, float scale, \nout vec4 outColor, out float outFac)\n{\nvec3 p = vector * scale;\np = (p + 0.00001) * 0.99999;\nfloat cx = floor(p.x);\nfloat cy = floor(p.y);\nfloat cz = floor(p.z);\nfloat result = sign(mod(cx + cy + cz, 2.0));\noutFac = max(result, 0.0);\noutColor = mix(color2, color1, outFac);\n}",
            node_tex_coord_bl_frag: "uniform mat4 nodeTexCoordObjectMatrices[NODE_TEX_COORD_NUM];\nvoid node_tex_coord(\nmat4 objectMat, vec3 viewPos, vec3 viewNorm, vec2 uv,\nout vec3 outGenerated, out vec3 outNormal, out vec3 outUV, out vec3 outObject,\nout vec3 outCamera, out vec3 outWindow, out vec3 outReflection)\n{\nvec4 view = vec4(-viewPos, 1.0);\nvec4 posWorld = invViewMatrix * view;\nvec3 loc = swizzleUpZ((invModelMatrix * posWorld).xyz);\n#if WORLD_NODES == 1\nloc = normalize(loc);\n#endif\n#if WORLD_NODES == 1\noutGenerated = loc;\n#else\nvec3 boxMin = vec3(boundingBoxMin.x, -boundingBoxMax.z, boundingBoxMin.y);\nvec3 boxMax = vec3(boundingBoxMax.x, -boundingBoxMin.z, boundingBoxMax.y);\nvec3 boxSize = boxMax - boxMin;\nif (abs(boxSize.x) < 0.001) {\noutGenerated.x = 0.5;\n} else {\noutGenerated.x = (loc.x - boxMin.x) / boxSize.x;\n}\nif (abs(boxSize.y) < 0.001) {\noutGenerated.y = 0.5;\n} else {\noutGenerated.y = (loc.y - boxMin.y) / boxSize.y;\n}\nif (abs(boxSize.z) < 0.001) {\noutGenerated.z = 0.5;\n} else {\noutGenerated.z = (loc.z - boxMin.z) / boxSize.z;\n}\n#endif\n#if WORLD_NODES == 1\noutNormal = -loc;\n#else\noutNormal = normalize(invModelMatrix * invViewMatrix * vec4(viewNorm, 0.0)).rgb;\noutNormal = swizzleUpZ(outNormal);\n#endif\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n#if WORLD_NODES == 1\noutObject = loc;\n#else\noutObject = swizzleUpZ((objectMat * posWorld).xyz);\n#endif\noutCamera = vec3(view.xy, -view.z);\n#if WORLD_NODES == 1\noutWindow = vec3(0.0);\n#else\noutWindow = vec3(gl_FragCoord.xy / viewWidthHeight, 0.0);\n#endif\n#if WORLD_NODES == 1\noutReflection = -loc;\n#else\nvec4 reflection = (invViewMatrix * vec4(reflect(view.xyz, normalize(viewNorm)), 0.0));\noutReflection = normalize(swizzleUpZ(reflection.xyz));\n#endif\n}",
            node_tex_environment_bl_frag: "#define TEX_PROJ_EQUIRECTANGULAR 0\n#define TEX_PROJ_MIRROR_BALL     1\nvoid node_tex_environment(sampler2D tex, const int encoding, const int projection, vec3 vector, out vec4 outColor) {\nvec2 uv;\nfloat bias;\nif (projection == TEX_PROJ_EQUIRECTANGULAR) {\nvec3 direction = swizzleUpY(vector);\nif (length(direction) == 0.0) {\ndirection = vec3(0.0, 1.0, 0.0);\n} else {\ndirection = normalize(direction);\n}\nuv.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nuv.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\n#if WORLD_NODES == 1\nbias = -16.0;\n#else\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (direction.z) / seamWidth) *\nclamp (1.0 - direction.x / seamWidth, 0.0, 1.0);\nbias = seamBiasFactor * seam;\n#endif\n} else {\nvec3 normal = normalize(vector);\nnormal.y -= 1.0;\nnormal /= (2.0 * sqrt(max(-0.5 * normal.y, 0.0)));\nuv = clamp(0.5 * normal.xz + 0.5, 0.0, 1.0);\nbias = 0.0;\n}\nuv.y = 1.0 - uv.y;\noutColor = texture2D(tex, uv, bias);\noutColor = nodeTexelToLinear(outColor, encoding);\n}",
            node_tex_environment_none_bl_frag: "void node_tex_environment_none(vec3 vector, out vec4 outColor) {\noutColor = vec4(1.0, 0.0, 1.0, 1.0);\n}",
            node_tex_gradient_bl_frag: "#define TEX_GRAD_LINEAR           0\n#define TEX_GRAD_QUADRATIC        1\n#define TEX_GRAD_EASING           2\n#define TEX_GRAD_DIAGONAL         3\n#define TEX_GRAD_SPHERICAL        4\n#define TEX_GRAD_QUADRATIC_SPHERE 5\n#define TEX_GRAD_RADIAL           6\nvoid node_tex_gradient(const int type, vec3 vector, out vec4 outColor, out float outFac)\n{\nfloat x, y, z, r;\nx = vector.x;\ny = vector.y;\nz = vector.z;\nif (type == TEX_GRAD_LINEAR) {\noutFac = x;\n} else if (type == TEX_GRAD_QUADRATIC) {\nr = max(x, 0.0);\noutFac = pow2(r);\n} else if (type == TEX_GRAD_EASING) {\nr = min(max(x, 0.0), 1.0);\noutFac = (3.0 * pow2(r) - 2.0 * pow3(r));\n} else if (type == TEX_GRAD_DIAGONAL) {\noutFac = (x + y) * 0.5;\n} else if (type == TEX_GRAD_RADIAL) {\noutFac = atan(y, x) / PI2 + 0.5;\n} else {\nr = max(0.99999 - sqrt(x * x + y * y + z * z), 0.0);\nif (type == TEX_GRAD_QUADRATIC_SPHERE) {\noutFac = pow2(r);\n} else if (type == TEX_GRAD_SPHERICAL) {\noutFac = r;\n}\n}\noutFac = clamp(outFac, 0.0, 1.0);\noutColor = vec4(outFac, outFac, outFac, 1.0);\n}",
            node_tex_ies_bl_frag: "void node_tex_ies(vec3 vector, float strength, out float fac) {\nfac = 0.0;\n}",
            node_tex_image_bl_frag: "#define TEX_PROJ_FLAT   0\n#define TEX_PROJ_BOX    1\n#define TEX_PROJ_SPHERE 2\n#define TEX_PROJ_TUBE   3\nvoid node_tex_image(sampler2D ima, const int encoding, vec3 viewNorm,\nconst int projection, const float projectionBlend, const bool clampToEdgeNoExtend,\nvec3 vector,\nout vec4 outColor, out float outAlpha) {\nif (projection == TEX_PROJ_FLAT) {\nvec2 uv = vector.xy;\nuv.y = 1.0 - uv.y;\nif (clampToEdgeNoExtend && (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)) {\noutColor = vec4(0.0);\noutAlpha = 0.0;\n} else {\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\n}\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_BOX) {\nvec3 norm = normalize(viewNorm * normalMatrix);\nvector = swizzleUpY(vector);\nvec2 uvX = vec2(-sign(norm.x) * vector.z, -vector.y);\nvec2 uvY = vec2(sign(norm.y) * vector.z, -vector.x);\nvec2 uvZ = vec2(sign(norm.z) * vector.x, -vector.y);\nvec4 colX = nodeTexelToLinear(texture2D(ima, uvX), encoding);\nvec4 colY = nodeTexelToLinear(texture2D(ima, uvY), encoding);\nvec4 colZ = nodeTexelToLinear(texture2D(ima, uvZ), encoding);\nvec3 barycentric = abs(norm);\nbarycentric /= barycentric.x + barycentric.y + barycentric.z;\nvec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),\n(projectionBlend - 1.0) / (projectionBlend - 3.0));\nvec3 edgeValue = (1.0 - projectionBlend) * (1.0 - edgeShape) / 2.0;\nvec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), 0.0);\nweight /= (weight.x + weight.y + weight.z);\noutColor = weight.x * colX + weight.y * colY + weight.z * colZ;\noutAlpha = outColor.a;\n} else if (projection == TEX_PROJ_SPHERE) {\nvector = normalize(vector * 2.0 - 1.0);\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, acos(vector.y) / PI);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_TUBE) {\nvector = vector * 2.0 - 1.0;\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, (1.0 - vector.y) / 2.0);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n}\n}",
            node_tex_image_none_bl_frag: "void node_tex_image_none(vec3 vector, out vec4 color, out float alpha)\n{\ncolor = vec4(1.0, 0.0, 1.0, 1.0);\nalpha = 1.0;\n}",
            node_tex_magic_bl_frag: "void node_tex_magic(vec3 vector, float scale, float distortion,\nout vec4 outColor, out float outFac)\n{\noutColor = vec4(0.0);\noutFac = 0.0;\n}",
            node_tex_musgrave_bl_frag: "void node_tex_musgrave(vec3 vector, float w, float scale, float detail,\nfloat dimension, float lacunarity, float offset, float gain,\nout float outFac) {\noutFac = 0.0;\n}\nvoid node_tex_musgrave(\nvec3 vector, float scale, float detail, float dimension, float lacunarity,\nfloat offset, float gain,\nout vec4 outColor, out float outFac)\n{\noutColor = vec4(0.0);\noutFac = 0.0;\n}",
            node_tex_noise_bl_frag: "\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float roughness,\nfloat distortion, out float outFac, out vec4 outColor) {\nvec3 p = vector * scale;\nvec3 dx = dFdx(p);\nvec3 dy = dFdy(p);\nfloat octaveLenPerPixel = (length(dx) + length(dy)) / 4.0;\nif (distortion != 0.0) {\nvec3 r, offset = vec3(13.5, 13.5, 13.5);\nr.x = noiseSmooth(p + offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.y = noiseSmooth(p, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.z = noiseSmooth(p - offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\np += r;\n}\noutFac = noiseTurbulence(p, detail, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nvec3 color = vec3(outFac,\nnoiseTurbulence(vec3(p.y, p.x, p.z), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor),\nnoiseTurbulence(vec3(p.y, p.z, p.x), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor)\n);\noutColor = vec4(color, 1.0);\n}\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float distortion,\nout float outFac, out vec4 outColor) {\nnode_tex_noise(falloffFactor, dispersionFactor, vector, w, scale, detail,\n0.5, distortion, outFac, outColor);\n}\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float scale, float detail, float distortion,\nout vec4 outColor, out float outFac) {\nnode_tex_noise(falloffFactor, dispersionFactor, vector, 0.0, scale, detail,\ndistortion, outFac, outColor);\n}",
            node_tex_pointdensity_bl_frag: "void node_tex_pointdensity(\nvec3 vector,\nout vec4 outColor, out float outDensity)\n{\noutColor = vec4(0.0);\noutDensity = 0.0;\n}",
            node_tex_sky_bl_frag: "\n#define TEX_SKY_PREETHAM 0\n#define TEX_SKY_HOSEK_WILKIE 1\n#define TEX_SKY_NISHITA 2\n#define Km 683.0\nvoid node_tex_sky(const int skyType, vec3 param0, vec3 param1, vec3 param2,\nvec3 param3, vec3 param4, vec3 param5, vec3 param6, vec3 param7,\nvec3 param8, vec3 radiance, vec3 sunDirection, vec3 vectorIn,\nout vec4 outColor) {\nif (length(vectorIn) == 0.0) {\nvectorIn = vec3(0.0, 1.0, 0.0);\n} else {\nvectorIn = normalize(vectorIn);\n}\nvectorIn = swizzleUpY(vectorIn);\nsunDirection = swizzleUpY(sunDirection);\nfloat cosGamma = clamp(dot(vectorIn, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(vectorIn.y, 0.0, 1.0);\nif (skyType == TEX_SKY_PREETHAM) {\nvec3 radInternal = (1.0 + param0 * exp(param1 / cosTheta)) * (\n1.0 + param2 * exp(param3 * acos(cosGamma))\n+ param4 * pow(cosGamma, 2.0)\n);\nvec3 XYZ = xyY_to_XYZ(radInternal.y * radiance.y,\nradInternal.z * radiance.z, radInternal.x * radiance.x);\noutColor = vec4(max(xyz_to_sRGB(XYZ), 0.0), 1.0);\n} else if (skyType == TEX_SKY_HOSEK_WILKIE) {\nfloat cosGammaSq = pow(cosGamma, 2.0);\nvec3 chi = (1.0 + cosGammaSq) / pow(1.0 + pow(param8, vec3(2.0))\n- 2.0 * param8 * cosGamma, vec3(1.5));\nvec3 radInternal = (1.0 + param0 * exp(param1 / (cosTheta + 0.01))) * (\nparam2 + param3 * exp(param4 * acos(cosGamma))\n+ param5 * cosGammaSq + param6 * chi + param7 * sqrt(cosTheta)\n);\noutColor = vec4(max(xyz_to_sRGB(radInternal * radiance), 0.0) * PI2/Km, 1.0);\n} else {\noutColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}",
            node_tex_voronoi_bl_frag: "#define DISTANCE_EUCLIDEAN 0\n#define DISTANCE_MANHATTAN 1\n#define DISTANCE_CHEBYCHEV 2\n#define DISTANCE_MINKOWSKI 3\n#define FEATURE_F1                  0\n#define FEATURE_F2                  1\n#define FEATURE_SMOOTH_F1           2\n#define FEATURE_DISTANCE_TO_EDGE    3\n#define FEATURE_N_SPHERE_RADIUS     4\nstruct VoronoiGridData {\nvec3 point;\nvec3 randVec;\nvec3 toClosest;\nfloat dist;\n};\nfloat worleyLength(vec3 vec, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn length(vec);\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(vec.x) + abs(vec.y) + abs(vec.z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nreturn pow(pow(abs(vec.x), exponent)\n+ pow(abs(vec.y), exponent)\n+ pow(abs(vec.z), exponent), 1.0 / exponent);\n}\nreturn 0.0;\n}\nvoid worleyNoise(vec3 pos, int distance, float exponent, int feature,\nfloat smoothness, float randomness, out float outDist, out vec4 outColor,\nout vec3 outPosition, out float outW, out float outRadius) {\nconst highp float RAND_FIX_ZERO = 0.125;\nvec3 posI = floor(pos);\nvec3 posF = fract(pos);\nVoronoiGridData vgd[27];\n#pragma unroll_loop_start\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop_start\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop_start\nfor (int k = 0; k <= 2; k++) {\nvec3 point = vec3((i), (j), (k)) - 1.0;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\nconst int counter = (i) + (j) * 3 + (k) * 9;\nvgd[counter].point = point;\nvgd[counter].randVec = randVec;\nvgd[counter].toClosest = toClosest;\nvgd[counter].dist = worleyLength(toClosest, distance, exponent);\n}\n#pragma unroll_loop_end\n}\n#pragma unroll_loop_end\n}\n#pragma unroll_loop_end\nfloat f1 = 1e10;\nfloat f2 = 1e10;\nvec3 edgeToClosest = vec3(0.0);\nfloat distToEdge = 1e10;\nvec3 randColF1 = vec3(0.0);\nvec3 randColF2 = vec3(0.0);\nvec3 toClosestF1 = vec3(0.0);\nvec3 toClosestF2 = vec3(0.0);\nvec3 radPoint = vec3(0.0);\nvec3 radToClosest = vec3(0.0);\n#pragma unroll_loop_start\nfor (int i = 0; i < 27; i++) {\nif (feature == FEATURE_F1) {\nif (vgd[i].dist < f1) {\nf1 = vgd[i].dist;\nrandColF1 = vgd[i].randVec;\ntoClosestF1 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_F2) {\nif (vgd[i].dist < f1) {\nf2 = f1;\nf1 = vgd[i].dist;\nrandColF2 = randColF1;\nrandColF1 = vgd[i].randVec;\ntoClosestF2 = toClosestF1;\ntoClosestF1 = vgd[i].toClosest;\n} else if (vgd[i].dist < f2) {\nf2 = vgd[i].dist;\nrandColF2 = vgd[i].randVec;\ntoClosestF2 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_SMOOTH_F1) {\nf1 = smoothMin(f1, vgd[i].dist, smoothness);\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nedgeToClosest = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nradPoint = vgd[i].point;\nradToClosest = vgd[i].toClosest;\n}\n}\n}\n#pragma unroll_loop_end\nif (feature == FEATURE_F1) {\noutDist = f1;\noutColor = vec4(randColF1, 1.0);\noutPosition = pos + toClosestF1;\n} else if (feature == FEATURE_F2) {\noutDist = f2;\noutColor = vec4(randColF2, 1.0);\noutPosition = pos + toClosestF2;\n} else if (feature == FEATURE_SMOOTH_F1) {\noutDist = f1;\nvec3 avgCol = vec3(0.0);\nvec3 avgOff = vec3(0.0);\nfloat sumWeightsCol = 0.0;\nfloat sumWeightsOff = 0.0;\n#pragma unroll_loop_start\nfor (int i = 0; i < 27; i++) {\nfloat smoothFac = getSmoothFactor(f1, vgd[i].dist, smoothness);\nfloat weightOff = smoothFac * smoothFac * smoothFac;\nfloat weightCol = weightOff * smoothFac;\navgCol += vgd[i].randVec * weightCol;\navgOff += vgd[i].toClosest * weightOff;\nsumWeightsCol += weightCol;\nsumWeightsOff += weightOff;\n}\n#pragma unroll_loop_end\noutColor = vec4(avgCol / sumWeightsCol, 1.0);\noutPosition = pos + avgOff / sumWeightsOff;\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\n#pragma unroll_loop_start\nfor (int i = 0; i < 27; i++) {\nif (vgd[i].toClosest != edgeToClosest) {\nfloat dist = dot(0.5 * (edgeToClosest + vgd[i].toClosest),\nnormalize(vgd[i].toClosest - edgeToClosest));\ndistToEdge = min(distToEdge, dist);\n}\n}\n#pragma unroll_loop_end\noutDist = distToEdge;\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat diam = 1e10;\n#pragma unroll_loop_start\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop_start\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop_start\nfor (int k = 0; k <= 2; k++) {\nvec3 localPoint = vec3((i), (j), (k)) - 1.0;\nif (length(localPoint) > 0.0) {\nvec3 point = localPoint + radPoint;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\ndiam = min(diam, length(toClosest - radToClosest));\n}\n}\n#pragma unroll_loop_end\n}\n#pragma unroll_loop_end\n}\n#pragma unroll_loop_end\noutRadius = diam / 2.0;\n}\n}\n#define VORONOI_SMOOTH_COEFF 0.74\nvoid node_tex_voronoi(\nint distance, int feature,\nvec3 vector, float w, float scale, float smoothness, float exponent,\nfloat randomness,\nout float outDistance, out vec4 outColor, out vec3 outPosition,\nout float outW, out float outRadius) {\nvector = scale * (vector - 0.0001);\nsmoothness = clamp(smoothness, 1e-3, 1.0);\nsmoothness *= VORONOI_SMOOTH_COEFF;\nworleyNoise(vector, distance, exponent, feature, smoothness, randomness,\noutDistance, outColor, outPosition, outW, outRadius);\noutPosition /= scale;\n}\n#define DISTANCE_DISTANCE DISTANCE_EUCLIDEAN\n#define FEATURE_F3   5\n#define FEATURE_F4   6\n#define FEATURE_F2F1 7\n#define COLORING_INTENSITY 0\n#define COLORING_CELLS     1\nstruct VoronoiClosest {\nvec4 closestDists;\nvec4 closestInds;\n};\nvoid updateVoronoiClosest(inout VoronoiClosest vf, vec3 newDistances,\nvec3 newIndices) {\n#pragma unroll_loop_start\nfor (int i = 0; i < 3; i++) {\nfloat currDist = newDistances[i];\nfloat currIdx = newIndices[i];\n#pragma unroll_loop_start\nfor (int j = 0; j < 4; j++) {\nif (currDist < vf.closestDists[j]) {\nfloat tmp = vf.closestDists[j];\nvf.closestDists[j] = currDist;\ncurrDist = tmp;\ntmp = vf.closestInds[j];\nvf.closestInds[j] = currIdx;\ncurrIdx = tmp;\n}\n}\n#pragma unroll_loop_end\n}\n#pragma unroll_loop_end\n}\nvec3 worleyPermute(vec3 x) {\nreturn mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 worleyDist(vec3 x, vec3 y, vec3 z, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn x * x + y * y + z * z;\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(x) + abs(y) + abs(z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(x), abs(y)), abs(z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nvec3 expVec = vec3(exponent);\nreturn pow(pow(abs(x), expVec)\n+ pow(abs(y), expVec)\n+ pow(abs(z), expVec), 1.0 / expVec);\n}\nreturn vec3(0.0);\n}\nVoronoiClosest worleyClosest(vec3 P, float jitter, int distance, float exponent) {\nfloat K = 0.142857142857;\nfloat Ko = 0.428571428571;\nfloat  K2 = 0.020408163265306;\nfloat Kz = 0.166666666667;\nfloat Kzo = 0.416666666667;\nvec3 Pi = mod(floor(P), 289.0);\nvec3 Pf = fract(P) - 0.5;\nvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\nvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\nvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\nvec3 p = worleyPermute(Pi.x + vec3(-1.0, 0.0, 1.0));\nvec3 p1 = worleyPermute(p + Pi.y - 1.0);\nvec3 p2 = worleyPermute(p + Pi.y);\nvec3 p3 = worleyPermute(p + Pi.y + 1.0);\nvec3 p11 = worleyPermute(p1 + Pi.z - 1.0);\nvec3 p12 = worleyPermute(p1 + Pi.z);\nvec3 p13 = worleyPermute(p1 + Pi.z + 1.0);\nvec3 p21 = worleyPermute(p2 + Pi.z - 1.0);\nvec3 p22 = worleyPermute(p2 + Pi.z);\nvec3 p23 = worleyPermute(p2 + Pi.z + 1.0);\nvec3 p31 = worleyPermute(p3 + Pi.z - 1.0);\nvec3 p32 = worleyPermute(p3 + Pi.z);\nvec3 p33 = worleyPermute(p3 + Pi.z + 1.0);\nvec3 ox11 = fract(p11*K) - Ko;\nvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\nvec3 oz11 = floor(p11*K2)*Kz - Kzo;\nvec3 ox12 = fract(p12*K) - Ko;\nvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\nvec3 oz12 = floor(p12*K2)*Kz - Kzo;\nvec3 ox13 = fract(p13*K) - Ko;\nvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\nvec3 oz13 = floor(p13*K2)*Kz - Kzo;\nvec3 ox21 = fract(p21*K) - Ko;\nvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\nvec3 oz21 = floor(p21*K2)*Kz - Kzo;\nvec3 ox22 = fract(p22*K) - Ko;\nvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\nvec3 oz22 = floor(p22*K2)*Kz - Kzo;\nvec3 ox23 = fract(p23*K) - Ko;\nvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\nvec3 oz23 = floor(p23*K2)*Kz - Kzo;\nvec3 ox31 = fract(p31*K) - Ko;\nvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\nvec3 oz31 = floor(p31*K2)*Kz - Kzo;\nvec3 ox32 = fract(p32*K) - Ko;\nvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\nvec3 oz32 = floor(p32*K2)*Kz - Kzo;\nvec3 ox33 = fract(p33*K) - Ko;\nvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\nvec3 oz33 = floor(p33*K2)*Kz - Kzo;\nvec3 dx11 = Pfx + jitter*ox11;\nvec3 dy11 = Pfy.x + jitter*oy11;\nvec3 dz11 = Pfz.x + jitter*oz11;\nvec3 dx12 = Pfx + jitter*ox12;\nvec3 dy12 = Pfy.x + jitter*oy12;\nvec3 dz12 = Pfz.y + jitter*oz12;\nvec3 dx13 = Pfx + jitter*ox13;\nvec3 dy13 = Pfy.x + jitter*oy13;\nvec3 dz13 = Pfz.z + jitter*oz13;\nvec3 dx21 = Pfx + jitter*ox21;\nvec3 dy21 = Pfy.y + jitter*oy21;\nvec3 dz21 = Pfz.x + jitter*oz21;\nvec3 dx22 = Pfx + jitter*ox22;\nvec3 dy22 = Pfy.y + jitter*oy22;\nvec3 dz22 = Pfz.y + jitter*oz22;\nvec3 dx23 = Pfx + jitter*ox23;\nvec3 dy23 = Pfy.y + jitter*oy23;\nvec3 dz23 = Pfz.z + jitter*oz23;\nvec3 dx31 = Pfx + jitter*ox31;\nvec3 dy31 = Pfy.z + jitter*oy31;\nvec3 dz31 = Pfz.x + jitter*oz31;\nvec3 dx32 = Pfx + jitter*ox32;\nvec3 dy32 = Pfy.z + jitter*oy32;\nvec3 dz32 = Pfz.y + jitter*oz32;\nvec3 dx33 = Pfx + jitter*ox33;\nvec3 dy33 = Pfy.z + jitter*oy33;\nvec3 dz33 = Pfz.z + jitter*oz33;\nvec3 d11 = worleyDist(dx11, dy11, dz11, distance, exponent);\nvec3 d12 = worleyDist(dx12, dy12, dz12, distance, exponent);\nvec3 d13 = worleyDist(dx13, dy13, dz13, distance, exponent);\nvec3 d21 = worleyDist(dx21, dy21, dz21, distance, exponent);\nvec3 d22 = worleyDist(dx22, dy22, dz22, distance, exponent);\nvec3 d23 = worleyDist(dx23, dy23, dz23, distance, exponent);\nvec3 d31 = worleyDist(dx31, dy31, dz31, distance, exponent);\nvec3 d32 = worleyDist(dx32, dy32, dz32, distance, exponent);\nvec3 d33 = worleyDist(dx33, dy33, dz33, distance, exponent);\nVoronoiClosest vf = VoronoiClosest(vec4(1e10), vec4(0.0));\nupdateVoronoiClosest(vf, d11, p11);\nupdateVoronoiClosest(vf, d12, p12);\nupdateVoronoiClosest(vf, d13, p13);\nupdateVoronoiClosest(vf, d21, p21);\nupdateVoronoiClosest(vf, d22, p22);\nupdateVoronoiClosest(vf, d23, p23);\nupdateVoronoiClosest(vf, d31, p31);\nupdateVoronoiClosest(vf, d32, p32);\nupdateVoronoiClosest(vf, d33, p33);\nreturn vf;\n}\nvoid node_tex_voronoi(int coloring, int distance, int feature, vec3 vector,\nfloat scale, float exponent, out vec4 outColor, out float outFac) {\nvector = scale * (vector - 0.0001);\nVoronoiClosest vf = worleyClosest(vector, 1.0, distance, exponent);\nvec4 vorColorData;\nif (coloring == COLORING_INTENSITY) {\nvorColorData = vf.closestDists;\n} else if (coloring == COLORING_CELLS) {\nvorColorData = vf.closestInds;\n}\nfloat vorColorFac;\nif (feature == FEATURE_F1) {\nvorColorFac = vorColorData.x;\n} else if (feature == FEATURE_F2) {\nvorColorFac = vorColorData.y;\n} else if (feature == FEATURE_F3) {\nvorColorFac = vorColorData.z;\n} else if (feature == FEATURE_F4) {\nvorColorFac = vorColorData.w;\n} else if (feature == FEATURE_F2F1) {\nvorColorFac = vorColorData.y - vorColorData.x;\n}\nif (coloring == COLORING_INTENSITY) {\noutFac = vorColorFac;\noutColor = vec4(vec3(outFac), 1.0);\n} else if (coloring == COLORING_CELLS) {\nvorColorFac += 1e-3;\nfloat r = rand(vec2(vorColorFac / 289.0));\nfloat g = rand(vec2(vorColorFac / 23535.0));\nfloat b = rand(vec2(vorColorFac / 4353.0));\noutFac = (r + g + b) / 3.0;\noutColor = vec4(r, g, b, 1.0);\n}\n}",
            node_tex_wave_bl_frag: "#define TEX_WAVE_TYPE_BANDS 0\n#define TEX_WAVE_TYPE_RINGS 1\n#define TEX_WAVE_PROFILE_SIN 0\n#define TEX_WAVE_PROFILE_SAW 1\n#define TEX_WAVE_PROFILE_TRI 2\n#define TEX_WAVE_BANDS_DIR_X        0\n#define TEX_WAVE_BANDS_DIR_Y        1\n#define TEX_WAVE_BANDS_DIR_Z        2\n#define TEX_WAVE_BANDS_DIR_DIAGONAL 3\n#define TEX_WAVE_RINGS_DIR_X         0\n#define TEX_WAVE_RINGS_DIR_Y         1\n#define TEX_WAVE_RINGS_DIR_Z         2\n#define TEX_WAVE_RINGS_DIR_SPHERICAL 3\nvoid node_tex_wave(\nint waveType, int waveProfile, int bandsDirection, int ringsDirection,\nvec3 vector, float scale, float distortion, float detail, float detailScale,\nfloat detailRoughness, float phaseOffset,\nout vec4 outColor, out float outFac) {\nvec3 coScaled = vector * scale;\nfloat waveFac;\nvec3 waveVec = coScaled;\nif (waveType == TEX_WAVE_TYPE_BANDS) {\nconst float BANDS_AXIS_SCALE = 2.0 / 3.0;\nif (bandsDirection == TEX_WAVE_BANDS_DIR_X) {\nwaveVec = waveVec.xxx * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Y) {\nwaveVec = waveVec.yyy * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Z) {\nwaveVec = waveVec.zzz * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_DIAGONAL) {\n}\nwaveFac = (waveVec.x + waveVec.y + waveVec.z) * 10.0;\n} else {\nif (ringsDirection == TEX_WAVE_RINGS_DIR_X) {\nwaveVec.x = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Y) {\nwaveVec.y = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Z) {\nwaveVec.z = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_SPHERICAL) {\n}\nwaveFac = length(waveVec) * 20.0;\n}\nif (distortion != 0.0) {\nwaveFac += distortion * noiseTurbulence(coScaled * detailScale, detail,\n0.0, 0.0, 1.0);\n}\nif (waveProfile == TEX_WAVE_PROFILE_SIN) {\nwaveFac = 0.5 + 0.5 * sin(waveFac - PI_HALF + phaseOffset);\n} else if (waveProfile == TEX_WAVE_PROFILE_SAW) {\nwaveFac = fract((waveFac + phaseOffset + 1e-4) / PI2);\n} else if (waveProfile == TEX_WAVE_PROFILE_TRI) {\nwaveFac = abs(2.0 * fract((waveFac + PI + phaseOffset) / PI2) - 1.0);\n}\noutColor = vec4(waveFac, waveFac, waveFac, 1.0);\noutFac = waveFac;\n}\nvoid node_tex_wave(int waveType, int waveProfile, int bandsDirection,\nint ringsDirection, vec3 vector, float scale, float distortion,\nfloat detail, float detailScale, out vec4 outColor, out float outFac) {\nfloat legacyOffset = 0.0;\nif (waveProfile == TEX_WAVE_PROFILE_SIN) {\nlegacyOffset = PI_HALF;\n}\nnode_tex_wave(waveType, waveProfile, bandsDirection, ringsDirection, vector,\nscale, distortion, detail, detailScale, 0.5, legacyOffset, outColor,\noutFac);\n}",
            node_tex_white_noise_bl_frag: "void node_tex_white_noise(vec3 vector, float w, out float outValue,\nout vec4 outColor) {\noutValue = 0.0;\noutColor = vec4(0.0);\n}\nvoid node_tex_white_noise(vec3 vector, float w, out float outValue) {\noutValue = 0.0;\n}",
            node_uvmap_bl_frag: "void node_uvmap(vec2 uv, out vec3 outUV) {\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n}",
            node_valtorgb_bl_frag: "\nvoid node_valtorgb(sampler2D colormap, float fac, out vec4 colOut, out float alphaOut)\n{\ncolOut = texture2D(colormap, vec2(fac, 0.0));\nalphaOut = colOut.a;\n}",
            node_value_bl_frag: "\nuniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_vect_math_bl_frag: "void node_vect_math_add(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 + v2;\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 - v2;\n}\nvoid node_vect_math_multiply(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = v1 * v2;\n}\nvoid node_vect_math_divide(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : v1.x / v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : v1.y / v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : v1.z / v2.z;\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = cross(v1, v2);\n}\nvoid node_vect_math_project(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nfloat d = dot(v2, v2);\noutVec = (d != 0.0) ? (dot(v1, v2) / d) * v2 : vec3(0.0);\n}\nvoid node_vect_math_reflect(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nif (v2 != vec3(0.0)) {\nv2 = normalize(v2);\n}\noutVec = reflect(v1, v2);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVal = dot(v1, v2);\n}\nvoid node_vect_math_distance(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = distance(v1, v2);\n}\nvoid node_vect_math_length(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = length(v1);\n}\nvoid node_vect_math_scale(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 * val;\n}\nvoid node_vect_math_normalize(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\nif (v1 != vec3(0.0)) {\nv1 = normalize(v1);\n}\noutVec = v1;\n}\nvoid node_vect_math_snap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : floor(v1.x / v2.x) * v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : floor(v1.y / v2.y) * v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : floor(v1.z / v2.z) * v2.z;\n}\nvoid node_vect_math_floor(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = floor(v1);\n}\nvoid node_vect_math_ceil(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = ceil(v1);\n}\nvoid node_vect_math_modulo(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nvec3 signProduct = sign(v1) * sign(v2);\nv1 += 1e-5 * signProduct;\noutVec.x = signProduct.x > 0.0 ? mod(v1.x, abs(v2.x)) : 0.0;\noutVec.y = signProduct.y > 0.0 ? mod(v1.y, abs(v2.y)) : 0.0;\noutVec.z = signProduct.z > 0.0 ? mod(v1.z, abs(v2.z)) : 0.0;\n}\nvoid node_vect_math_fraction(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = fract(v1);\n}\nvoid node_vect_math_absolute(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = abs(v1);\n}\nvoid node_vect_math_minimum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = min(v1, v2);\n}\nvoid node_vect_math_maximum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = max(v1, v2);\n}\nvoid node_vect_math_cosine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = cos(v1);\n}\nvoid node_vect_math_sine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = sin(v1);\n}\nvoid node_vect_math_tangent(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = tan(v1);\n}\nvoid node_vect_math_wrap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nv1 += 1e-5;\noutVec.x = v2.x == v3.x ? v2.x : mod(v1.x - v3.x, v2.x - v3.x) + v3.x;\noutVec.y = v2.y == v3.y ? v2.y : mod(v1.y - v3.y, v2.y - v3.y) + v3.y;\noutVec.z = v2.z == v3.z ? v2.z : mod(v1.z - v3.z, v2.z - v3.z) + v3.z;\n}\nvoid node_vect_math_absolute(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_absolute(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_add(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_add(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_ceil(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_ceil(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_cross_product(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_distance(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_distance(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_divide(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_divide(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_dot_product(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_floor(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_floor(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_fraction(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_fraction(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_maximum(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_maximum(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_length(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_length(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_minimum(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_minimum(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_modulo(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_modulo(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_project(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_project(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_normalize(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_normalize(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_multiply(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_multiply(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_scale(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_scale(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_reflect(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_reflect(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_subtract(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_snap(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_snap(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_add(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 + v2;\noutVal = (abs(outVec[0]) + abs(outVec[1]) + abs(outVec[2])) * RECIPROCAL_3;\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 - v2;\noutVal = (abs(outVec[0]) + abs(outVec[1]) + abs(outVec[2])) * RECIPROCAL_3;\n}\nvoid node_vect_math_average(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 + v2;\noutVal = length(outVec);\noutVec = normalize(outVec);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = vec3(0, 0, 0);\noutVal = dot(v1, v2);\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = cross(v1, v2);\noutVal = length(outVec);\noutVec /= outVal;\n}\nvoid node_vect_math_normalize(vec3 v, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVal = length(v);\noutVec = normalize(v);\n}",
            node_vect_transform_bl_frag: "\n#define VEC_TRANS_NONE     0\n#define VEC_TRANS_W_O      1\n#define VEC_TRANS_W_C      2\n#define VEC_TRANS_O_W      3\n#define VEC_TRANS_O_C      4\n#define VEC_TRANS_C_W      5\n#define VEC_TRANS_C_O      6\n#define VEC_TRANS_W_O_DIR  7\n#define VEC_TRANS_W_C_DIR  8\n#define VEC_TRANS_O_W_DIR  9\n#define VEC_TRANS_O_C_DIR 10\n#define VEC_TRANS_C_W_DIR 11\n#define VEC_TRANS_C_O_DIR 12\nvoid node_vect_transform(const int vecTransType, const int invCamZ, vec3 vIn, out vec3 vOut)\n{\nif (vecTransType == VEC_TRANS_NONE)\nvOut = vIn;\nelse {\nvec4 vec;\nif (vecTransType < VEC_TRANS_W_O_DIR)\nvec = vec4(vIn.xyz, 1.0);\nelse\nvec = vec4(vIn.xyz, 0.0);\nif (vecTransType == VEC_TRANS_W_O || vecTransType == VEC_TRANS_W_O_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = invModelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_W_C || vecTransType == VEC_TRANS_W_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = viewMatrix * vec;\nif (invCamZ == 1)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_O_W || vecTransType == VEC_TRANS_O_W_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_O_C || vecTransType == VEC_TRANS_O_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelViewMatrix * vec;\nif (invCamZ == 1)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_C_W || vecTransType == VEC_TRANS_C_W_DIR) {\nif (invCamZ == 1)\nvec[2] = -vec[2];\nvec = invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_C_O || vecTransType == VEC_TRANS_C_O_DIR) {\nif (invCamZ == 1)\nvec[2] = -vec[2];\nvec = invModelMatrix * invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n}\nvOut = vec.xyz;\n}\n}",
            node_vector_displacement_bl_frag: "void node_vector_displacement(vec4 vector, float midLevel, float scale,\nout vec3 displacement) {\ndisplacement = vec3(0.0);\n}",
            node_vector_rotate_bl_frag: "void node_vector_rotate_axis_angle(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nif (length(axis) > 0.0) {\nvector -= center;\noutVector = vec3RotateAxisAngle(vector, axis, invert * angle);\noutVector += center;\n} else {\noutVector = vector;\n}\n}\nvoid node_vector_rotate_euler_xyz(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvec4 axisAngle = eulerToAxisAngle(rotation);\nvector -= center;\noutVector = vec3RotateAxisAngle(vector, axisAngle.xyz, invert * axisAngle.w);\noutVector += center;\n}\nvoid node_vector_rotate_x_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateXAngle(vector, invert * angle);\noutVector += center;\n}\nvoid node_vector_rotate_y_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateYAngle(vector, invert * angle);\noutVector += center;\n}\nvoid node_vector_rotate_z_axis(float invert, vec3 vector, vec3 center,\nvec3 axis, float angle, vec3 rotation, out vec3 outVector) {\nvector -= center;\noutVector = vec3RotateZAngle(vector, invert * angle);\noutVector += center;\n}",
            node_vertex_color_bl_frag: "void node_vertex_color(vec4 color, out vec4 outColor, out float outAlpha) {\noutColor = color;\noutAlpha = color.a;\n}",
            node_volume_absorption_bl_frag: "void node_volume_absorption(vec4 color, float density, out vec4 outColor)\n{\noutColor = color;\n}",
            node_volume_info_bl_frag: "void node_volume_info(out vec4 color, out float density, out float flame,\nout float temperature) {\ncolor = vec4(vec3(0.0), 1.0);\ndensity = 0.0;\nflame = 0.0;\ntemperature = 0.0;\n}",
            node_volume_scatter_bl_frag: "void node_volume_scatter(vec4 color, float density, float anisotropy, out vec4 outColor)\n{\noutColor = vec4(color);\n}",
            node_wavelength_bl_frag: "void node_wavelength(float wavelength, out vec4 outColor)\n{\noutColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if __VERSION__ == 300\nvec3 xyz = vec3(0.0);\nfloat ii = (wavelength - 380.0) / 5.0;\nint i = int(ii);\nif (i < 0 || i >= 80) {\nreturn;\n}\nii -= float(i);\nvec3 c1 = cieColorMatch[i];\nvec3 c2 = cieColorMatch[i+1];\nxyz = mix(c1, c2, ii);\noutColor = vec4(xyz_to_sRGB(xyz), 1.0);\n#endif\n}",
            node_wireframe_bl_frag: "void node_wireframe(float size, out float outFac)\n{\noutFac = 0.0;\n}",
            node_arnold_map_to_mtl_mx_frag: "\nvoid node_arnold_map_to_mtl(bool opaqueEnabled, vec4 color, out vec4 outColor)\n{\noutColor = vec4(color.rgb, opaqueEnabled ? color.a : 1.0);\n}",
            node_bitmap_none_mx_frag: "void node_bitmap_none(out vec4 color)\n{\ncolor = vec4(1.0);\n}",
            node_bitmap_env_mx_frag: "void node_bitmap_env(sampler2D envMap, int reflectMode, float IOR,\nconst int encoding, const int alphaAsMono, const int alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle, vec3 normal,\nout vec4 color, out float value)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec = normalize(cameraToVertex);\n#else\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\n#endif\nmat3 uvTransform = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle);\ncolor = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\nif (alphaAsMono == 1)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB == 1)\ncolor = vec4(color.a);\n}",
            node_bitmap_mx_frag: "void node_bitmap(sampler2D map, const vec2 uvIn, const int mapping, const int axis,\nconst ivec2 clampToEdgeNoExtend,\nconst int encoding, const int alphaAsMono, const int alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 color, out float value)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nvec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\ncolor = vec4(0.0, 0.0, 0.0, 1.0);\n} else {\ncolor = texture2D(map, uv);\ncolor = nodeTexelToLinear(color, encoding);\n}\nif (alphaAsMono == 1)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB == 1)\ncolor = vec4(color.a);\n}",
            node_bump_mx_frag: "void node_bump(sampler2D bumpMap, const vec3 eyePos, const vec3 normal, const vec2 uvIn,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec3 normalOut)\n{\nvec3 coordsIn;\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nvec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);\nvec2 dSTdx = dFdx(uv);\nvec2 dSTdy = dFdy(uv);\nif (any(equal(dSTdx, vec2(0.0))) || any(equal(dSTdy, vec2(0.0)))) {\nnormalOut = normal;\n} else {\nconst float bumpScale = 1.0;\nvec3 vSigmaX = vec3(dFdx(eyePos.x), dFdx(eyePos.y), dFdx(eyePos.z));\nvec3 vSigmaY = vec3(dFdy(eyePos.x), dFdy(eyePos.y), dFdy(eyePos.z));\nvec3 vN = normal;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nfloat Hll = bumpScale * texture2D(bumpMap, uv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, uv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, uv + dSTdy).x - Hll;\nvec2 dHdxy = vec2(dBx, dBy);\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nnormalOut = normalize(abs(fDet) * normal - vGrad);\n}\n}",
            node_blend_mx_frag: "void node_blend(\nconst int useCurve, const float curveLower, const float curveUpper,\nconst vec4 color1, const vec4 color2, float mask,\nout vec4 color)\n{\nif (useCurve == 1)\nmask = smoothstep(curveLower, curveUpper, mask);\nelse\nmask = clamp(mask, 0.0, 1.0);\ncolor = mix(color1, color2, mask);\n}",
            node_color_correction_mx_frag: "#define REWIRE_RED        0\n#define REWIRE_GREEN      1\n#define REWIRE_BLUE       2\n#define REWIRE_ALPHA      3\n#define REWIRE_RED_INV    4\n#define REWIRE_GREEN_INV  5\n#define REWIRE_BLUE_INV   6\n#define REWIRE_ALPHA_INV  7\n#define REWIRE_MONOCHROME 8\n#define REWIRE_ONE        9\n#define REWIRE_ZERO       10\nfloat rewireChannel(int type, vec4 color)\n{\nif (type == REWIRE_RED)\nreturn color.r;\nelse if (type == REWIRE_GREEN)\nreturn color.g;\nelse if (type == REWIRE_BLUE)\nreturn color.b;\nelse if (type == REWIRE_ALPHA)\nreturn color.a;\nelse if (type == REWIRE_RED_INV)\nreturn 1.0-color.r;\nelse if (type == REWIRE_GREEN_INV)\nreturn 1.0-color.g;\nelse if (type == REWIRE_BLUE_INV)\nreturn 1.0-color.b;\nelse if (type == REWIRE_ALPHA_INV)\nreturn 1.0-color.a;\nelse if (type == REWIRE_MONOCHROME)\nreturn average(color.rgb);\nelse if (type == REWIRE_ONE)\nreturn 1.0;\nelse\nreturn 0.0;\n}\nvoid node_color_correction(const ivec4 rewire,\nconst vec4 color, const float hueShift, const float saturation,\nconst vec4 tint, const float tintStrength,\nconst float brightness, const float contrast,\nout vec4 outColor)\n{\nif (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {\noutColor = color;\n} else {\noutColor.r = rewireChannel(rewire.x, color);\noutColor.g = rewireChannel(rewire.y, color);\noutColor.b = rewireChannel(rewire.z, color);\noutColor.a = rewireChannel(rewire.w, color);\n}\nvec4 hsv;\nrgbToHSV(outColor, hsv);\nhsv[0] += hueShift / 360.0;\nif (hsv[0] > 1.0)\nhsv[0] -= 1.0;\nelse if (hsv[0] < 0.0)\nhsv[0] += 1.0;\nhsv[1] *= (saturation / 100.0 + 1.0);\nhsv[1] = saturate(hsv[1]);\nif (tintStrength > 0.0) {\nvec4 hsvTint;\nrgbToHSV(tint, hsvTint);\nhsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;\n}\nhsvToRGB(hsv, outColor);\noutColor = (outColor - 0.5) * (contrast / 100.0 + 1.0) + 0.5 + brightness / 100.0;\noutColor = max(outColor, 0.0);\n}",
            node_color_map_mx_frag: "void node_color_map(const int reverseGamma,\nconst vec4 color, const float gamma, const float gain,\nout vec4 outColor)\n{\nfloat p = (reverseGamma == 1) ? gamma : 1.0 / gamma;\nfloat g = (reverseGamma == 1) ? (gain > EPSILON ? 1.0 / gain : 1.0) : gain;\noutColor = vec4(g * pow(abs(color.rgb), vec3(p)), color.a);\n}",
            node_composite_layer_mx_frag: "#define COMP_BLEND_NORMAL      0\n#define COMP_BLEND_AVERAGE     1\n#define COMP_BLEND_ADD         2\n#define COMP_BLEND_SUBTRACT    3\n#define COMP_BLEND_DARKEN      4\n#define COMP_BLEND_MULTIPLY    5\n#define COMP_BLEND_COLORBURN   6\n#define COMP_BLEND_LINEARBURN  7\n#define COMP_BLEND_LIGHTEN     8\n#define COMP_BLEND_SCREEN      9\n#define COMP_BLEND_COLORDODGE  10\n#define COMP_BLEND_LINEARDODGE 11\n#define COMP_BLEND_SPOT        12\n#define COMP_BLEND_SPOTBLEND   13\n#define COMP_BLEND_OVERLAY     14\n#define COMP_BLEND_SOFTLIGHT   15\n#define COMP_BLEND_HARDLIGHT   16\n#define COMP_BLEND_PINLIGHT    17\n#define COMP_BLEND_HARDMIX     18\n#define COMP_BLEND_DIFFERENCE  19\n#define COMP_BLEND_EXCLUSION   20\n#define COMP_BLEND_HUE         21\n#define COMP_BLEND_SATURATION  22\n#define COMP_BLEND_COLOR       23\n#define COMP_BLEND_VALUE       24\nvec4 calcBlending(const vec4 colorBG, const vec4 colorFG, const int blendMode) {\nif (blendMode == COMP_BLEND_NORMAL)\nreturn colorFG;\nelse if (blendMode == COMP_BLEND_AVERAGE)\nreturn (colorFG + colorBG) / 2.0;\nelse if (blendMode == COMP_BLEND_ADD)\nreturn colorBG + colorFG;\nelse if (blendMode == COMP_BLEND_SUBTRACT)\nreturn colorBG - colorFG;\nelse if (blendMode == COMP_BLEND_DARKEN)\nreturn min(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_MULTIPLY)\nreturn colorBG * colorFG;\nelse if (blendMode == COMP_BLEND_COLORBURN) {\nif (colorFG.r == 0.0 && colorFG.g == 0.0 && colorFG.b == 0.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn max(1.0 - (1.0 - colorBG) / colorFG, 0.0);\n} else if (blendMode == COMP_BLEND_LINEARBURN)\nreturn max(colorFG + colorBG - 1.0, 0.0);\nelse if (blendMode == COMP_BLEND_LIGHTEN)\nreturn max(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_SCREEN)\nreturn colorFG + colorBG - colorFG * colorBG;\nelse if (blendMode == COMP_BLEND_COLORDODGE) {\nif (colorFG.r == 1.0 && colorFG.g == 1.0 && colorFG.b == 1.0)\nreturn vec4(1.0);\nelse\nreturn min(colorBG / (1.0 - colorFG), 1.0);\n} else if (blendMode == COMP_BLEND_LINEARDODGE)\nreturn min(colorFG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOT)\nreturn min(2.0 * colorFG * colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOTBLEND)\nreturn min(colorFG * colorBG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_OVERLAY) {\nif (colorBG.r <= 0.5 && colorBG.g <= 0.5 && colorBG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0 * (1.0-colorFG) * (1.0-colorBG));\n} else if (blendMode == COMP_BLEND_SOFTLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(colorBG * (colorBG + 2.0 * colorFG * (1.0 - colorBG)));\nelse\nreturn saturate(colorBG + (2.0 * colorFG - 1.0) * (sqrt(colorBG) - colorBG));\n} else if (blendMode == COMP_BLEND_HARDLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0*(1.0 - colorFG)*(1.0 - colorBG));\n} else if (blendMode == COMP_BLEND_PINLIGHT) {\nif (((colorFG.r > 0.5 && colorFG.g > 0.5 && colorFG.b > 0.5) && all(greaterThan(colorFG, colorBG))) ||\n((colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5) && all(lessThan(colorFG, colorBG))))\nreturn colorFG;\nelse\nreturn colorBG;\n} else if (blendMode == COMP_BLEND_HARDMIX) {\nif (colorFG.r + colorBG.r <= 1.0 && colorFG.g + colorBG.g <= 1.0 && colorFG.b + colorBG.b <= 1.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn vec4(1.0);\n} else if (blendMode == COMP_BLEND_DIFFERENCE)\nreturn abs(colorFG - colorBG);\nelse if (blendMode == COMP_BLEND_EXCLUSION)\nreturn colorFG + colorBG - 2.0 * colorFG * colorBG;\n}\nvec4 calcBlendingHSV(const vec4 colorBG, const vec4 colorFG, const int blendMode)\n{\nvec4 hsvBG, hsvFG;\nvec4 outColor;\nif (blendMode == COMP_BLEND_HUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvBG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_SATURATION) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_COLOR) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_VALUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvBG[1], hsvFG[2], 1.0), outColor);\n}\nreturn outColor;\n}\nvoid node_composite_layer(const int blendMode, const float opacity, \nconst vec4 colorBG, const vec4 colorFG, const vec4 mask,\nout vec4 outColor)\n{\nfloat fac = saturate(opacity * average(mask.rgb));\nif (blendMode < COMP_BLEND_HUE)\noutColor = calcBlending(colorBG, colorFG, blendMode);\nelse\noutColor = calcBlendingHSV(colorBG, colorFG, blendMode);\noutColor = mix(colorBG, outColor, fac);\n}",
            node_falloff_mx_frag: "void node_falloff(vec3 viewPos, float IOR,\nconst vec4 color1, const vec4 color2, vec3 normal, out vec4 color)\n{\nfloat fac;\n\nvec3 dir = normalize(viewPos);\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(dir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\ncolor = mix(color1, color2, fac);\n}",
            node_gradient_ramp_mx_frag: "#define GRAD_TYPE_4_CORNER  0\n#define GRAD_TYPE_BOX       1\n#define GRAD_TYPE_DIAGONAL  2\n#define GRAD_TYPE_LIGHTING  3\n#define GRAD_TYPE_LINEAR    4\n#define GRAD_TYPE_MAPPED    5\n#define GRAD_TYPE_NORMAL    6\n#define GRAD_TYPE_PONG      7\n#define GRAD_TYPE_RADIAL    8\n#define GRAD_TYPE_SPIRAL    9\n#define GRAD_TYPE_SWEEP    10\n#define GRAD_TYPE_TARTAN   11\nvoid node_gradient_ramp(\nsampler2D gradientData, int gradientType, vec2 uvIn, vec3 geometryNormal,\nvec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,\nvec4 sourceMap, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nfloat coord = uvIn.x;\nuvIn = coordsOut.xy;\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\noutCol = vec4(0.0, 0.0, 0.0, 1.0);\nreturn;\n}\nuvIn = fract(uvIn);\nif (gradientType == GRAD_TYPE_4_CORNER) {\ncoord = pow(uvIn.x, 2.0);\n} else if (gradientType == GRAD_TYPE_BOX) {\nvec2 boxUv = abs(uvIn - vec2(0.5)) * 2.0;\ncoord = max(boxUv.x, boxUv.y);\n} else if (gradientType == GRAD_TYPE_DIAGONAL) {\ncoord = abs(uvIn.x - uvIn.y) * sqrt(2.0);\n} else if (gradientType == GRAD_TYPE_LIGHTING) {\nIncidentLight directLight;\nGeometricContext geometry;\ngeometry.position = -viewPos;\nvec3 irr = vec3(0.0);\n#if (NUM_POINT_LIGHTS > 0)\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\ngetPointDirectLightIrradiance(pointLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#pragma unroll_loop_end\n#endif\n#if (NUM_SPOT_LIGHTS > 0)\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\ngetSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#pragma unroll_loop_end\n#endif\n#if (NUM_DIR_LIGHTS > 0)\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ngetDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#pragma unroll_loop_end\n#endif\n#if defined(PHYSICALLY_CORRECT_LIGHTS)\nirr /= PI;\n#endif\nvec3 ambIrr = getAmbientLightIrradiance(ambientLightColor);\n#if !defined(PHYSICALLY_CORRECT_LIGHTS)\nambIrr /= PI;\n#endif\nirr += ambIrr;\ncoord = (irr.x + irr.y + irr.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_LINEAR) {\ncoord = uvIn.x;\n} else if (gradientType == GRAD_TYPE_MAPPED) {\ncoord = (sourceMap.x + sourceMap.y + sourceMap.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_NORMAL) {\nfloat angle = acos(clamp(dot(geometryNormal, normalize(viewPos)), -1.0, 1.0));\nfloat k = 100.0;\ncoord = 1.0 - sin(pow2(k) - k * sqrt(pow2(k) - pow2(angle)));\n} else if (gradientType == GRAD_TYPE_PONG) {\nfloat y = min(uvIn.y, uvIn.x);\nfloat x = max(uvIn.y, uvIn.x);\ncoord = y / x;\n} else if (gradientType == GRAD_TYPE_RADIAL) {\ncoord = length(uvIn - vec2(0.5)) * 2.0;\n} else if (gradientType == GRAD_TYPE_SPIRAL) {\nvec2 uvSpiral = mat2(0.0, 1.0, -1.0, 0.0) * (uvIn - vec2(0.5));\ncoord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;\n} else if (gradientType == GRAD_TYPE_SWEEP) {\ncoord = atan(uvIn.x, uvIn.y) / PI_HALF;\n} else if (gradientType == GRAD_TYPE_TARTAN) {\nvec2 uvTartan = abs(uvIn - vec2(0.5));\ncoord = 1.0 - min(uvTartan.x, uvTartan.y) * 2.0;\n}\noutCol = texture2D(gradientData, vec2(coord, 0.0));\n}",
            node_map_mx_frag: "\nvoid node_map(const vec4 colorIn, out vec4 color)\n{\ncolor = colorIn;\n}",
            node_mask_mx_frag: "void node_mask(const int maskInverted, \nconst vec4 color, vec4 mask,\nout vec4 outColor)\n{\nmask = (maskInverted == 1) ? vec4(vec3(1.0) - mask.rgb, mask.a) : mask;\noutColor = color * mask;\n}",
            node_material_mx_frag: "\nvoid node_material(\nfloat reflectionRatio, const float refractionRatio,\nconst int selfIllumColorOn,\nconst vec4 ambientColor, const vec4 diffuseColor, const vec4 specularColor,\nconst float glossiness, const float specularLevel, const vec4 selfIllum,\nconst float opacity, const vec4 filterColor, const vec3 normal,\nconst vec4 reflection, const vec4 refraction, const float displacement,\nout vec4 outColor)\n{\nvec3 diffuse, specular;\nNodeMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specularColor.rgb;\nmaterial.diffuseIntensity = 1.0;\nmaterial.specularHardness = 4.0 * exp2(glossiness * 10.0);\nmaterial.specularIntensity = specularLevel;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\ndiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nif (selfIllumColorOn == 1) {\ndiffuse += selfIllum.rgb;\n} else {\ndiffuse = mix(diffuse, material.diffuseColor, selfIllum[0]);\n}\nspecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nfloat specularStrength = maxFromRGB(specular);\noutColor = vec4(saturate(diffuse + specular), 1.0);\nfloat alpha = opacity - saturate(maxFromRGB(specular)) * (opacity - 1.0);\noutColor += reflection * specularColor * reflectionRatio;\noutColor += refraction * refractionRatio;\nalpha += saturate(maxFromRGB(reflection.rgb) * maxFromRGB(specularColor.rgb)) * reflectionRatio;\nalpha += saturate(maxFromRGB(refraction.rgb)) * refractionRatio;\noutColor.a = alpha;\n}",
            node_matte_shadow_mx_frag: "void node_matte_shadow(\nvec3 normal, bool receiveShadow, float shadowBrightness, vec3 color,\nout vec4 outColor) {\nfloat shadow = 1.0;\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);\nIncidentLight directLight;\n#if NUM_POINT_LIGHTS > 0\nPointLight pointLight;\n#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\npointLight = pointLights[i];\ngetPointDirectLightIrradiance(pointLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)\npointLightShadow = pointLightShadows[i];\nshadow *= all(bvec2(directLight.visible, receiveShadow)) ?\ngetPointShadow(pointLightShadow, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\nspotLight = spotLights[i];\ngetSpotDirectLightIrradiance(spotLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow = spotLightShadows[i];\nif (all(bvec2(directLight.visible, receiveShadow))) {\nif (spotLightShadow.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n- geometry.position, 0.0)).xyz);\n#endif\nshadow *= getSpotShadow(spotLightShadow, spotShadowMap[i],\nvSpotShadowCoord[i], distWorld);\n} else if (spotLightShadow.shadow == 2) {\nshadow *= getSpotOmniShadow(spotLightShadow, spotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ndirectionalLight = directionalLights[i];\ngetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_DIR_LIGHT_SHADOWS)\ndirectionalLightShadow = directionalLightShadows[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLightShadow.position\n- directionalLight.direction * directionalLightShadow.shadowCameraNear\n- geometry.position, 0.0)).xyz);\n#endif\nshadow *= all(bvec3(directLight.visible, receiveShadow,\nvViewPosition.z < directionalLightShadow.maxDistance))\n? getDirShadow(directionalLightShadow, directionalShadowMap[i],\nvDirectionalShadowCoord[i], distWorld) : 1.0;\n#endif\n}\n#pragma unroll_loop_end\n#endif\noutColor = vec4(color, 1.0 - (shadowBrightness + (1.0 - shadowBrightness) * shadow));\n}",
            node_mix_mx_frag: "void node_mix(const vec4 color1, const vec4 color2, const float amount, out vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}",
            node_noise_mx_frag: "#define NOISE_REGULAR 0\n#define NOISE_FRACTAL 1\n#define NOISE_TURBULENCE 2\nfloat noise(vec3 vec, const int noiseType, const float size, const float thresholdLow, const float thresholdHigh, const float levels, float phase) {\nvec /= size;\nfloat n = 0.0;\nif (noiseType == NOISE_REGULAR) {\nn = (1.0 + snoise(vec4(vec, phase))) * 0.5;\n} else if (noiseType == NOISE_FRACTAL) {\nfloat l, f = 1.0;\nfor (l = levels; l >= 1.0; l-=1.0) {                \nn += snoise(vec4(vec * f, phase)) / f;\nf *= 2.0;\n}\nif (l > 0.0)                \nn += l * snoise(vec4(vec * f, phase)) / f;              \nn = 0.5 * (n + 1.0);\n} else {\nfloat l, f = 1.0;\nfloat ml = levels;\nfor (l = levels; l >= 1.0; l-=1.0, ml-=1.0) {\nn += abs(snoise(vec4(vec * f, phase))) / f;\nf *= 2.0f;\n}\nif (l > 0.0)\nn += l * abs(snoise(vec4(vec * f, phase))) / f;\n}\nreturn clamp(smoothstep(thresholdLow, thresholdHigh, n), 0.0, 1.0);\n}\nvoid node_noise(const vec2 uv, const int noiseType, const int coordType, \nconst vec3 color1, const vec3 color2, const float size,\nconst float thresholdLow, const float thresholdHigh, const float levels,\nconst float phase, const vec3 offset, const vec3 tiling, const vec3 angle,\nout vec4 color) {\nvec3 vec = (calcXYZTransform(offset, tiling, angle) * vec4(uv.x, 1.0 - uv.y, 1.0, 1.0)).xyz;\ncolor = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);\n}\nvoid node_noise(const vec3 viewPos, const int noiseType, const int coordType,\nconst vec3 color1, const vec3 color2, const float size,\nconst float thresholdLow, const float thresholdHigh, const float levels,\nconst float phase, const vec3 offset, const vec3 tiling, const vec3 angle,\nout vec4 color) {\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nvec3 vec;\nif (coordType == 0)\nvec = (invModelMatrix * posWorld).xyz;\nelse\nvec = posWorld.xyz;\nvec = (calcXYZTransform(offset, tiling, angle) * vec4(swizzleUpZ(vec), 1.0)).xyz;\ncolor = vec4(mix(color1, color2, noise(vec, noiseType, size, thresholdLow, thresholdHigh, levels, phase)), 1.0);\n}",
            node_normal_bump_mx_frag: "void node_normal_bump(const vec4 tangent, const vec3 normal, ivec2 flip,\nvec4 normalColor, vec3 additionalBump, float normalMult, float addBumpMult,\nout vec3 normalOut)\n{\nif (flip[0] == 1)\nnormalColor.x = 1.0 - normalColor.x;\nif (flip[1] == 0)\nnormalColor.y = 1.0 - normalColor.y;\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize(modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, normalMult);\nadditionalBump = mix(normal, additionalBump, addBumpMult);\nnormalOut = normalize(normalOut + additionalBump);\n}",
            node_output_map_mx_frag: "vec4 processOutputColor(vec4 color, const bool invert, const bool clampColor, const bool alphaFromRGB,\nconst float rgbLevel, const float rgbOffset, const float outputAmount)\n{\nvec3 color3 = color.rgb;\ncolor3 = clampColor ? saturate(color3) : color3;\ncolor3 = color3 * rgbLevel + vec3(rgbOffset);\ncolor3 = invert ? (vec3(1.0) - color3) : color3;\ncolor = outputAmount * vec4(color3, color.a);\ncolor.a = alphaFromRGB ? average(color.rgb) : color.a;\nreturn color;\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB,\nconst vec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\noutColor = processOutputColor(color, invert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB, sampler2D colormap,\nvec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\nfloat r = texture2D(colormap, vec2(color.r, 0.0)).r;\nfloat g = texture2D(colormap, vec2(color.g, 0.0)).g;\nfloat b = texture2D(colormap, vec2(color.b, 0.0)).b;\noutColor = processOutputColor(vec4(r, g, b, color.a),\ninvert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}",
            node_output_mx_frag: "void node_output(vec4 color, out vec4 outgoingLight)\n{\noutgoingLight = color;\n}",
            node_physical_mx_frag: "#define DEFAULT_REFLECTION_EDGE 1.0\n#define DEFAULT_REFLECTION_SLOPE 5.0\nvoid node_physical(\nvec3 geometryNormal, const float emitLuminance, const int useCustomReflCurve,\nconst float reflFacing, const float reflEdge, const float reflSlope,\nconst bool roughnessInv, const bool transRoughnessLock, const bool transRoughnessInv,\nconst bool thinWalled,\nconst float baseWeight, const vec4 baseColor, const float reflectivity,\nconst vec4 reflColor, const float roughness, const float metalness,\nconst float diffRoughness, const float anisotropy, const float anisoangle,\nconst float transparency, const vec4 transColor, const float transRoughness,\nconst float ior, const float scattering, const vec4 sssColor,\nconst float sssScale, const float emission, const vec4 emitColor,\nconst float coating, const vec4 coatColor, const float coatRoughness,\nconst vec3 normal, const vec3 clearcoatNormal, const float displacement,\nconst float cutout,\nout vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = baseWeight * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - transparency);\n#ifdef CLEARCOAT\nmaterial.clearcoat = saturate(coating);\nmaterial.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);\n#endif\nfloat facing, edge, slope;\nif (useCustomReflCurve == 1) {\nfacing = reflFacing;\nedge = reflEdge;\nslope = reflSlope;\n} else {\nfacing = pow2((1.0 - ior) / (1.0 + ior));\nedge = DEFAULT_REFLECTION_EDGE;\nslope = DEFAULT_REFLECTION_SLOPE;\n}\nfloat cosTheta = saturate(dot(normal, normalize(vViewPosition)));\nfloat fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope))\n* saturate(reflectivity + metalness);\nfloat kd = 1.0 - (metalness * (1.0 - fresnelRefl) + fresnelRefl);\nmaterial.specularColor = mix(metalness * baseColorWeighted, reflColor.rgb, fresnelRefl);\nmaterial.diffuseColor *= kd;\nmaterial.specularRoughness = clamp(roughnessInv ? (1.0 - roughness) : roughness, 0.0, 1.0);\nmaterial.refractionColor = pow(transparency * (1.0 - metalness) * transColor.rgb, vec3(2.0));\nmaterial.refractionIOR = ior;\nfloat tRough;\nif (transRoughnessLock) {\ntRough = roughnessInv ? 1.0 - roughness : roughness;\n} else {\ntRough = transRoughnessInv ? 1.0 - transRoughness : transRoughness;\n}\nmaterial.refractionRoughness = pow2(tRough);\n#if defined(ENVMAP_TYPE_CUBE) || defined(ENVMAP_TYPE_CUBE_UV)\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\nvec3 totalEmissiveRadiance = emitLuminance / LUMENS_PER_WATT * emission * emitColor.rgb;\nvec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nspecular + totalEmissiveRadiance;\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = 1.0 - saturate(transparency) + maxFromRGB(specular) * saturate(transparency);\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\n}",
            node_phy_sun_sky_env_mx_frag: "vec3 perezSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 direction)\n{\nfloat cosGamma = clamp(dot(direction, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(direction.y, 0.0, 1.0);\nvec3 radInternal = (1.0 + paramA * exp(paramB / cosTheta)) * (\n1.0 + paramC * exp(paramD * acos(cosGamma))\n+ paramE * pow(cosGamma, 2.0)\n);\nfloat ciex = radInternal.y * radiance.y;\nfloat ciey = radInternal.z * radiance.z;\nfloat cieY = clamp(radInternal.x * radiance.x, 0.0, 1000000.0);\nvec3 XYZ = xyY_to_XYZ(ciex, ciey, cieY);\nreturn max(xyz_to_sRGB(XYZ), 0.0);\n}\n#define GROUND_SKY_SAMPLES 16\nvec3 groundSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE, vec3 radiance, vec3 sunDirection, vec3 sunIlluminance)\n{\nconst int horizSamples = GROUND_SKY_SAMPLES;\nconst int vertSamples = GROUND_SKY_SAMPLES / 2;\nvec3 result = vec3(0.0);\nfor (int horizSampleIdx = 0; horizSampleIdx < horizSamples; horizSampleIdx++) {\nfloat horizSample = float(horizSampleIdx) / float(horizSamples);\nfloat horizAngle = PI2 * horizSample;\nfor (int vertSampleIdx = 0; vertSampleIdx < vertSamples; vertSampleIdx++) {\nfloat vertSample = float(vertSampleIdx) / float(vertSamples);\nfloat y = 1.0 - vertSample;\nfloat x = sqrt(1.0 - y*y) * cos(horizAngle);\nfloat z = -sqrt(1.0 - y*y) * sin(horizAngle);\nvec3 direction = vec3(x, y, z);\nvec3 sampleColor = perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, direction);\n\nresult += direction.y * sampleColor;\n}\n}\nresult /= float(horizSamples * vertSamples);\nresult += (sunIlluminance * sunDirection.y) / PI;\nreturn result;\n}\nvoid node_phy_sun_sky_env(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 sunIlluminance, vec3 sunLuminance, \nfloat globalIntensity, vec4 groundColor,\nout vec4 outColor) \n{\nvec3 dir = vWorldPosition;\nif (length(dir) == 0.0) {\ndir = vec3(0.0, 0.0, -1.0);\n} else {\ndir = normalize(dir);\n}\nif (dir.y < 0.0) {\noutColor = groundColor * vec4(groundSky(paramA, paramB, paramC, paramD, paramE, radiance, sunDirection, sunIlluminance), 1.0);\n} else {\noutColor = vec4(perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, dir), 1.0);\n}\noutColor = globalIntensity * outColor;\n}",
            node_reflect_refract_mx_frag: "void node_reflect_refract(sampler2D envMap,\nint reflectMode, const float IOR, const int encoding,\nvec3 normal, out vec4 color)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\nreflectVec = normalize(reflectVec);\ncolor = sampleEquirectangular(envMap, reflectVec, mat3(1.0), encoding);\n}",
            node_reflect_refract_color_mx_frag: "void node_reflect_refract_color(const vec4 colorIn, out vec4 color)\n{\ncolor = vec4(colorIn);\n}",
            node_rgb_multiply_mx_frag: "void node_rgb_multiply(const vec4 color1, const vec4 color2, out vec4 color)\n{\ncolor = color1 * color2;\n}",
            node_rgb_tint_mx_frag: "void node_rgb_tint(const vec4 color, const vec4 red, const vec4 green, const vec4 blue,\nout vec4 outColor)\n{\nmat3 tintMatrix = mat3(red.rgb, green.rgb, blue.rgb);\noutColor = vec4(tintMatrix * color.rgb, color.a);\n}",
            node_rgb_mx_frag: "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_shellac_mx_frag: "void node_shellac(const vec4 color1, const vec4 color2, const float amount,\nout vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}",
            node_tex_environment_mx_frag: "\nvoid node_tex_environment(sampler2D tex, const int encoding, vec3 vector, out vec4 outColor) {\n\nvec3 direction = swizzleUpY(vector);\nif (length(direction) == 0.0) {\ndirection = vec3(0.0, 1.0, 0.0);\n} else {\ndirection = normalize(direction);\n}\nvec2 uv;\nuv.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nuv.x = atan(direction.x, direction.z) * RECIPROCAL_PI2 + 0.5;\nuv.y *= -1.0;\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (direction.x) / seamWidth) *\nclamp (1.0 - direction.z / seamWidth, 0.0, 1.0);\noutColor = texture2D(tex, uv, seamBiasFactor * seam);\noutColor = nodeTexelToLinear(outColor, encoding);\n}",
            node_value_mx_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_vertex_color_mx_frag: "void node_vertex_color(vec3 color, out vec4 outColor)\n{\noutColor = vec4(color, 1.0);\n}",
            node_ai_facing_ratio_my_frag: "void node_ai_facing_ratio(\nvec3 viewNorm,\nconst float bias, const float gain, const bool invert, const bool linear,\nout float outValue)\n{\noutValue = dot(normalize(viewNorm), normalize(vViewPosition));\n}",
            node_ai_flat_my_frag: "void node_ai_flat(vec3 color, out vec3 outColor)\n{\noutColor = color;\n}",
            node_ai_mix_shader_my_frag: "void node_ai_mix_shader(const int mode, \nconst float mixAmt, const vec3 shader1, const vec3 shader2,\nout vec3 color)\n{\nif (mode == 0)\ncolor = mix(shader1, shader2, clamp(mixAmt, 0.0, 1.0));\nelse\ncolor = shader1 + shader2;\n}",
            node_ai_normal_map_my_frag: "void node_ai_normal_map(\nvec4 tangentParam,\nvec3 inputVal, vec3 normal, float strength, vec3 tangent,\nout vec3 outValue) {\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nvec3 normalTex = inputVal.xyz * 2.0 - 1.0;\nvec3 bitangent = tangentParam.w * cross(normal, tangent);\noutValue = normalize(normalTex.x * tangent + normalTex.y * bitangent + normalTex.z * normal);\noutValue = mix(normal, outValue, strength);\n}",
            node_ai_ray_switch_my_frag: "void node_ai_ray_switch(vec3 camera, vec3 diffuseReflection, vec3 diffuseTransmission,\nvec3 shadow, vec3 specularReflection, vec3 specularTransmission,\nout vec3 outColor, out float outAlpha)\n{\n#if LIGHT_PATH_IS_CAM_RAY\noutColor = camera;\n#else\noutColor = diffuseReflection;\n#endif\noutAlpha = 1.0;\n}",
            node_ai_shadow_matte_my_frag: "void node_ai_shadow_matte(\nvec3 normal,\nvec3 shadowColor, float backlighting, float shadowOpacity,\nout vec4 outColor, out float outAlpha) {\nfloat shadow = 1.0;\nbool receiveShadow = true;\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);\nIncidentLight directLight;\n#if NUM_POINT_LIGHTS > 0\nPointLight pointLight;\n#if defined(USE_SHADOWMAP) && NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\npointLight = pointLights[i];\ngetPointDirectLightIrradiance(pointLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)\npointLightShadow = pointLightShadows[i];\nshadow *= all(bvec2(directLight.visible, receiveShadow)) ?\ngetPointShadow(pointLightShadow, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP) && NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\nspotLight = spotLights[i];\ngetSpotDirectLightIrradiance(spotLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow = spotLightShadows[i];\nif (all(bvec2(directLight.visible, receiveShadow))) {\nif (spotLightShadow.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n- geometry.position, 0.0)).xyz);\n#endif\nshadow *= getSpotShadow(spotLightShadow, spotShadowMap[i],\nvSpotShadowCoord[i], distWorld);\n} else if (spotLightShadow.shadow == 2) {\nshadow *= getSpotOmniShadow(spotLightShadow, spotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP) && NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLightShadow;\n#endif\n#pragma unroll_loop_start\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ndirectionalLight = directionalLights[i];\ngetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_DIR_LIGHT_SHADOWS)\ndirectionalLightShadow = directionalLightShadows[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLightShadow.position\n- directionalLight.direction * directionalLighShadowt.shadowCameraNear\n- geometry.position, 0.0)).xyz);\n#endif\nshadow *= all(bvec3(directLight.visible, receiveShadow,\nvViewPosition.z < directionalLightShadow.maxDistance))\n? getDirShadow(directionalLightShadow, directionalShadowMap[i],\nvDirectionalShadowCoord[i], distWorld) : 1.0;\n#endif\n}\n#pragma unroll_loop_end\n#endif\noutColor = vec4(shadowColor, shadowOpacity * (1.0 - shadow));\noutAlpha = outColor.a;\n}",
            node_ai_skydome_light_my_frag: "void node_ai_skydome_light(vec3 color, float intensity,\nout vec4 outgoingLight)\n{\noutgoingLight = vec4(color * intensity, 1.0);\n}\nvoid node_ai_skydome_light(sampler2D envMap, int encoding, vec3 normal,\nfloat intensity,\nout vec4 outgoingLight)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec = normalize(cameraToVertex);\nmat3 uvTransform = mat3(1.0);\nvec4 color = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\n#if LIGHT_PATH_IS_CAM_RAY\nintensity = 1.0;\n#endif\noutgoingLight = color * intensity;\n}",
            node_anim_curve_ta_my_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_anim_curve_ta(float val, out float outVal)\n{\noutVal = val;\n}",
            node_anim_curve_tu_my_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_anim_curve_tu(float val, out float outVal)\n{\noutVal = val;\n}",
            node_blend_colors_my_frag: "void node_blend_colors(float blender, vec3 color1, vec3 color2, out vec3 outColor)\n{\nblender = clamp(blender, 0.0, 1.0);\noutColor = mix(color1, color2, 1.0 - blender);\n}\nvoid node_blend_colors(float blender, vec4 color1, vec4 color2, out vec4 outColor)\n{\nblender = clamp(blender, 0.0, 1.0);\noutColor = mix(color1, color2, 1.0 - blender);\n}",
            node_blinn_my_frag: "void node_blinn(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat eccentricity, vec3 specularColor, float specularRollOff, float translucence,\nvec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.specularRoughness = max(eccentricity, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}",
            node_bump_2d_my_frag: "void node_bump_2d(\nvec3 normal,\nfloat bumpDepth, float bumpValue,\nout vec3 outNormal) {\nvec3 position = vViewPosition;\nvec3 dPdx = dFdx(position);\nvec3 dPdy = dFdy(position);\nfloat dHdx = dFdx(bumpValue);\nfloat dHdy = dFdy(bumpValue);\nvec3 tanX = cross(dPdy, normal);\nvec3 tanY = cross(normal, dPdx);\nvec3 surfaceGrad = dHdx * tanX + dHdy * tanY;\nfloat dotPosTanX = dot(dPdx, tanX);\noutNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * sign(dotPosTanX));\noutNormal = normalize(mix(normal, outNormal, max(0.0, bumpDepth)));\n}\nvoid node_bump_2d(\nvec3 normal, vec4 tangent,\nfloat bumpDepth, vec3 bumpValue,\nout vec3 outNormal) {\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nvec3 normalTex = (bumpValue.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\noutNormal = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\noutNormal = mix(normal, outNormal, bumpDepth);\n}",
            node_channels_my_frag: "void node_channels(\nint channelR, int channelG, int channelB, int channelA,\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutAlpha = 1.0;\noutColor = vec3(1.0);\nif (channelR == 0)\noutColor.r = inColor.r;\nelse if (channelR == 1)\noutColor.r = inColor.g;\nelse if (channelR == 2)\noutColor.r = inColor.b;\nelse\noutColor.r = inAlpha;\nif (channelG == 0)\noutColor.g = inColor.r;\nelse if (channelG == 1)\noutColor.g = inColor.g;\nelse if (channelG == 2)\noutColor.g = inColor.b;\nelse\noutColor.g = inAlpha;\nif (channelB == 0)\noutColor.b = inColor.r;\nelse if (channelB == 1)\noutColor.b = inColor.g;\nelse if (channelB == 2)\noutColor.b = inColor.b;\nelse\noutColor.b = inAlpha;\nif (channelA == 0)\noutAlpha = inColor.r;\nelse if (channelA == 1)\noutAlpha = inColor.g;\nelse if (channelA == 2)\noutAlpha = inColor.b;\nelse\noutAlpha = inAlpha;\n}",
            node_checker_my_frag: "void node_checker(\nvec3 color1, vec3 color2, float contrast, vec2 uvCoord,\nout float outAlpha, out vec3 outColor) {\nuvCoord -= floor(uvCoord); \nvec3 deltaColor = color2 - color1;\ncolor1 += (1.0 - contrast) * 0.5 * deltaColor;\ncolor2 -= (1.0 - contrast) * 0.5 * deltaColor;\nif ((uvCoord.x < 0.5 && uvCoord.y >= 0.5) || (uvCoord.x >= 0.5 && uvCoord.y < 0.5)) { \noutColor = color2; \noutAlpha = 1.0; \n} else {\noutColor = color1; \noutAlpha = 0.0; \n}\n}",
            node_clamp_my_frag: "void node_clamp(\nvec3 inputValue, vec3 maxValue, vec3 minValue,\nout vec3 outputValue) {\noutputValue = clamp(inputValue, minValue, maxValue);\n}",
            node_color_composite_my_frag: "void node_color_composite(int operation,\nvec3 colorA, float alphaA, vec3 colorB, float alphaB, float factor,\nout vec3 outColor, out float outAlpha)\n{\nif (factor <= 0.0) {\noutColor = colorA;\noutAlpha = alphaA;\nreturn;\n}\nif (operation == 0) {\noutColor[0] = colorA[0] + (colorB[0] * factor);\noutColor[1] = colorA[1] + (colorB[1] * factor);\noutColor[2] = colorA[2] + (colorB[2] * factor);\noutAlpha = alphaA + (alphaB * factor);\n} else if (operation == 1) {\noutColor[0] = colorA[0] + ((colorB[0] - 1.0) * factor);\noutColor[1] = colorA[1] + ((colorB[1] - 1.0) * factor);\noutColor[2] = colorA[2] + ((colorB[2] - 1.0) * factor);\noutAlpha = alphaA + ((alphaB - 1.0) * factor);\n} else if (operation == 2) {\nif (factor >= 1.0) {\noutColor = colorB;\noutAlpha = alphaB;\nreturn;\n}\noutColor[0] = mix(colorA[0], colorB[0], factor);\noutColor[1] = mix(colorA[1], colorB[1], factor);\noutColor[2] = mix(colorA[2], colorB[2], factor);\noutAlpha = mix(alphaA, alphaB, factor);\n} else if (operation == 3) {\noutColor[0] = colorA[0] * (colorB[0] * factor + (1.0 - factor));\noutColor[1] = colorA[1] * (colorB[1] * factor + (1.0 - factor));\noutColor[2] = colorA[2] * (colorB[2] * factor + (1.0 - factor));\noutAlpha = alphaA * (alphaB * factor + (1.0 - factor));\n} else if (operation == 4) {\noutColor[0] = 1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor));\noutColor[1] = 1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor));\noutColor[2] = 1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor));\noutAlpha = 1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor));\n} else if (operation == 5) {\noutColor[0] = colorB[0] > 0.5 ? (2.0 * colorA[0] * colorB[0] * factor) + colorA[0] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[0]) * (1.0 - colorB[0] * factor)) * (2.0 - (1.0 - factor));\noutColor[1] = colorB[1] > 0.5 ? (2.0 * colorA[1] * colorB[1] * factor) + colorA[1] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[1]) * (1.0 - colorB[1] * factor)) * (2.0 - (1.0 - factor));\noutColor[2] = colorB[2] > 0.5 ? (2.0 * colorA[2] * colorB[2] * factor) + colorA[2] * (1.0 - factor) :\n1.0 - ((1.0 - colorA[2]) * (1.0 - colorB[2] * factor)) * (2.0 - (1.0 - factor));\noutAlpha = alphaB > 0.5 ? (2.0 * alphaA * alphaB * factor) + alphaA * (1.0 - factor) :\n1.0 - ((1.0 - alphaA) * (1.0 - alphaB * factor)) * (2.0 - (1.0 - factor));\n} else if (operation == 6) {\noutColor[0] = abs(colorA[0] - (colorB[0] * factor));\noutColor[1] = abs(colorA[1] - (colorB[1] * factor));\noutColor[2] = abs(colorA[2] - (colorB[2] * factor));\noutAlpha = abs(alphaA - (alphaB * factor));\n} else if (operation == 7) {\noutColor[0] = clamp(mix(colorA[0], colorA[0] / max(1.0 - colorB[0], 0.00001), factor), colorA[0], colorB[0]);\noutColor[1] = clamp(mix(colorA[1], colorA[1] / max(1.0 - colorB[1], 0.00001), factor), colorA[1], colorB[1]);\noutColor[2] = clamp(mix(colorA[2], colorA[2] / max(1.0 - colorB[2], 0.00001), factor), colorA[2], colorB[2]);\noutAlpha = clamp(mix(alphaA, alphaA / max(1.0 - alphaB, 0.00001), factor), alphaA, alphaB);\n} else if (operation == 8) {\noutColor[0] = clamp(mix(colorA[0], 1.0 - (colorA[0] / max(1.0 - colorB[0], 0.00001)), factor), colorA[0], colorB[0]);\noutColor[1] = clamp(mix(colorA[1], 1.0 - (colorA[1] / max(1.0 - colorB[1], 0.00001)), factor), colorA[1], colorB[1]);\noutColor[2] = clamp(mix(colorA[2], 1.0 - (colorA[2] / max(1.0 - colorB[2], 0.00001)), factor), colorA[2], colorB[2]);\noutAlpha = clamp(mix(alphaA, 1.0 - (alphaA / max(1.0 - alphaB, 0.00001)), factor), alphaA, alphaB);\n}\n}",
            node_color_constant_my_frag: "void node_color_constant(vec3 inColor, float inAlpha, out vec3 outColor, out float outAlpha)\n{\noutColor = inColor;\noutAlpha = inAlpha;\n}",
            node_color_math_my_frag: "void node_color_math(\nint operation,\nfloat alphaA, float alphaB, vec3 colorA, vec3 colorB,\nout float outAlpha, out vec3 outColor) {\nif (operation == 0) {\noutColor = colorA + colorB;\noutAlpha = alphaA + alphaB;\n} else if (operation == 1) {\noutColor = colorA - colorB;\noutAlpha = alphaA - alphaB;\n} else if (operation == 2) {\noutColor = colorA * colorB;\noutAlpha = alphaA * alphaB;\n} else if (operation == 3) {\noutColor = colorA / colorB;\noutAlpha = alphaA / alphaB;\n} else if (operation == 4) {\noutColor = min(colorA, colorB);\noutAlpha = min(alphaA, alphaB);\n} else  {\noutColor = max(colorA, colorB);\noutAlpha = max(alphaA, alphaB);\n}\n}",
            node_condition_my_frag: "void node_condition(\nint operation,\nvec3 colorIfFalse, vec3 colorIfTrue, float firstTerm, float secondTerm,\nout vec3 outColor) {\nif (operation == 0) {\nif (firstTerm == secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 1) {\nif (firstTerm != secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 2) {\nif (firstTerm > secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 3) {\nif (firstTerm >= secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 4) {\nif (firstTerm < secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n} else if (operation == 5) {\nif (firstTerm <= secondTerm)\noutColor = colorIfTrue;\nelse\noutColor = colorIfFalse;\n}\n}",
            node_env_sphere_my_frag: "void node_env_sphere(sampler2D envMap, int encoding, vec3 normal,\nmat4 placementMatrix,\nout float outAlpha, out vec3 outColor)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec = normalize(cameraToVertex);\n#else\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nreflectVec = reflect(cameraToVertex, worldNormal);\n#endif\nmat3 uvTransform = mat3(1.0);\nreflectVec = toMat3(placementMatrix) * reflectVec;\nvec4 tex = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\noutAlpha = tex.a;\noutColor = tex.rgb;\n}",
            node_file_my_frag: "void node_file(sampler2D ima, const int encoding,\nvec2 uvCoord,\nout float outAlpha, out vec3 outColor, out vec2 outSize, out vec3 outTransparency) {\nvec2 uv = vec2(uvCoord.x, 1.0 - uvCoord.y);\nvec4 tex = texture2D(ima, uv);\noutColor = nodeTexelToLinear(tex, encoding).rgb;\noutAlpha = tex.a;\noutSize = vec2(0.0);\noutTransparency = vec3(1.0 - outAlpha, 1.0 - outAlpha, 1.0 - outAlpha);\n}",
            node_float_composite_my_frag: "void node_float_composite(int operation,\nfloat floatA, float floatB, float factor,\nout float outFloat)\n{\nif (factor <= 0.0) {\noutFloat = floatA;\nreturn;\n}\nif (operation == 0) {\noutFloat = floatA + (floatB * factor);\n} else if (operation == 1) {\noutFloat = floatA + ((floatB - 1.0) * factor);\n} else if (operation == 2) {\nif (factor >= 1.0) {\noutFloat = floatB;\nreturn;\n}\noutFloat = mix(floatA, floatB, factor);\n} else if (operation == 3) {\noutFloat = floatA * (floatB * factor + (1.0 - factor));\n} else if (operation == 4) {\noutFloat = 1.0 - ((1.0 - floatA) * (1.0 - floatB * factor));\n} else if (operation == 5) {\noutFloat = floatB > 0.5 ? (2.0 * floatA * floatB * factor) + floatA * (1.0 - factor) :\n1.0 - ((1.0 - floatA) * (1.0 - floatB * factor)) * (2.0 - (1.0 - factor));\n} else if (operation == 6) {\noutFloat = abs(floatA - (floatB * factor));\n} else if (operation == 7) {\noutFloat = clamp(mix(floatA, floatA / max(1.0 - floatB, 0.00001), factor), floatA, floatB);\n} else if (operation == 8) {\noutFloat = clamp(mix(floatA, 1.0 - (floatA / max(1.0 - floatB, 0.00001)), factor), floatA, floatB);\n}\n}",
            node_float_constant_my_frag: "void node_float_constant(float inFloat, out float outFloat)\n{\noutFloat = inFloat;\n}",
            node_float_math_my_frag: "void node_float_math(\nint operation,\nfloat floatA, float floatB,\nout float outFloat) {\nif (operation == 0) {\noutFloat = floatA + floatB;\n} else if (operation == 1) {\noutFloat = floatA - floatB;\n} else if (operation == 2) {\noutFloat = floatA * floatB;\n} else if (operation == 3) {\noutFloat = floatA / floatB;\n} else if (operation == 4) {\noutFloat = min(floatA, floatB);\n} else if (operation == 5) {\noutFloat = max(floatA, floatB);\n} else {\noutFloat = pow(floatA, floatB);\n}\n}",
            node_gamma_correct_my_frag: "void node_gamma_correct(\nvec3 gamma, vec3 value,\nout vec3 outValue) {\noutValue = pow(value, 1.0 / gamma);\n}",
            node_lambert_my_frag: "\nvoid node_lambert(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_IndirectDiffuse\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + incandescence, alpha);\n}",
            node_layered_texture_layer_my_frag: "#define LAYER_BLEND_MODE_NONE        0.0\n#define LAYER_BLEND_MODE_OVER        1.0\n#define LAYER_BLEND_MODE_IN          2.0\n#define LAYER_BLEND_MODE_OUT         3.0\n#define LAYER_BLEND_MODE_ADD         4.0\n#define LAYER_BLEND_MODE_SUBTRACT    5.0\n#define LAYER_BLEND_MODE_MULTIPLY    6.0\n#define LAYER_BLEND_MODE_DIFFERENCE  7.0\n#define LAYER_BLEND_MODE_LIGHTEN     8.0\n#define LAYER_BLEND_MODE_DARKEN      9.0\n#define LAYER_BLEND_MODE_SATURATE   10.0\n#define LAYER_BLEND_MODE_DESATURATE 11.0\n#define LAYER_BLEND_MODE_ILLUMINATE 12.0\nvoid node_layered_texture_layer(\nconst float alphaBG, const vec3 colorBG, \nconst vec3 color, const float alpha, const float blendMode, const bool isVisible,\nout float outAlpha, out vec3 outColor)\n{\noutAlpha = alphaBG;\noutColor = colorBG;\nif (!isVisible)\nreturn;\nif (blendMode == LAYER_BLEND_MODE_NONE) {\noutColor = color;\n} else if (blendMode == LAYER_BLEND_MODE_OVER) {\noutColor = mix(colorBG, color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_IN) {\noutColor = alpha * colorBG;\n} else if (blendMode == LAYER_BLEND_MODE_OUT) {\noutColor = (1.0 - alpha) * colorBG;\n} else if (blendMode == LAYER_BLEND_MODE_ADD) {\noutColor = mix(colorBG, colorBG + color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_SUBTRACT) {\noutColor = mix(colorBG, colorBG - color, alpha);\n} else if (blendMode == LAYER_BLEND_MODE_MULTIPLY) {\noutColor = mix(colorBG, colorBG * color, alpha);\n} else {\noutColor = mix(colorBG, color, alpha);\n}\n}",
            node_light_path_my_frag: "void node_light_path(out float isCameraRay)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay = 1.0;\n#else\nisCameraRay = 0.0;\n#endif\n}",
            node_multiply_divide_my_frag: "void node_multiply_divide(\nint operation,\nvec3 input1, vec3 input2,\nout vec3 outValue) {\nif (operation == 0) {\noutValue = input1;\n} else if (operation == 1) {\noutValue = input1 * input2;\n} else if (operation == 2) {\n\noutValue = input1 / input2;\n} else {\noutValue = pow(input1, input2);\n}\n}",
            node_output_my_frag: "void node_output(vec4 rgb, out vec4 outgoingLight)\n{\noutgoingLight = rgb;\n}",
            node_place_2d_texture_my_frag: "void node_place_2d_texture(const vec2 inUv,\nvec2 offset, vec2 repeatUv, float rotateUv,\nout vec2 outUv)\n{\noutUv = (calcUvTransform(offset.x, offset.y, repeatUv.x, repeatUv.y, rotateUv) * vec3(inUv, 1.0)).xy;\noutUv.y = 1.0 - outUv.y;\n}",
            node_phong_my_frag: "void node_phong(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat cosinePower, vec3 specularColor, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nfloat roughness = sqrt(1.0 / (0.454 * cosinePower + 3.357));\nmaterial.specularRoughness = max(roughness, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}",
            node_phong_e_my_frag: "void node_phong_e(\nvec3 geometryNormal,\nvec3 color, vec3 ambientColor, vec3 incandescence, float matteOpacity,\nfloat diffuse, vec3 normal, float reflectivity, vec3 reflectedColor,\nfloat highlightSize, float roughness, vec3 specularColor, float translucence, vec3 transparency,\nout vec4 outColor) {\nNodeMaterial material;\nmaterial.diffuseColor = diffuse * color;\n#ifdef CLEARCOAT\n#undef CLEARCOAT\n#define _CLEARCOAT_RESTORE\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.specularRoughness = max(roughness, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\nmaterial.specularColor = specularColor;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#ifdef _CLEARCOAT_RESTORE\n#undef _CLEARCOAT_RESTORE\n#define CLEARCOAT\n#endif\nfloat alpha = 1.0 - average(transparency);\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nreflectedLight.directSpecular + reflectedLight.indirectSpecular + incandescence, alpha);\n}",
            node_premultiply_my_frag: "void node_premultiply(\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutColor = inColor * inAlpha;\noutAlpha = inAlpha;\n}",
            node_ramp_my_frag: "void node_ramp(\nsampler2D rampData, int rampType,\nvec2 uvCoord,\nout float outAlpha, out vec3 outColor)\n{\nfloat coord;\nif (rampType == 0) {\ncoord = uvCoord.y;\n} else if (rampType == 1) {\ncoord = uvCoord.x;\n} else if (rampType == 2) {\ncoord = abs(uvCoord.x + uvCoord.y) / 2.0;\n} else if (rampType == 3) {\nvec2 uvSpiral = mat2(0.0, 1.0, 1.0, 0.0) * (uvCoord - vec2(0.5));\ncoord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;\n} else if (rampType == 4) {\ncoord = length(uvCoord - vec2(0.5)) * sqrt(2.0);\n} else if (rampType == 5) {\nvec2 boxUv = abs(uvCoord - vec2(0.5)) * 2.0;\ncoord = max(boxUv.x, boxUv.y);\n} else if (rampType == 6) {\nuvCoord = abs((uvCoord - vec2(0.5)) * 2.0);\ncoord = uvCoord.y;\n} else if (rampType == 7) {\ncoord = uvCoord.y;\n} else {\ncoord = uvCoord.y;\n}\nvec4 tex = texture2D(rampData, vec2(coord, 0.0));\noutAlpha = average(tex.xyz);\noutColor = tex.xyz;\n}",
            node_remap_hsv_my_frag: "void node_remap_hsv(vec3 color, out vec3 outColor)\n{\noutColor = color;\n}",
            node_reverse_my_frag: "void node_reverse(\nvec3 inValue,\nout vec3 outValue) {\noutValue = 1.0 - inValue;\n}",
            node_sampler_info_my_frag: "void node_sampler_info(\nbool frontFacing, vec4 tangent, vec2 uv,\nvec3 viewNorm, \nout float facingRatio, out bool flippedNormal, out mat4 matrixEyeToWorld,\nout vec3 normalCamera, out vec2 pixelCenter, out vec3 pointCamera,\nout vec3 pointObj, out vec3 pointWorld,\nout vec3 tangentUCamera, out vec3 tangentVCamera, out vec2 uvCoord)\n{\nvec4 worldPos = invViewMatrix * vec4(-vViewPosition, 1.0);\nfacingRatio = dot(normalize(viewNorm), normalize(vViewPosition));\nflippedNormal = frontFacing;\nmatrixEyeToWorld = invViewMatrix;\nnormalCamera = viewNorm;\npixelCenter = vec2(1.0);\npointCamera = -vViewPosition;\npointObj = (invModelMatrix * worldPos).xyz;\npointWorld = worldPos.xyz;\ntangentUCamera = normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz);\ntangentVCamera = tangent.w * cross(viewNorm, tangentUCamera);\nuvCoord = vec2(uv.x, 1.0-uv.y);\n}",
            node_set_range_my_frag: "void node_set_range(\nvec3 maxValue, vec3 minValue, vec3 oldMax, vec3 oldMin, vec3 value,\nout vec3 outValue) {\noutValue = minValue + (((value - oldMin) / (oldMax - oldMin)) * (maxValue - minValue));\n}",
            node_shading_engine_my_frag: "void node_shading_engine(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}",
            node_standard_surface_my_frag: "#define DEFAULT_REFLECTION_EDGE 1.0\n#define DEFAULT_REFLECTION_SLOPE 5.0\nvoid node_standard_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float base, const vec3 baseColor, const float diffuseRoughness,\nconst float metalness, const float specular, const vec3 specularColor,\nconst float specularRoughness, const float trans, const vec3 transColor,\nconst float transDepth, const vec3 transScatter, const float transExtraRoughness,\nconst float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,\nconst float coat, const vec3 coatColor, const float coatRoughness,\nconst float sheen, const vec3 sheenColor, const float sheenRoughness,\nconst float emission, const vec3 emissionColor, const vec3 opacity,\nconst vec3 normal, const vec3 clearcoatNormal, const float specularIOR,\nout vec4 outColor, out vec3 outTransparency)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = base * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - metalness) * (1.0 - trans);\n#ifdef CLEARCOAT\nmaterial.clearcoat = saturate(coat);\nmaterial.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = saturate(sheen * sheenColor);\nmaterial.sheenRoughness = clamp(sheenRoughness, 0.0, 1.0);\n#endif\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.specularRoughness = max(specularRoughness, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\nvec3 dielRefl = DEFAULT_SPECULAR_COEFFICIENT * specular * specularColor;\nmaterial.specularColor = mix(dielRefl, baseColorWeighted, metalness);\nmaterial.refractionColor = pow(trans * (1.0 - metalness) * transColor.rgb, vec3(2.0));\nmaterial.refractionIOR = specularIOR;\nmaterial.refractionRoughness = material.specularRoughness;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 refractedLight = vec3(0.0);\n#define RE_DirectDiffuse RE_DirectDiffuse_Node\n#define RE_DirectSpecular RE_DirectSpecular_Node\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Node\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#define RE_Refraction RE_Refraction_Node\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef RE_DirectDiffuse\n#undef RE_DirectSpecular\n#undef RE_IndirectDiffuse\n#undef RE_IndirectSpecular\n#undef RE_Refraction\nvec3 totalEmissiveRadiance = emission * emissionColor;\nvec3 outSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\noutSpecular + totalEmissiveRadiance;\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = average(opacity) * (1.0 - saturate(trans) + maxFromRGB(outSpecular) * saturate(trans));\n} else { \noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\noutTransparency = outColor3;\n}\nvoid node_standard_surface(\nvec3 geometryNormal, const bool thinWalled,\nconst float base, const vec3 baseColor, const float diffuseRoughness,\nconst float metalness, const float specular, const vec3 specularColor,\nconst float specularRoughness, const float trans, const vec3 transColor,\nconst float transDepth, const vec3 transScatter, const float transExtraRoughness,\nconst float subsurface, const vec3 subsurfaceColor, const vec3 subsurfaceRadius,\nconst float coat, const vec3 coatColor, const float coatRoughness,\nconst float sheen, const vec3 sheenColor, const float sheenRoughness,\nconst float emission, const vec3 emissionColor, const vec3 opacity,\nconst vec3 normal, const vec3 clearcoatNormal,\nout vec4 outColor, out vec3 outTransparency)\n{\nnode_standard_surface(\ngeometryNormal, thinWalled,\nbase, baseColor, diffuseRoughness,\nmetalness, specular, specularColor,\nspecularRoughness, trans, transColor,\ntransDepth, transScatter, transExtraRoughness,\nsubsurface, subsurfaceColor, subsurfaceRadius,\ncoat, coatColor, coatRoughness,\nsheen, sheenColor, sheenRoughness,\nemission, emissionColor, opacity,\nnormal, clearcoatNormal, 1.5,\noutColor, outTransparency);\n}",
            node_surface_shader_my_frag: "void node_surface_shader(\nvec3 color, vec3 glowColor, vec3 matteOpacity, vec3 transparency,\nout vec3 outColor, out vec3 outGlowColor, out vec3 outMatteOpacity, out vec3 outTransparency)\n{\noutColor = color;\noutGlowColor = glowColor;\noutMatteOpacity = matteOpacity;\noutTransparency = transparency;\n}",
            node_unit_conversion_my_frag: "void node_unit_conversion(float conversionFactor, float inInput, out float outOutput)\n{\noutOutput = conversionFactor * inInput;\n}",
            node_unpremultiply_my_frag: "void node_unpremultiply(\nfloat inAlpha, vec3 inColor,\nout float outAlpha, out vec3 outColor) {\noutColor = inColor / inAlpha;\noutAlpha = inAlpha;\n}",
            node_vector_product_my_frag: "void node_vector_product(\nconst int operation, const bool normalizeOutput,\nvec3 input1, vec3 input2, mat4 matrix,\nout vec3 outVector) {\nif (operation == 0) {\noutVector = input1;\n} else if (operation == 1) {\nif (normalizeOutput) {\ninput1 = normalize(input1);\ninput2 = normalize(input2);\n}\noutVector = vec3(dot(input1, input2));\n} else if (operation == 2) {\noutVector = cross(input1, input2);\n} else if (operation == 3) {\noutVector = (matrix * vec4(input1, 0.0)).xyz;\n} else {\noutVector = (matrix * vec4(input1, 1.0)).xyz;\n}\n\nif (operation > 1 && normalizeOutput)\noutVector = normalize(outVector);\n}",
            pp_plane_vert: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
            pp_bloom_composite_frag: "varying vec2 vUv;\nuniform sampler2D blurTexture1;\nuniform sampler2D blurTexture2;\nuniform sampler2D blurTexture3;\nuniform sampler2D blurTexture4;\nuniform sampler2D blurTexture5;\nuniform sampler2D dirtTexture;\nuniform float bloomStrength;\nuniform float bloomRadius;\nuniform float bloomFactors[NUM_MIPS];\nuniform vec3 bloomTintColors[NUM_MIPS];\nfloat lerpBloomFactor(const in float factor) {\nfloat mirrorFactor = 1.2 - factor;\nreturn mix(factor, mirrorFactor, bloomRadius);\n}\nvoid main() {\ngl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv)\n);\n}",
            pp_bloom_lum_high_pass_frag: "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat v = dot(texel.xyz, luma);\nvec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);\nfloat alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\ngl_FragColor = mix(outputColor, texel, alpha);\ngl_FragColor = clamp(gl_FragColor, 0.0, 10.0);\n}",
            pp_bloom_separable_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat fSigma = float(SIGMA);\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = direction * invSize * x;\nvec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\nvec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\ndiffuseSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}",
            pp_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\n#if LOG_SPACE == 1\nvec3 origDiffuse = texture2D(colorTexture, vUv).rgb;\nvec3 diffuseSum = vec3(weightSum);\n#else\nvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\n#endif\nvec2 delta = direction * invSize * kernelRadius/float(MAX_SAMPLE_RADIUS);\nvec2 uvOffset = delta;\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeDir = normalize(octUVToCubeVec(vUv, invSize));\nvec3 dirX = normalize(abs(cubeDir.y) < 0.99999 ? vec3(cubeDir.z, 0.0, -cubeDir.x)\n: vec3(0.0, -cubeDir.z, cubeDir.y));\nvec3 dirY = cross(cubeDir, dirX);\n#endif\n#pragma unroll_loop_start\nfor (int i = 1; i <= MAX_SAMPLE_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeOffset = uvOffset.x * dirX + uvOffset.y * dirY;\nvec2 uv1 = cubeVecToOctUV(cubeDir + cubeOffset, invSize);\nvec2 uv2 = cubeVecToOctUV(cubeDir - cubeOffset, invSize);\n#else\nvec2 uv1 = vUv + uvOffset;\nvec2 uv2 = vUv - uvOffset;\n#endif\nvec3 sample1 = texture2D(colorTexture, uv1).rgb;\nvec3 sample2 = texture2D(colorTexture, uv2).rgb;\n#if LOG_SPACE == 1\ndiffuseSum += (\nclamp(exp(sample1 - origDiffuse), 0.0, 1e38) +\nclamp(exp(sample2 - origDiffuse), 0.0, 1e38)\n) * w;\n#else\ndiffuseSum += ((sample1 + sample2) * w);\n#endif\nweightSum += 2.0 * w;\nuvOffset += delta;\n}\n#pragma unroll_loop_end\n#if LOG_SPACE == 1\ngl_FragColor = vec4(origDiffuse + log(diffuseSum/weightSum), 1.0);\n#else\ngl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n#endif\n}",
            pp_brightness_contrast_frag: "\nuniform sampler2D tDiffuse;\nuniform float brightness;\nuniform float contrast;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\ntexel.rgb += brightness;\nif (contrast > 0.0)\ntexel.rgb = (texel.rgb - 0.5) / (1.0 - contrast) + 0.5;\nelse\ntexel.rgb = (texel.rgb - 0.5) * (1.0 + contrast) + 0.5;\ngl_FragColor = texel;\n}",
            pp_bokeh_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\nuniform float depthLeakThreshold;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition) {\n#if DEPTH_PACKING == 1\nreturn unpackRGBAToDepth(texture2D(tDepth, screenPosition));\n#else\nreturn texture2D(tDepth, screenPosition).x;\n#endif\n}\nfloat getViewZ(const in float depth) {\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth, nearClip, farClip);\n#else\nreturn orthoDepthToViewZ(depth, nearClip, farClip);\n#endif\n}\nvec4 blurSample(vec2 uvOffset, vec4 centerCol, float viewZCenter) {\nfloat viewZ = -getViewZ(getDepth(vUv + uvOffset));\nfloat blurFactor = (viewZ >= viewZCenter) ? 1.0 : \nmin(depthLeakThreshold * abs((focus - viewZ) / aperture), 1.0);\nreturn mix(centerCol, texture2D(tColor, vUv + uvOffset), blurFactor);\n}\nvoid main() {\nvec2 aspectcorrect = vec2(1.0, aspect);\nfloat viewZ = -getViewZ(getDepth(vUv));\nfloat factor = abs(focus - viewZ);\n\nfloat dofblur = maxblur * min(factor / aperture, 1.0);\nfloat dofblur9 = dofblur * 0.9;\nfloat dofblur7 = dofblur * 0.7;\nfloat dofblur4 = dofblur * 0.4;\nvec4 centerCol = texture2D(tColor, vUv);\nvec4 col = centerCol;\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15,  0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37,  0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.40,  0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15,  0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37,  0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.15,  0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37,  0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15,  0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37,  0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.40,  0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.4,   0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ngl_FragColor = col / 41.0;\ngl_FragColor.a = centerCol.a;\n}",
            pp_copy_frag: "uniform sampler2D tDiffuse;\nuniform float opacity;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = (texture2D(tDiffuse, vUv));\n#if MAP_TEXELS == 1\ntexel = mapTexelToLinear(texel);\n#endif\ngl_FragColor = opacity * texel;\n#if MAP_TEXELS == 1\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#endif\n}",
            pp_cube_octahedral_proj_frag: "#include <common>\nuniform samplerCube tCube;\nuniform vec2 texelSize;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = textureCube(tCube, octUVToCubeVec(gl_FragCoord.xy * texelSize,\ntexelSize));\n}",
            pp_fxaa_frag: "precision highp float;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n#define FXAA_GREEN_AS_LUMA 1\n#ifndef FXAA_PC_CONSOLE\n#define FXAA_PC_CONSOLE 0\n#endif\n#ifndef FXAA_GLSL_120\n#define FXAA_GLSL_120 0\n#endif\n#ifndef FXAA_GLSL_130\n#define FXAA_GLSL_130 0\n#endif\n#ifndef FXAA_HLSL_3\n#define FXAA_HLSL_3 0\n#endif\n#ifndef FXAA_HLSL_4\n#define FXAA_HLSL_4 0\n#endif\n#ifndef FXAA_HLSL_5\n#define FXAA_HLSL_5 0\n#endif\n#ifndef FXAA_GREEN_AS_LUMA\n#define FXAA_GREEN_AS_LUMA 0\n#endif\n#ifndef FXAA_EARLY_EXIT\n#define FXAA_EARLY_EXIT 1\n#endif\n#ifndef FXAA_DISCARD\n#define FXAA_DISCARD 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#ifdef GL_EXT_gpu_shader4\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#define FXAA_FAST_PIXEL_OFFSET 0\n#endif\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n#if (FXAA_HLSL_5 == 1)\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n#define FXAA_GATHER4_ALPHA 0\n#endif\n#endif\n#ifndef FXAA_QUALITY_PRESET\n#define FXAA_QUALITY_PRESET 12\n#endif\n#if (FXAA_QUALITY_PRESET == 10)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 3.0\n#define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 3.0\n#define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 4.0\n#define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 4.0\n#define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 4.0\n#define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 2.0\n#define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 3.0\n#define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n#define FXAA_QUALITY_PS 9\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 4.0\n#define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n#define FXAA_QUALITY_PS 10\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 4.0\n#define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n#define FXAA_QUALITY_PS 11\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 4.0\n#define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.0\n#define FXAA_QUALITY_P2 1.0\n#define FXAA_QUALITY_P3 1.0\n#define FXAA_QUALITY_P4 1.0\n#define FXAA_QUALITY_P5 1.5\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#else\n#define FxaaBool bool\n#define FxaaDiscard clip(-1)\n#define FxaaFloat float\n#define FxaaFloat2 float2\n#define FxaaFloat3 float3\n#define FxaaFloat4 float4\n#define FxaaHalf half\n#define FxaaHalf2 half2\n#define FxaaHalf3 half3\n#define FxaaHalf4 half4\n#define FxaaSat(x) saturate(x)\n#endif\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GLSL_120 == 1)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GATHER4_ALPHA == 1)\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n#if (FXAA_GLSL_130 == 1)\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#if (FXAA_GATHER4_ALPHA == 1)\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n#if (FXAA_HLSL_3 == 1)\n#define FxaaInt2 float2\n#define FxaaTex sampler2D\n#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n#if (FXAA_HLSL_4 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n#if (FXAA_HLSL_5 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n#if (FXAA_PC == 1)\nFxaaFloat4 FxaaPixelShader(\nFxaaFloat2 pos,\nFxaaFloat4 fxaaConsolePosPos,\nFxaaTex tex,\nFxaaTex fxaaConsole360TexExpBiasNegOne,\nFxaaTex fxaaConsole360TexExpBiasNegTwo,\nFxaaFloat2 fxaaQualityRcpFrame,\nFxaaFloat4 fxaaConsoleRcpFrameOpt,\nFxaaFloat4 fxaaConsoleRcpFrameOpt2,\nFxaaFloat4 fxaaConsole360RcpFrameOpt2,\nFxaaFloat fxaaQualitySubpix,\nFxaaFloat fxaaQualityEdgeThreshold,\nFxaaFloat fxaaQualityEdgeThresholdMin,\nFxaaFloat fxaaConsoleEdgeSharpness,\nFxaaFloat fxaaConsoleEdgeThreshold,\nFxaaFloat fxaaConsoleEdgeThresholdMin,\nFxaaFloat4 fxaaConsole360ConstDir\n) {\nFxaaFloat2 posM;\nposM.x = pos.x;\nposM.y = pos.y;\n#if (FXAA_GATHER4_ALPHA == 1)\n#if (FXAA_DISCARD == 0)\nFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\nFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n#else\nFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\nFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n#endif\n#if (FXAA_DISCARD == 1)\n#define lumaM luma4A.w\n#endif\n#define lumaE luma4A.z\n#define lumaS luma4A.x\n#define lumaSE luma4A.y\n#define lumaNW luma4B.w\n#define lumaN luma4B.z\n#define lumaW luma4B.x\n#else\nFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n#endif\n#endif\nFxaaFloat maxSM = max(lumaS, lumaM);\nFxaaFloat minSM = min(lumaS, lumaM);\nFxaaFloat maxESM = max(lumaE, maxSM);\nFxaaFloat minESM = min(lumaE, minSM);\nFxaaFloat maxWN = max(lumaN, lumaW);\nFxaaFloat minWN = min(lumaN, lumaW);\nFxaaFloat rangeMax = max(maxWN, maxESM);\nFxaaFloat rangeMin = min(minWN, minESM);\nFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\nFxaaFloat range = rangeMax - rangeMin;\nFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\nFxaaBool earlyExit = range < rangeMaxClamped;\nif(earlyExit)\n#if (FXAA_DISCARD == 1)\nreturn rgbyM;\n#else\nreturn rgbyM;\n#endif\n#if (FXAA_GATHER4_ALPHA == 0)\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\n#else\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\nFxaaFloat lumaNS = lumaN + lumaS;\nFxaaFloat lumaWE = lumaW + lumaE;\nFxaaFloat subpixRcpRange = 1.0/range;\nFxaaFloat subpixNSWE = lumaNS + lumaWE;\nFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\nFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\nFxaaFloat lumaNESE = lumaNE + lumaSE;\nFxaaFloat lumaNWNE = lumaNW + lumaNE;\nFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\nFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\nFxaaFloat lumaNWSW = lumaNW + lumaSW;\nFxaaFloat lumaSWSE = lumaSW + lumaSE;\nFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\nFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\nFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\nFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\nFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\nFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\nFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\nFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\nFxaaBool horzSpan = edgeHorz >= edgeVert;\nFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\nif(!horzSpan) lumaN = lumaW;\nif(!horzSpan) lumaS = lumaE;\nif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\nFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\nFxaaFloat gradientN = lumaN - lumaM;\nFxaaFloat gradientS = lumaS - lumaM;\nFxaaFloat lumaNN = lumaN + lumaM;\nFxaaFloat lumaSS = lumaS + lumaM;\nFxaaBool pairN = abs(gradientN) >= abs(gradientS);\nFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\nif(pairN) lengthSign = -lengthSign;\nFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\nFxaaFloat2 posB;\nposB.x = posM.x;\nposB.y = posM.y;\nFxaaFloat2 offNP;\noffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\noffNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\nif(!horzSpan) posB.x += lengthSign * 0.5;\nif(horzSpan) posB.y += lengthSign * 0.5;\nFxaaFloat2 posN;\nposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\nposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\nFxaaFloat2 posP;\nposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\nposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\nFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\nFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\nFxaaFloat subpixE = subpixC * subpixC;\nFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\nif(!pairN) lumaNN = lumaSS;\nFxaaFloat gradientScaled = gradient * 1.0/4.0;\nFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\nFxaaFloat subpixF = subpixD * subpixE;\nFxaaBool lumaMLTZero = lumaMM < 0.0;\nlumaEndN -= lumaNN * 0.5;\nlumaEndP -= lumaNN * 0.5;\nFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\nFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\nFxaaBool doneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n#if (FXAA_QUALITY_PS > 3)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n#if (FXAA_QUALITY_PS > 4)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n#if (FXAA_QUALITY_PS > 5)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n#if (FXAA_QUALITY_PS > 6)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n#if (FXAA_QUALITY_PS > 7)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n#if (FXAA_QUALITY_PS > 8)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n#if (FXAA_QUALITY_PS > 9)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n#if (FXAA_QUALITY_PS > 10)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n#if (FXAA_QUALITY_PS > 11)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n#if (FXAA_QUALITY_PS > 12)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\nFxaaFloat dstN = posM.x - posN.x;\nFxaaFloat dstP = posP.x - posM.x;\nif(!horzSpan) dstN = posM.y - posN.y;\nif(!horzSpan) dstP = posP.y - posM.y;\nFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\nFxaaFloat spanLength = (dstP + dstN);\nFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\nFxaaFloat spanLengthRcp = 1.0/spanLength;\nFxaaBool directionN = dstN < dstP;\nFxaaFloat dst = min(dstN, dstP);\nFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\nFxaaFloat subpixG = subpixF * subpixF;\nFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\nFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\nFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\nFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\nif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\nif(horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n#if (FXAA_DISCARD == 1)\nreturn FxaaTexTop(tex, posM);\n#else\nreturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n#endif\n}\n#endif\nvoid main() {\ngl_FragColor = FxaaPixelShader(\nvUv,\nvec4(0.0),\ntDiffuse,\ntDiffuse,\ntDiffuse,\nresolution,\nvec4(0.0),\nvec4(0.0),\nvec4(0.0),\n0.75,\n0.166,\n0.0833,\n0.0,\n0.0,\n0.0,\nvec4(0.0)\n);\n\n}",
            pp_grayscale_frag: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat bw = texel.r * 0.35 + texel.g * 0.45 + texel.b * 0.2;\ntexel = vec4(bw, bw, bw, texel.a);\ngl_FragColor = texel;\n}",
            pp_outline_edge_frag: "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec4 visibleEdgeColor;\nuniform vec4 hiddenEdgeColor;\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\nvec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\nvec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\nvec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\nvec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\nfloat diff1 = (c1.r - c2.r) * 0.5;\nfloat diff2 = (c3.r - c4.r) * 0.5;\nfloat d = length(vec2(diff1, diff2));\nfloat a1 = min(c1.g, c2.g);\nfloat a2 = min(c3.g, c4.g);\nfloat visibilityFactor = min(a1, a2);\nvec4 edgeColor = (1.0 - visibilityFactor > 0.001) ? visibleEdgeColor : hiddenEdgeColor;\ngl_FragColor = edgeColor * vec4(d);\n}",
            pp_outline_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\nvec4 diffuseSum = texture2D(colorTexture, vUv);\n#if defined(LOG_SPACE)\ndiffuseSum = exp(diffuseSum);\n#endif\ndiffuseSum *= weightSum;\nvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\nvec2 uvOffset = delta;\nfor (int i = 1; i <= MAX_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\nvec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\nvec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n#if defined(LOG_SPACE)\nsample1 = exp(sample1);\nsample2 = exp(sample2);\n#endif\ndiffuseSum += ((sample1 + sample2) * w);\nweightSum += (2.0 * w);\nuvOffset += delta;\n}\nvec4 finalCol = diffuseSum / weightSum;\n#if defined(LOG_SPACE)\nfinalCol = log(finalCol);\n#endif\ngl_FragColor = finalCol;\n}",
            pp_outline_overlay_frag: "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform sampler2D edgeTexture1;\nuniform sampler2D edgeTexture2;\nuniform sampler2D patternTexture;\nuniform float edgeStrength;\nuniform float edgeGlow;\nuniform bool usePatternTexture;\nvoid main() {\nvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\nvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\nvec4 maskColor = texture2D(maskTexture, vUv);\nvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\nfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\nvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\nvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\nif (usePatternTexture)\nfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\nfloat maxChannel = max(finalColor.r, max(finalColor.g, finalColor.b));\nif (maxChannel != 0.0) {\nfinalColor.rgb /= maxChannel;\n}\ngl_FragColor = finalColor;\n}",
            pp_ssao_blur_frag: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 texelSize = (1.0 / resolution);\nfloat result = 0.0;\nfor (int i = - 2; i <= 2; i++) {\nfor (int j = - 2; j <= 2; j ++) {\nvec2 offset = (vec2(float(i), float(j))) * texelSize;\nresult += texture2D(tDiffuse, vUv + offset).r;\n}\n}\ngl_FragColor = vec4(vec3(result / (5.0 * 5.0)), 1.0);\n}",
            pp_ssao_depth_frag: "uniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nvarying vec2 vUv;\n#include <packing>\nfloat getLinearDepth(const in vec2 screenPosition) {\n#if PERSPECTIVE_CAMERA == 1\nfloat fragCoordZ = texture2D(tDepth, screenPosition).x;\nfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\nreturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n#else\nreturn texture2D(depthSampler, coord).x;\n#endif\n}\nvoid main() {\nfloat depth = getLinearDepth(vUv);\ngl_FragColor = vec4(vec3(1.0 - depth), 1.0);\n}",
            pp_ssao_frag: "uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform vec3 kernel[KERNEL_SIZE];\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float kernelRadius;\nuniform float minDistance;\nuniform float maxDistance;\nvarying vec2 vUv;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition) {\nreturn texture2D(tDepth, screenPosition).x;\n}\nfloat getLinearDepth(const in vec2 screenPosition) {\n#if PERSPECTIVE_CAMERA == 1\nfloat fragCoordZ = texture2D(tDepth, screenPosition).x;\nfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\nreturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n#else\nreturn texture2D(depthSampler, coord).x;\n#endif\n}\nfloat getViewZ(const in float depth) {\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n#endif\n}\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\nfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\nvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\nclipPosition *= clipW;\nreturn (cameraInverseProjectionMatrix * clipPosition).xyz;\n}\nvec3 getViewNormal(const in vec2 screenPosition) {\nreturn unpackRGBToNormal(texture2D(tNormal, screenPosition).xyz);\n}\nvoid main() {\nfloat depth = getDepth(vUv);\nfloat viewZ = getViewZ(depth);\nvec3 viewPosition = getViewPosition(vUv, depth, viewZ);\nvec3 viewNormal = getViewNormal(vUv);\nvec2 noiseScale = vec2(resolution.x / 4.0, resolution.y / 4.0);\nvec3 random = texture2D(tNoise, vUv * noiseScale).xyz;\nvec3 tangent = normalize(random - viewNormal * dot(random, viewNormal));\nvec3 bitangent = cross(viewNormal, tangent);\nmat3 kernelMatrix = mat3(tangent, bitangent, viewNormal);\nfloat occlusion = 0.0;\nfor (int i = 0; i < KERNEL_SIZE; i++) {\nvec3 sampleVector = kernelMatrix * kernel[i];\nvec3 samplePoint = viewPosition + (sampleVector * kernelRadius);\nvec4 samplePointNDC = cameraProjectionMatrix * vec4(samplePoint, 1.0);\nsamplePointNDC /= samplePointNDC.w;\nvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\nfloat realDepth = getLinearDepth(samplePointUv);\nfloat sampleDepth = viewZToOrthographicDepth(samplePoint.z, cameraNear, cameraFar);\nfloat delta = sampleDepth - realDepth;\nif (delta > minDistance && delta < maxDistance) {\nocclusion += 1.0;\n}\n}\nocclusion = clamp(occlusion / float(KERNEL_SIZE), 0.0, 1.0);\ngl_FragColor = vec4(vec3(1.0 - occlusion), 1.0);\n}",
            pp_tonemap_frag: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat alpha = clamp(texel.a, 0.0, 1.0);\ngl_FragColor = texel;\ngl_FragColor.rgb /= alpha;\n#include <tonemapping_fragment>\ngl_FragColor = LinearTosRGB(gl_FragColor);\ngl_FragColor.rgb *= alpha;\n}",
            raw_meshline_frag: "precision mediump float;\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\nuniform vec2 repeat;\nuniform vec3 color;\nuniform float opacity;\nvarying vec2 vUV;\nvarying float vCounters;\n#include <encodings_pars_fragment>\nvoid main() {\nvec4 c = vec4(color, opacity);\nif (useMap == 1.0) {\nc *= texture2D(map, vUV * repeat);\n}\nif (useAlphaMap == 1.0) {\nc.a *= texture2D(alphaMap, vUV * repeat).a;\n}\nif (c.a < alphaTest) {\ndiscard;\n}\ngl_FragColor = c;\ngl_FragColor.a *= step(vCounters, visibility);\ngl_FragColor = LinearTosRGB(gl_FragColor);\n}",
            raw_meshline_vert: "precision highp float;\nattribute vec3 position;\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute vec2 uv;\nattribute float counters;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\nvarying float vCounters;\nvarying vec2 vUV;\nconst float EQ_EPS = 0.000001;\nvec2 fix(vec4 i, float aspect) {\nvec2 res = i.xy / i.w;\nres.x *= aspect;\nreturn res;\n}\nbool posEqual(vec2 pos0, vec2 pos1) {\nreturn length(pos0 - pos1) < EQ_EPS;\n}\nvoid main() {\nfloat aspect = resolution.x / resolution.y;\nvCounters = counters;\nvUV = uv;\nmat4 m = projectionMatrix * modelViewMatrix;\nvec4 finalPosition = m * vec4(position, 1.0);\nvec4 prevPos = m * vec4(previous, 1.0);\nvec4 nextPos = m * vec4(next, 1.0);\nvec2 currentP = fix(finalPosition, aspect);\nvec2 prevP = fix(prevPos, aspect);\nvec2 nextP = fix(nextPos, aspect);\nfloat w = lineWidth * width;\nif (sizeAttenuation == 0.0) {\nw *= finalPosition.w / resolution.x;\n}\nvec2 dir;\nif (posEqual(nextP, currentP)) {\ndir = normalize(currentP - prevP);\n} else if (posEqual(prevP, currentP)) {\ndir = normalize(nextP - currentP);\n} else {\nvec2 dir1 = normalize(currentP - prevP);\nvec2 dir2 = normalize(nextP - currentP);\ndir = normalize(dir1 + dir2);\n}\nvec2 offset = vec2(-dir.y, dir.x);\noffset.y *= aspect;\noffset *= w;\nfinalPosition.xy += offset * side;\ngl_Position = finalPosition;\n}"
        },
        wa = {
            basic: {
                uniforms: na([va.common, va.specularmap, va.envmap, va.aomap, va.lightmap, va.fog]),
                vertexShader: Ma.meshbasic_vert,
                fragmentShader: Ma.meshbasic_frag
            },
            lambert: {
                uniforms: na([va.common, va.specularmap, va.envmap, va.aomap, va.lightmap, va.emissivemap, va.fog, va.lights, {
                    emissive: {
                        value: new Qr(0)
                    }
                }]),
                vertexShader: Ma.meshlambert_vert,
                fragmentShader: Ma.meshlambert_frag
            },
            phong: {
                uniforms: na([va.common, va.specularmap, va.envmap, va.aomap, va.lightmap, va.emissivemap, va.bumpmap, va.normalmap, va.displacementmap, va.fog, va.lights, {
                    emissive: {
                        value: new Qr(0)
                    },
                    specular: {
                        value: new Qr(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ma.meshphong_vert,
                fragmentShader: Ma.meshphong_frag
            },
            standard: {
                uniforms: na([va.common, va.envmap, va.aomap, va.lightmap, va.emissivemap, va.bumpmap, va.normalmap, va.displacementmap, va.roughnessmap, va.metalnessmap, va.fog, va.lights, {
                    emissive: {
                        value: new Qr(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ma.meshphysical_vert,
                fragmentShader: Ma.meshphysical_frag
            },
            toon: {
                uniforms: na([va.common, va.aomap, va.lightmap, va.emissivemap, va.bumpmap, va.normalmap, va.displacementmap, va.gradientmap, va.fog, va.lights, {
                    emissive: {
                        value: new Qr(0)
                    }
                }]),
                vertexShader: Ma.meshtoon_vert,
                fragmentShader: Ma.meshtoon_frag
            },
            matcap: {
                uniforms: na([va.common, va.bumpmap, va.normalmap, va.displacementmap, va.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Ma.meshmatcap_vert,
                fragmentShader: Ma.meshmatcap_frag
            },
            points: {
                uniforms: na([va.points, va.fog]),
                vertexShader: Ma.points_vert,
                fragmentShader: Ma.points_frag
            },
            dashed: {
                uniforms: na([va.common, va.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ma.linedashed_vert,
                fragmentShader: Ma.linedashed_frag
            },
            depth: {
                uniforms: na([va.common, va.displacementmap, {
                    slopeScaledBias: {
                        value: 0
                    }
                }]),
                vertexShader: Ma.depth_vert,
                fragmentShader: Ma.depth_frag
            },
            normal: {
                uniforms: na([va.common, va.bumpmap, va.normalmap, va.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ma.normal_vert,
                fragmentShader: Ma.normal_frag
            },
            sprite: {
                uniforms: na([va.sprite, va.fog]),
                vertexShader: Ma.sprite_vert,
                fragmentShader: Ma.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new gn
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: Ma.background_vert,
                fragmentShader: Ma.background_frag
            },
            cube: {
                uniforms: na([va.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ma.cube_vert,
                fragmentShader: Ma.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    invertU: {
                        value: !1
                    },
                    offsetU: {
                        value: 0
                    }
                },
                vertexShader: Ma.equirect_vert,
                fragmentShader: Ma.equirect_frag
            },
            distanceRGBA: {
                uniforms: na([va.common, va.displacementmap, {
                    referencePosition: {
                        value: new Tn
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    },
                    slopeScaledBias: {
                        value: 0
                    }
                }]),
                vertexShader: Ma.distanceRGBA_vert,
                fragmentShader: Ma.distanceRGBA_frag
            },
            shadow: {
                uniforms: na([va.lights, va.fog, {
                    color: {
                        value: new Qr(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ma.shadow_vert,
                fragmentShader: Ma.shadow_frag
            },
            mask: {
                uniforms: na([va.common, va.displacementmap, va.mask]),
                vertexShader: Ma.mask_vert,
                fragmentShader: Ma.mask_frag
            },
            equicube: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    faceIndex: {
                        value: 0
                    },
                    invertU: {
                        value: !1
                    },
                    offsetU: {
                        value: 0
                    }
                },
                vertexShader: Ma.equicube_vert,
                fragmentShader: Ma.equicube_frag
            },
            node: {
                uniforms: na([va.common, va.displacementmap, va.envmap, va.fog, va.lights, va.ssr, va.node, {
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ma.meshnode_vert,
                fragmentShader: Ma.meshnode_frag
            },
            cubeOctahedral: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    texelSize: {
                        value: new vn(.5, .5)
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_cube_octahedral_proj_frag
            }
        };

    function Sa(s, l, n, c, r) {
        var u, d, h = new Qr(0),
            f = 0,
            p = null,
            m = 0,
            v = null;

        function g(e, t) {
            n.buffers.color.setClear(e.r, e.g, e.b, t, r)
        }
        return {
            getClearColor: function() {
                return h
            },
            setClearColor: function(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
                h.set(e), g(h, f = t)
            },
            getClearAlpha: function() {
                return f
            },
            setClearAlpha: function(e) {
                g(h, f = e)
            },
            dispose: function() {
                u && (u.geometry.dispose(), u.material.dispose()), u = void 0, d && (d.geometry.dispose(), d.material.dispose()), d = void 0
            },
            render: function(e, t, n, r) {
                var i = t.background && t.background.isSceneBackground,
                    a = i ? t.background.data : t.background;
                a && a.isTexture && (a = l.get(a));
                var o = s.xr;
                (o = o.getSession && o.getSession()) && "additive" === o.environmentBlendMode && (a = null), null === a ? g(h, f) : a && a.isColor && (g(a, 1), r = !0), (s.autoClear || r) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), t = !!i && t.background.useHDR, a && (a.isCubeTexture || a.isWebGLCubeRenderTarget || a.mapping === B) ? (void 0 === d && ((d = new Ki(new ea(1, 1, 1), new oa({
                    name: "BackgroundCubeMaterial",
                    uniforms: ta(wa.cube.uniforms),
                    vertexShader: wa.cube.vertexShader,
                    fragmentShader: wa.cube.fragmentShader,
                    side: ae,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    useHDR: t
                }))).geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(e, t, n) {
                    var r = n.far;
                    this.matrixWorld.makeScale(r, r, r), this.matrixWorld.copyPosition(n.matrixWorld)
                }, Object.defineProperty(d.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }), c.update(d)), a.isWebGLCubeRenderTarget && (a = a.texture), d.material.uniforms.envMap.value = a, d.material.uniforms.flipEnvMap.value = a.isCubeTexture && a._needsFlipEnvMap ? -1 : 1, p === a && m === a.version && v === s.toneMapping || (d.material.needsUpdate = !0, m = (p = a).version, v = s.toneMapping), e.unshift(d, d.geometry, d.material, 0, 0, null)) : a && a.isTexture && (void 0 === u && ((u = new Ki(new ba(2, 2), new oa({
                    name: "BackgroundMaterial",
                    uniforms: ta(wa.background.uniforms),
                    vertexShader: wa.background.vertexShader,
                    fragmentShader: wa.background.fragmentShader,
                    side: ie,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), c.update(u)), !0 === (u.material.uniforms.t2D.value = a).matrixAutoUpdate && a.updateMatrix(), u.material.uniforms.uvTransform.value.copy(a.matrix), p === a && m === a.version && v === s.toneMapping || (u.material.needsUpdate = !0, m = (p = a).version, v = s.toneMapping), e.unshift(u, u.geometry, u.material, 0, 0, null))
            }
        }
    }

    function Aa(b, M, w, S) {
        var a = b.getParameter(34921),
            o = S.isWebGL2 ? null : M.get("OES_vertex_array_object"),
            l = S.isWebGL2 || null !== o,
            c = {},
            e = h(null),
            u = e;

        function d(e) {
            return S.isWebGL2 ? b.bindVertexArray(e) : o.bindVertexArrayOES(e)
        }

        function s(e) {
            return S.isWebGL2 ? b.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
        }

        function h(e) {
            for (var t = [], n = [], r = [], i = 0; i < a; i++) t[i] = 0, n[i] = 0, r[i] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: t,
                enabledAttributes: n,
                attributeDivisors: r,
                object: e,
                attributes: {},
                index: null
            }
        }

        function A() {
            for (var e = u.newAttributes, t = 0, n = e.length; t < n; t++) e[t] = 0
        }

        function T(e) {
            E(e, 0)
        }

        function E(e, t) {
            var n = u.newAttributes,
                r = u.enabledAttributes,
                i = u.attributeDivisors;
            n[e] = 1, 0 === r[e] && (b.enableVertexAttribArray(e), r[e] = 1), i[e] !== t && ((S.isWebGL2 ? b : M.get("ANGLE_instanced_arrays"))[S.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), i[e] = t)
        }

        function C() {
            for (var e = u.newAttributes, t = u.enabledAttributes, n = 0, r = t.length; n < r; n++) t[n] !== e[n] && (b.disableVertexAttribArray(n), t[n] = 0)
        }

        function L(e, t, n, r, i, a) {
            !0 !== S.isWebGL2 || 5124 !== n && 5125 !== n ? b.vertexAttribPointer(e, t, n, r, i, a) : b.vertexAttribIPointer(e, t, n, i, a)
        }

        function f() {
            t(), u !== e && d((u = e).object)
        }

        function t() {
            e.geometry = null, e.program = null, e.wireframe = !1
        }
        return {
            setup: function(e, t, n, s, r) {
                var i, a = !1;
                l ? (i = function(e, t, n) {
                    var r = !0 === n.wireframe,
                        n = c[e.id];
                    void 0 === n && (n = {}, c[e.id] = n);
                    e = n[t.id];
                    void 0 === e && (e = {}, n[t.id] = e);
                    t = e[r];
                    void 0 === t && (t = h(S.isWebGL2 ? b.createVertexArray() : o.createVertexArrayOES()), e[r] = t);
                    return t
                }(s, n, t), u !== i && d((u = i).object), (a = function(e, t) {
                    var n, r = u.attributes,
                        i = e.attributes,
                        a = 0;
                    for (n in i) {
                        var o = r[n],
                            s = i[n];
                        if (void 0 === o) return !0;
                        if (o.attribute !== s) return !0;
                        if (o.data !== s.data) return !0;
                        a++
                    }
                    return u.attributesNum !== a || u.index !== t
                }(s, r)) && function(e) {
                    var t, n = {},
                        r = s.attributes,
                        i = 0;
                    for (t in r) {
                        var a = r[t],
                            o = {};
                        (o.attribute = a).data && (o.data = a.data), n[t] = o, i++
                    }
                    u.attributes = n, u.attributesNum = i, u.index = e
                }(r)) : (i = !0 === t.wireframe, u.geometry === s.id && u.program === n.id && u.wireframe === i || (u.geometry = s.id, u.program = n.id, u.wireframe = i, a = !0)), !0 === e.isInstancedMesh && (a = !0), null !== r && w.update(r, 34963), a && (function(e, t, n, r) {
                    if (!1 !== S.isWebGL2 || !e.isInstancedMesh && !r.isInstancedBufferGeometry || null !== M.get("ANGLE_instanced_arrays")) {
                        A();
                        var i, a = r.attributes,
                            o = n.getAttributes(),
                            s = t.defaultAttributeValues;
                        for (i in o) {
                            var l = o[i];
                            if (0 <= l) {
                                var c = a[i];
                                if (void 0 !== c) {
                                    var u, d, h, f, p, m = c.normalized,
                                        v = c.itemSize,
                                        g = w.get(c);
                                    void 0 !== g && (u = g.buffer, d = g.type, h = g.bytesPerElement, c.isInterleavedBufferAttribute ? (f = c.data, p = f.stride, g = c.offset, f && f.isInstancedInterleavedBuffer ? (E(l, f.meshPerAttribute), void 0 === r._maxInstanceCount && (r._maxInstanceCount = f.meshPerAttribute * f.count)) : T(l), b.bindBuffer(34962, u), L(l, v, d, m, p * h, g * h)) : (c.isInstancedBufferAttribute ? (E(l, c.meshPerAttribute), void 0 === r._maxInstanceCount && (r._maxInstanceCount = c.meshPerAttribute * c.count)) : T(l), b.bindBuffer(34962, u), L(l, v, d, m, 0, 0)))
                                } else if ("instanceMatrix" === i) {
                                    m = w.get(e.instanceMatrix);
                                    void 0 !== m && (y = m.buffer, _ = m.type, E(l + 0, 1), E(l + 1, 1), E(l + 2, 1), E(l + 3, 1), b.bindBuffer(34962, y), b.vertexAttribPointer(l + 0, 4, _, !1, 64, 0), b.vertexAttribPointer(l + 1, 4, _, !1, 64, 16), b.vertexAttribPointer(l + 2, 4, _, !1, 64, 32), b.vertexAttribPointer(l + 3, 4, _, !1, 64, 48))
                                } else if ("instanceColor" === i) {
                                    var _, y = w.get(e.instanceColor);
                                    void 0 !== y && (_ = y.buffer, y = y.type, E(l, 1), b.bindBuffer(34962, _), b.vertexAttribPointer(l, 3, y, !1, 12, 0))
                                } else if (void 0 !== s) {
                                    var x = s[i];
                                    if (void 0 !== x) switch (x.length) {
                                        case 2:
                                            b.vertexAttrib2fv(l, x);
                                            break;
                                        case 3:
                                            b.vertexAttrib3fv(l, x);
                                            break;
                                        case 4:
                                            b.vertexAttrib4fv(l, x);
                                            break;
                                        default:
                                            b.vertexAttrib1fv(l, x)
                                    }
                                }
                            }
                        }
                        C()
                    }
                }(e, t, n, s), null !== r && b.bindBuffer(34963, w.get(r).buffer))
            },
            reset: f,
            resetDefaultState: t,
            dispose: function() {
                for (var e in f(), c) {
                    var t, n = c[e];
                    for (t in n) {
                        var r, i = n[t];
                        for (r in i) s(i[r].object), delete i[r];
                        delete n[t]
                    }
                    delete c[e]
                }
            },
            releaseStatesOfGeometry: function(e) {
                if (void 0 !== c[e.id]) {
                    var t, n = c[e.id];
                    for (t in n) {
                        var r, i = n[t];
                        for (r in i) s(i[r].object), delete i[r];
                        delete n[t]
                    }
                    delete c[e.id]
                }
            },
            releaseStatesOfProgram: function(e) {
                for (var t in c) {
                    var n = c[t];
                    if (void 0 !== n[e.id]) {
                        var r, i = n[e.id];
                        for (r in i) s(i[r].object), delete i[r];
                        delete n[e.id]
                    }
                }
            },
            initAttributes: A,
            enableAttribute: T,
            disableUnusedAttributes: C
        }
    }

    function Ta(a, o, s, e) {
        var l, c = e.isWebGL2;
        this.setMode = function(e) {
            l = e
        }, this.render = function(e, t) {
            a.drawArrays(l, e, t), s.update(t, l, 1)
        }, this.renderInstances = function(e, t, n) {
            if (0 !== n) {
                var r, i;
                if (c) r = a, i = "drawArraysInstanced";
                else if (i = "drawArraysInstancedANGLE", null === (r = o.get("ANGLE_instanced_arrays"))) return void console.error("v3d.WebGLBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                r[i](l, e, t, n), s.update(t, l, n)
            }
        }
    }

    function Ea(t, n, e) {
        var r;

        function i(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
            o = void 0 !== e.precision ? e.precision : "highp",
            s = i(o);
        s !== o && (console.warn("v3d.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
        var l = !0 === e.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            u = t.getParameter(35660),
            d = t.getParameter(3379),
            h = t.getParameter(34076),
            f = t.getParameter(34921),
            p = t.getParameter(36347),
            m = t.getParameter(36348),
            v = t.getParameter(36349),
            s = 0 < u,
            e = a || !!n.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function() {
                if (void 0 !== r) return r;
                var e = n.get("EXT_texture_filter_anisotropic");
                return r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: i,
            precision: o,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: h,
            maxAttributes: f,
            maxVertexUniforms: p,
            maxVaryings: m,
            maxFragmentUniforms: v,
            vertexTextures: s,
            floatFragmentTextures: e,
            floatVertexTextures: s && e,
            maxSamples: a ? t.getParameter(36183) : 0
        }
    }

    function Ca(c) {
        var u = this,
            d = null,
            h = 0,
            f = !1,
            p = !1,
            m = new Rr,
            v = new gn,
            g = {
                value: null,
                needsUpdate: !1
            };

        function _() {
            g.value !== d && (g.value = d, g.needsUpdate = 0 < h), u.numPlanes = h, u.numIntersection = 0
        }

        function y(e, t, n, r) {
            var i = null !== e ? e.length : 0,
                a = null;
            if (0 !== i) {
                if (a = g.value, !0 !== r || null === a) {
                    var r = n + 4 * i,
                        o = t.matrixWorldInverse;
                    v.getNormalMatrix(o), (null === a || a.length < r) && (a = new Float32Array(r));
                    for (var s = 0, l = n; s !== i; ++s, l += 4) m.copy(e[s]).applyMatrix4(o, v), m.normal.toArray(a, l), a[l + 3] = m.constant
                }
                g.value = a, g.needsUpdate = !0
            }
            return u.numPlanes = i, u.numIntersection = 0, a
        }
        this.uniform = g, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, n) {
            var r = 0 !== e.length || t || 0 !== h || f;
            return f = t, d = y(e, n, 0), h = e.length, r
        }, this.beginShadows = function() {
            p = !0, y(null)
        }, this.endShadows = function() {
            p = !1, _()
        }, this.setState = function(e, t, n) {
            var r = e.clippingPlanes,
                i = e.clipIntersection,
                a = e.clipShadows,
                e = c.get(e);
            if (!f || null === r || 0 === r.length || p && !a) p ? y(null) : _();
            else {
                var a = p ? 0 : h,
                    o = 4 * a,
                    s = e.clippingState || null;
                g.value = s, s = y(r, t, o, n);
                for (var l = 0; l !== o; ++l) s[l] = d[l];
                e.clippingState = s, this.numIntersection = i ? this.numPlanes : 0, this.numPlanes += a
            }
        }
    }

    function La(i) {
        var a = new WeakMap;

        function o(e, t) {
            return t === F ? e.mapping = N : t === k && (e.mapping = I), e
        }

        function s(e) {
            var t = e.target;
            t.removeEventListener("dispose", s);
            e = a.get(t);
            void 0 !== e && (a.delete(t), e.dispose())
        }
        return {
            get: function(e) {
                if (e && e.isTexture) {
                    var t = e.mapping;
                    if (t === F || t === k) {
                        if (a.has(e)) return o(a.get(e).texture, e.mapping);
                        var n = e.image;
                        if (n && 0 < n.height) {
                            var r = i.getRenderList(),
                                t = i.getRenderTarget(),
                                n = new da(n.height / 2);
                            return n.fromEquirectangularTexture(i, e), a.set(e, n), i.setRenderTarget(t), i.setRenderList(r), e.addEventListener("dispose", s), o(n.texture, e.mapping)
                        }
                        return null
                    }
                }
                return e
            },
            dispose: function() {
                a = new WeakMap
            }
        }
    }

    function Pa(n) {
        var r = {};
        return {
            has: function(e) {
                if (void 0 !== r[e]) return null !== r[e];
                var t;
                switch (e) {
                    case "WEBGL_depth_texture":
                        t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        t = n.getExtension(e)
                }
                return null !== (r[e] = t)
            },
            get: function(e) {
                return this.has(e) || console.warn("v3d.WebGLRenderer: " + e + " extension not supported."), r[e]
            }
        }
    }

    function Ra(e, g, i, a) {
        var o = new WeakMap,
            _ = new WeakMap;

        function s(e) {
            var t, n = e.target,
                r = o.get(n);
            for (t in null !== r.index && g.remove(r.index), r.attributes) g.remove(r.attributes[t]);
            n.removeEventListener("dispose", s), o.delete(n);
            e = _.get(r);
            e && (g.remove(e), _.delete(r)), a.releaseStatesOfGeometry(r), !0 === n.isInstancedBufferGeometry && delete n._maxInstanceCount, i.memory.geometries--
        }

        function r(e) {
            var t = [],
                n = e.index,
                r = e.attributes.position,
                i = 0;
            if (null !== n)
                for (var a = n.array, i = n.version, o = 0, s = a.length; o < s; o += 3) {
                    var l = a[o + 0],
                        c = a[o + 1],
                        u = a[o + 2];
                    t.push(l, c, c, u, u, l)
                } else {
                    var d = r.array;
                    i = r.version;
                    for (var h = 0, f = d.length / 3 - 1; h < f; h += 3) {
                        var p = h + 0,
                            m = h + 1,
                            v = h + 2;
                        t.push(p, m, m, v, v, p)
                    }
                }
            d = new(65535 < mi(t) ? ui : li)(t, 1);
            d.version = i;
            i = _.get(e);
            i && g.remove(i), _.set(e, d)
        }
        return {
            get: function(e, t) {
                var n = o.get(t);
                return n || (t.addEventListener("dispose", s), t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Oi).setFromObject(e)), n = t._bufferGeometry), o.set(t, n), i.memory.geometries++, n)
            },
            update: function(e) {
                var t, n = e.attributes;
                for (t in n) g.update(n[t], 34962);
                var r, i = e.morphAttributes;
                for (r in i)
                    for (var a = i[r], o = 0, s = a.length; o < s; o++) g.update(a[o], 34962)
            },
            getWireframeAttribute: function(e) {
                var t, n = _.get(e);
                return (!n || null !== (t = e.index) && n.version < t.version) && r(e), _.get(e)
            }
        }
    }

    function Da(a, o, s, e) {
        var l, c, u, d = e.isWebGL2;
        this.setMode = function(e) {
            l = e
        }, this.setIndex = function(e) {
            c = e.type, u = e.bytesPerElement
        }, this.render = function(e, t) {
            a.drawElements(l, t, c, e * u), s.update(t, l, 1)
        }, this.renderInstances = function(e, t, n) {
            if (0 !== n) {
                var r, i;
                if (d) r = a, i = "drawElementsInstanced";
                else if (i = "drawElementsInstancedANGLE", null === (r = o.get("ANGLE_instanced_arrays"))) return void console.error("v3d.WebGLIndexedBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                r[i](l, t, c, e * u, n), s.update(t, l, n)
            }
        }
    }

    function Oa(e) {
        var a = {
                geometries: 0,
                textures: 0,
                textureSpecs: new Map
            },
            r = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
        return {
            memory: a,
            render: r,
            programs: null,
            autoReset: !0,
            reset: function() {
                r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
            },
            update: function(e, t, n) {
                switch (r.calls++, t) {
                    case 4:
                        r.triangles += n * (e / 3);
                        break;
                    case 1:
                        r.lines += n * (e / 2);
                        break;
                    case 3:
                        r.lines += n * (e - 1);
                        break;
                    case 2:
                        r.lines += n * e;
                        break;
                    case 0:
                        r.points += n * e;
                        break;
                    default:
                        console.error("v3d.WebGLInfo: Unknown draw mode:", t)
                }
            },
            addTextureSpec: function(e) {
                var t, n, r, i = e.isWebGLRenderTarget ? (t = e.texture.name, n = "WebGLRenderTarget", r = e.width, e.height) : (t = e.name, n = "Texture", r = e.image.width, e.image.height);
                a.textureSpecs.set(e, {
                    name: t,
                    type: n,
                    width: r,
                    height: i
                })
            },
            removeTextureSpec: function(e) {
                a.textureSpecs.delete(e)
            }
        }
    }

    function Na(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function Ia(g) {
        var _ = {},
            y = new Float32Array(12);
        return {
            update: function(e, t, n, r) {
                var i = e.morphTargetInfluences,
                    a = void 0 === i ? 0 : i.length,
                    o = _[t.id];
                if (void 0 === o) {
                    o = [];
                    for (var s = 0; s < a; s++) o[s] = [s, 0];
                    _[t.id] = o
                }
                for (var l = n.morphTargets && t.morphAttributes.position, c = n.morphNormals && t.morphAttributes.normal, u = 0; u < a; u++) 0 !== o[u][1] && (l && t.deleteAttribute("morphTarget" + u), c && t.deleteAttribute("morphNormal" + u));
                for (var d = 0; d < a; d++) {
                    var h = o[d];
                    h[0] = d, h[1] = i[d]
                }
                o.sort(Na);
                for (var f = 0, p = 0; p < y.length; p++) {
                    var m = o[p];
                    if (m) {
                        var v = m[0],
                            m = m[1];
                        if (m) {
                            l && t.setAttribute("morphTarget" + p, l[v]), c && t.setAttribute("morphNormal" + p, c[v]), f += y[p] = m;
                            continue
                        }
                    }
                    y[p] = 0
                }
                n = t.morphTargetsRelative ? 1 : 1 - f, r.getUniforms().setValue(g, "morphTargetBaseInfluence", n), r.getUniforms().setValue(g, "morphTargetInfluences", y)
            }
        }
    }

    function Fa(e, i, a, o) {
        var s = new WeakMap;

        function l(e) {
            e = e.target;
            e.removeEventListener("dispose", l), a.remove(e.instanceMatrix), null !== e.instanceColor && a.remove(e.instanceColor)
        }
        return {
            update: function(e) {
                var t = o.render.frame,
                    n = e.geometry,
                    r = i.get(e, n);
                return s.get(r) !== t && (n.isGeometry && r.updateFromObject(e), i.update(r), s.set(r, t)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", l) && e.addEventListener("dispose", l), a.update(e.instanceMatrix, 34962), null !== e.instanceColor && a.update(e.instanceColor, 34962)), r
            },
            dispose: function() {
                s = new WeakMap
            }
        }
    }

    function ka() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
        xn.call(this, null), this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        }, this.magFilter = ke, this.minFilter = ke, this.wrapR = V, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function Ba() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1;
        xn.call(this, null), this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        }, this.magFilter = ke, this.minFilter = ke, this.wrapR = V, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    wa.physical = {
        uniforms: na([wa.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new vn(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Qr(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }]),
        vertexShader: Ma.meshphysical_vert,
        fragmentShader: Ma.meshphysical_frag
    }, wa.copy = {
        defines: {
            MAP_TEXELS: 0
        },
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_copy_frag
    }, wa.bokeh = {
        defines: {
            DEPTH_PACKING: 1,
            PERSPECTIVE_CAMERA: 1
        },
        uniforms: {
            tColor: {
                value: null
            },
            tDepth: {
                value: null
            },
            focus: {
                value: 1
            },
            aspect: {
                value: 1
            },
            aperture: {
                value: .025
            },
            maxblur: {
                value: 1
            },
            nearClip: {
                value: 1
            },
            farClip: {
                value: 1e3
            },
            depthLeakThreshold: {
                value: .2
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_bokeh_frag
    }, wa.fxaa = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            resolution: {
                value: new vn(1 / 1024, 1 / 512)
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_fxaa_frag
    }, wa.grayscale = {
        uniforms: {
            tDiffuse: {
                value: null
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_grayscale_frag
    }, wa.brightness_contrast = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            brightness: {
                value: 0
            },
            contrast: {
                value: 0
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_brightness_contrast_frag
    }, wa.bloomLumHighPass = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null
            },
            luminosityThreshold: {
                type: "f",
                value: 1
            },
            smoothWidth: {
                type: "f",
                value: 1
            },
            defaultColor: {
                type: "c",
                value: new Qr(0)
            },
            defaultOpacity: {
                type: "f",
                value: 0
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_bloom_lum_high_pass_frag
    }, wa.blur = {
        defines: {
            LOG_SPACE: 0,
            OCTAHEDRAL_MAP: 0
        },
        uniforms: {
            colorTexture: {
                value: null
            },
            texSize: {
                value: new vn(.5, .5)
            },
            direction: {
                value: new vn(.5, .5)
            },
            kernelRadius: {
                value: 1
            }
        },
        customPrepTokens: {
            MAX_SAMPLE_RADIUS: 4
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_blur_frag
    }, wa.tonemap = {
        uniforms: {
            tDiffuse: {
                value: null
            }
        },
        vertexShader: Ma.pp_plane_vert,
        fragmentShader: Ma.pp_tonemap_frag
    }, ((ka.prototype = Object.create(xn.prototype)).constructor = ka).prototype.isDataTexture2DArray = !0, ((Ba.prototype = Object.create(xn.prototype)).constructor = Ba).prototype.isDataTexture3D = !0;
    var za = new xn,
        Ua = new ka,
        Va = new Ba,
        Ga = new ua,
        ja = [],
        Wa = [],
        Ha = new Float32Array(16),
        Xa = new Float32Array(9),
        Ya = new Float32Array(4);

    function qa(e, t, n) {
        var r = e[0];
        if (r <= 0 || 0 < r) return e;
        var i = t * n,
            a = ja[i];
        if (void 0 === a && (a = new Float32Array(i), ja[i] = a), 0 !== t) {
            r.toArray(a, 0);
            for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
        }
        return a
    }

    function Za(e, t) {
        if (e.length === t.length) {
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] !== t[n]) return;
            return 1
        }
    }

    function Qa(e, t) {
        for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
    }

    function Ka(e, t) {
        var n = Wa[t];
        void 0 === n && (n = new Int32Array(t), Wa[t] = n);
        for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
        return n
    }

    function Ja(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function $a(e, t) {
        var n = this.cache;
        void 0 !== t.x ? n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y) : Za(n, t) || (e.uniform2fv(this.addr, t), Qa(n, t))
    }

    function eo(e, t) {
        var n = this.cache;
        void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z) : void 0 !== t.r ? n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b) : Za(n, t) || (e.uniform3fv(this.addr, t), Qa(n, t))
    }

    function to(e, t) {
        var n = this.cache;
        void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w) : Za(n, t) || (e.uniform4fv(this.addr, t), Qa(n, t))
    }

    function no(e, t) {
        var n = this.cache,
            r = t.elements;
        void 0 === r ? Za(n, t) || (e.uniformMatrix2fv(this.addr, !1, t), Qa(n, t)) : Za(n, r) || (Ya.set(r), e.uniformMatrix2fv(this.addr, !1, Ya), Qa(n, r))
    }

    function ro(e, t) {
        var n = this.cache,
            r = t.elements;
        void 0 === r ? Za(n, t) || (e.uniformMatrix3fv(this.addr, !1, t), Qa(n, t)) : Za(n, r) || (Xa.set(r), e.uniformMatrix3fv(this.addr, !1, Xa), Qa(n, r))
    }

    function io(e, t) {
        var n = this.cache,
            r = t.elements;
        void 0 === r ? Za(n, t) || (e.uniformMatrix4fv(this.addr, !1, t), Qa(n, t)) : Za(n, r) || (Ha.set(r), e.uniformMatrix4fv(this.addr, !1, Ha), Qa(n, r))
    }

    function ao(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || za, i)
    }

    function oo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Ua, i)
    }

    function so(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Va, i)
    }

    function lo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || Ga, i)
    }

    function co(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function uo(e, t) {
        var n = this.cache;
        Za(n, t) || (e.uniform2iv(this.addr, t), Qa(n, t))
    }

    function ho(e, t) {
        var n = this.cache;
        Za(n, t) || (e.uniform3iv(this.addr, t), Qa(n, t))
    }

    function fo(e, t) {
        var n = this.cache;
        Za(n, t) || (e.uniform4iv(this.addr, t), Qa(n, t))
    }

    function po(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
    }

    function mo(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function vo(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function go(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function _o(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function yo(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function xo(e, t) {
        t = qa(t, this.size, 2);
        e.uniform2fv(this.addr, t)
    }

    function bo(e, t) {
        t = qa(t, this.size, 3);
        e.uniform3fv(this.addr, t)
    }

    function Mo(e, t) {
        t = qa(t, this.size, 4);
        e.uniform4fv(this.addr, t)
    }

    function wo(e, t) {
        t = qa(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, t)
    }

    function So(e, t) {
        t = qa(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, t)
    }

    function Ao(e, t) {
        t = qa(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, t)
    }

    function To(e, t, n) {
        var r = t.length,
            i = Ka(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || za, i[a])
    }

    function Eo(e, t, n) {
        var r = t.length,
            i = Ka(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || Ga, i[a])
    }

    function Co(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return Ja;
                case 35664:
                    return $a;
                case 35665:
                    return eo;
                case 35666:
                    return to;
                case 35674:
                    return no;
                case 35675:
                    return ro;
                case 35676:
                    return io;
                case 5124:
                case 35670:
                    return co;
                case 35667:
                case 35671:
                    return uo;
                case 35668:
                case 35672:
                    return ho;
                case 35669:
                case 35673:
                    return fo;
                case 5125:
                    return po;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return ao;
                case 35679:
                case 36299:
                case 36307:
                    return so;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return lo;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return oo
            }
        }(t.type)
    }

    function Lo(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return mo;
                case 35664:
                    return xo;
                case 35665:
                    return bo;
                case 35666:
                    return Mo;
                case 35674:
                    return wo;
                case 35675:
                    return So;
                case 35676:
                    return Ao;
                case 5124:
                case 35670:
                    return vo;
                case 35667:
                case 35671:
                    return go;
                case 35668:
                case 35672:
                    return _o;
                case 35669:
                case 35673:
                    return yo;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return To;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Eo
            }
        }(t.type)
    }

    function Po(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    Lo.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Qa(t, e)
    }, Po.prototype.setValue = function(e, t, n) {
        for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
            var o = r[i];
            o.setValue(e, t[o.id], n)
        }
    };
    var Ro = /(\w+)(\])?(\[|\.)?/g;

    function Do(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function Oo(e, t) {
        this.seq = [], this.map = {};
        for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
            var i = e.getActiveUniform(t, r);
            ! function(e, t, n) {
                var r = e.name,
                    i = r.length;
                for (Ro.lastIndex = 0;;) {
                    var a = Ro.exec(r),
                        o = Ro.lastIndex,
                        s = a[1],
                        l = "]" === a[2],
                        a = a[3];
                    if (l && (s |= 0), void 0 === a || "[" === a && o + 2 === i) {
                        Do(n, new(void 0 === a ? Co : Lo)(s, e, t));
                        break
                    }
                    a = n.map[s];
                    void 0 === a && Do(n, a = new Po(s)), n = a
                }
            }(i, e.getUniformLocation(t, i.name), this)
        }
    }

    function No(e, t, n) {
        t = e.createShader(t);
        return e.shaderSource(t, n), e.compileShader(t), t
    }
    Oo.prototype.setValue = function(e, t, n, r) {
        t = this.map[t];
        void 0 !== t && t.setValue(e, n, r)
    }, Oo.prototype.setOptional = function(e, t, n) {
        t = t[n];
        void 0 !== t && this.setValue(e, n, t)
    }, Oo.upload = function(e, t, n, r) {
        for (var i = 0, a = t.length; i !== a; ++i) {
            var o = t[i],
                s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, r)
        }
    }, Oo.seqWithValue = function(e, t) {
        for (var n = [], r = 0, i = e.length; r !== i; ++r) {
            var a = e[r];
            a.id in t && n.push(a)
        }
        return n
    };
    var Io = 0;

    function Fo(e) {
        switch (e) {
            case Vt:
                return ["Linear", "(value)"];
            case Gt:
                return ["sRGB", "(value)"];
            case jt:
                return ["RGBE", "(value)"];
            case Ht:
                return ["RGBM", "(value, 7.0)"];
            case Xt:
                return ["RGBM", "(value, 16.0)"];
            case Yt:
                return ["RGBD", "(value, 256.0)"];
            case r:
                return ["Gamma", "(value, float(GAMMA_FACTOR))"];
            case Wt:
                return ["LogLuv", "(value)"];
            default:
                return console.warn("v3d.WebGLProgram: Unsupported encoding:", e), ["Linear", "(value)"]
        }
    }

    function ko(e, t, n) {
        var r = e.getShaderParameter(t, 35713),
            i = e.getShaderInfoLog(t).trim();
        return r && "" === i ? "" : "v3d.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(e) {
            for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
            return t.join("\n")
        }(e.getShaderSource(t))
    }

    function Bo(e, t) {
        t = Fo(t);
        return "vec4 " + e + "(vec4 value) { return " + t[0] + "ToLinear" + t[1] + "; }"
    }

    function zo(e) {
        return "" !== e
    }

    function Uo(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function Vo(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function Go(e, t) {
        var n = Object.keys(t);
        if (n.length) {
            n = new RegExp(n.join("|"), "g");
            return e.replace(n, function(e) {
                return t[e]
            })
        }
        return e
    }

    function jo(e, t) {
        for (var n in t) e = e.replace("#include <" + n + ">", t[n]);
        return e
    }
    var Wo = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Ho(e) {
        return e.replace(Wo, Xo)
    }

    function Xo(e, t) {
        var n = Ma[t];
        if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
        return Ho(n)
    }

    function Yo(e) {
        for (var t, n = new RegExp("#pragma unroll_loop_start[\\s]+?for \\(int (\\w+) \\= (\\d+)\\; (\\w+) <(=?) (\\w+)\\; (\\w+)\\+\\+\\) \\{"), r = new RegExp("\\{|\\}", "g"); t = n.exec(e);) {
            for (var i, a = void 0, o = a = r.lastIndex = t.index + t[0].length, s = 1;
                (i = r.exec(e)) && ("{" == i[0] ? s++ : "}" == i[0] && s--, a = i.index), i && 0 < s;);
            if (0 == s) {
                for (var l = e.substring(t.index, r.lastIndex), c = e.substring(o, a), u = new RegExp("\\[".concat(t[1], "\\]"), "g"), d = new RegExp("\\(".concat(t[1], "\\)"), "g"), h = "", o = parseInt(t[2]), f = parseInt(t[5]) + ("=" === t[4] ? 1 : 0), p = o; p < f; p++) h += "{" + c.replace(u, "[".concat(p, "]")).replace(d, "(".concat(p, ")")) + "}";
                e = e.replace(l, h)
            }
        }
        return e = e.replace("#pragma unroll_loop_end", "")
    }

    function qo(e) {
        var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Zo(s, e, t, n) {
        var l, c, u = s.getContext(),
            r = t.defines,
            i = t.vertexShader,
            a = t.fragmentShader,
            o = (v = "SHADOWMAP_TYPE_BASIC", (m = t).shadowMapType === J ? v = "SHADOWMAP_TYPE_PCF" : m.shadowMapType === $ ? v = "SHADOWMAP_TYPE_PCF_SOFT" : m.shadowMapType === ee ? v = "SHADOWMAP_TYPE_VSM" : m.shadowMapType === te ? v = "SHADOWMAP_TYPE_ESM" : m.shadowMapType === ne ? v = "SHADOWMAP_TYPE_PCF_POISSON_DISK" : m.shadowMapType === re && (v = "SHADOWMAP_TYPE_BILINEAR"), v),
            d = function(e) {
                var t = "ENVMAP_TYPE_CUBE";
                if (e.envMap) switch (e.envMapMode) {
                    case N:
                    case I:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case B:
                    case z:
                        t = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case F:
                    case k:
                        t = "ENVMAP_TYPE_EQUIREC"
                }
                return t
            }(t),
            h = function(e) {
                var t = "ENVMAP_MODE_REFLECTION";
                if (e.envMap) switch (e.envMapMode) {
                    case I:
                    case k:
                        t = "ENVMAP_MODE_REFRACTION"
                }
                return t
            }(t),
            f = function(e) {
                var t = "ENVMAP_BLENDING_NONE";
                if (e.envMap) switch (e.combine) {
                    case T:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case E:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case C:
                        t = "ENVMAP_BLENDING_ADD"
                }
                return t
            }(t),
            p = 0 < s.gammaFactor ? s.gammaFactor : 1,
            m = t.unitsScaleFactor % 1 ? String(t.unitsScaleFactor) : String(t.unitsScaleFactor) + ".0",
            v = t.isWebGL2 ? "" : [(g = t).extensionDerivatives || g.envMapCubeUV || g.bumpMap || g.tangentSpaceNormalMap || g.clearcoatNormalMap || g.flatShading || "physical" === g.shaderID || g.useSlopeScaledBias ? "#extension GL_OES_standard_derivatives : enable" : "", (g.extensionFragDepth || g.logarithmicDepthBuffer) && g.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", g.extensionDrawBuffers && g.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (g.extensionShaderTextureLOD || g.envMap) && g.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(zo).join("\n"),
            g = function(e) {
                var t, n = [];
                for (t in e) {
                    var r = e[t];
                    !1 !== r && n.push("#define " + t + " " + r)
                }
                return n.join("\n")
            }(r),
            _ = u.createProgram(),
            y = this,
            r = t.glslVersion ? "#version " + t.glslVersion + "\n" : "";
        t.isRawShaderMaterial ? (0 < (l = [g].filter(zo).join("\n")).length && (l += "\n"), 0 < (c = [v, g].filter(zo).join("\n")).length && (c += "\n")) : (l = [qo(t), "#define SHADER_NAME " + t.shaderName, s.compatSettings.saturateSpecEnvBlenderApprox ? "#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX" : "", s.compatSettings.useSpecEnvBlenderApprox ? "#define COMPAT_USE_SPEC_ENV_BLENDER_APPROX" : "", g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + t.maxBones, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.useVertexTexture ? "#define BONE_TEXTURE" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && !1 === t.flatShading ? "#define USE_MORPHNORMALS" : "", "#define NUM_MORPH_TARGETS " + t.numMorphTargets, t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + o : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "\n            uniform mat4 modelMatrix;\n            uniform mat4 modelViewMatrix;\n            uniform mat4 projectionMatrix;\n            uniform mat4 viewMatrix;\n            uniform mat3 normalMatrix;\n            uniform vec3 cameraPosition;\n            uniform bool isOrthographic;\n\n            #ifdef USE_INSTANCING\n                attribute mat4 instanceMatrix;\n            #endif\n\n            #ifdef USE_INSTANCING_COLOR\n                attribute vec3 instanceColor;\n            #endif\n\n            attribute vec3 position;\n            attribute vec3 normal;\n            attribute vec2 uv;\n\n            #ifdef USE_TANGENT\n                attribute vec4 tangent;\n            #endif\n\n            #ifdef USE_COLOR\n                attribute vec3 color;\n            #endif\n\n            #ifdef USE_MORPHTARGETS\n                #if NUM_MORPH_TARGETS > 0\n                    attribute vec3 morphTarget0;\n                #endif\n                #if NUM_MORPH_TARGETS > 1\n                    attribute vec3 morphTarget1;\n                #endif\n                #if NUM_MORPH_TARGETS > 2\n                    attribute vec3 morphTarget2;\n                #endif\n                #if NUM_MORPH_TARGETS > 3\n                    attribute vec3 morphTarget3;\n                #endif\n                #if NUM_MORPH_TARGETS > 4\n                    attribute vec3 morphTarget4;\n                #endif\n                #if NUM_MORPH_TARGETS > 5\n                    attribute vec3 morphTarget5;\n                #endif\n\n                #ifdef USE_MORPHNORMALS\n                    #if NUM_MORPH_TARGETS > 0\n                        attribute vec3 morphNormal0;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 1\n                        attribute vec3 morphNormal1;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 2\n                        attribute vec3 morphNormal2;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 3\n                        attribute vec3 morphNormal3;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 4\n                        attribute vec3 morphNormal4;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 5\n                        attribute vec3 morphNormal5;\n                    #endif\n                #else\n                    #if NUM_MORPH_TARGETS > 6\n                        attribute vec3 morphTarget6;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 7\n                        attribute vec3 morphTarget7;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 8\n                        attribute vec3 morphTarget8;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 9\n                        attribute vec3 morphTarget9;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 10\n                        attribute vec3 morphTarget10;\n                    #endif\n                    #if NUM_MORPH_TARGETS > 11\n                        attribute vec3 morphTarget11;\n                    #endif\n                #endif\n            #endif\n\n            #ifdef USE_SKINNING\n                attribute vec4 skinIndex;\n                attribute vec4 skinWeight;\n            #endif\n            "].filter(zo).join("\n"), c = [v, qo(t), "#define SHADER_NAME " + t.shaderName, g, function(e) {
            switch (e) {
                case "blender":
                    return "#define MT_BLENDER";
                case "max":
                    return "#define MT_MAX";
                case "maya":
                    return "#define MT_MAYA";
                default:
                    return ""
            }
        }(t.materialProfile), s.compatSettings.saturateSpecEnvBlenderApprox ? "#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX" : "", s.compatSettings.useSpecEnvBlenderApprox ? "#define COMPAT_USE_SPEC_ENV_BLENDER_APPROX" : "", t.alphaTest ? "#define ALPHATEST " + t.alphaTest + (t.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + f : "", 0 !== t.envMapCubeUVTileSize ? "#define cubeUV_maxTileSize ".concat(bi(t.envMapCubeUVTileSize)) : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.sheen ? "#define USE_SHEEN" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + o : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", t.physicallyCorrectLights ? "#define UNITS_SCALE_FACTOR " + m : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping === L || t.useHDR ? "" : "#define TONE_MAPPING", t.toneMapping === L || t.useHDR ? "" : Ma.tonemapping_pars_fragment, t.toneMapping === L || t.useHDR ? "" : function(e, t) {
            var n;
            switch (t) {
                case Oe:
                    n = "Linear";
                    break;
                case P:
                    n = "Reinhard";
                    break;
                case R:
                    n = "OptimizedCineon";
                    break;
                case D:
                    n = "ACESFilmic";
                    break;
                case Ne:
                    n = "LogarithmicMax";
                    break;
                case Ie:
                    n = "PhysicalMax";
                    break;
                case O:
                    n = "FilmicBlender";
                    break;
                default:
                    console.warn("v3d.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
            }
            return "vec3 " + e + "(vec3 color) { return " + n + "ToneMapping(color); }"
        }("toneMapping", t.toneMapping), t.dithering ? "#define DITHERING" : "", Ma.encodings_pars_fragment, t.map ? Bo("mapTexelToLinear", t.mapEncoding) : "", t.matcap ? Bo("matcapTexelToLinear", t.matcapEncoding) : "", t.envMap ? Bo("envMapTexelToLinear", t.envMapEncoding) : "", t.emissiveMap ? Bo("emissiveMapTexelToLinear", t.emissiveMapEncoding) : "", t.lightMap ? Bo("lightMapTexelToLinear", t.lightMapEncoding) : "", (o = "linearToOutputTexel", m = Fo(m = t.outputEncoding), "vec4 " + o + "(vec4 value) { return LinearTo" + m[0] + m[1] + "; }"), t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", t.distancePacking ? "#define DISTANCE_PACKING " + t.distancePacking : "", t.useSlopeScaledBias ? "#define USE_SLOPE_SCALED_BIAS" : "", "#define ESM_DISTANCE_SCALE ".concat(bi(t.esmDistanceScale)), "\n"].filter(zo).join("\n")), t.isMeshNodeMaterial && (i = jo(i, t.nodeChunks), a = jo(a, t.nodeChunks)), i = Vo(i = Uo(i = Ho(i), t), t), t.customPrepTokens && (i = Go(i, t.customPrepTokens)), a = Vo(a = Uo(a = Ho(a), t), t), t.customPrepTokens && (a = Go(a, t.customPrepTokens)), i = Yo(i), a = Yo(a), t.isWebGL2 && !0 !== t.isRawShaderMaterial && (r = "#version 300 es\n", l = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + l, c = ["#define varying in", t.glslVersion === an ? "" : "out highp vec4 pc_fragColor;", t.glslVersion === an ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + c);
        i = r + l + i, a = r + c + a;
        s.debug.disableCompiledShaderCache && (i += "\nconst float ANTI_CACHE = " + Math.random() + ";", a += "\nconst float ANTI_CACHE = " + Math.random() + ";");
        var x = No(u, 35633, i),
            b = No(u, 35632, a);
        u.attachShader(_, x), u.attachShader(_, b), void 0 !== t.index0AttributeName ? u.bindAttribLocation(_, 0, t.index0AttributeName) : !0 === t.morphTargets && u.bindAttribLocation(_, 0, "position"), u.linkProgram(_);
        var M, w, S = !0;

        function A() {
            var e, t, n, r, i, a, o;
            S = !1, s.debug.checkShaderErrors && (e = u.getProgramInfoLog(_).trim(), t = u.getShaderInfoLog(x).trim(), n = u.getShaderInfoLog(b).trim(), !(i = r = !0) === u.getProgramParameter(_, 35714) ? (r = !1, a = ko(u, x, "vertex"), o = ko(u, b, "fragment"), console.error("v3d.WebGLProgram: shader error: ", u.getError(), "35715", u.getProgramParameter(_, 35715), "gl.getProgramInfoLog", e, a, o)) : "" !== e ? console.warn("v3d.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== n || (i = !1), i && (y.diagnostics = {
                runnable: r,
                programLog: e,
                vertexShader: {
                    log: t,
                    prefix: l
                },
                fragmentShader: {
                    log: n,
                    prefix: c
                }
            })), u.deleteShader(x), u.deleteShader(b)
        }
        return this.getUniforms = function() {
            return void 0 === M && (S && A(), M = new Oo(u, _)), M
        }, this.getAttributes = function() {
            return void 0 === w && (S && A(), w = function(e, t) {
                for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                    var a = e.getActiveAttrib(t, i).name;
                    n[a] = e.getAttribLocation(t, a)
                }
                return n
            }(u, _)), w
        }, this.destroy = function() {
            n.releaseStatesOfProgram(this), u.deleteProgram(_), this.program = void 0
        }, this.name = t.shaderName, this.id = Io++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = x, this.fragmentShader = b, this.profile = {
            calcRenderTime: !1,
            renderTime: 0,
            timerQueries: [],
            materials: []
        }, this.getTexUniformCount = function() {
            return this.getUniforms().seq.reduce(function(e, t) {
                if (t.info) switch (t.info.type) {
                    case 35678:
                    case 35679:
                    case 35680:
                    case 35682:
                    case 36289:
                    case 36292:
                    case 36293:
                    case 36298:
                    case 36299:
                    case 36300:
                    case 36303:
                    case 36306:
                    case 36307:
                    case 36308:
                    case 36311:
                        e += t.info.size
                }
                return e
            }, 0)
        }, this.beginTimerQuery = function(e, t) {
            var n, r;
            !this.profile.calcRenderTime || (n = e.getExtension(t ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")) && (t ? (r = e.createQuery(), e.beginQuery(n.TIME_ELAPSED_EXT, r)) : (r = n.createQueryEXT(), n.beginQueryEXT(n.TIME_ELAPSED_EXT, r)), this.profile.timerQueries.push(r))
        }, this.endTimerQuery = function(e, t) {
            if (this.profile.calcRenderTime) {
                var n = e.getExtension(t ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
                if (n) {
                    t ? e.endQuery(n.TIME_ELAPSED_EXT) : n.endQueryEXT(n.TIME_ELAPSED_EXT);
                    for (var r = this.profile.timerQueries, i = r.length - 1; 0 <= i; i--) {
                        var a = r[i],
                            o = t ? e.getQueryParameter(a, 34919) : n.getQueryObjectEXT(a, n.QUERY_RESULT_AVAILABLE_EXT),
                            s = e.getParameter(n.GPU_DISJOINT_EXT);
                        o && !s && (a = t ? e.getQueryParameter(a, 34918) : n.getQueryObjectEXT(a, n.QUERY_RESULT_EXT), this.profile.renderTime += a / 1e6, r.splice(i, 1))
                    }
                }
            }
        }, this
    }

    function Qo(f, p, m, v, s, g) {
        var l = [],
            _ = v.isWebGL2,
            y = v.logarithmicDepthBuffer,
            x = v.floatVertexTextures,
            b = v.maxVertexUniforms,
            M = v.vertexTextures,
            w = v.precision,
            S = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite",
                MeshMaskMaterial: "mask",
                MeshNodeMaterial: "node"
            },
            a = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap", "distancePacking", "useSlopeScaledBias", "numMorphTargets", "unitsScaleFactor", "useHDR", "esmDistanceScale"];

        function A(e) {
            e = e && e.isTexture ? e.encoding : e && e.isWebGLRenderTarget ? (console.warn("v3d.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e.texture.encoding) : Vt;
            return e
        }
        return {
            getParameters: function(e, t, n, r, i) {
                var a, o = r.fog,
                    s = e.isMeshStandardMaterial ? r.environment : null,
                    l = p.get(e.envMap || s),
                    c = S[e.type],
                    r = i.isSkinnedMesh ? (u = (d = i).skeleton.bones, x ? 1024 : (d = Math.floor((b - 20) / 4), (d = Math.min(d, u.length)) < u.length ? (console.warn("v3d.WebGLRenderer: Skeleton has " + u.length + " bones. This GPU supports " + d + "."), 0) : d)) : 0;
                null !== e.precision && (w = v.getMaxPrecision(e.precision)) !== e.precision && console.warn("v3d.WebGLProgram.getParameters:", e.precision, "not supported, using", w, "instead."), s = c ? (a = (h = wa[c]).vertexShader, h.fragmentShader) : (a = e.vertexShader, e.fragmentShader);
                var u = f.getRenderTarget(),
                    d = i.geometry,
                    h = !!l && (l.mapping === B || l.mapping === z);
                return {
                    isWebGL2: _,
                    shaderID: c,
                    shaderName: e.type,
                    vertexShader: a,
                    fragmentShader: s,
                    defines: e.defines,
                    isRawShaderMaterial: !0 === e.isRawShaderMaterial,
                    glslVersion: e.glslVersion,
                    precision: w,
                    instancing: !0 === i.isInstancedMesh,
                    instancingColor: !0 === i.isInstancedMesh && null !== i.instanceColor,
                    supportsVertexTextures: M,
                    outputEncoding: null !== u ? A(u.texture) : f.outputEncoding,
                    map: !!e.map,
                    mapEncoding: A(e.map),
                    matcap: !!e.matcap,
                    matcapEncoding: A(e.matcap),
                    envMap: !!l,
                    envMapMode: l && l.mapping,
                    envMapEncoding: A(l),
                    envMapCubeUV: h,
                    envMapCubeUVTileSize: h && void 0 !== l.image ? l.image.width / 3 : 0,
                    lightMap: !!e.lightMap,
                    lightMapEncoding: A(e.lightMap),
                    aoMap: !!e.aoMap,
                    emissiveMap: !!e.emissiveMap,
                    emissiveMapEncoding: A(e.emissiveMap),
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    objectSpaceNormalMap: e.normalMapType === $t,
                    tangentSpaceNormalMap: e.normalMapType === Jt,
                    clearcoatMap: !!e.clearcoatMap,
                    clearcoatRoughnessMap: !!e.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!e.clearcoatNormalMap,
                    displacementMap: !!e.displacementMap,
                    roughnessMap: !!e.roughnessMap,
                    metalnessMap: !!e.metalnessMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    gradientMap: !!e.gradientMap,
                    sheen: !!e.sheen,
                    transmissionMap: !!e.transmissionMap,
                    combine: e.combine,
                    vertexTangents: e.normalMap && (e.vertexTangents || d && d.isBufferGeometry && d.getAttribute("tangent")),
                    vertexColors: e.vertexColors,
                    vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.displacementMap),
                    uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap),
                    fog: !!o,
                    useFog: e.fog,
                    fogExp2: o && o.isFogExp2,
                    flatShading: e.flatShading,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: y,
                    skinning: e.skinning && 0 < r,
                    maxBones: r,
                    useVertexTexture: x,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: f.maxMorphTargets,
                    maxMorphNormals: f.maxMorphNormals,
                    numDirLights: t.directional.length,
                    numPointLights: t.point.length,
                    numSpotLights: t.spot.length,
                    numRectAreaLights: t.rectArea.length,
                    numHemiLights: t.hemi.length,
                    numDirLightShadows: t.directionalShadowMap.length,
                    numPointLightShadows: t.pointShadowMap.length,
                    numSpotLightShadows: t.spotShadowMap.length,
                    numClippingPlanes: g.numPlanes,
                    numClipIntersection: g.numIntersection,
                    dithering: e.dithering,
                    shadowMapEnabled: f.shadowMap.enabled && 0 < n.length,
                    shadowMapType: f.shadowMap.type,
                    toneMapping: e.toneMapped ? f.toneMapping : L,
                    physicallyCorrectLights: f.physicallyCorrectLights,
                    premultipliedAlpha: e.premultipliedAlpha,
                    alphaTest: e.alphaTest,
                    doubleSided: e.side === oe,
                    flipSided: e.side === ae,
                    depthPacking: void 0 !== e.depthPacking && e.depthPacking,
                    numMorphTargets: Math.min((i.morphTargetInfluences || []).length, f.maxMorphTargets),
                    distancePacking: void 0 !== e.distancePacking && e.distancePacking,
                    useSlopeScaledBias: void 0 !== e.useSlopeScaledBias && e.useSlopeScaledBias,
                    esmDistanceScale: f.shadowMap.esmDistanceScale,
                    materialName: e.name,
                    materialProfile: e.profile,
                    unitsScaleFactor: f.unitsScaleFactor,
                    useHDR: !!e.useHDR,
                    customPrepTokens: e.customPrepTokens,
                    isMeshNodeMaterial: e.isMeshNodeMaterial,
                    nodeChunks: e.nodeChunks,
                    nodeChunksHash: e.nodeChunksHash,
                    index0AttributeName: e.index0AttributeName,
                    extensionDerivatives: e.extensions && e.extensions.derivatives,
                    extensionFragDepth: e.extensions && e.extensions.fragDepth,
                    extensionDrawBuffers: e.extensions && e.extensions.drawBuffers,
                    extensionShaderTextureLOD: e.extensions && e.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: _ || m.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: _ || m.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: _ || m.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: e.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(e) {
                var t = [];
                if (e.shaderID ? t.push(e.shaderID) : (t.push(e.fragmentShader), t.push(e.vertexShader)), void 0 !== e.defines)
                    for (var n in e.defines) t.push(n), t.push(e.defines[n]);
                if (void 0 !== e.customPrepTokens)
                    for (var r in e.customPrepTokens) t.push(r), t.push(e.customPrepTokens[r]);
                if (!1 === e.isRawShaderMaterial) {
                    for (var i = 0; i < a.length; i++) t.push(e[a[i]]);
                    t.push(f.outputEncoding), t.push(f.gammaFactor)
                }
                return t.push(e.customProgramCacheKey), void 0 !== e.nodeChunksHash && t.push(e.nodeChunksHash), t.join()
            },
            getUniforms: function(e) {
                var t = S[e.type];
                return t ? (t = wa[t], ra.clone(t.uniforms)) : e.uniforms
            },
            acquireProgram: function(e, t) {
                for (var n, r = 0, i = l.length; r < i; r++) {
                    var a = l[r];
                    if (a.cacheKey === t) {
                        ++(n = a).usedTimes;
                        break
                    }
                }
                void 0 === n && (n = new Zo(f, t, e, s), l.push(n));
                var o = n.profile.materials;
                return e.materialName && o.indexOf(e.materialName) < 0 && o.push(e.materialName), n
            },
            releaseProgram: function(e) {
                var t;
                0 == --e.usedTimes && (t = l.indexOf(e), l[t] = l[l.length - 1], l.pop(), e.destroy())
            },
            programs: this.programs = l
        }
    }

    function Ko() {
        var r = new WeakMap;
        return {
            get: function(e) {
                var t = r.get(e);
                return void 0 === t && (t = {}, r.set(e, t)), t
            },
            remove: function(e) {
                r.delete(e)
            },
            update: function(e, t, n) {
                r.get(e)[t] = n
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }

    function Jo(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function $o(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function es(l) {
        var c = [],
            u = 0,
            o = [],
            s = [],
            d = {
                id: -1
            };

        function h(e, t, n, r, i, a) {
            var o = c[u],
                s = l.get(n);
            return void 0 === o ? (o = {
                id: e.id,
                object: e,
                geometry: t,
                material: n,
                program: s.program || d,
                groupOrder: r,
                renderOrder: e.renderOrder,
                z: i,
                group: a
            }, c[u] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = n, o.program = s.program || d, o.groupOrder = r, o.renderOrder = e.renderOrder, o.z = i, o.group = a), u++, o
        }
        return {
            opaque: o,
            transparent: s,
            init: function() {
                u = 0, o.length = 0, s.length = 0
            },
            push: function(e, t, n, r, i, a) {
                a = h(e, t, n, r, i, a), (!0 === n.transparent ? s : o).push(a)
            },
            unshift: function(e, t, n, r, i, a) {
                a = h(e, t, n, r, i, a), (!0 === n.transparent ? s : o).unshift(a)
            },
            finish: function() {
                for (var e = u, t = c.length; e < t; e++) {
                    var n = c[e];
                    if (null === n.id) break;
                    n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                }
            },
            sort: function(e, t) {
                1 < o.length && o.sort(e || Jo), 1 < s.length && s.sort(t || $o)
            }
        }
    }

    function ts(i) {
        var a = new WeakMap;
        return {
            get: function(e, t) {
                var n, r = a.get(e);
                return void 0 === r ? (n = new es(i), a.set(e, new WeakMap), a.get(e).set(t, n)) : void 0 === (n = r.get(t)) && (n = new es(i), r.set(t, n)), n
            },
            dispose: function() {
                a = new WeakMap
            }
        }
    }

    function ns(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new vn(512, 512), this.map = null, this.mapPass = null, this.matrix = new nr, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ma, this._frameExtents = new vn(1, 1), this._viewportCount = 1, this._viewports = [new Mn(0, 0, 1, 1)], this.expBias = 1, this.slopeScaledBias = 0, this._additionalMap2D = null, this._additionalMapCube = null
    }
    Object.assign(ns.prototype, {
        isLightShadow: !0,
        _projScreenMatrix: new nr,
        _lightPositionWorld: new Tn,
        _lookTarget: new Tn,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(e) {
            var t = this.camera,
                n = this.matrix,
                r = this._projScreenMatrix,
                i = this._lookTarget,
                a = this._lightPositionWorld;
            a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
        },
        getViewport: function(e) {
            return this._viewports[e]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this.expBias = e.expBias, this.slopeScaledBias = e.slopeScaledBias, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        dispose: function() {
            null !== this.map && this.map.dispose(), null !== this._additionalMap2D && this._additionalMap2D.dispose(), null !== this._additionalMapCube && this._additionalMapCube.dispose()
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    });
    var rs = Math.PI / 4;

    function is() {
        ns.call(this, new la(50, 1, .5, 500)), this.focus = 1, this.useOmniMaps = !1, this.useMinFov90 = !1, this._frameExtentsOmni = new vn(4, 2), this._viewportCountOmni = 6, this._viewportsOmni = [new Mn(2, 1, 1, 1), new Mn(0, 1, 1, 1), new Mn(3, 1, 1, 1), new Mn(1, 1, 1, 1), new Mn(3, 0, 1, 1), new Mn(1, 0, 1, 1)], this._cubeDirections = [new Tn(1, 0, 0), new Tn(-1, 0, 0), new Tn(0, 0, 1), new Tn(0, 0, -1), new Tn(0, 1, 0), new Tn(0, -1, 0)], this._cubeUps = [new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 0, 1), new Tn(0, 0, -1)]
    }

    function as() {
        var n = {};
        return {
            get: function(e) {
                if (void 0 !== n[e.id]) return n[e.id];
                var t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            direction: new Tn,
                            color: new Qr
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new Tn,
                            direction: new Tn,
                            color: new Qr,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new Tn,
                            color: new Qr,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new Tn,
                            skyColor: new Qr,
                            groundColor: new Qr
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new Qr,
                            position: new Tn,
                            halfWidth: new Tn,
                            halfHeight: new Tn
                        }
                }
                return n[e.id] = t
            }
        }
    }
    is.prototype = Object.assign(Object.create(ns.prototype), {
        constructor: is,
        isSpotLightShadow: !0,
        updateMatrices: function(e) {
            var t, n, r, i, a, o = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
            this.useOmniMaps ? (i = this.camera, n = this.matrix, r = this._lightPositionWorld, t = this._lookTarget, a = this._projScreenMatrix, r.setFromMatrixPosition(e.matrixWorld), i.position.copy(r), t.copy(i.position), t.add(this._cubeDirections[o]), i.up.copy(this._cubeUps[o]), i.lookAt(t), i.updateMatrixWorld(), n.makeTranslation(-r.x, -r.y, -r.z), a.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(a)) : (n = this.camera, r = 2 * mn.RAD2DEG * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, a = e.distance || n.far, r === n.fov && i === n.aspect && a === n.far || (n.fov = r, n.aspect = i, n.far = a, n.updateProjectionMatrix()), ns.prototype.updateMatrices.call(this, e))
        },
        getViewportCount: function() {
            return this.useOmniMaps ? this._viewportCountOmni : ns.prototype.getViewportCount.call(this)
        },
        getViewport: function(e) {
            return this.useOmniMaps ? this._viewportsOmni[e] : ns.prototype.getViewport.call(this, e)
        },
        getFrameExtents: function() {
            return this.useOmniMaps ? this._frameExtentsOmni : ns.prototype.getFrameExtents.call(this)
        },
        calcUseOmniMaps: function(e) {
            return this.useOmniMaps = rs < e, this.useOmniMaps
        },
        copy: function(e) {
            return ns.prototype.copy.call(this, e), this.useOmniMaps = e.useOmniMaps, this.useMinFov90 = e.useMinFov90, this
        }
    });
    var os = 0;

    function ss(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }

    function ls(E, C) {
        for (var n, L = new as, P = (n = {}, {
                get: function(e) {
                    if (void 0 !== n[e.id]) return n[e.id];
                    var t;
                    switch (e.type) {
                        case "DirectionalLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new vn,
                                position: new Tn,
                                shadowCameraNear: 1,
                                maxDistance: 0,
                                expBias: 1
                            };
                            break;
                        case "SpotLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new vn,
                                shadow: 0,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3,
                                expBias: 1
                            };
                            break;
                        case "PointLight":
                            t = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new vn,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3,
                                expBias: 1
                            }
                    }
                    return n[e.id] = t
                }
            }), R = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, e = 0; e < 9; e++) R.probe.push(new Tn);
        var m = new Tn,
            v = new nr,
            g = new nr;
        return {
            setup: function(e) {
                for (var t = 0, n = 0, r = 0, i = 0; i < 9; i++) R.probe[i].set(0, 0, 0);
                var a = 0,
                    o = 0,
                    s = 0,
                    l = 0,
                    c = 0,
                    u = 0,
                    d = 0,
                    h = 0;
                e.sort(ss);
                for (var f = 0, p = e.length; f < p; f++) {
                    var m, v, g, _, y, x = e[f],
                        b = x.color,
                        M = x.intensity,
                        w = x.distance,
                        S = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                    if (x.isAmbientLight) t += b.r * M, n += b.g * M, r += b.b * M;
                    else if (x.isLightProbe)
                        for (var A = 0; A < 9; A++) R.probe[A].addScaledVector(x.sh.coefficients[A], M);
                    else x.isDirectionalLight ? ((g = L.get(x)).color.copy(x.color).multiplyScalar(x.intensity), x.castShadow && (v = x.shadow, (m = P.get(x)).shadowBias = v.bias, m.shadowNormalBias = v.normalBias, m.shadowRadius = v.radius, m.shadowMapSize = v.mapSize, R.directionalShadow[a] = m, R.directionalShadowMap[a] = S, R.directionalShadowMatrix[a] = x.shadow.matrix, m.shadowCameraNear = v.camera.near, m.expBias = v.expBias, u++), R.directional[a] = g, a++) : x.isSpotLight ? ((v = L.get(x)).position.setFromMatrixPosition(x.matrixWorld), v.color.copy(b).multiplyScalar(M), v.distance = w, v.coneCos = Math.cos(x.angle), v.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), v.decay = x.decay, x.castShadow && (g = x.shadow, (w = P.get(x)).shadowBias = g.bias, w.shadowNormalBias = g.normalBias, w.shadowRadius = g.radius, w.shadowMapSize = g.mapSize, R.spotShadow[s] = w, R.spotShadowMap[s] = S, R.spotShadowMatrix[s] = x.shadow.matrix, w.shadow = x.castShadow ? g.calcUseOmniMaps(x.angle) ? 2 : 1 : 0, w.shadowCameraNear = g.camera.near, w.shadowCameraFar = g.camera.far, w.expBias = g.expBias, h++), R.spot[s] = v, s++) : x.isRectAreaLight ? ((_ = L.get(x)).color.copy(b).multiplyScalar(M), _.halfWidth.set(.5 * x.width, 0, 0), _.halfHeight.set(0, .5 * x.height, 0), R.rectArea[l] = _, l++) : x.isPointLight ? ((y = L.get(x)).color.copy(x.color).multiplyScalar(x.intensity), y.distance = x.distance, y.decay = x.decay, x.castShadow && (b = x.shadow, (_ = P.get(x)).shadowBias = b.bias, _.shadowNormalBias = b.normalBias, _.shadowRadius = b.radius, _.shadowMapSize = b.mapSize, _.shadowCameraNear = b.camera.near, _.shadowCameraFar = b.camera.far, _.expBias = b.expBias, R.pointShadow[o] = _, R.pointShadowMap[o] = S, R.pointShadowMatrix[o] = x.shadow.matrix, d++), R.point[o] = y, o++) : x.isHemisphereLight && ((y = L.get(x)).skyColor.copy(x.color).multiplyScalar(M), y.groundColor.copy(x.groundColor).multiplyScalar(M), R.hemi[c] = y, c++)
                }
                0 < l && (C.isWebGL2 || !0 === E.has("OES_texture_float_linear") ? (R.rectAreaLTC1 = va.LTC_FLOAT_1, R.rectAreaLTC2 = va.LTC_FLOAT_2) : !0 === E.has("OES_texture_half_float_linear") ? (R.rectAreaLTC1 = va.LTC_HALF_1, R.rectAreaLTC2 = va.LTC_HALF_2) : console.error("v3d.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), R.ambient[0] = t, R.ambient[1] = n, R.ambient[2] = r;
                var T = R.hash;
                T.directionalLength === a && T.pointLength === o && T.spotLength === s && T.rectAreaLength === l && T.hemiLength === c && T.numDirectionalShadows === u && T.numPointShadows === d && T.numSpotShadows === h || (R.directional.length = a, R.spot.length = s, R.rectArea.length = l, R.point.length = o, R.hemi.length = c, R.directionalShadow.length = u, R.directionalShadowMap.length = u, R.pointShadow.length = d, R.pointShadowMap.length = d, R.spotShadow.length = h, R.spotShadowMap.length = h, R.directionalShadowMatrix.length = u, R.pointShadowMatrix.length = d, R.spotShadowMatrix.length = h, T.directionalLength = a, T.pointLength = o, T.spotLength = s, T.rectAreaLength = l, T.hemiLength = c, T.numDirectionalShadows = u, T.numPointShadows = d, T.numSpotShadows = h, R.version = os++)
            },
            setupView: function(e, t) {
                for (var n = 0, r = 0, i = 0, a = 0, o = 0, s = t.matrixWorldInverse, l = 0, c = e.length; l < c; l++) {
                    var u, d, h, f, p = e[l];
                    p.isDirectionalLight ? ((d = R.directional[n]).direction.setFromMatrixPosition(p.matrixWorld), m.setFromMatrixPosition(p.target.matrixWorld), d.direction.sub(m), d.direction.transformDirection(s), p.castShadow && (u = p.shadow, (d = P.get(p)).position.setFromMatrixPosition(p.matrixWorld), d.position.applyMatrix4(s), d.maxDistance = u.isDirectionalLightShadowCSM ? u.maxDistance : t.far), n++) : p.isSpotLight ? ((h = R.spot[i]).position.setFromMatrixPosition(p.matrixWorld), h.position.applyMatrix4(s), h.direction.setFromMatrixPosition(p.matrixWorld), m.setFromMatrixPosition(p.target.matrixWorld), h.direction.sub(m), h.direction.transformDirection(s), i++) : p.isRectAreaLight ? ((h = R.rectArea[a]).position.setFromMatrixPosition(p.matrixWorld), h.position.applyMatrix4(s), g.identity(), v.copy(p.matrixWorld), v.premultiply(s), g.extractRotation(v), h.halfWidth.set(.5 * p.width, 0, 0), h.halfHeight.set(0, .5 * p.height, 0), h.halfWidth.applyMatrix4(g), h.halfHeight.applyMatrix4(g), a++) : p.isPointLight ? ((f = R.point[r]).position.setFromMatrixPosition(p.matrixWorld), f.position.applyMatrix4(s), r++) : p.isHemisphereLight && ((f = R.hemi[o]).direction.setFromMatrixPosition(p.matrixWorld), f.direction.transformDirection(s), f.direction.normalize(), o++)
                }
            },
            state: R
        }
    }

    function cs(e, t) {
        var n = new ls(e, t),
            r = [],
            i = [];
        return {
            init: function() {
                r.length = 0, i.length = 0
            },
            state: {
                lightsArray: r,
                shadowsArray: i,
                lights: n
            },
            setupLights: function() {
                n.setup(r)
            },
            setupLightsView: function(e) {
                n.setupView(r, e)
            },
            pushLight: function(e) {
                r.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }

    function us(r, i) {
        var a = new WeakMap;
        return {
            get: function(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                return !1 === a.has(e) ? (t = new cs(r, i), a.set(e, []), a.get(e).push(t)) : n >= a.get(e).length ? (t = new cs(r, i), a.get(e).push(t)) : t = a.get(e)[n], t
            },
            dispose: function() {
                a = new WeakMap
            }
        }
    }

    function ds(e) {
        $r.call(this), this.type = "MeshDepthMaterial", this.depthPacking = qt, this.useSlopeScaledBias = !1, this.slopeScaledBias = 0, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
    }

    function hs(e) {
        $r.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Tn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.defines = {
            DISTANCE_SCALE: "1.0"
        }, this.distancePacking = Qt, this.useSlopeScaledBias = !1, this.slopeScaledBias = 0, this.setValues(e)
    }((ds.prototype = Object.create($r.prototype)).constructor = ds).prototype.isMeshDepthMaterial = !0, ds.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ((hs.prototype = Object.create($r.prototype)).constructor = hs).prototype.isMeshDistanceMaterial = !0, hs.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.defines = Object.assign({}, e.defines), this.distancePacking = e.distancePacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this
    };
    var fs = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\nfloat mean = 0.0;\nfloat squared_mean = 0.0;\nfloat depth = unpackRGBAToDepth(texture2D(shadow_pass, (gl_FragCoord.xy) / resolution));\nfor (float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n#ifdef HORIZONTAL_PASS\nvec2 distribution = unpackRGBATo2Half(texture2D(shadow_pass, (gl_FragCoord.xy + vec2(i, 0.0) * radius) / resolution));\nmean += distribution.x;\nsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n#else\nfloat depth = unpackRGBAToDepth(texture2D(shadow_pass, (gl_FragCoord.xy + vec2(0.0, i) * radius) / resolution));\nmean += depth;\nsquared_mean += depth * depth;\n#endif\n}\nmean = mean * HALF_SAMPLE_RATE;\nsquared_mean = squared_mean * HALF_SAMPLE_RATE;\nfloat std_dev = sqrt(squared_mean - mean * mean);\ngl_FragColor = pack2HalfToRGBA(vec2(mean, std_dev));\n}",
        ps = "void main() {\ngl_Position = vec4(position, 1.0);\n}";

    function ms() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : -1,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : -1,
            i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : .1,
            a = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 2e3;
        sa.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix()
    }
    ms.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: ms,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return sa.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function(e, t, n, r, i, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - e,
                a = n + e,
                n = r + t,
                e = r - t;
            null !== this.view && this.view.enabled && (r = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom, a = (i += r * this.view.offsetX) + r * this.view.width, e = (n -= t * this.view.offsetY) - t * this.view.height), this.projectionMatrix.makeOrthographic(i, a, n, e, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        },
        toJSON: function(e) {
            e = Er.prototype.toJSON.call(this, e);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    });
    var vs = .8,
        gs = .2,
        _s = .8,
        ys = 50;

    function xs(x, g, p, b) {
        var M = new ma,
            w = new vn,
            m = new vn,
            v = new Mn,
            i = [],
            a = [],
            _ = {},
            y = {
                0: ae,
                1: ie,
                2: oe
            },
            S = new oa({
                defines: {
                    SAMPLE_RATE: .25,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new vn
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: ps,
                fragmentShader: fs
            }),
            A = S.clone();
        A.defines.HORIZONTAL_PASS = 1;
        var e = new Oi;
        e.setAttribute("position", new ri(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        var T = new Ki(e, S),
            E = new nr,
            u = new nr,
            C = new vn(p, p),
            L = new Tn,
            P = new Tn,
            R = new Tn,
            D = [new Tn(1, 0, 0), new Tn(-1, 0, 0), new Tn(0, 1, 0), new Tn(0, -1, 0), new Tn(0, 0, 1), new Tn(0, 0, -1)],
            O = [new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 0, 1), new Tn(0, 0, -1), new Tn(0, 1, 0), new Tn(0, 1, 0)],
            N = (new Mn, new Mn, new Mn, new Mn, new Mn, new Mn, new Yn),
            d = [new Tn, new Tn, new Tn, new Tn, new Tn, new Tn, new Tn, new Tn],
            h = new Ki(new ba(1, 1, 1, 1));
        h.name = "esmFarPlane", h.castShadow = !0, h.material.shadowSide = ie;
        var I = 0,
            F = 1,
            k = 0,
            B = 1,
            z = new ms(-1, 1, 1, -1, 0, 10),
            U = new Ki(new ba(2, 2)),
            V = new oa({
                type: "ShadowCubeOctahedral",
                defines: Object.assign({}, wa.cubeOctahedral.defines),
                uniforms: ra.clone(wa.cubeOctahedral.uniforms),
                vertexShader: wa.cubeOctahedral.vertexShader,
                fragmentShader: wa.cubeOctahedral.fragmentShader
            }),
            s = {},
            l = {},
            G = this;

        function j(e, t, n) {
            var r = e << 0 | t << 1 | n << 2,
                n = i[r];
            return void 0 === n && (n = new ds({
                depthPacking: Zt,
                morphTargets: e,
                skinning: t
            }), i[r] = n), n
        }

        function W(e, t, n) {
            var r = e << 0 | t << 1 | n << 2,
                n = a[r];
            return void 0 === n && (n = new hs({
                morphTargets: e,
                skinning: t
            }), a[r] = n), n
        }

        function H(e, t, n, r, i, a, o, s, l) {
            var c = null,
                u = j,
                d = e.customDepthMaterial;
            !s && o !== te || (u = W, d = e.customDistanceMaterial);
            var h, f, p = !1;
            switch (c = void 0 === d ? (!0 === n.morphTargets && (p = t.morphAttributes && t.morphAttributes.position && 0 < t.morphAttributes.position.length), !(t = !1) === e.isSkinnedMesh && (!0 === n.skinning ? t = !0 : console.warn("v3d.WebGLShadowMap: v3d.SkinnedMesh with material.skinning set to false:", e)), u(p, t, !0 === e.isInstancedMesh)) : d, x.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length ? (h = c.uuid, f = n.uuid, void 0 === (d = _[h]) && (d = {}, _[h] = d), void 0 === (h = d[f]) && (h = c.clone(), d[f] = h), c = h) : p && (f = c.uuid, h = n.uuid, void 0 === (p = _[f]) && (p = {}, _[f] = p), void 0 === (f = p[h]) && (f = c.clone(), p[h] = f), c = f), c.visible = n.visible, c.wireframe = n.wireframe, c.side = o === ee ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : y[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !s && o !== te || !0 !== c.isMeshDistanceMaterial || (c.referencePosition.copy(l), c.nearDistance = i, c.farDistance = a, c.distancePacking = o === te ? Kt : Qt), o === te && (c.defines.DISTANCE_SCALE = bi(G.esmDistanceScale)), o) {
                case K:
                case re:
                case J:
                case $:
                case ne:
                    c.useSlopeScaledBias = !0, c.slopeScaledBias = r.shadow.slopeScaledBias;
                    break;
                case te:
                    c.useSlopeScaledBias = !0, c.slopeScaledBias = .5
            }
            return c
        }

        function X(e, t, n, r, i, a) {
            if (!1 !== e.visible) {
                var o = e.layers.test(t.layers);
                if (o && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && i === ee) && (!e.frustumCulled || M.intersectsObject(e))) {
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                    var s = g.update(e),
                        l = e.material;
                    if (Array.isArray(l))
                        for (var c = s.groups, u = 0, d = c.length; u < d; u++) {
                            var h = c[u],
                                f = l[h.materialIndex];
                            f && f.visible && (f = H(e, s, f, r, n.near, n.far, i, a, P), x.renderBufferDirect(n, null, s, f, e, h))
                        } else l.visible && (o = H(e, s, l, r, n.near, n.far, i, a, P), x.renderBufferDirect(n, null, s, o, e, null))
                }
                for (var p = e.children, m = 0, v = p.length; m < v; m++) X(p[m], t, n, r, i, a)
            }
        }

        function Y(e, t, n, r) {
            var i = n.shadow,
                a = i.camera;
            P.setFromMatrixPosition(n.matrixWorld), w.copy(i.mapSize);
            var o = i.getFrameExtents();
            w.multiply(o), m.copy(i.mapSize), (w.x > p || w.y > p) && (w.x > p && (m.x = Math.floor(p / o.x), w.x = m.x * o.x, i.mapSize.x = m.x), w.y > p && (m.y = Math.floor(p / o.y), w.y = m.y * o.y, i.mapSize.y = m.y)), n.isSpotLight && i.map && i.map.width / i.map.height != 2 && (o = i.map, i.map = i._additionalMap2D, i._additionalMap2D = o);
            var s, l = n.isPointLight || n.isSpotLight && i.useOmniMaps;
            l ? n.isSpotLight && (a.fov = 90, a.updateProjectionMatrix()) : n.isDirectionalLight ? (n.shadow.isDirectionalLightShadowCSM && (s = Z(t, i, w, N), a.left = s.center.x - s.radius, a.right = s.center.x + s.radius, a.top = s.center.y + s.radius, a.bottom = s.center.y - s.radius, a.near = -s.center.z - s.radius, a.far = -s.center.z + s.radius, a.updateProjectionMatrix()), s = n.getWorldDirection(R), P.addScaledVector(s, a.near)) : n.isSpotLight && i.useMinFov90 && (a.fov = 90, a.updateProjectionMatrix()), null !== i.map || l || r !== ee || (c = {
                minFilter: Ue,
                magFilter: Ue,
                format: Qe
            }, i.map = new wn(w.x, w.y, c), i.map.texture.name = n.name + ".shadowMap", i.mapPass = new wn(w.x, w.y, c), a.updateProjectionMatrix()), null === i.map && (u = {
                minFilter: ke,
                magFilter: ke,
                format: Qe
            }, i.map = new wn(w.x, w.y, u), i.map.texture.name = n.name + ".shadowMap", a.updateProjectionMatrix()), x.state.buffers.color.setClear(1, 1, 1, 1), x.setRenderTarget(i.map), x.clear();
            for (var c, u, d = i.getViewportCount(), h = 0; h < d; h++) {
                var f = i.getViewport(h);
                v.set(m.x * f.x, m.y * f.y, m.x * f.z, m.y * f.w), x.state.viewport(v), i.updateMatrices(n, h), M = i.getFrustum(), X(e, t, i.camera, n, r, l)
            }
            l || r !== ee || (c = i, u = t, a = g.update(T), S.uniforms.shadow_pass.value = c.map.texture, S.uniforms.resolution.value = c.mapSize, S.uniforms.radius.value = c.radius, x.setRenderTarget(c.mapPass), x.clear(), x.renderBufferDirect(u, null, a, S, T, null), A.uniforms.shadow_pass.value = c.mapPass.texture, A.uniforms.resolution.value = c.mapSize, A.uniforms.radius.value = c.radius, x.setRenderTarget(c.map), x.clear(), x.renderBufferDirect(u, null, a, A, T, null))
        }

        function q(e, t, n, r, i, a, o) {
            r = U.material = (o === k ? function(e) {
                e in s || ((s[e] = new oa({
                    type: "ShadowBlur",
                    defines: Object.assign({}, wa.blur.defines, {
                        LOG_SPACE: 1,
                        OCTAHEDRAL_MAP: 1
                    }),
                    uniforms: ra.clone(wa.blur.uniforms),
                    customPrepTokens: Object.assign({}, wa.blur.customPrepTokens),
                    vertexShader: wa.blur.vertexShader,
                    fragmentShader: wa.blur.fragmentShader
                })).customPrepTokens.MAX_SAMPLE_RADIUS = e);
                return s[e]
            } : function(e) {
                e in l || ((l[e] = new oa({
                    type: "ShadowBlur",
                    defines: Object.assign({}, wa.blur.defines, {
                        LOG_SPACE: 1
                    }),
                    uniforms: ra.clone(wa.blur.uniforms),
                    customPrepTokens: Object.assign({}, wa.blur.customPrepTokens),
                    vertexShader: wa.blur.vertexShader,
                    fragmentShader: wa.blur.fragmentShader
                })).customPrepTokens.MAX_SAMPLE_RADIUS = e);
                return l[e]
            })(r);
            r.uniforms.direction.value.set(+(a === I), +(a === F)), r.uniforms.colorTexture.value = t.texture, r.uniforms.texSize.value.set(t.width, t.height), r.uniforms.kernelRadius.value = i, r.uniformsNeedUpdate = !0, e.setRenderTarget(n), e.clear(), e.updateGeometry(U), e.renderBufferDirect(z, !1, U.geometry, r, U, null)
        }

        function Z(e, t, n, r) {
            for (var i = mn.clamp(t.maxDistance, e.near, e.far) / e.far, a = 0; a < d.length; a++) {
                var o = d[a],
                    s = 1 & a;
                o.set(a >> 2 & 1, a >> 1 & 1, s).multiplyScalar(2).subScalar(1).applyMatrix4(e.projectionMatrixInverse), 1 == s && o.multiplyScalar(i)
            }
            r.setFromPoints(d), u.multiplyMatrices(t.camera.matrixWorldInverse, e.matrixWorld);
            var l = r.center.applyMatrix4(u),
                c = r.radius *= u.getMaxScaleOnAxis(),
                t = n.x / 2 / c,
                c = n.y / 2 / c;
            return l.x = Math.round(l.x * t) / t, l.y = Math.round(l.y * c) / c, r
        }

        function Q(e, t, n, r) {
            var i, a, o, s, l, c;
            t.isPerspectiveCamera ? (i = a = 0, s = l = 2 * -(o = -.999 * t.far) * Math.tan(mn.degToRad(t.fov) / 2), c = 1) : t.isOrthographicCamera && (i = (t.right + t.left) / 2, a = (t.top + t.bottom) / 2, o = -.999 * t.far, s = t.right - t.left, l = t.top - t.bottom, c = 1), t.add(h), h.scale.set(s, l, c), h.position.set(i, a, o), h.updateMatrixWorld(), X(h, e, t, n, r, !0)
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = J, this.esmDistanceScale = 1, this.render = function(e, t, n) {
            if (!1 !== G.enabled && (!1 !== G.autoUpdate || !1 !== G.needsUpdate) && 0 !== e.length) {
                var r = x.getRenderTarget(),
                    i = x.getActiveCubeFace(),
                    a = x.getActiveMipmapLevel(),
                    o = x.state;
                o.setBlending(se), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                for (var s, l, c, u, d, h, f, p, m, v = 0, g = e.length; v < g; v++) {
                    var _ = e[v],
                        y = _.shadow;
                    if (void 0 !== y) {
                        if (!1 !== y.autoUpdate || !1 !== y.needsUpdate) {
                            if (_.isSpotLight && y.calcUseOmniMaps(_.angle), _.isPointLight || _.isSpotLight && y.useOmniMaps) switch (G.type) {
                                case K:
                                case re:
                                case J:
                                case $:
                                case ne:
                                    Y(t, n, _, G.type);
                                    break;
                                case te:
                                    ! function(e, t, n, r) {
                                        var i = n.shadow,
                                            a = i.camera,
                                            o = i.matrix,
                                            s = n.isPointLight ? 2 : 1,
                                            l = w.copy(i.mapSize).multiplyScalar(s).min(C).multiplyScalar(1 / s);
                                        null === i._additionalMapCube && (i._additionalMapCube = new da(l.x, {
                                            minFilter: Ue,
                                            magFilter: Ue,
                                            format: b ? $e : Qe,
                                            type: Ye
                                        }), i._additionalMapCube.texture.name = n.name + ".shadowMap.tmpCube"), null === i._additionalMap2D && (i._additionalMap2D = new wn(l.x * s, l.y * s, {
                                            minFilter: Ue,
                                            magFilter: Ue,
                                            format: b ? $e : Qe,
                                            type: Ye
                                        }), i._additionalMap2D.texture.name = n.name + ".shadowMap.tmp2D"), null === i.map && (i.map = new wn(l.x * s, l.y * s, {
                                            minFilter: Ue,
                                            magFilter: Ue,
                                            format: b ? $e : Qe,
                                            type: Ye
                                        }), i.map.texture.name = n.name + ".shadowMap"), P.setFromMatrixPosition(n.matrixWorld), a.position.copy(P), n.isSpotLight && (a.fov = 90, a.updateProjectionMatrix()), o.makeTranslation(-P.x, -P.y, -P.z);
                                        for (var c = 0; c < 6; c++) L.copy(a.position), L.add(D[c]), a.up.copy(O[c]), 2 !== c && 3 !== c && a.up.multiplyScalar(-1), a.lookAt(L), a.updateMatrixWorld(), E.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), M.setFromProjectionMatrix(E), x.setRenderTarget(i._additionalMapCube, c), x.clearDepth(), Q(t, a, n, r), X(e, t, a, n, r, !0);
                                        o = Math.max(i.radius * s, .001), s = function(e) {
                                                return Math.ceil(gs * e)
                                            }(o),
                                            function(e, t, n) {
                                                var r = U.material = V;
                                                r.uniforms.tCube.value = t.texture, r.uniforms.texelSize.value.set(1 / n.width, 1 / n.height), r.uniformsNeedUpdate = !0, e.setRenderTarget(n), e.clear(), e.updateGeometry(U), e.renderBufferDirect(z, !1, U.geometry, r, U, null)
                                            }(x, i._additionalMapCube, i.map), q(x, i.map, i._additionalMap2D, s, o, F, k), q(x, i._additionalMap2D, i.map, s, o, I, k)
                                    }(t, n, _, G.type);
                                    break;
                                default:
                                    continue
                            } else {
                                if (!_.isSpotLight && !_.isDirectionalLight) continue;
                                switch (G.type) {
                                    case K:
                                    case re:
                                    case J:
                                    case $:
                                    case ne:
                                    case ee:
                                        Y(t, n, _, G.type);
                                        break;
                                    case te:
                                        s = t, l = n, c = _, u = G.type, m = p = f = h = d = void 0, h = c.shadow, f = h.camera, p = h.matrix, m = w.copy(h.mapSize).min(C), null === h._additionalMap2D && (h._additionalMap2D = new wn(m.x, m.y, {
                                            minFilter: Ue,
                                            magFilter: Ue,
                                            format: b ? $e : Qe,
                                            type: Ye
                                        }), h._additionalMap2D.texture.name = c.name + ".shadowMap.tmp2D"), null === h.map && (h.map = new wn(m.x, m.y, {
                                            minFilter: Ue,
                                            magFilter: Ue,
                                            format: b ? $e : Qe,
                                            type: Ye
                                        }), h.map.texture.name = c.name + ".shadowMap"), P.setFromMatrixPosition(c.matrixWorld), f.position.copy(P), L.setFromMatrixPosition(c.target.matrixWorld), f.lookAt(L), f.updateMatrixWorld(), c.isDirectionalLight ? (c.shadow.isDirectionalLightShadowCSM && (d = Z(l, h, m, N), f.left = d.center.x - d.radius, f.right = d.center.x + d.radius, f.top = d.center.y + d.radius, f.bottom = d.center.y - d.radius, f.near = -d.center.z - d.radius, f.far = -d.center.z + d.radius, f.updateProjectionMatrix()), d = c.getWorldDirection(R), P.addScaledVector(d, f.near)) : c.isSpotLight && h.useMinFov90 && (f.fov = 90, f.updateProjectionMatrix()), p.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), p.multiply(f.projectionMatrix), p.multiply(f.matrixWorldInverse), E.multiplyMatrices(f.projectionMatrix, f.matrixWorldInverse), M.setFromProjectionMatrix(E), x.setRenderTarget(h.map), x.clearDepth(), Q(l, f, c, u), X(s, l, f, c, u, !1), f = c.isDirectionalLight && c.shadow.isDirectionalLightShadowCSM ? function(e, t) {
                                            return ys * e / t
                                        }(h.radius, (f.right - f.left) / 2) : c.isSpotLight ? h.radius * _s : h.radius, c = function(e) {
                                            return Math.ceil(vs * e)
                                        }(f = Math.max(f, .001)), q(x, h.map, h._additionalMap2D, c, f, I, B), !void q(x, h._additionalMap2D, h.map, c, f, F, B);
                                        break;
                                    default:
                                        continue
                                }
                            }
                            y.needsUpdate = !1
                        }
                    } else console.warn("v3d.WebGLShadowMap:", _, "has no shadow.")
                }
                G.needsUpdate = !1, x.setRenderTarget(r, i, a)
            }
        }
    }

    function bs(u, e, t) {
        var n = t.isWebGL2;
        var r = new function() {
                var t = !1,
                    a = new Mn,
                    n = null,
                    o = new Mn(0, 0, 0, 0);
                return {
                    setMask: function(e) {
                        n === e || t || (u.colorMask(e, e, e, e), n = e)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(e, t, n, r, i) {
                        !0 === i && (e *= r, t *= r, n *= r), a.set(e, t, n, r), !1 === o.equals(a) && (u.clearColor(e, t, n, r), o.copy(a))
                    },
                    reset: function() {
                        t = !1, n = null, o.set(-1, 0, 0, 0)
                    }
                }
            },
            i = new function() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null;
                return {
                    setTest: function(e) {
                        (e ? D : O)(2929)
                    },
                    setMask: function(e) {
                        n === e || t || (u.depthMask(e), n = e)
                    },
                    setFunc: function(e) {
                        if (r !== e) {
                            if (e) switch (e) {
                                case Se:
                                    u.depthFunc(512);
                                    break;
                                case Ae:
                                    u.depthFunc(519);
                                    break;
                                case Te:
                                    u.depthFunc(513);
                                    break;
                                case Ee:
                                    u.depthFunc(515);
                                    break;
                                case Ce:
                                    u.depthFunc(514);
                                    break;
                                case Le:
                                    u.depthFunc(518);
                                    break;
                                case Re:
                                    u.depthFunc(516);
                                    break;
                                case De:
                                    u.depthFunc(517);
                                    break;
                                default:
                                    u.depthFunc(515)
                            } else u.depthFunc(515);
                            r = e
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(e) {
                        i !== e && (u.clearDepth(e), i = e)
                    },
                    reset: function() {
                        t = !1, i = r = n = null
                    }
                }
            },
            a = new function() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null,
                    a = null,
                    o = null,
                    s = null,
                    l = null,
                    c = null;
                return {
                    setTest: function(e) {
                        t || (e ? D : O)(2960)
                    },
                    setMask: function(e) {
                        n === e || t || (u.stencilMask(e), n = e)
                    },
                    setFunc: function(e, t, n) {
                        r === e && i === t && a === n || (u.stencilFunc(e, t, n), r = e, i = t, a = n)
                    },
                    setOp: function(e, t, n) {
                        o === e && s === t && l === n || (u.stencilOp(e, t, n), o = e, s = t, l = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(e) {
                        c !== e && (u.clearStencil(e), c = e)
                    },
                    reset: function() {
                        t = !1, c = l = s = o = a = i = r = n = null
                    }
                }
            },
            o = {},
            s = null,
            l = null,
            c = null,
            d = null,
            h = null,
            f = null,
            p = null,
            m = null,
            v = null,
            g = !1,
            _ = null,
            y = null,
            x = null,
            b = null,
            M = null,
            w = u.getParameter(35661),
            S = !1,
            A = 0,
            t = u.getParameter(7938); - 1 !== t.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(t)[1]), S = 1 <= A) : -1 !== t.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(t)[1]), S = 2 <= A);
        var T = null,
            E = {},
            C = new Mn,
            L = new Mn;

        function P(e, t, n) {
            var r = new Uint8Array(4),
                i = u.createTexture();
            u.bindTexture(e, i), u.texParameteri(e, 10241, 9728), u.texParameteri(e, 10240, 9728);
            for (var a = 0; a < n; a++) u.texImage2D(t + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return i
        }
        var R = {};

        function D(e) {
            !0 !== o[e] && (u.enable(e), o[e] = !0)
        }

        function O(e) {
            !1 !== o[e] && (u.disable(e), o[e] = !1)
        }
        R[3553] = P(3553, 3553, 1), R[34067] = P(34067, 34069, 6), r.setClear(0, 0, 0, 1), i.setClear(1), a.setClear(0), D(2929), i.setFunc(Ee), B(!1), z(j), D(2884), k(se);
        var N, I = (_defineProperty(A = {}, Q, 32774), _defineProperty(A, le, 32778), _defineProperty(A, ce, 32779), A);
        n ? (I[ue] = 32775, I[he] = 32776) : null !== (N = e.get("EXT_blend_minmax")) && (I[ue] = N.MIN_EXT, I[he] = N.MAX_EXT);
        var F = (_defineProperty(N = {}, fe, 0), _defineProperty(N, pe, 1), _defineProperty(N, me, 768), _defineProperty(N, ge, 770), _defineProperty(N, we, 776), _defineProperty(N, be, 774), _defineProperty(N, ye, 772), _defineProperty(N, ve, 769), _defineProperty(N, _e, 771), _defineProperty(N, Me, 775), _defineProperty(N, xe, 773), N);

        function k(e, t, n, r, i, a, o, s) {
            if (e !== se) {
                if (l || (D(3042), l = !0), e === Z) i = i || t, a = a || n, o = o || r, t === d && i === p || (u.blendEquationSeparate(I[t], I[i]), d = t, p = i), n === h && r === f && a === m && o === v || (u.blendFuncSeparate(F[n], F[r], F[a], F[o]), h = n, f = r, m = a, v = o), c = e, g = null;
                else if (e !== c || s !== g) {
                    if (d === Q && p === Q || (u.blendEquation(32774), p = d = Q), s) switch (e) {
                        case H:
                            u.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case X:
                            u.blendFunc(1, 1);
                            break;
                        case Y:
                            u.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case q:
                            u.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("v3d.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case H:
                            u.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case X:
                            u.blendFunc(770, 1);
                            break;
                        case Y:
                            u.blendFunc(0, 769);
                            break;
                        case q:
                            u.blendFunc(0, 768);
                            break;
                        default:
                            console.error("v3d.WebGLState: Invalid blending: ", e)
                    }
                    v = m = f = h = null, c = e, g = s
                }
            } else l && (O(3042), l = !1)
        }

        function B(e) {
            _ !== e && (e ? u.frontFace(2304) : u.frontFace(2305), _ = e)
        }

        function z(e) {
            e !== G ? (D(2884), e !== y && (e === j ? u.cullFace(1029) : e === W ? u.cullFace(1028) : u.cullFace(1032))) : O(2884), y = e
        }

        function U(e, t, n) {
            e ? (D(32823), b === t && M === n || (u.polygonOffset(t, n), b = t, M = n)) : O(32823)
        }

        function V(e) {
            void 0 === e && (e = 33984 + w - 1), T !== e && (u.activeTexture(e), T = e)
        }
        return {
            buffers: {
                color: r,
                depth: i,
                stencil: a
            },
            enable: D,
            disable: O,
            useProgram: function(e) {
                return s !== e && (u.useProgram(e), s = e, !0)
            },
            setBlending: k,
            setMaterial: function(e, t) {
                (e.side === oe ? O : D)(2884);
                var n = e.side === ae;
                t && (n = !n), B(n), e.blending === H && !1 === e.transparent ? k(se) : k(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), i.setFunc(e.depthFunc), i.setTest(e.depthTest), i.setMask(e.depthWrite), r.setMask(e.colorWrite), n = e.stencilWrite, a.setTest(n), n && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), U(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: B,
            setCullFace: z,
            setLineWidth: function(e) {
                e !== x && (S && u.lineWidth(e), x = e)
            },
            setPolygonOffset: U,
            setScissorTest: function(e) {
                (e ? D : O)(3089)
            },
            activeTexture: V,
            bindTexture: function(e, t) {
                null === T && V();
                var n = E[T];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, E[T] = n), n.type === e && n.texture === t || (u.bindTexture(e, t || R[e]), n.type = e, n.texture = t)
            },
            unbindTexture: function() {
                var e = E[T];
                void 0 !== e && void 0 !== e.type && (u.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    u.compressedTexImage2D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    u.texImage2D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    u.texImage3D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            scissor: function(e) {
                !1 === C.equals(e) && (u.scissor(e.x, e.y, e.z, e.w), C.copy(e))
            },
            viewport: function(e) {
                !1 === L.equals(e) && (u.viewport(e.x, e.y, e.z, e.w), L.copy(e))
            },
            reset: function() {
                o = {}, g = !(E = {}), M = b = x = y = _ = v = m = p = f = h = d = c = l = s = T = null, r.reset(), i.reset(), a.reset()
            }
        }
    }

    function Ms(x, r, b, c, i, M, u) {
        var e, a, w = i.isWebGL2,
            t = i.maxTextures,
            S = i.maxCubemapSize,
            v = i.maxTextureSize,
            n = i.maxSamples,
            o = new WeakMap,
            s = !1;
        try {
            s = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (e) {}

        function l(e, t) {
            return s ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function A(e, t, n, r) {
            var i = 1;
            if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    r = t ? mn.floorPowerOfTwo : Math.floor, t = r(i * e.width), i = r(i * e.height);
                    void 0 === a && (a = l(t, i));
                    n = n ? l(t, i) : a;
                    return n.width = t, n.height = i, n.getContext("2d").drawImage(e, 0, 0, t, i), console.warn("v3d.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + i + ")."), n
                }
                return "data" in e && console.warn("v3d.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
            }
            return e
        }

        function T(e) {
            return mn.isPowerOfTwo(e.width) && mn.isPowerOfTwo(e.height)
        }

        function E(e, t) {
            return e.generateMipmaps && t && e.minFilter !== ke && e.minFilter !== Ue
        }

        function C(e, t, n, r) {
            x.generateMipmap(e), c.get(t).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
        }

        function L(e, t, n) {
            if (!1 === w) return t;
            if (null !== e) {
                if (void 0 !== x[e]) return x[e];
                console.warn("v3d.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'")
            }
            e = t;
            return 6403 === t && (5126 === n && (e = 33326), 5131 === n && (e = 33325), 5121 === n && (e = 33321)), 6407 === t && (5126 === n && (e = 34837), 5131 === n && (e = 34843), 5121 === n && (e = 32849)), 6408 === t && (5126 === n && (e = 34836), 5131 === n && (e = 34842), 5121 === n && (e = 32856)), 33325 !== e && 33326 !== e && 34842 !== e && 34836 !== e || r.get("EXT_color_buffer_float"), e
        }

        function d(e) {
            return e === ke || e === Be || e === ze ? 9728 : 9729
        }

        function h(e) {
            var t, n = e.target;
            n.removeEventListener("dispose", h), t = n, void 0 !== (e = c.get(t)).__webglInit && (x.deleteTexture(e.__webglTexture), c.remove(t)), n.isVideoTexture && o.delete(n), u.memory.textures--, u.removeTextureSpec(n)
        }

        function f(e) {
            e = e.target;
            e.removeEventListener("dispose", f),
                function(e) {
                    var t = c.get(e),
                        n = c.get(e.texture);
                    if (e) {
                        if (void 0 !== n.__webglTexture && x.deleteTexture(n.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                            for (var r = 0; r < 6; r++) x.deleteFramebuffer(t.__webglFramebuffer[r]), t.__webglDepthbuffer && x.deleteRenderbuffer(t.__webglDepthbuffer[r]);
                        else x.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && x.deleteRenderbuffer(t.__webglDepthbuffer), t.__webglMultisampledFramebuffer && x.deleteFramebuffer(t.__webglMultisampledFramebuffer), t.__webglColorRenderbuffer && x.deleteRenderbuffer(t.__webglColorRenderbuffer), t.__webglDepthRenderbuffer && x.deleteRenderbuffer(t.__webglDepthRenderbuffer);
                        c.remove(e.texture), c.remove(e)
                    }
                }(e), u.memory.textures--, u.removeTextureSpec(e)
        }
        var p = 0;

        function m(e, t) {
            var n, r = c.get(e);
            if (e.isVideoTexture && (i = e, n = u.render.frame, o.get(i) !== n && (o.set(i, n), i.update())), 0 < e.version && r.__version !== e.version) {
                var i = e.image;
                if (void 0 === i) console.warn("v3d.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== i.complete) return void D(r, e, t);
                    console.warn("v3d.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            b.activeTexture(33984 + t), b.bindTexture(3553, r.__webglTexture)
        }

        function g(e, t) {
            var n = c.get(e);
            0 < e.version && n.__version !== e.version ? function(e, t, n) {
                if (6 === t.image.length) {
                    R(e, t), b.activeTexture(33984 + n), b.bindTexture(34067, e.__webglTexture), x.pixelStorei(37440, t.flipY);
                    for (var r = t && (t.isCompressedTexture || t.image[0].isCompressedTexture), i = t.image[0] && t.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = r || i ? i ? t.image[o].image : t.image[o] : A(t.image[o], !1, !0, S);
                    var s, l = a[0],
                        n = T(l) || w,
                        c = M.convert(t.format),
                        u = M.convert(t.type),
                        d = L(t.internalFormat, c, u);
                    if (P(34067, t, n), r) {
                        for (var h = 0; h < 6; h++) {
                            s = a[h].mipmaps;
                            for (var f = 0; f < s.length; f++) {
                                var p = s[f];
                                t.format !== Qe && t.format !== Ze ? null !== c ? b.compressedTexImage2D(34069 + h, f, d, p.width, p.height, 0, p.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(34069 + h, f, d, p.width, p.height, 0, c, u, p.data)
                            }
                        }
                        e.__maxMipLevel = s.length - 1
                    } else {
                        s = t.mipmaps;
                        for (var m = 0; m < 6; m++)
                            if (i) {
                                b.texImage2D(34069 + m, 0, d, a[m].width, a[m].height, 0, c, u, a[m].data);
                                for (var v = 0; v < s.length; v++) {
                                    var g = s[v].image[m].image;
                                    b.texImage2D(34069 + m, v + 1, d, g.width, g.height, 0, c, u, g.data)
                                }
                            } else {
                                b.texImage2D(34069 + m, 0, d, c, u, a[m]);
                                for (var _ = 0; _ < s.length; _++) {
                                    var y = s[_];
                                    b.texImage2D(34069 + m, _ + 1, d, c, u, y.image[m])
                                }
                            } e.__maxMipLevel = s.length
                    }
                    E(t, n) && C(34067, t, l.width, l.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
                }
            }(n, e, t) : (b.activeTexture(33984 + t), b.bindTexture(34067, n.__webglTexture))
        }
        var _ = (_defineProperty(e = {}, U, 10497), _defineProperty(e, V, 33071), _defineProperty(e, Fe, 33648), e),
            y = (_defineProperty(e = {}, ke, 9728), _defineProperty(e, Be, 9984), _defineProperty(e, ze, 9986), _defineProperty(e, Ue, 9729), _defineProperty(e, Ve, 9985), _defineProperty(e, Ge, 9987), e);

        function P(e, t, n) {
            n ? (x.texParameteri(e, 10242, _[t.wrapS]), x.texParameteri(e, 10243, _[t.wrapT]), 32879 !== e && 35866 !== e || x.texParameteri(e, 32882, _[t.wrapR]), x.texParameteri(e, 10240, y[t.magFilter]), x.texParameteri(e, 10241, y[t.minFilter])) : (x.texParameteri(e, 10242, 33071), x.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || x.texParameteri(e, 32882, 33071), t.wrapS === V && t.wrapT === V || console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to v3d.ClampToEdgeWrapping."), x.texParameteri(e, 10240, d(t.magFilter)), x.texParameteri(e, 10241, d(t.minFilter)), t.minFilter !== ke && t.minFilter !== Ue && console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to v3d.NearestFilter or v3d.LinearFilter."));
            n = r.get("EXT_texture_filter_anisotropic");
            n && (t.type === Xe && null === r.get("OES_texture_float_linear") || t.type === Ye && null === (w || r.get("OES_texture_half_float_linear")) || (1 < t.anisotropy || c.get(t).__currentAnisotropy) && (x.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, i.getMaxAnisotropy())), c.get(t).__currentAnisotropy = t.anisotropy))
        }

        function R(e, t) {
            void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", h), e.__webglTexture = x.createTexture(), u.memory.textures++, u.addTextureSpec(t))
        }

        function D(e, t, n) {
            var r = 3553;
            t.isDataTexture2DArray && (r = 35866), t.isDataTexture3D && (r = 32879), R(e, t), b.activeTexture(33984 + n), b.bindTexture(r, e.__webglTexture), x.pixelStorei(37440, t.flipY), x.pixelStorei(37441, t.premultiplyAlpha), x.pixelStorei(3317, t.unpackAlignment);
            var i, n = (a = t, !w && (a.wrapS !== V || a.wrapT !== V || a.minFilter !== ke && a.minFilter !== Ue) && !1 === T(t.image)),
                a = A(t.image, n, !1, v),
                n = T(a) || w,
                o = M.convert(t.format),
                s = M.convert(t.type),
                l = L(t.internalFormat, o, s);
            P(r, t, n);
            var c = t.mipmaps;
            if (t.isDepthTexture) l = 6402, w ? l = t.type === Xe ? 36012 : t.type === He ? 33190 : t.type === qe ? 35056 : 33189 : t.type === Xe && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), t.format === Ke && 6402 === l && t.type !== We && t.type !== He && (console.warn("v3d.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = We, s = M.convert(t.type)), t.format === Je && 6402 === l && (l = 34041, t.type !== qe && (console.warn("v3d.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = qe, s = M.convert(t.type))), b.texImage2D(3553, 0, l, a.width, a.height, 0, o, s, null);
            else if (t.isDataTexture)
                if (0 < c.length && n) {
                    for (var u = 0, d = c.length; u < d; u++) i = c[u], b.texImage2D(3553, u, l, i.width, i.height, 0, o, s, i.data);
                    t.generateMipmaps = !1, e.__maxMipLevel = c.length - 1
                } else b.texImage2D(3553, 0, l, a.width, a.height, 0, o, s, a.data), e.__maxMipLevel = 0;
            else if (t.isCompressedTexture) {
                for (var h = 0, f = c.length; h < f; h++) i = c[h], t.format !== Qe && t.format !== Ze ? null !== o ? b.compressedTexImage2D(3553, h, l, i.width, i.height, 0, i.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(3553, h, l, i.width, i.height, 0, o, s, i.data);
                e.__maxMipLevel = c.length - 1
            } else if (t.isDataTexture2DArray) b.texImage3D(35866, 0, l, a.width, a.height, a.depth, 0, o, s, a.data), e.__maxMipLevel = 0;
            else if (t.isDataTexture3D) b.texImage3D(32879, 0, l, a.width, a.height, a.depth, 0, o, s, a.data), e.__maxMipLevel = 0;
            else if (0 < c.length && n) {
                for (var p = 0, m = c.length; p < m; p++) i = c[p], b.texImage2D(3553, p, l, o, s, i);
                t.generateMipmaps = !1, e.__maxMipLevel = c.length - 1
            } else b.texImage2D(3553, 0, l, o, s, a), e.__maxMipLevel = 0;
            E(t, n) && C(r, t, a.width, a.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
        }

        function O(e, t, n, r) {
            var i = M.convert(t.texture.format),
                a = M.convert(t.texture.type),
                o = L(t.texture.internalFormat, i, a);
            b.texImage2D(r, 0, o, t.width, t.height, 0, i, a, null), x.bindFramebuffer(36160, e), x.framebufferTexture2D(36160, n, r, c.get(t.texture).__webglTexture, 0), x.bindFramebuffer(36160, null)
        }

        function N(e, t, n) {
            var r, i, a;
            x.bindRenderbuffer(36161, e), t.depthBuffer && !t.stencilBuffer ? (r = 33189, n ? ((i = t.depthTexture) && i.isDepthTexture && (i.type === Xe ? r = 36012 : i.type === He && (r = 33190)), i = F(t), x.renderbufferStorageMultisample(36161, i, r, t.width, t.height)) : x.renderbufferStorage(36161, r, t.width, t.height), x.framebufferRenderbuffer(36160, 36096, 36161, e)) : t.depthBuffer && t.stencilBuffer ? (n ? (a = F(t), x.renderbufferStorageMultisample(36161, a, 35056, t.width, t.height)) : x.renderbufferStorage(36161, 34041, t.width, t.height), x.framebufferRenderbuffer(36160, 33306, 36161, e)) : (a = M.convert(t.texture.format), e = M.convert(t.texture.type), e = L(t.texture.internalFormat, a, e), n ? (n = F(t), x.renderbufferStorageMultisample(36161, n, e, t.width, t.height)) : x.renderbufferStorage(36161, e, t.width, t.height)), x.bindRenderbuffer(36161, null)
        }

        function I(e) {
            var t = c.get(e),
                n = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(e, t) {
                    if (t && t.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (x.bindFramebuffer(36160, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of v3d.DepthTexture");
                    if (c.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), m(t.depthTexture, 0), e = c.get(t.depthTexture).__webglTexture, t.depthTexture.format === Ke) x.framebufferTexture2D(36160, 36096, 3553, e, 0);
                    else {
                        if (t.depthTexture.format !== Je) throw new Error("Unknown depthTexture format");
                        x.framebufferTexture2D(36160, 33306, 3553, e, 0)
                    }
                }(t.__webglFramebuffer, e)
            } else if (n) {
                t.__webglDepthbuffer = [];
                for (var r = 0; r < 6; r++) x.bindFramebuffer(36160, t.__webglFramebuffer[r]), t.__webglDepthbuffer[r] = x.createRenderbuffer(), N(t.__webglDepthbuffer[r], e, !1)
            } else x.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = x.createRenderbuffer(), N(t.__webglDepthbuffer, e, !1);
            x.bindFramebuffer(36160, null)
        }

        function F(e) {
            return w && e.isWebGLMultisampleRenderTarget ? Math.min(n, e.samples) : 0
        }
        var k = !1,
            B = !1;
        this.allocateTextureUnit = function() {
            var e = p;
            return t <= e && console.warn("v3d.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + t), p += 1, e
        }, this.resetTextureUnits = function() {
            p = 0
        }, this.setTexture2D = m, this.setTexture2DArray = function(e, t) {
            var n = c.get(e);
            0 < e.version && n.__version !== e.version ? D(n, e, t) : (b.activeTexture(33984 + t), b.bindTexture(35866, n.__webglTexture))
        }, this.setTexture3D = function(e, t) {
            var n = c.get(e);
            0 < e.version && n.__version !== e.version ? D(n, e, t) : (b.activeTexture(33984 + t), b.bindTexture(32879, n.__webglTexture))
        }, this.setTextureCube = g, this.setupRenderTarget = function(e) {
            var t = c.get(e),
                n = c.get(e.texture);
            e.addEventListener("dispose", f), n.__webglTexture = x.createTexture(), u.memory.textures++, u.addTextureSpec(e);
            var r, i = !0 === e.isWebGLCubeRenderTarget,
                a = !0 === e.isWebGLMultisampleRenderTarget,
                o = T(e) || w;
            if (!w || e.texture.format !== Ze || e.texture.type !== Xe && e.texture.type !== Ye || (e.texture.format = Qe, console.warn("v3d.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), i) {
                t.__webglFramebuffer = [];
                for (var s = 0; s < 6; s++) t.__webglFramebuffer[s] = x.createFramebuffer()
            } else t.__webglFramebuffer = x.createFramebuffer(), a && (w ? (t.__webglMultisampledFramebuffer = x.createFramebuffer(), t.__webglColorRenderbuffer = x.createRenderbuffer(), x.bindRenderbuffer(36161, t.__webglColorRenderbuffer), r = M.convert(e.texture.format), a = M.convert(e.texture.type), r = L(e.texture.internalFormat, r, a), a = F(e), x.renderbufferStorageMultisample(36161, a, r, e.width, e.height), x.bindFramebuffer(36160, t.__webglMultisampledFramebuffer), x.framebufferRenderbuffer(36160, 36064, 36161, t.__webglColorRenderbuffer), x.bindRenderbuffer(36161, null), e.depthBuffer && (t.__webglDepthRenderbuffer = x.createRenderbuffer(), N(t.__webglDepthRenderbuffer, e, !0)), x.bindFramebuffer(36160, null)) : console.warn("v3d.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."));
            if (i) {
                b.bindTexture(34067, n.__webglTexture), P(34067, e.texture, o);
                for (var l = 0; l < 6; l++) O(t.__webglFramebuffer[l], e, 36064, 34069 + l);
                E(e.texture, o) && C(34067, e.texture, e.width, e.height), b.bindTexture(34067, null)
            } else b.bindTexture(3553, n.__webglTexture), P(3553, e.texture, o), O(t.__webglFramebuffer, e, 36064, 3553), E(e.texture, o) && C(3553, e.texture, e.width, e.height), b.bindTexture(3553, null);
            e.depthBuffer && I(e)
        }, this.updateRenderTargetMipmap = function(e) {
            var t, n, r = e.texture;
            E(r, T(e) || w) && (t = e.isWebGLCubeRenderTarget ? 34067 : 3553, n = c.get(r).__webglTexture, b.bindTexture(t, n), C(t, r, e.width, e.height), b.bindTexture(t, null))
        }, this.updateMultisampleRenderTarget = function(e) {
            var t, n, r, i;
            e.isWebGLMultisampleRenderTarget && (w ? (t = c.get(e), x.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), x.bindFramebuffer(36009, t.__webglFramebuffer), n = e.width, r = e.height, i = 16384, e.depthBuffer && (i |= 256), e.stencilBuffer && (i |= 1024), x.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728), x.bindFramebuffer(36160, t.__webglMultisampledFramebuffer)) : console.warn("v3d.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."))
        }, this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === k && (console.warn("v3d.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), k = !0), e = e.texture), m(e, t)
        }, this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === B && (console.warn("v3d.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), g(e, t)
        }
    }

    function ws(e, n, t) {
        var r = t.isWebGL2;
        return {
            convert: function(e) {
                var t;
                if (e === je) return 5121;
                if (e === l) return 32819;
                if (e === c) return 32820;
                if (e === u) return 33635;
                if (e === i) return 5120;
                if (e === a) return 5122;
                if (e === We) return 5123;
                if (e === s) return 5124;
                if (e === He) return 5125;
                if (e === Xe) return 5126;
                if (e === Ye) return r ? 5131 : null !== (t = n.get("OES_texture_half_float")) ? t.HALF_FLOAT_OES : null;
                if (e === d) return 6406;
                if (e === Ze) return 6407;
                if (e === Qe) return 6408;
                if (e === h) return 6409;
                if (e === f) return 6410;
                if (e === Ke) return 6402;
                if (e === Je) return 34041;
                if (e === $e) return 6403;
                if (e === p) return 36244;
                if (e === m) return 33319;
                if (e === v) return 33320;
                if (e === g) return 36248;
                if (e === _) return 36249;
                if (e === y || e === x || e === b || e === M) {
                    if (null === (t = n.get("WEBGL_compressed_texture_s3tc"))) return null;
                    if (e === y) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === x) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === b) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === M) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (e === S || e === A || e === et || e === tt) {
                    if (null === (t = n.get("WEBGL_compressed_texture_pvrtc"))) return null;
                    if (e === S) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === A) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === et) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === tt) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === nt) return null !== (t = n.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((e === rt || e === it) && null !== (t = n.get("WEBGL_compressed_texture_etc"))) {
                    if (e === rt) return t.COMPRESSED_RGB8_ETC2;
                    if (e === it) return t.COMPRESSED_RGBA8_ETC2_EAC
                }
                return e === at || e === ot || e === st || e === lt || e === ct || e === ut || e === dt || e === ht || e === ft || e === pt || e === mt || e === vt || e === gt || e === _t || e === xt || e === bt || e === Mt || e === wt || e === St || e === At || e === Tt || e === Et || e === Ct || e === Lt || e === Pt || e === Rt || e === Dt || e === Ot ? null !== (t = n.get("WEBGL_compressed_texture_astc")) ? e : null : e === yt ? null !== (t = n.get("EXT_texture_compression_bptc")) ? e : null : e === qe ? r ? 34042 : null !== (t = n.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }

    function Ss() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [];
        la.call(this), this.cameras = e
    }

    function As() {
        Er.call(this), this.type = "Group"
    }

    function Ts() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    Ss.prototype = Object.assign(Object.create(la.prototype), {
        constructor: Ss,
        isArrayCamera: !0
    }), As.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: As,
        isGroup: !0,
        getWorldDirection: function(e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
    }), Object.assign(Ts.prototype, {
        constructor: Ts,
        getHandSpace: function() {
            if (null === this._hand && (this._hand = new As, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                    pinching: !1
                }, window.XRHand))
                for (var e = 0; e <= window.XRHand.LITTLE_PHALANX_TIP; e++) {
                    var t = new As;
                    t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t)
                }
            return this._hand
        },
        getTargetRaySpace: function(e) {
            return null === this._targetRay && (this._targetRay = new As, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.name = "XR_CONTROLLER_" + String(e)), this._targetRay
        },
        getGripSpace: function() {
            return null === this._grip && (this._grip = new As, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
        },
        dispatchEvent: function(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
        },
        disconnect: function(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
        },
        update: function(e, t, n) {
            var r = null,
                i = null,
                a = null,
                o = this._targetRay,
                s = this._grip,
                l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
                if (l && e.hand) {
                    a = !0;
                    for (var c, u, d = 0; d <= window.XRHand.LITTLE_PHALANX_TIP; d++) e.hand[d] && (u = t.getJointPose(e.hand[d], n), c = l.joints[d], null !== u && (c.matrix.fromArray(u.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.jointRadius = u.radius), c.visible = null !== u, c = l.joints[window.XRHand.INDEX_PHALANX_TIP], u = l.joints[window.XRHand.THUMB_PHALANX_TIP], u = c.position.distanceTo(u.position), l.inputState.pinching && .025 < u ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && u <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    })))
                } else null !== o && null !== (r = t.getPose(e.targetRaySpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale)), null !== s && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale));
            return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this
        }
    });
    var Es = {
        checkWebGL: function() {
            try {
                var e = document.createElement("canvas");
                return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl"))
            } catch (e) {
                return !1
            }
        },
        checkWebGL2: function() {
            try {
                var e = document.createElement("canvas");
                return !(!window.WebGL2RenderingContext || !e.getContext("webgl2"))
            } catch (e) {
                return !1
            }
        },
        checkWorkers: function() {
            return !!window.Worker
        },
        checkFileAPI: function() {
            return window.File && window.FileReader && window.FileList && window.Blob
        },
        genWebGLErrorMessage: function() {
            var e = document.createElement("div");
            return e.setAttribute("class", "v3d-webgl-error"), e.innerHTML = (window.WebGLRenderingContext ? ["Ouch! Your graphics card does not support WebGL.<br/>", 'Find out how to fix it <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.'] : ["Ouch! Your browser does not support WebGL.<br/>", 'Find out how to fix it <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.']).join("\n"), e
        },
        showWebGLErrorMessage: function(e) {
            (e = e || document.body).appendChild(Es.genWebGLErrorMessage());
            e = document.getElementById("v3d_preloader_container");
            e && (e.style.visibility = "hidden")
        },
        checkIOS: function() {
            return (/iPad|iPhone|iPod/.test(navigator.platform) || "MacIntel" === navigator.platform && 1 < navigator.maxTouchPoints) && !window.MSStream
        },
        checkAndroid: function() {
            return !!navigator.userAgent.match(/Android/i)
        },
        checkFloatTex: function(e, t) {
            var n = e.getContext();
            return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float") || t && !n.getExtension("OES_texture_float_linear")) || !(e.capabilities.isWebGL2 || !n.getExtension("OES_texture_float") || t && !n.getExtension("OES_texture_float_linear"))
        },
        checkHalfFloatTex: function(e, t) {
            var n = e.getContext();
            return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float")) || !(e.capabilities.isWebGL2 || !n.getExtension("OES_texture_half_float") || t && !n.getExtension("OES_texture_half_float_linear"))
        },
        checkDepthTex: function(e) {
            var t = e.getContext();
            return !(!e.capabilities.isWebGL2 && !t.getExtension("WEBGL_depth_texture"))
        },
        getGPUVendor: function(e) {
            var t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl"),
                e = t.getExtension("WEBGL_debug_renderer_info");
            return null != e ? t.getParameter(e.UNMASKED_VENDOR_WEBGL) : ""
        },
        getGPUModel: function(e) {
            var t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl"),
                e = t.getExtension("WEBGL_debug_renderer_info");
            return null != e ? t.getParameter(e.UNMASKED_RENDERER_WEBGL) : ""
        },
        checkWebXR: function(e, t, n) {
            "xr" in navigator && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported(e).then(function(e) {
                (e ? t : n)()
            }).catch(n) : n()
        },
        checkNativeWebXR: function() {
            var e = "polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill;
            return "xr" in navigator && (!e || e && polyfill.nativeWebXR)
        },
        checkCardboard: function() {
            if (!("polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill)) return !1;
            for (var e = Object.getOwnPropertySymbols(navigator.xr), t = 0; t < e.length; t++) {
                var n = e[t];
                if ("Symbol(@@webxr-polyfill/XR)" == n.toString()) {
                    n = navigator.xr[n].device;
                    if (n && "CardboardXRDevice" == n.constructor.name) return !0
                }
            }
            return !1
        },
        checkSwiftShader: function(e) {
            return "Google SwiftShader" == this.getGPUModel(e)
        },
        checkWebAudio: function() {
            return void 0 !== (window.AudioContext || window.webkitAudioContext)
        }
    };

    function Cs(e, t, n, r) {
        this.ray = new tr(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new fr, this.params = {
            Mesh: {
                omitGeometry: !1
            },
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {},
            checkVisibility: !0
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("v3d.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Ls(e, t) {
        return e.distance - t.distance
    }

    function Ps(e, t, n, r, i) {
        if (!(i && (!1 === e.visible || e.isMesh && e.isMaterialGeneratedMesh && e.parent && !e.parent.visible) || (e.layers.test(t.layers) && e.raycast(t, n), !0 !== r)))
            for (var a = e.children, o = 0, s = a.length; o < s; o++) Ps(a[o], t, n, !0, i)
    }

    function Rs(p, t) {
        var m = this,
            v = null,
            n = 1,
            r = null,
            i = "local-floor",
            g = null,
            _ = [],
            s = new Map,
            l = new la;
        l.layers.enable(1), l.viewport = new Mn;
        var c = new la;
        c.layers.enable(2), c.viewport = new Mn;
        var y = [l, c],
            x = new Ss;
        x.layers.enable(1), x.layers.enable(2);
        var u = null,
            d = null,
            a = null,
            b = null,
            M = null,
            w = null,
            S = null,
            o = new Tn,
            h = new Tn,
            f = new An;

        function A(e) {
            var t = s.get(e.inputSource);
            t && t.dispatchEvent({
                type: e.type,
                data: e.inputSource
            })
        }

        function T() {
            s.forEach(function(e, t) {
                e.disconnect(t)
            }), s.clear(), p.setFramebuffer(null), p.setRenderTarget(p.getRenderTarget()), O.stop(), m.isPresenting = !1, m.dispatchEvent({
                type: "sessionend"
            })
        }

        function E(e) {
            r = e, O.setContext(v), O.start(), m.isPresenting = !0, m.dispatchEvent({
                type: "sessionstart"
            })
        }

        function C(n) {
            for (var e = b || v.inputSources, t = 0; t < _.length; t++) s.set(e[t], _[t]);
            for (var r = 0; r < n.removed.length; r++) {
                var i = n.removed[r],
                    a = s.get(i);
                a && (a.dispatchEvent({
                    type: "disconnected",
                    data: i
                }), s.delete(i))
            }
            for (var o = 0; o < n.added.length; o++) ! function() {
                var e = n.added[o],
                    t = s.get(e);
                t && (b ? setTimeout(function() {
                    t.dispatchEvent({
                        type: "connected",
                        data: e
                    })
                }, 0) : t.dispatchEvent({
                    type: "connected",
                    data: e
                }))
            }()
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
            var t = _[e];
            return void 0 === t && (t = new Ts, _[e] = t), t.getTargetRaySpace(e)
        }, this.getControllerGrip = function(e) {
            var t = _[e];
            return void 0 === t && (t = new Ts, _[e] = t), t.getGripSpace()
        }, this.getHand = function(e) {
            var t = _[e];
            return void 0 === t && (t = new Ts, _[e] = t), t.getHandSpace()
        }, this.setFramebufferScaleFactor = function(e) {
            n = e, !0 === m.isPresenting && console.warn("v3d.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(e) {
            i = e, !0 === m.isPresenting && console.warn("v3d.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            if (a) {
                a.clone().invert().decompose(o, f, h);
                var e = new XRRigidTransform({
                    x: o.x,
                    y: o.y,
                    z: o.z
                }, {
                    x: f.x,
                    y: f.y,
                    z: f.z,
                    w: f.w
                });
                return r.getOffsetReferenceSpace(e)
            }
            return r
        }, this.getSession = function() {
            return v
        }, this.setSession = function(e) {
            null !== (v = e) && (v.addEventListener("select", A), v.addEventListener("selectstart", A), v.addEventListener("selectend", A), v.addEventListener("squeeze", A), v.addEventListener("squeezestart", A), v.addEventListener("squeezeend", A), v.addEventListener("end", T), !0 !== (e = t.getContextAttributes()).xrCompatible && t.makeXRCompatible(), e = {
                antialias: e.antialias,
                alpha: e.alpha,
                depth: e.depth,
                stencil: e.stencil,
                framebufferScaleFactor: n
            }, e = new XRWebGLLayer(v, t, e), v.updateRenderState({
                baseLayer: e
            }), v.requestReferenceSpace(i).then(E), v.addEventListener("inputsourceschange", C), Es.checkCardboard() && (C({
                added: b = [{
                    gamepad: null,
                    gripSpace: null,
                    handedness: "none",
                    targetRayMode: "gaze",
                    targetRaySpace: {},
                    profiles: []
                }],
                removed: []
            }), document.addEventListener("touchstart", function() {
                var e = _[0];
                e && e._targetRay && e._targetRay.dispatchEvent({
                    type: "selectstart"
                })
            }), document.addEventListener("touchend", function() {
                var e = _[0];
                e && e._targetRay && (e._targetRay.dispatchEvent({
                    type: "selectend"
                }), e._targetRay.dispatchEvent({
                    type: "select"
                }))
            })))
        };
        var L = new Tn,
            P = new Tn;

        function R(e, t) {
            a = null === t ? (e.matrixWorld.copy(e.matrix), null) : (e.matrixWorld.copy(e.matrix), t.matrixWorld), e.matrixWorldInverse.copy(e.matrixWorld).invert()
        }
        this.getCamera = function(e) {
            x.near = c.near = l.near = e.near, x.far = c.far = l.far = e.far, u === x.near && d === x.far || (v.updateRenderState({
                depthNear: x.near,
                depthFar: x.far
            }), u = x.near, d = x.far);
            var t = e.parent,
                n = x.cameras;
            R(x, t);
            for (var r = 0; r < n.length; r++) R(n[r], t);
            e.matrixWorld.copy(x.matrixWorld), null === t ? e.matrix.copy(e.matrixWorld) : (e.matrix.copy(t.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale);
            for (var i = e.children, a = 0, o = i.length; a < o; a++) i[a].updateMatrixWorld(!0);
            return 2 === n.length ? function(e, t, n) {
                L.setFromMatrixPosition(t.matrixWorld), P.setFromMatrixPosition(n.matrixWorld);
                var r = L.distanceTo(P),
                    i = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    l = (i[9] + 1) / i[5],
                    c = (i[9] - 1) / i[5],
                    u = (i[8] - 1) / i[0],
                    n = (a[8] + 1) / a[0],
                    i = o * u,
                    a = o * n,
                    u = (n = r / (n - u)) * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(u), e.translateZ(n), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), o += n, i -= u, a = r - u + a, l = l * s / (n = s + n) * o, s = c * s / n * o, e.projectionMatrix.makePerspective(i, a, l, s, o, n)
            }(x, l, c) : x.projectionMatrix.copy(l.projectionMatrix), x
        };
        var D = null;
        var O = new ya;
        O.setAnimationLoop(function(e, t) {
            var n = m.getReferenceSpace();
            if (null !== (g = t.getViewerPose(n))) {
                var r = g.views,
                    i = v.renderState.baseLayer;
                p.setFramebuffer(i.framebuffer);
                var a = !1;
                r.length !== x.cameras.length && (a = !(x.cameras.length = 0));
                for (var o = 0; o < r.length; o++) {
                    var s = r[o],
                        l = i.getViewport(s),
                        c = y[o];
                    c.matrix.fromArray(s.transform.matrix), c.projectionMatrix.fromArray(s.projectionMatrix), c.viewport.set(l.x, l.y, l.width, l.height), 0 === o && x.matrix.copy(c.matrix), !0 === a && x.cameras.push(c)
                }
            }
            for (var u = v.inputSources, d = 0; d < _.length; d++) {
                var h = _[d],
                    f = u[d];
                h.update(f, t, n), b && b[d] && h._targetRay && (h._targetRay.matrix.copy(x.matrix), h._targetRay.matrix.decompose(h._targetRay.position, h._targetRay.rotation, h._targetRay.scale)), f = t, h = void 0, M && ((h = f.getHitTestResults(M)).length ? (f = h[0].getPose(m.getReferenceSpace()), h = (new nr).fromArray(f.transform.matrix), (f = new Tn).setFromMatrixPosition(h), w(f)) : S())
            }
            D && D(e, t)
        }), this.setAnimationLoop = function(e) {
            D = e
        }, this.dispose = function() {}, this.arHitTest = function(e, t, n, r) {
            v && XRSession.prototype.requestHitTestSource && (w = n || function() {}, S = r || function() {}, this.raycaster = this.raycaster || new Cs, this.raycaster.setFromCamera({
                x: e,
                y: t
            }, y[0]), t = this.raycaster.ray, new XRRay(t.origin, t.direction), v.requestReferenceSpace("viewer").then(function(e) {
                e = {
                    space: e
                };
                v.requestHitTestSource(e).then(function(e) {
                    M = e
                })
            }))
        }
    }

    function Ds(b) {
        function M(e, t) {
            e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap);
            var n, r, i = b.get(t).envMap;
            i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, void 0 !== (i = b.get(i).__maxMipLevel) && (e.maxMipLevel.value = i)), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap ? n = t.emissiveMap : t.clearcoatMap ? n = t.clearcoatMap : t.clearcoatNormalMap ? n = t.clearcoatNormalMap : t.clearcoatRoughnessMap && (n = t.clearcoatRoughnessMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)), t.aoMap ? r = t.aoMap : t.lightMap && (r = t.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uv2Transform.value.copy(r.matrix))
        }

        function w(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === ae && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === ae && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), b.get(t).envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(e, t) {
                e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            },
            refreshMaterialUniforms: function(e, t, n, r) {
                var i, a, o, s, l, c, u, d, h, f, p, m, v, g, _, y, x;
                t.ssrParams && (x = t, (y = e).invProjectionMatrix.value = x.ssrParams.invProjectionMatrix, y.ssrSourceBuffer.value = x.ssrParams.sourceBuffer.texture, y.ssrDepthBuffer.value = x.ssrParams.depthBuffer.texture, y.ssrBackfaceDepthBuffer.value = x.ssrParams.backfaceDepthBuffer.texture, y.ssrResolution.value = new vn(x.ssrParams.sourceBuffer.width, x.ssrParams.sourceBuffer.height), y.ssrStride.value = x.ssrParams.stride, y.ssrThickness.value = x.ssrParams.thickness, y.ssrMaxDistance.value = x.ssrParams.maxDistance, y.ssrJitter.value = x.ssrParams.jitter), t.isMeshBasicMaterial ? M(e, t) : t.isMeshLambertMaterial ? (M(e, t), y = e, (x = t).emissiveMap && (y.emissiveMap.value = x.emissiveMap)) : t.isMeshToonMaterial ? (M(e, t), g = e, (_ = t).gradientMap && (g.gradientMap.value = _.gradientMap), _.emissiveMap && (g.emissiveMap.value = _.emissiveMap), _.bumpMap && (g.bumpMap.value = _.bumpMap, g.bumpScale.value = _.bumpScale, _.side === ae && (g.bumpScale.value *= -1)), _.normalMap && (g.normalMap.value = _.normalMap, g.normalScale.value.copy(_.normalScale), _.side === ae && g.normalScale.value.negate()), _.displacementMap && (g.displacementMap.value = _.displacementMap, g.displacementScale.value = _.displacementScale, g.displacementBias.value = _.displacementBias)) : t.isMeshPhongMaterial ? (M(e, t), g = t, (_ = e).specular.value.copy(g.specular), _.shininess.value = Math.max(g.shininess, 1e-4), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap), g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === ae && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === ae && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias)) : t.isMeshStandardMaterial ? (M(e, t), t.isMeshPhysicalMaterial ? (w(m = e, v = t), m.reflectivity.value = v.reflectivity, m.clearcoat.value = v.clearcoat, m.clearcoatRoughness.value = v.clearcoatRoughness, v.sheen && m.sheen.value.copy(v.sheen), v.clearcoatMap && (m.clearcoatMap.value = v.clearcoatMap), v.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap), v.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), m.clearcoatNormalMap.value = v.clearcoatNormalMap, v.side === ae && m.clearcoatNormalScale.value.negate()), m.transmission.value = v.transmission, v.transmissionMap && (m.transmissionMap.value = v.transmissionMap)) : w(e, t)) : t.isMeshMatcapMaterial ? (M(e, t), m = e, (v = t).matcap && (m.matcap.value = v.matcap), v.bumpMap && (m.bumpMap.value = v.bumpMap, m.bumpScale.value = v.bumpScale, v.side === ae && (m.bumpScale.value *= -1)), v.normalMap && (m.normalMap.value = v.normalMap, m.normalScale.value.copy(v.normalScale), v.side === ae && m.normalScale.value.negate()), v.displacementMap && (m.displacementMap.value = v.displacementMap, m.displacementScale.value = v.displacementScale, m.displacementBias.value = v.displacementBias)) : t.isMeshDepthMaterial ? (M(e, t), f = e, (p = t).displacementMap && (f.displacementMap.value = p.displacementMap, f.displacementScale.value = p.displacementScale, f.displacementBias.value = p.displacementBias), f.slopeScaledBias.value = p.slopeScaledBias) : t.isMeshDistanceMaterial ? (M(e, t), f = e, (p = t).displacementMap && (f.displacementMap.value = p.displacementMap, f.displacementScale.value = p.displacementScale, f.displacementBias.value = p.displacementBias), f.referencePosition.value.copy(p.referencePosition), f.nearDistance.value = p.nearDistance, f.farDistance.value = p.farDistance, f.slopeScaledBias.value = p.slopeScaledBias) : t.isMeshNormalMaterial ? (M(e, t), d = e, (h = t).bumpMap && (d.bumpMap.value = h.bumpMap, d.bumpScale.value = h.bumpScale, h.side === ae && (d.bumpScale.value *= -1)), h.normalMap && (d.normalMap.value = h.normalMap, d.normalScale.value.copy(h.normalScale), h.side === ae && d.normalScale.value.negate()), h.displacementMap && (d.displacementMap.value = h.displacementMap, d.displacementScale.value = h.displacementScale, d.displacementBias.value = h.displacementBias)) : t.isLineBasicMaterial ? (d = t, (h = e).diffuse.value.copy(d.color), h.opacity.value = d.opacity, t.isLineDashedMaterial && (u = t, (d = e).dashSize.value = u.dashSize, d.totalSize.value = u.dashSize + u.gapSize, d.scale.value = u.scale)) : t.isPointsMaterial ? (u = t, n = n, r = r, (l = e).diffuse.value.copy(u.color), l.opacity.value = u.opacity, l.size.value = u.size * n, l.scale.value = .5 * r, u.map && (l.map.value = u.map), u.alphaMap && (l.alphaMap.value = u.alphaMap), u.map ? c = u.map : u.alphaMap && (c = u.alphaMap), void 0 !== c && (!0 === c.matrixAutoUpdate && c.updateMatrix(), l.uvTransform.value.copy(c.matrix))) : t.isSpriteMaterial ? (l = t, (c = e).diffuse.value.copy(l.color), c.opacity.value = l.opacity, c.rotation.value = l.rotation, l.map && (c.map.value = l.map), l.alphaMap && (c.alphaMap.value = l.alphaMap), l.map ? s = l.map : l.alphaMap && (s = l.alphaMap), void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), c.uvTransform.value.copy(s.matrix))) : t.isShadowMaterial ? (e.color.value.copy(t.color), e.opacity.value = t.opacity) : t.isMeshMaskMaterial ? (M(e, t), a = e, (o = t).displacementMap && (a.displacementMap.value = o.displacementMap, a.displacementScale.value = o.displacementScale, a.displacementBias.value = o.displacementBias), o.cameraNearFar && (a.cameraNearFar.value = o.cameraNearFar), a.depthTexture.value = o.depthTexture, o.textureMatrix && (a.textureMatrix.value = o.textureMatrix)) : t.isMeshNodeMaterial ? (a = e, i = t, (o = b.get(i).envMap) && (a.envMap.value = o, a.flipEnvMap.value = o.isCubeTexture ? -1 : 1, a.reflectivity.value = i.reflectivity, a.refractionRatio.value = i.refractionRatio, a.maxMipLevel.value = b.get(o).__maxMipLevel), i.displacementMap && (a.displacementMap.value = i.displacementMap, a.displacementScale.value = i.displacementScale, a.displacementBias.value = i.displacementBias)) : t.isMeshLineMaterial ? (i = t, (e = e).lineWidth.value = i.lineWidth, e.sizeAttenuation.value = i.sizeAttenuation, e.color.value = i.color, e.opacity.value = i.opacity, e.useMap.value = i.useMap, i.map && (e.map.value = i.map), e.useAlphaMap.value = i.useAlphaMap, i.alphaMap && (e.alphaMap.value = i.alphaMap), e.visibility.value = i.visibility, e.alphaTest.value = i.alphaTest, e.repeat.value = i.repeat) : t.isShaderMaterial && (t.uniformsNeedUpdate = !1)
            }
        }
    }
    Object.assign(Cs.prototype, {
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("v3d.Raycaster: Unsupported camera type: " + t.type)
        },
        intersectObject: function(e, t, n) {
            n = n || [];
            return Ps(e, this, n, t, this.params.checkVisibility), n.sort(Ls), n
        },
        intersectObjects: function(e, t, n) {
            var r = n || [];
            if (!1 === Array.isArray(e)) return console.warn("v3d.Raycaster.intersectObjects: objects is not an Array."), r;
            for (var i = 0, a = e.length; i < a; i++) Ps(e[i], this, r, t, this.params.checkVisibility);
            return r.sort(Ls), r
        }
    }), Object.assign(Rs.prototype, n.prototype);
    var Os = 16,
        Ns = 16;

    function Is(e) {
        var t, i = void 0 !== (e = e || {}).canvas ? e.canvas : ((t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).style.display = "block", t),
            t = void 0 !== e.context ? e.context : null,
            n = void 0 !== e.alpha && e.alpha,
            r = void 0 === e.depth || e.depth,
            a = void 0 === e.stencil || e.stencil,
            o = void 0 !== e.antialias && e.antialias,
            s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            c = void 0 !== e.powerPreference ? e.powerPreference : "default",
            u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            y = null,
            x = null,
            d = [];
        this.domElement = i, this.debug = {
            checkShaderErrors: !0,
            disableCompiledShaderCache: !1
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Vt, this.physicallyCorrectLights = !1, this.unitsScaleFactor = 1, this.toneMapping = Oe, this.toneMappingExposure = 1, this.maxMorphTargets = 12, this.maxMorphNormals = 6, this.compatSettings = {
            useSpecEnvBlenderApprox: !0,
            saturateSpecEnvBlenderApprox: !1
        };
        var v = this,
            h = !1,
            f = null,
            p = 0,
            m = 0,
            g = null,
            _ = null,
            b = -1,
            M = null,
            w = new Mn,
            S = new Mn,
            A = null,
            T = i.width,
            E = i.height,
            C = 1,
            L = null,
            P = null,
            R = new Mn(0, 0, T, E),
            D = new Mn(0, 0, T, E),
            O = !1,
            N = new ma,
            I = !1,
            F = !1,
            k = new nr,
            B = new nr,
            z = new nr,
            U = new vn,
            V = new Tn,
            G = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function j() {
            return null === g ? C : 1
        }
        var W, H, X, Y, q, Z, Q, K, J, $, ee, te, ne, re, ie, ae, oe, se, le, ce, ue, de, he = t;

        function fe(e, t) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n],
                    r = i.getContext(r, t);
                if (null !== r) return r
            }
            return null
        }
        try {
            var pe = {
                alpha: n,
                depth: r,
                stencil: a,
                antialias: o,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: c,
                xrCompatible: !0,
                failIfMajorPerformanceCaveat: u
            };
            if (i.addEventListener("webglcontextlost", ye, !1), i.addEventListener("webglcontextrestored", xe, !1), null === he) {
                var me = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === v.isWebGL1Renderer && me.shift(), null === (he = fe(me, pe))) throw fe(me) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                me = "undefined" != typeof WebGL2RenderingContext && he instanceof WebGL2RenderingContext;
                console.log("Verge3D " + Pe + " " + xi() + " (" + (3483952072 == mn.hashString(sn) ? "Trial" : "License") + ", " + (me ? "WebGL 2.0" : "WebGL 1.0") + ")")
            }
            void 0 === he.getShaderPrecisionFormat && (he.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("v3d.WebGLRenderer: " + e.message), e
        }

        function ve() {
            W = new Pa(he), !1 === (H = new Ea(he, W, e)).isWebGL2 && (W.get("WEBGL_depth_texture"), W.get("OES_texture_float"), W.get("OES_texture_half_float"), W.get("OES_texture_half_float_linear"), W.get("OES_standard_derivatives"), W.get("OES_element_index_uint"), W.get("OES_vertex_array_object"), W.get("ANGLE_instanced_arrays")), W.get("OES_texture_float_linear"), W.get("KHR_parallel_shader_compile"), ce = new ws(0, W, H), (X = new bs(he, W, H)).scissor(S.copy(D).multiplyScalar(C).floor()), X.viewport(w.copy(R).multiplyScalar(C).floor()), Y = new Oa, q = new Ko, Z = new Ms(he, W, X, q, H, ce, Y), Q = new La(v), K = new xa(he, H), ue = new Aa(he, W, K, H), J = new Ra(0, K, Y, ue), $ = new Fa(0, J, K, Y), oe = new Ia(he), ie = new Ca(q), ee = new Qo(v, Q, W, H, ue, ie), te = new Ds(q), ne = new ts(q), re = new us(W, H), ae = new Sa(v, Q, X, $, s), se = new Ta(he, W, Y, H), le = new Da(he, W, Y, H), Y.programs = ee.programs, v.capabilities = H, v.extensions = W, v.properties = q, v.renderLists = ne, v.state = X, v.info = Y, de = new ga
        }
        ve();
        var ge = new Rs(v, he);
        this.xr = ge;
        var _e = new xs(v, $, H.maxTextureSize, H.isWebGL2);

        function ye(e) {
            e.preventDefault(), console.log("v3d.WebGLRenderer: Context Lost."), h = !0
        }

        function xe() {
            console.log("v3d.WebGLRenderer: Context Restored."), h = !1, ve()
        }

        function be(e) {
            e = e.target;
            e.removeEventListener("dispose", be), Me(e = e), q.remove(e)
        }

        function Me(e) {
            var t = q.get(e).program;
            (e.program = void 0) !== t && ee.releaseProgram(t)
        }
        this.shadowMap = _e, this.getContext = function() {
            return he
        }, this.getContextAttributes = function() {
            return he.getContextAttributes()
        }, this.forceContextLoss = function() {
            var e = W.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function() {
            var e = W.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function() {
            return C
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (C = e, this.setSize(T, E, !1))
        }, this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new vn), e.set(T, E)
        }, this.setSize = function(e, t, n) {
            ge.isPresenting ? console.warn("v3d.WebGLRenderer: Can't change size while VR device is presenting.") : (T = e, E = t, i.width = Math.floor(e * C), i.height = Math.floor(t * C), !1 !== n && (i.style.width = e + "px", i.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new vn), e.set(T * C, E * C).floor()
        }, this.setDrawingBufferSize = function(e, t, n) {
            T = e, E = t, C = n, i.width = Math.floor(e * n), i.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new Mn), e.copy(w)
        }, this.getViewport = function(e) {
            return e.copy(R)
        }, this.setViewport = function(e, t, n, r) {
            e.isVector4 ? R.set(e.x, e.y, e.z, e.w) : R.set(e, t, n, r), X.viewport(w.copy(R).multiplyScalar(C).floor())
        }, this.getScissor = function(e) {
            return e.copy(D)
        }, this.setScissor = function(e, t, n, r) {
            e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r), X.scissor(S.copy(D).multiplyScalar(C).floor())
        }, this.getScissorTest = function() {
            return O
        }, this.setScissorTest = function(e) {
            X.setScissorTest(O = e)
        }, this.setOpaqueSort = function(e) {
            L = e
        }, this.setTransparentSort = function(e) {
            P = e
        }, this.getClearColor = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), e = new Qr), e.copy(ae.getClearColor())
        }, this.setClearColor = function() {
            ae.setClearColor.apply(ae, arguments)
        }, this.getClearAlpha = function() {
            return ae.getClearAlpha()
        }, this.setClearAlpha = function() {
            ae.setClearAlpha.apply(ae, arguments)
        }, this.clear = function(e, t, n) {
            var r = 0;
            void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== n && !n || (r |= 1024), he.clear(r)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            i.removeEventListener("webglcontextlost", ye, !1), i.removeEventListener("webglcontextrestored", xe, !1), this.disposeInternalCaches(), ge.dispose(), Se.stop()
        }, this.disposeInternalCaches = function() {
            ne.dispose(), re.dispose(), q.dispose(), Q.dispose(), $.dispose(), ue.dispose(), ae.dispose(), K.dispose(), de.dispose()
        }, this.renderBufferImmediate = function(e, t) {
            ue.initAttributes();
            var n = q.get(e);
            e.hasPositions && !n.position && (n.position = he.createBuffer()), e.hasNormals && !n.normal && (n.normal = he.createBuffer()), e.hasUvs && !n.uv && (n.uv = he.createBuffer()), e.hasColors && !n.color && (n.color = he.createBuffer());
            t = t.getAttributes();
            e.hasPositions && (he.bindBuffer(34962, n.position), he.bufferData(34962, e.positionArray, 35048), ue.enableAttribute(t.position), he.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (he.bindBuffer(34962, n.normal), he.bufferData(34962, e.normalArray, 35048), ue.enableAttribute(t.normal), he.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (he.bindBuffer(34962, n.uv), he.bufferData(34962, e.uvArray, 35048), ue.enableAttribute(t.uv), he.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (he.bindBuffer(34962, n.color), he.bufferData(34962, e.colorArray, 35048), ue.enableAttribute(t.color), he.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), ue.disableUnusedAttributes(), he.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, t, n, r, i, a) {
            null === t && (t = G);
            var o = i.isMesh && i.matrixWorld.determinant() < 0,
                s = Le(e, t, r, i);
            X.setMaterial(r, o);
            var l = n.index,
                c = n.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count) return
            } else if (0 === l.count) return;
            e = 1;
            !0 === r.wireframe && (l = J.getWireframeAttribute(n), e = 2), (r.morphTargets || r.morphNormals) && oe.update(i, n, r, s), ue.setup(i, r, s, n, l);
            t = se;
            null !== l && (u = K.get(l), (t = le).setIndex(u));
            var o = (null !== l ? l : c).count,
                u = n.drawRange.start * e,
                l = n.drawRange.count * e,
                c = null !== a ? a.start * e : 0,
                a = null !== a ? a.count * e : 1 / 0,
                e = Math.max(u, c),
                a = Math.min(o, u + l, c + a) - 1,
                a = Math.max(0, a - e + 1);
            0 !== a && (i.isMesh ? !0 === r.wireframe ? (X.setLineWidth(r.wireframeLinewidth * j()), t.setMode(1)) : t.setMode(4) : i.isLine ? (void 0 === (r = r.linewidth) && (r = 1), X.setLineWidth(r * j()), i.isLineSegments ? t.setMode(1) : i.isLineLoop ? t.setMode(2) : t.setMode(3)) : i.isPoints ? t.setMode(0) : i.isSprite && t.setMode(4), s.beginTimerQuery(he, H.isWebGL2), i.isInstancedMesh ? t.renderInstances(e, a, i.count) : n.isInstancedBufferGeometry ? (n = Math.min(n.instanceCount, n._maxInstanceCount), t.renderInstances(e, a, n)) : t.render(e, a), s.endTimerQuery(he, H.isWebGL2))
        }, this.compile = function(n, e) {
            var r = re.get(n, e);
            r.init(), n.traverse(function(e) {
                e.isLight && (r.pushLight(e), e.castShadow && r.pushShadow(e))
            }), r.setupLights(e);
            var i = {};
            n.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var t = 0; t < e.material.length; t++) e.material[t].uuid in i == !1 && (Ee(e.material[t], n, e, r), i[e.material[t].uuid] = !0);
                    else e.material.uuid in i == !1 && (Ee(e.material, n, e, r), i[e.material.uuid] = !0)
            })
        }, this.compileAsync = function(n, e, i) {
            var a = new cs(W, H);
            a.init();
            var o, s, l, c, u, r, d = [];
            n.traverse(function(t) {
                t.isLight && (a.pushLight(t), t.castShadow && a.pushShadow(t)), t.material && (Array.isArray(t.material) ? t.material : [t.material]).forEach(function(e) {
                    d.push({
                        scene: n,
                        obj: t,
                        mat: e
                    })
                })
            }), a.setupLights(e), 0 === d.length ? i(1) : (o = W.get("KHR_parallel_shader_compile"), s = (null === o ? 1 : 2) * d.length, c = l = 0, u = {}, Ai(d, function(e, t, n) {
                var r;
                Ee(e.mat, e.scene, e.obj, a), o && ((r = e.mat.program.id) in u || (u[r] = {
                    program: e.mat.program,
                    weight: 0
                }), u[r].weight++), i && i((++l + c) / s)
            }, Os), o && (r = setInterval(function() {
                var e, t = 0;
                for (e in u) {
                    var n = u[e];
                    (void 0 === n.program.program || he.getProgramParameter(n.program.program, o.COMPLETION_STATUS_KHR)) && (t += n.weight)
                }
                c = Math.max(c, t), i && i((l + c) / s), c === d.length && clearInterval(r)
            }, Ns)))
        };
        var we = null;
        var Se = new ya;

        function Ae(e, t, n) {
            for (var r = !0 === t.isScene ? t.overrideMaterial : null, i = 0, a = e.length; i < a; i++) {
                var o = e[i],
                    s = o.object,
                    l = o.geometry,
                    c = r ? de.get(s, l, o.material, r) : o.material,
                    u = o.group;
                if (n.isArrayCamera)
                    for (var d = n.cameras, h = 0, f = d.length; h < f; h++) {
                        var p = d[h];
                        s.layers.test(p.layers) && (X.viewport(w.copy(p.viewport)), x.setupLightsView(p), Te(s, t, p, l, c, u))
                    } else Te(s, t, n, l, c, u)
            }
        }

        function Te(e, t, n, r, i, a) {
            var o, s;
            e.onBeforeRender(v, t, n, r, i, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject ? (o = Le(n, t, i, e), X.setMaterial(i), ue.reset(), s = o, e.render(function(e) {
                v.renderBufferImmediate(e, s)
            })) : v.renderBufferDirect(n, t, r, i, e, a), e.onAfterRender(v, t, n, r, i, a)
        }

        function Ee(e, t, n, r) {
            !0 !== t.isScene && (t = G);
            var i = q.get(e),
                a = r.state.lights,
                o = r.state.shadowsArray,
                s = a.state.version,
                l = ee.getParameters(e, a.state, o, t, n),
                c = ee.getProgramCacheKey(l),
                r = i.program,
                o = !0;
            if (void 0 === r) e.addEventListener("dispose", be);
            else if (r.cacheKey !== c) Me(e);
            else if (i.lightsStateVersion !== s) o = !1;
            else {
                if (void 0 !== l.shaderID) {
                    n = e.isMeshStandardMaterial ? t.environment : null;
                    return void(i.envMap = Q.get(e.envMap || n))
                }
                o = !1
            }
            if (o && (l.uniforms = ee.getUniforms(e), e.onBeforeCompile(l, v), r = ee.acquireProgram(l, c), i.program = r, i.uniforms = l.uniforms, i.outputEncoding = l.outputEncoding, e.program = r), e.morphTargets || e.morphNormals) {
                var u = r.getAttributes();
                if (e.morphTargets)
                    for (var d = e.numSupportedMorphTargets = 0; d < v.maxMorphTargets; d++) 0 <= u["morphTarget" + d] && e.numSupportedMorphTargets++;
                if (e.morphNormals)
                    for (var h = e.numSupportedMorphNormals = 0; h < v.maxMorphNormals; h++) 0 <= u["morphNormal" + h] && e.numSupportedMorphNormals++
            }
            r = i.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = ie.numPlanes, i.numIntersection = ie.numIntersection, r.clippingPlanes = ie.uniform), i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = Q.get(e.envMap || i.environment), i.needsLights = (t = e).isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights || t.isMeshNodeMaterial, i.lightsStateVersion = s, i.needsLights && (r.ambientLightColor.value = a.state.ambient, r.lightProbe.value = a.state.probe, r.directionalLights.value = a.state.directional, r.directionalLightShadows.value = a.state.directionalShadow, r.spotLights.value = a.state.spot, r.spotLightShadows.value = a.state.spotShadow, r.rectAreaLights.value = a.state.rectArea, r.ltc_1.value = a.state.rectAreaLTC1, r.ltc_2.value = a.state.rectAreaLTC2, r.pointLights.value = a.state.point, r.pointLightShadows.value = a.state.pointShadow, r.hemisphereLights.value = a.state.hemi, r.directionalShadowMap.value = a.state.directionalShadowMap, r.directionalShadowMatrix.value = a.state.directionalShadowMatrix, r.spotShadowMap.value = a.state.spotShadowMap, r.spotShadowMatrix.value = a.state.spotShadowMatrix, r.pointShadowMap.value = a.state.pointShadowMap, r.pointShadowMatrix.value = a.state.pointShadowMatrix), e.nodeValue && (r.nodeValue.value = e.nodeValue), e.nodeRGBArr && (r.nodeRGB.value = e.nodeRGBArr), i.uniformsList = null
        }

        function Ce(e) {
            var t;
            return null === e.uniformsList && (t = e.program.getUniforms(), e.uniformsList = Oo.seqWithValue(t.seq, e.uniforms)), e.uniformsList
        }

        function Le(e, t, n, r) {
            !0 !== t.isScene && (t = G), Z.resetTextureUnits();
            var i, a = t.fog,
                o = n.isMeshStandardMaterial ? t.environment : null,
                s = null === g ? v.outputEncoding : g.texture.encoding,
                l = Q.get(n.envMap || o),
                c = q.get(n),
                u = x.state.lights;
            if (!0 === I && (!0 !== F && e === M || (i = e === M && n.id === b, ie.setState(n, e, i))), n.version === c.__version)(n.fog && c.fog !== a || c.environment !== o || c.needsLights && c.lightsStateVersion !== u.state.version || void 0 !== c.numClippingPlanes && (c.numClippingPlanes !== ie.numPlanes || c.numIntersection !== ie.numIntersection) || c.outputEncoding !== s || c.envMap !== l) && Ee(n, t, r, x);
            else if (Ee(n, t, r, x), c.__version = n.version, n.nodeRGBArr)
                for (var d = 0; d < n.nodeRGB.length; d++) n.nodeRGB[d].toArray(n.nodeRGBArr, 4 * d);
            var h, f, o = !1,
                u = !1,
                s = !1,
                l = c.program,
                p = l.getUniforms(),
                t = c.uniforms;
            if (X.useProgram(l.program) && (s = u = o = !0), n.id !== b && (b = n.id, u = !0), !o && M === e || (p.setValue(he, "projectionMatrix", e.projectionMatrix), H.logarithmicDepthBuffer && p.setValue(he, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), M !== e && (M = e, s = u = !0), !(n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.isMeshNodeMaterial || n.envMap) || void 0 !== (h = p.map.cameraPosition) && h.setValue(he, V.setFromMatrixPosition(e.matrixWorld)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isMeshNodeMaterial) && p.setValue(he, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isMeshNodeMaterial || n.skinning) && p.setValue(he, "viewMatrix", e.matrixWorldInverse), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshNodeMaterial || n.isMeshPhysicalMaterial || n.isShadowMaterial) && p.setValue(he, "invViewMatrix", e.matrixWorld)), n.skinning && (p.setOptional(he, r, "bindMatrix"), p.setOptional(he, r, "bindMatrixInverse"), (f = r.skeleton) && (o = f.bones, H.floatVertexTextures ? (null === f.boneTexture && (h = Math.sqrt(4 * o.length), h = mn.ceilPowerOfTwo(h), h = Math.max(h, 4), (e = new Float32Array(h * h * 4)).set(f.boneMatrices), o = new ha(e, h, h, Qe, Xe), f.boneMatrices = e, f.boneTexture = o, f.boneTextureSize = h), p.setValue(he, "boneTexture", f.boneTexture, Z), p.setValue(he, "boneTextureSize", f.boneTextureSize)) : p.setOptional(he, f, "boneMatrices"))), !u && c.receiveShadow === r.receiveShadow || (c.receiveShadow = r.receiveShadow, p.setValue(he, "receiveShadow", r.receiveShadow)), !n.needsBoundingBox || (f = r.geometry) && (null === f.boundingBox && f.computeBoundingBox(), p.setValue(he, "boundingBoxMin", f.boundingBox.min), p.setValue(he, "boundingBoxMax", f.boundingBox.max)), u) {
                if (p.setValue(he, "toneMappingExposure", v.toneMappingExposure), v.toneMapping == Ne ? (p.setValue(he, "toneMappingBrightness", v.toneMappingBrightness), p.setValue(he, "toneMappingContrast", v.toneMappingContrast), p.setValue(he, "toneMappingMidTones", v.toneMappingMidTones), p.setValue(he, "toneMappingPhysicalScale", v.toneMappingPhysicalScale), p.setValue(he, "toneMappingChromaticAdaptation", v.toneMappingChromaticAdaptation), p.setValue(he, "toneMappingWhiteColor", v.toneMappingWhiteColor), p.setValue(he, "toneMappingColorDifferentiation", v.toneMappingColorDifferentiation), p.setValue(he, "toneMappingExteriorDaylight", v.toneMappingExteriorDaylight)) : v.toneMapping == Ie && (p.setValue(he, "toneMappingResolution", U.set(T, E)), p.setValue(he, "toneMappingWhiteBalance", v.toneMappingWhiteBalance), p.setValue(he, "toneMappingHighlights", v.toneMappingHighlights), p.setValue(he, "toneMappingMidTones", v.toneMappingMidTones), p.setValue(he, "toneMappingShadows", v.toneMappingShadows), p.setValue(he, "toneMappingSaturation", v.toneMappingSaturation), p.setValue(he, "toneMappingPhysicalScale", v.toneMappingPhysicalScale), p.setValue(he, "toneMappingAperture", v.toneMappingAperture), p.setValue(he, "toneMappingShutter", v.toneMappingShutter), p.setValue(he, "toneMappingISO", v.toneMappingISO), p.setValue(he, "toneMappingVignetting", v.toneMappingVignetting)), c.needsLights && (u = s, (s = t).ambientLightColor.needsUpdate = u, s.lightProbe.needsUpdate = u, s.directionalLights.needsUpdate = u, s.directionalLightShadows.needsUpdate = u, s.pointLights.needsUpdate = u, s.pointLightShadows.needsUpdate = u, s.spotLights.needsUpdate = u, s.spotLightShadows.needsUpdate = u, s.rectAreaLights.needsUpdate = u, s.hemisphereLights.needsUpdate = u), a && n.fog && te.refreshFogUniforms(t, a), te.refreshMaterialUniforms(t, n, C, E), n.isMeshNodeMaterial)
                    for (var m in n.nodeTextures) p.setValue(he, m, n.nodeTextures[m], Z);
                n.isMeshLineMaterial && p.setValue(he, "resolution", U.set(T, E)), Oo.upload(he, Ce(c), t, Z)
            }
            return n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Oo.upload(he, Ce(c), t, Z), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && p.setValue(he, "center", r.center), n.isMeshNodeMaterial && (B.copy(r.matrixWorld).invert(), p.setValue(he, "invModelMatrix", B), p.setValue(he, "viewWidthHeight", U.set(w.z - w.x, w.w - w.y)), n.nodeTexCoordObject.forEach(function(e, t) {
                (null === e ? B : z.copy(e.matrixWorld).invert()).toArray(n.nodeTexCoordObjectArr, 16 * t)
            }), n.nodeTexCoordObjectArr && p.setValue(he, "nodeTexCoordObjectMatrices", n.nodeTexCoordObjectArr)), p.setValue(he, "modelViewMatrix", r.modelViewMatrix), p.setValue(he, "normalMatrix", r.normalMatrix), p.setValue(he, "modelMatrix", r.matrixWorld), l
        }
        Se.setAnimationLoop(function(e) {
            ge.isPresenting || we && we(e)
        }), "undefined" != typeof window && Se.setContext(window), this.setAnimationLoop = function(e) {
            we = e, ge.setAnimationLoop(e), null === e ? Se.stop() : Se.start()
        }, this.render = function(e, t) {
            var n, r, i;
            void 0 !== arguments[2] && (console.warn("v3d.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), r = arguments[2]), void 0 !== arguments[3] && (console.warn("v3d.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 === t || !0 === t.isCamera ? !0 !== h && (ue.resetDefaultState(), b = -1, !(M = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === ge.enabled && !0 === ge.isPresenting && (t = ge.getCamera(t)), !0 === e.isScene && e.onBeforeRender(v, e, t, r || g), (x = re.get(e, d.length)).init(), d.push(x), k.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), N.setFromProjectionMatrix(k), F = this.localClippingEnabled, I = ie.init(this.clippingPlanes, F, t), (y = ne.get(e, t)).init(), function e(t, n, r, i) {
                t.isAnnotationControl && t.update(n);
                var a = !1;
                if (t.visible && (a = t.layers.test(n.layers)))
                    if (t.isGroup) r = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                else if (t.isLight) x.pushLight(t), t.castShadow && x.pushShadow(t);
                else if (t.isSprite) {
                    var o, s;
                    t.frustumCulled && !N.intersectsSprite(t) || (i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k), o = $.update(t), s = t.material, y.push(t, o, s, r, V.z, null))
                } else if (t.isImmediateRenderObject) i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k), y.push(t, null, t.material, r, V.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || N.intersectsObject(t))) {
                    i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k);
                    var l = $.update(t),
                        c = t.material;
                    if (Array.isArray(c))
                        for (var u = l.groups, d = 0, h = u.length; d < h; d++) {
                            var f = u[d],
                                p = c[f.materialIndex];
                            p && p.visible && y.push(t, l, p, r, V.z, f)
                        } else c.visible && y.push(t, l, c, r, V.z, null)
                }
                if (t.disableChildRendering) return;
                var m = t.children;
                for (var v = 0, g = m.length; v < g; v++) {
                    var _ = m[v];
                    !a && _.isMesh && _.isMaterialGeneratedMesh || e(_, n, r, i)
                }
            }(e, t, 0, v.sortObjects), y.finish(), !0 === v.sortObjects && y.sort(L, P), !0 === I && ie.beginShadows(), n = x.state.shadowsArray, _e.render(n, e, t), x.setupLights(), x.setupLightsView(t), !0 === I && ie.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== r && this.setRenderTarget(r), ae.render(y, e, t, i), r = y.opaque, i = y.transparent, 0 < r.length && Ae(r, e, t), 0 < i.length && Ae(i, e, t), !0 === e.isScene && e.onAfterRender(v, e, t), null !== g && (Z.updateRenderTargetMipmap(g), Z.updateMultisampleRenderTarget(g)), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), d.pop(), x = 0 < d.length ? d[d.length - 1] : null, y = null) : console.error("v3d.WebGLRenderer.render: camera is not an instance of v3d.Camera.")
        }, this.setFramebuffer = function(e) {
            f !== e && null === g && he.bindFramebuffer(36160, e), f = e
        }, this.getActiveCubeFace = function() {
            return p
        }, this.getActiveMipmapLevel = function() {
            return m
        }, this.getRenderList = function() {
            return y
        }, this.setRenderList = function(e) {
            y = e
        }, this.getRenderTarget = function() {
            return g
        }, this.setRenderTarget = function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            p = t, m = n, (g = e) && void 0 === q.get(e).__webglFramebuffer && Z.setupRenderTarget(e);
            var r, i = f,
                a = !1;
            A = e ? (r = q.get(e).__webglFramebuffer, e.isWebGLCubeRenderTarget ? (i = r[t], a = !0) : i = e.isWebGLMultisampleRenderTarget ? q.get(e).__webglMultisampledFramebuffer : r, w.copy(e.viewport), S.copy(e.scissor), e.scissorTest) : (w.copy(R).multiplyScalar(C).floor(), S.copy(D).multiplyScalar(C).floor(), O), _ !== i && (he.bindFramebuffer(36160, i), _ = i), X.viewport(w), X.scissor(S), X.setScissorTest(A), a && (e = q.get(e.texture), he.framebufferTexture2D(36160, 36064, 34069 + t, e.__webglTexture, n))
        }, this.readRenderTargetPixels = function(e, t, n, r, i, a, o) {
            if (e && e.isWebGLRenderTarget) {
                var s = q.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                    o = !1;
                    s !== _ && (he.bindFramebuffer(36160, s), o = !0);
                    try {
                        var l = e.texture,
                            c = l.format,
                            l = l.type;
                        if (c !== Qe && ce.convert(c) !== he.getParameter(35739)) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(l === je || ce.convert(l) === he.getParameter(35738) || l === Xe && (H.isWebGL2 || W.get("OES_texture_float") || W.get("WEBGL_color_buffer_float")) || l === Ye && (H.isWebGL2 ? W.get("EXT_color_buffer_float") : W.get("EXT_color_buffer_half_float")))) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === he.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && he.readPixels(t, n, r, i, ce.convert(c), ce.convert(l), a) : console.error("v3d.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        o && he.bindFramebuffer(36160, _)
                    }
                }
            } else console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not v3d.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(e, t) {
            var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                r = Math.pow(2, -n),
                i = Math.floor(t.image.width * r),
                a = Math.floor(t.image.height * r),
                r = ce.convert(t.format);
            Z.setTexture2D(t, 0), he.copyTexImage2D(3553, n, r, e.x, e.y, i, a, 0), X.unbindTexture()
        }, this.copyTextureToTexture = function(e, t, n) {
            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0,
                i = t.image.width,
                a = t.image.height,
                o = ce.convert(n.format),
                s = ce.convert(n.type);
            Z.setTexture2D(n, 0), he.pixelStorei(37440, n.flipY), he.pixelStorei(37441, n.premultiplyAlpha), he.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? he.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? he.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : he.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 0 === r && n.generateMipmaps && he.generateMipmap(3553), X.unbindTexture()
        }, this.initTexture = function(e) {
            Z.setTexture2D(e, 0), X.unbindTexture()
        }, this.resetState = function() {
            X.reset(), ue.reset()
        }, "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        })), this.updateGeometry = function(e) {
            return $.update(e)
        }, this.setCanvas = function(e) {
            _readOnlyError("_canvas"), i = e, this.domElement = e
        }
    }

    function Fs(e) {
        Is.call(this, e)
    }
    Fs.prototype = Object.assign(Object.create(Is.prototype), {
        constructor: Fs,
        isWebGL1Renderer: !0
    });
    var ks = function() {
            function n(e, t) {
                _classCallCheck(this, n), Object.defineProperty(this, "isFogExp2", {
                    value: !0
                }), this.name = "", this.color = new Qr(e), this.density = void 0 !== t ? t : 25e-5
            }
            return _createClass(n, [{
                key: "clone",
                value: function() {
                    return new n(this.color, this.density)
                }
            }, {
                key: "toJSON",
                value: function() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }]), n
        }(),
        Bs = function() {
            function r(e, t, n) {
                _classCallCheck(this, r), Object.defineProperty(this, "isFog", {
                    value: !0
                }), this.name = "", this.color = new Qr(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }
            return _createClass(r, [{
                key: "clone",
                value: function() {
                    return new r(this.color, this.near, this.far)
                }
            }, {
                key: "toJSON",
                value: function() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }]), r
        }();

    function zs(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = nn, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = mn.generateUUID()
    }
    Object.defineProperty(zs.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(zs.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e, this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        },
        copyAt: function(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        set: function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.array.set(e, t), this
        },
        clone: function(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = mn.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            e = new zs(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), this.stride);
            return e.setUsage(this.usage), e
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        toJSON: function(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = mn.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    });
    var Us, Vs = new Tn;

    function Gs(e, t, n, r) {
        this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
    }

    function js(e) {
        $r.call(this), this.type = "SpriteMaterial", this.color = new Qr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
    }
    Object.defineProperties(Gs.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        },
        needsUpdate: {
            set: function(e) {
                this.data.needsUpdate = e
            }
        }
    }), Object.assign(Gs.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(e) {
            for (var t = 0, n = this.data.count; t < n; t++) Vs.x = this.getX(t), Vs.y = this.getY(t), Vs.z = this.getZ(t), Vs.applyMatrix4(e), this.setXYZ(t, Vs.x, Vs.y, Vs.z);
            return this
        },
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        },
        setXYZ: function(e, t, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
        },
        setXYZW: function(e, t, n, r, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
        },
        clone: function(e) {
            if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Gs(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            console.log("v3d.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            for (var t = [], n = 0; n < this.count; n++)
                for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i]);
            return new ri(new this.array.constructor(t), this.itemSize, this.normalized)
        },
        toJSON: function(e) {
            if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
            console.log("v3d.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            for (var t = [], n = 0; n < this.count; n++)
                for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i]);
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        }
    }), ((js.prototype = Object.create($r.prototype)).constructor = js).prototype.isSpriteMaterial = !0, js.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    };
    var Ws = new Tn,
        Hs = new Tn,
        Xs = new Tn,
        Ys = new vn,
        qs = new vn,
        Zs = new nr,
        Qs = new Tn,
        Ks = new Tn,
        Js = new Tn,
        $s = new vn,
        el = new vn,
        tl = new vn;

    function nl(e) {
        var t;
        Er.call(this), this.type = "Sprite", void 0 === Us && (Us = new Oi, t = new zs(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5), Us.setIndex([0, 1, 2, 0, 2, 3]), Us.setAttribute("position", new Gs(t, 3, 0, !1)), Us.setAttribute("uv", new Gs(t, 2, 3, !1))), this.geometry = Us, this.material = void 0 !== e ? e : new js, this.center = new vn(.5, .5)
    }

    function rl(e, t, n, r, i, a) {
        Ys.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (qs.x = a * Ys.x - i * Ys.y, qs.y = i * Ys.x + a * Ys.y) : qs.copy(Ys), e.copy(t), e.x += qs.x, e.y += qs.y, e.applyMatrix4(Zs)
    }
    nl.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: nl,
        isSprite: !0,
        raycast: function(e, t) {
            null === e.camera && console.error('v3d.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Hs.setFromMatrixScale(this.matrixWorld), Zs.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Xs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Hs.multiplyScalar(-Xs.z);
            var n, r, i = this.material.rotation;
            0 !== i && (r = Math.cos(i), n = Math.sin(i));
            var a = this.center;
            rl(Qs.set(-.5, -.5, 0), Xs, a, Hs, n, r), rl(Ks.set(.5, -.5, 0), Xs, a, Hs, n, r), rl(Js.set(.5, .5, 0), Xs, a, Hs, n, r), $s.set(0, 0), el.set(1, 0), tl.set(1, 1);
            i = e.ray.intersectTriangle(Qs, Ks, Js, !1, Ws);
            null === i && (rl(Ks.set(-.5, .5, 0), Xs, a, Hs, n, r), el.set(0, 1), null === (i = e.ray.intersectTriangle(Qs, Js, Ks, !1, Ws))) || ((i = e.ray.origin.distanceTo(Ws)) < e.near || i > e.far || t.push({
                distance: i,
                point: Ws.clone(),
                uv: Gr.getUV(Ws, Qs, Ks, Js, $s, el, tl, new vn),
                face: null,
                object: this
            }))
        },
        copy: function(e) {
            return Er.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
        }
    });
    var il = new Tn,
        al = new Tn;

    function ol() {
        Er.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }), this.autoUpdate = !0
    }
    ol.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: ol,
        isLOD: !0,
        copy: function(e) {
            Er.prototype.copy.call(this, e, !1);
            for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this.autoUpdate = e.autoUpdate, this
        },
        addLevel: function(e) {
            for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, t = Math.abs(t), n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
            return n.splice(r, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getCurrentLevel: function() {
            return this._currentLevel
        },
        getObjectForDistance: function(e) {
            var t = this.levels;
            if (0 < t.length) {
                for (var n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                return t[n - 1].object
            }
            return null
        },
        raycast: function(e, t) {
            var n;
            0 < this.levels.length && (il.setFromMatrixPosition(this.matrixWorld), n = e.ray.origin.distanceTo(il), this.getObjectForDistance(n).raycast(e, t))
        },
        update: function(e) {
            var t = this.levels;
            if (1 < t.length) {
                il.setFromMatrixPosition(e.matrixWorld), al.setFromMatrixPosition(this.matrixWorld);
                var n, r, i = il.distanceTo(al) / e.zoom;
                for (t[0].object.visible = !0, n = 1, r = t.length; n < r && i >= t[n].distance; n++) t[n - 1].object.visible = !1, t[n].object.visible = !0;
                for (this._currentLevel = n - 1; n < r; n++) t[n].object.visible = !1
            }
        },
        toJSON: function(e) {
            var t = Er.prototype.toJSON.call(this, e);
            !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var a = n[r];
                t.object.levels.push({
                    object: a.object.uuid,
                    distance: a.distance
                })
            }
            return t
        }
    });
    var sl = new Tn,
        ll = new Mn,
        cl = new Mn,
        ul = new Tn,
        dl = new nr;

    function hl(e, t) {
        e && e.isGeometry && console.error("v3d.SkinnedMesh no longer supports v3d.Geometry. Use v3d.BufferGeometry instead."), Ki.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new nr, this.bindMatrixInverse = new nr, this.normalizeSkinWeights()
    }

    function fl() {
        Er.call(this), this.type = "Bone"
    }
    hl.prototype = Object.assign(Object.create(Ki.prototype), {
        constructor: hl,
        isSkinnedMesh: !0,
        copy: function(e) {
            return Ki.prototype.copy.call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
        },
        bind: function(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new Mn, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                var i = 1 / e.manhattanLength();
                i != 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Ki.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("v3d.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        boneTransform: function(e, t) {
            var n = this.skeleton,
                r = this.geometry;
            ll.fromBufferAttribute(r.attributes.skinIndex, e), cl.fromBufferAttribute(r.attributes.skinWeight, e), sl.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
            for (var i = 0; i < 4; i++) {
                var a, o = cl.getComponent(i);
                0 !== o && (a = ll.getComponent(i), dl.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(ul.copy(sl).applyMatrix4(dl), o))
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }), fl.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: fl,
        isBone: !0
    });
    var pl = new nr,
        ml = new nr;

    function vl() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [];
        this.uuid = mn.generateUUID(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
    }
    Object.assign(vl.prototype, {
        init: function() {
            var e = this.bones,
                t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("v3d.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new nr)
            }
        },
        calculateInverses: function() {
            for (var e = this.boneInverses.length = 0, t = this.bones.length; e < t; e++) {
                var n = new nr;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
            }
        },
        pose: function() {
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (var r = 0, i = this.bones.length; r < i; r++) {
                var a = this.bones[r];
                a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
            }
        },
        update: function() {
            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) {
                var o = e[i] ? e[i].matrixWorld : ml;
                pl.multiplyMatrices(o, t[i]), pl.toArray(n, 16 * i)
            }
            null !== r && (r.needsUpdate = !0)
        },
        clone: function() {
            return new vl(this.bones, this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, n = this.bones.length; t < n; t++) {
                var r = this.bones[t];
                if (r.name === e) return r
            }
        },
        dispose: function() {
            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
        },
        fromJSON: function(e, t) {
            this.uuid = e.uuid;
            for (var n = 0, r = e.bones.length; n < r; n++) {
                var i = e.bones[n],
                    a = t[i];
                void 0 === a && (console.warn("v3d.Skeleton: No bone found with UUID:", i), a = new fl), this.bones.push(a), this.boneInverses.push((new nr).fromArray(e.boneInverses[n]))
            }
            return this.init(), this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            for (var t = this.bones, n = this.boneInverses, r = 0, i = t.length; r < i; r++) {
                var a = t[r];
                e.bones.push(a.uuid);
                a = n[r];
                e.boneInverses.push(a.toArray())
            }
            return e
        }
    });
    var gl = new nr,
        _l = new nr,
        yl = [],
        xl = new Ki;

    function bl(e, t, n) {
        Ki.call(this, e, t), this.instanceMatrix = new ri(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
    }

    function Ml(e) {
        $r.call(this), this.type = "LineBasicMaterial", this.color = new Qr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e)
    }
    bl.prototype = Object.assign(Object.create(Ki.prototype), {
        constructor: bl,
        isInstancedMesh: !0,
        copy: function(e) {
            return Ki.prototype.copy.call(this, e), this.instanceMatrix.copy(e.instanceMatrix), this.count = e.count, this
        },
        getColorAt: function(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
        },
        getMatrixAt: function(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        },
        raycast: function(e, t) {
            var n = this.matrixWorld,
                r = this.count;
            if (xl.geometry = this.geometry, xl.material = this.material, void 0 !== xl.material)
                for (var i = 0; i < r; i++) {
                    this.getMatrixAt(i, gl), _l.multiplyMatrices(n, gl), xl.matrixWorld = _l, xl.raycast(e, yl);
                    for (var a = 0, o = yl.length; a < o; a++) {
                        var s = yl[a];
                        s.instanceId = i, s.object = this, t.push(s)
                    }
                    yl.length = 0
                }
        },
        setColorAt: function(e, t) {
            null === this.instanceColor && (this.instanceColor = new ri(new Float32Array(3 * this.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
        },
        setMatrixAt: function(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        },
        updateMorphTargets: function() {},
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), ((Ml.prototype = Object.create($r.prototype)).constructor = Ml).prototype.isLineBasicMaterial = !0, Ml.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this
    };
    var wl = new Tn,
        Sl = new Tn,
        Al = new nr,
        Tl = new tr,
        El = new Yn;

    function Cl() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Oi,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Ml;
        Er.call(this), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    Cl.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Cl,
        isLine: !0,
        copy: function(e) {
            return Er.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this
        },
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) wl.fromBufferAttribute(t, r - 1), Sl.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += wl.distanceTo(Sl);
                    e.setAttribute("lineDistance", new hi(n, 1))
                } else console.warn("v3d.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var a = e.vertices,
                    o = e.lineDistances;
                o[0] = 0;
                for (var s = 1, l = a.length; s < l; s++) o[s] = o[s - 1], o[s] += a[s - 1].distanceTo(a[s])
            }
            return this
        },
        raycast: function(e, t) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = e.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), El.copy(n.boundingSphere), El.applyMatrix4(r), El.radius += i, !1 !== e.ray.intersectsSphere(El)) {
                Al.copy(r).invert(), Tl.copy(e.ray).applyMatrix4(Al);
                var i = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = i * i,
                    o = new Tn,
                    s = new Tn,
                    l = new Tn,
                    c = new Tn,
                    u = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var i = n.index,
                        d = n.attributes.position;
                    if (null !== i)
                        for (var h = i.array, f = 0, p = h.length - 1; f < p; f += u) {
                            var m = h[f],
                                v = h[f + 1];
                            o.fromBufferAttribute(d, m), s.fromBufferAttribute(d, v), a < Tl.distanceSqToSegment(o, s, c, l) || (c.applyMatrix4(this.matrixWorld), (v = e.ray.origin.distanceTo(c)) < e.near || v > e.far || t.push({
                                distance: v,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: f,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        } else
                            for (var g, _ = 0, y = d.count - 1; _ < y; _ += u) o.fromBufferAttribute(d, _), s.fromBufferAttribute(d, _ + 1), a < Tl.distanceSqToSegment(o, s, c, l) || (c.applyMatrix4(this.matrixWorld), (g = e.ray.origin.distanceTo(c)) < e.near || g > e.far || t.push({
                                distance: g,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                } else if (n.isGeometry)
                    for (var x, b = n.vertices, M = b.length, w = 0; w < M - 1; w += u) a < Tl.distanceSqToSegment(b[w], b[w + 1], c, l) || (c.applyMatrix4(this.matrixWorld), (x = e.ray.origin.distanceTo(c)) < e.near || x > e.far || t.push({
                        distance: x,
                        point: l.clone().applyMatrix4(this.matrixWorld),
                        index: w,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
            }
        },
        updateMorphTargets: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes,
                    n = Object.keys(t);
                if (0 < n.length) {
                    var r = t[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, a = r.length; i < a; i++) {
                            var o = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                        }
                    }
                }
            } else {
                e = e.morphTargets;
                void 0 !== e && 0 < e.length && console.error("v3d.Line.updateMorphTargets() does not support v3d.Geometry. Use v3d.BufferGeometry instead.")
            }
        }
    });
    var Ll = new Tn,
        Pl = new Tn;

    function Rl(e, t) {
        Cl.call(this, e, t), this.type = "LineSegments"
    }

    function Dl(e, t) {
        Cl.call(this, e, t), this.type = "LineLoop"
    }

    function Ol(e) {
        $r.call(this), this.type = "PointsMaterial", this.color = new Qr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
    }
    Rl.prototype = Object.assign(Object.create(Cl.prototype), {
        constructor: Rl,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) Ll.fromBufferAttribute(t, r), Pl.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Ll.distanceTo(Pl);
                    e.setAttribute("lineDistance", new hi(n, 1))
                } else console.warn("v3d.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry)
                for (var a = e.vertices, o = e.lineDistances, s = 0, l = a.length; s < l; s += 2) Ll.copy(a[s]), Pl.copy(a[s + 1]), o[s] = 0 === s ? 0 : o[s - 1], o[s + 1] = o[s] + Ll.distanceTo(Pl);
            return this
        }
    }), Dl.prototype = Object.assign(Object.create(Cl.prototype), {
        constructor: Dl,
        isLineLoop: !0
    }), ((Ol.prototype = Object.create($r.prototype)).constructor = Ol).prototype.isPointsMaterial = !0, Ol.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    };
    var Nl = new nr,
        Il = new tr,
        Fl = new Yn,
        kl = new Tn;

    function Bl() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Oi,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Ol;
        Er.call(this), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
    }

    function zl(e, t, n, r, i, a, o) {
        var s = Il.distanceSqToPoint(e);
        s < n && (n = new Tn, Il.closestPointToPoint(e, n), n.applyMatrix4(r), (r = i.ray.origin.distanceTo(n)) < i.near || r > i.far || a.push({
            distance: r,
            distanceToRay: Math.sqrt(s),
            point: n,
            index: t,
            face: null,
            object: o
        }))
    }

    function Ul(t, e, n, r, i, a, o, s, l) {
        xn.call(this, t, e, n, r, i, a, o, s, l), this.format = void 0 !== o ? o : Ze, this.minFilter = void 0 !== a ? a : Ue, this.magFilter = void 0 !== i ? i : Ue, this.generateMipmaps = !1;
        var c = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
            c.needsUpdate = !0, t.requestVideoFrameCallback(e)
        })
    }

    function Vl(e, t, n, r, i, a, o, s, l, c, u, d) {
        xn.call(this, null, a, o, s, l, c, r, i, u, d), this.image = {
            width: t,
            height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }

    function Gl(e, t, n, r, i, a, o, s, l) {
        xn.call(this, e, t, n, r, i, a, o, s, l), this.needsUpdate = !0
    }

    function jl(e, t, n, r, i, a, o, s, l, c) {
        if ((c = void 0 !== c ? c : Ke) !== Ke && c !== Je) throw new Error("DepthTexture format must be either v3d.DepthFormat or v3d.DepthStencilFormat");
        void 0 === n && c === Ke && (n = We), void 0 === n && c === Je && (n = qe), xn.call(this, null, r, i, a, o, s, c, n, l), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== o ? o : ke, this.minFilter = void 0 !== s ? s : ke, this.flipY = !1, this.generateMipmaps = !1
    }
    Bl.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Bl,
        isPoints: !0,
        copy: function(e) {
            return Er.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this
        },
        raycast: function(e, t) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = e.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Fl.copy(n.boundingSphere), Fl.applyMatrix4(r), Fl.radius += i, !1 !== e.ray.intersectsSphere(Fl)) {
                Nl.copy(r).invert(), Il.copy(e.ray).applyMatrix4(Nl);
                var i = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = i * i;
                if (n.isBufferGeometry) {
                    var i = n.index,
                        o = n.attributes.position;
                    if (null !== i)
                        for (var s = i.array, l = 0, c = s.length; l < c; l++) {
                            var u = s[l];
                            kl.fromBufferAttribute(o, u), zl(kl, u, a, r, e, t, this)
                        } else
                            for (var d = 0, h = o.count; d < h; d++) kl.fromBufferAttribute(o, d), zl(kl, d, a, r, e, t, this)
                } else
                    for (var f = n.vertices, p = 0, m = f.length; p < m; p++) zl(f[p], p, a, r, e, t, this)
            }
        },
        updateMorphTargets: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes,
                    n = Object.keys(t);
                if (0 < n.length) {
                    var r = t[n[0]];
                    if (void 0 !== r) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (var i = 0, a = r.length; i < a; i++) {
                            var o = r[i].name || String(i);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i
                        }
                    }
                }
            } else {
                e = e.morphTargets;
                void 0 !== e && 0 < e.length && console.error("v3d.Points.updateMorphTargets() does not support v3d.Geometry. Use v3d.BufferGeometry instead.")
            }
        }
    }), Ul.prototype = Object.assign(Object.create(xn.prototype), {
        constructor: Ul,
        clone: function() {
            return new this.constructor(this.image).copy(this)
        },
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), ((Vl.prototype = Object.create(xn.prototype)).constructor = Vl).prototype.isCompressedTexture = !0, ((Gl.prototype = Object.create(xn.prototype)).constructor = Gl).prototype.isCanvasTexture = !0, ((jl.prototype = Object.create(xn.prototype)).constructor = jl).prototype.isDepthTexture = !0;
    var Wl = 0,
        Hl = new nr,
        Xl = new Er,
        Yl = new Tn;

    function ql() {
        Object.defineProperty(this, "id", {
            value: Wl += 2
        }), this.uuid = mn.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    ql.prototype = Object.assign(Object.create(n.prototype), {
        constructor: ql,
        isGeometry: !0,
        applyMatrix4: function(e) {
            for (var t = (new gn).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(e);
            for (var i = 0, a = this.faces.length; i < a; i++) {
                var o = this.faces[i];
                o.normal.applyMatrix3(t).normalize();
                for (var s = 0, l = o.vertexNormals.length; s < l; s++) o.vertexNormals[s].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function(e) {
            return Hl.makeRotationX(e), this.applyMatrix4(Hl), this
        },
        rotateY: function(e) {
            return Hl.makeRotationY(e), this.applyMatrix4(Hl), this
        },
        rotateZ: function(e) {
            return Hl.makeRotationZ(e), this.applyMatrix4(Hl), this
        },
        translate: function(e, t, n) {
            return Hl.makeTranslation(e, t, n), this.applyMatrix4(Hl), this
        },
        scale: function(e, t, n) {
            return Hl.makeScale(e, t, n), this.applyMatrix4(Hl), this
        },
        lookAt: function(e) {
            return Xl.lookAt(e), Xl.updateMatrix(), this.applyMatrix4(Xl.matrix), this
        },
        fromBufferGeometry: function(e) {
            var o = this,
                t = null !== e.index ? e.index : void 0,
                n = e.attributes;
            if (void 0 === n.position) return console.error("v3d.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var r = n.position,
                s = n.normal,
                l = n.color,
                c = n.uv,
                u = n.uv2;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var i = 0; i < r.count; i++) o.vertices.push((new Tn).fromBufferAttribute(r, i)), void 0 !== l && o.colors.push((new Qr).fromBufferAttribute(l, i));

            function a(e, t, n, r) {
                var i = void 0 === l ? [] : [o.colors[e].clone(), o.colors[t].clone(), o.colors[n].clone()],
                    a = void 0 === s ? [] : [(new Tn).fromBufferAttribute(s, e), (new Tn).fromBufferAttribute(s, t), (new Tn).fromBufferAttribute(s, n)],
                    r = new Kr(e, t, n, a, i, r);
                o.faces.push(r), void 0 !== c && o.faceVertexUvs[0].push([(new vn).fromBufferAttribute(c, e), (new vn).fromBufferAttribute(c, t), (new vn).fromBufferAttribute(c, n)]), void 0 !== u && o.faceVertexUvs[1].push([(new vn).fromBufferAttribute(u, e), (new vn).fromBufferAttribute(u, t), (new vn).fromBufferAttribute(u, n)])
            }
            var d = e.groups;
            if (0 < d.length)
                for (var h = 0; h < d.length; h++)
                    for (var f = d[h], p = f.start, m = p, v = p + f.count; m < v; m += 3) void 0 !== t ? a(t.getX(m), t.getX(m + 1), t.getX(m + 2), f.materialIndex) : a(m, m + 1, m + 2, f.materialIndex);
            else if (void 0 !== t)
                for (var g = 0; g < t.count; g += 3) a(t.getX(g), t.getX(g + 1), t.getX(g + 2));
            else
                for (var _ = 0; _ < r.count; _ += 3) a(_, _ + 1, _ + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Yl).negate(), this.translate(Yl.x, Yl.y, Yl.z), this
        },
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius,
                n = 0 === t ? 1 : 1 / t,
                t = new nr;
            return t.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(t), this
        },
        computeFaceNormals: function() {
            for (var e = new Tn, t = new Tn, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    a = this.vertices[i.a],
                    o = this.vertices[i.b],
                    s = this.vertices[i.c];
                e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), i.normal.copy(e)
            }
        },
        computeVertexNormals: function() {
            for (var e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0], t = new Array(this.vertices.length), n = 0, r = this.vertices.length; n < r; n++) t[n] = new Tn;
            if (e)
                for (var i = new Tn, a = new Tn, o = 0, s = this.faces.length; o < s; o++) {
                    var l = this.faces[o],
                        c = this.vertices[l.a],
                        u = this.vertices[l.b],
                        d = this.vertices[l.c];
                    i.subVectors(d, u), a.subVectors(c, u), i.cross(a), t[l.a].add(i), t[l.b].add(i), t[l.c].add(i)
                } else {
                    this.computeFaceNormals();
                    for (var h = 0, f = this.faces.length; h < f; h++) {
                        var p = this.faces[h];
                        t[p.a].add(p.normal), t[p.b].add(p.normal), t[p.c].add(p.normal)
                    }
                }
            for (var m = 0, v = this.vertices.length; m < v; m++) t[m].normalize();
            for (var g = 0, _ = this.faces.length; g < _; g++) {
                var y = this.faces[g],
                    x = y.vertexNormals;
                3 === x.length ? (x[0].copy(t[y.a]), x[1].copy(t[y.b]), x[2].copy(t[y.c])) : (x[0] = t[y.a].clone(), x[1] = t[y.b].clone(), x[2] = t[y.c].clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (var e = 0, t = this.faces.length; e < t; e++) {
                var n = this.faces[e],
                    r = n.vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            for (var e = 0, t = this.faces.length; e < t; e++) {
                var n = this.faces[e];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                for (var r = 0, i = n.vertexNormals.length; r < i; r++) n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone()
            }
            var a = new ql;
            a.faces = this.faces;
            for (var o = 0, s = this.morphTargets.length; o < s; o++) {
                if (!this.morphNormals[o]) {
                    this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [];
                    for (var l = this.morphNormals[o].faceNormals, c = this.morphNormals[o].vertexNormals, u = 0, d = this.faces.length; u < d; u++) {
                        var h = new Tn,
                            f = {
                                a: new Tn,
                                b: new Tn,
                                c: new Tn
                            };
                        l.push(h), c.push(f)
                    }
                }
                var p = this.morphNormals[o];
                a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                for (var m = 0, v = this.faces.length; m < v; m++) {
                    var g = this.faces[m],
                        _ = p.faceNormals[m],
                        y = p.vertexNormals[m];
                    _.copy(g.normal), y.a.copy(g.vertexNormals[0]), y.b.copy(g.vertexNormals[1]), y.c.copy(g.vertexNormals[2])
                }
            }
            for (var x = 0, b = this.faces.length; x < b; x++) {
                var M = this.faces[x];
                M.normal = M.__originalFaceNormal, M.vertexNormals = M.__originalVertexNormals
            }
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ln), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Yn), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t) {
            var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            if (e && e.isGeometry) {
                var r, i = this.vertices.length,
                    a = this.vertices,
                    o = e.vertices,
                    s = this.faces,
                    l = e.faces,
                    c = this.colors,
                    u = e.colors;
                void 0 !== t && (r = (new gn).getNormalMatrix(t));
                for (var d = 0, h = o.length; d < h; d++) {
                    var f = o[d].clone();
                    void 0 !== t && f.applyMatrix4(t), a.push(f)
                }
                for (var p = 0, m = u.length; p < m; p++) c.push(u[p].clone());
                for (var v = 0, g = l.length; v < g; v++) {
                    var _ = l[v],
                        y = void 0,
                        x = void 0,
                        b = _.vertexNormals,
                        M = _.vertexColors,
                        w = new Kr(_.a + i, _.b + i, _.c + i);
                    w.normal.copy(_.normal), void 0 !== r && w.normal.applyMatrix3(r).normalize();
                    for (var S = 0, A = b.length; S < A; S++) y = b[S].clone(), void 0 !== r && y.applyMatrix3(r).normalize(), w.vertexNormals.push(y);
                    w.color.copy(_.color);
                    for (var T = 0, E = M.length; T < E; T++) x = M[T], w.vertexColors.push(x.clone());
                    w.materialIndex = _.materialIndex + n, s.push(w)
                }
                for (var C = 0, L = e.faceVertexUvs.length; C < L; C++) {
                    var P = e.faceVertexUvs[C];
                    void 0 === this.faceVertexUvs[C] && (this.faceVertexUvs[C] = []);
                    for (var R = 0, D = P.length; R < D; R++) {
                        for (var O = P[R], N = [], I = 0, F = O.length; I < F; I++) N.push(O[I].clone());
                        this.faceVertexUvs[C].push(N)
                    }
                }
            } else console.error("v3d.Geometry.merge(): geometry not an instance of v3d.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("v3d.Geometry.mergeMesh(): mesh not an instance of v3d.Mesh.", e)
        },
        mergeVertices: function() {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 4, t = {}, n = [], r = [], i = Math.pow(10, e), a = 0, o = this.vertices.length; a < o; a++) {
                var s = this.vertices[a],
                    s = Math.round(s.x * i) + "_" + Math.round(s.y * i) + "_" + Math.round(s.z * i);
                void 0 === t[s] ? (t[s] = a, n.push(this.vertices[a]), r[a] = n.length - 1) : r[a] = r[t[s]]
            }
            for (var l = [], c = 0, u = this.faces.length; c < u; c++) {
                var d = this.faces[c];
                d.a = r[d.a], d.b = r[d.b], d.c = r[d.c];
                for (var h = [d.a, d.b, d.c], f = 0; f < 3; f++)
                    if (h[f] === h[(f + 1) % 3]) {
                        l.push(c);
                        break
                    }
            }
            for (var p = l.length - 1; 0 <= p; p--) {
                var m = l[p];
                this.faces.splice(m, 1);
                for (var v = 0, g = this.faceVertexUvs.length; v < g; v++) this.faceVertexUvs[v].splice(m, 1)
            }
            e = this.vertices.length - n.length;
            return this.vertices = n, e
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, n = e.length; t < n; t++) {
                var r = e[t];
                this.vertices.push(new Tn(r.x, r.y, r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
            e.sort(function(e, t) {
                return e.materialIndex - t.materialIndex
            });
            var r, i, a = this.faceVertexUvs[0],
                o = this.faceVertexUvs[1];
            a && a.length === t && (r = []), o && o.length === t && (i = []);
            for (var s = 0; s < t; s++) {
                var l = e[s]._id;
                r && r.push(a[l]), i && i.push(o[l])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t, n = this.parameters;
                for (t in n) void 0 !== n[t] && (e[t] = n[t]);
                return e
            }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var a = this.vertices[i];
                r.push(a.x, a.y, a.z)
            }
            for (var o = [], s = [], l = {}, c = [], u = {}, d = [], h = {}, f = 0; f < this.faces.length; f++) {
                var p, m = this.faces[f],
                    v = void 0 !== this.faceVertexUvs[0][f],
                    g = 0 < m.normal.length(),
                    _ = 0 < m.vertexNormals.length,
                    y = 1 !== m.color.r || 1 !== m.color.g || 1 !== m.color.b,
                    x = 0 < m.vertexColors.length;
                p = b(2, 3, v), p = b(p, 4, g), p = b(p, 5, _), p = b(p, 6, y), p = b(p, 7, x), o.push(p), o.push(m.a, m.b, m.c), o.push(m.materialIndex), v && (v = this.faceVertexUvs[0][f], o.push(S(v[0]), S(v[1]), S(v[2]))), g && o.push(M(m.normal)), _ && (_ = m.vertexNormals, o.push(M(_[0]), M(_[1]), M(_[2]))), y && o.push(w(m.color)), x && (m = m.vertexColors, o.push(w(m[0]), w(m[1]), w(m[2])))
            }

            function b(e, t, n) {
                return n ? e | 1 << t : e & ~(1 << t)
            }

            function M(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
            }

            function w(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] || (u[t] = c.length, c.push(e.getHex())), u[t]
            }

            function S(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== h[t] || (h[t] = d.length / 2, d.push(e.x, e.y)), h[t]
            }
            return e.data = {}, e.data.vertices = r, e.data.normals = s, 0 < c.length && (e.data.colors = c), 0 < d.length && (e.data.uvs = [d]), e.data.faces = o, e
        },
        clone: function() {
            return (new ql).copy(this)
        },
        copy: function(e) {
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            for (var t = e.vertices, n = 0, r = t.length; n < r; n++) this.vertices.push(t[n].clone());
            for (var i = e.colors, a = 0, o = i.length; a < o; a++) this.colors.push(i[a].clone());
            for (var s = e.faces, l = 0, c = s.length; l < c; l++) this.faces.push(s[l].clone());
            for (var u = 0, d = e.faceVertexUvs.length; u < d; u++) {
                var h = e.faceVertexUvs[u];
                void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                for (var f = 0, p = h.length; f < p; f++) {
                    for (var m = h[f], v = [], g = 0, _ = m.length; g < _; g++) {
                        var y = m[g];
                        v.push(y.clone())
                    }
                    this.faceVertexUvs[u].push(v)
                }
            }
            for (var x = e.morphTargets, b = 0, M = x.length; b < M; b++) {
                var w = {};
                if (w.name = x[b].name, void 0 !== x[b].vertices) {
                    w.vertices = [];
                    for (var S = 0, A = x[b].vertices.length; S < A; S++) w.vertices.push(x[b].vertices[S].clone())
                }
                if (void 0 !== x[b].normals) {
                    w.normals = [];
                    for (var T = 0, E = x[b].normals.length; T < E; T++) w.normals.push(x[b].normals[T].clone())
                }
                this.morphTargets.push(w)
            }
            for (var C = e.morphNormals, L = 0, P = C.length; L < P; L++) {
                var R = {};
                if (void 0 !== C[L].vertexNormals) {
                    R.vertexNormals = [];
                    for (var D = 0, O = C[L].vertexNormals.length; D < O; D++) {
                        var N = C[L].vertexNormals[D],
                            I = {};
                        I.a = N.a.clone(), I.b = N.b.clone(), I.c = N.c.clone(), R.vertexNormals.push(I)
                    }
                }
                if (void 0 !== C[L].faceNormals) {
                    R.faceNormals = [];
                    for (var F = 0, k = C[L].faceNormals.length; F < k; F++) R.faceNormals.push(C[L].faceNormals[F].clone())
                }
                this.morphNormals.push(R)
            }
            for (var B = e.skinWeights, z = 0, U = B.length; z < U; z++) this.skinWeights.push(B[z].clone());
            for (var V = e.skinIndices, G = 0, j = V.length; G < j; G++) this.skinIndices.push(V[G].clone());
            for (var W = e.lineDistances, H = 0, X = W.length; H < X; H++) this.lineDistances.push(W[H]);
            var Y = e.boundingBox;
            null !== Y && (this.boundingBox = Y.clone());
            Y = e.boundingSphere;
            return null !== Y && (this.boundingSphere = Y.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Zl = function() {
            _inherits(l, ql);
            var s = _createSuper(l);

            function l(e, t, n, r, i, a) {
                var o;
                return _classCallCheck(this, l), (o = s.call(this)).type = "BoxGeometry", o.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: a
                }, o.fromBufferGeometry(new ea(e, t, n, r, i, a)), o.mergeVertices(), o
            }
            return l
        }(),
        Ql = function() {
            _inherits(v, Oi);
            var m = _createSuper(v);

            function v() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 8,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                _classCallCheck(this, v), (e = m.call(this)).type = "CircleBufferGeometry", e.parameters = {
                    radius: t,
                    segments: n,
                    thetaStart: r,
                    thetaLength: i
                }, n = Math.max(3, n);
                var a = [],
                    o = [],
                    s = [],
                    l = [],
                    c = new Tn,
                    u = new vn;
                o.push(0, 0, 0), s.push(0, 0, 1), l.push(.5, .5);
                for (var d = 0, h = 3; d <= n; d++, h += 3) {
                    var f = r + d / n * i;
                    c.x = t * Math.cos(f), c.y = t * Math.sin(f), o.push(c.x, c.y, c.z), s.push(0, 0, 1), u.x = (o[h] / t + 1) / 2, u.y = (o[h + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (var p = 1; p <= n; p++) a.push(p, p + 1, 0);
                return e.setIndex(a), e.setAttribute("position", new hi(o, 3)), e.setAttribute("normal", new hi(s, 3)), e.setAttribute("uv", new hi(l, 2)), e
            }
            return v
        }(),
        Kl = function() {
            _inherits(o, ql);
            var a = _createSuper(o);

            function o(e, t, n, r) {
                var i;
                return _classCallCheck(this, o), (i = a.call(this)).type = "CircleGeometry", i.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, i.fromBufferGeometry(new Ql(e, t, n, r)), i.mergeVertices(), i
            }
            return o
        }(),
        Jl = function() {
            _inherits(i, Oi);
            var r = _createSuper(i);

            function i() {
                var e, _ = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    x = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                    b = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 8,
                    M = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1,
                    t = 5 < arguments.length && void 0 !== arguments[5] && arguments[5],
                    w = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 0,
                    S = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : 2 * Math.PI;
                _classCallCheck(this, i), (e = r.call(this)).type = "CylinderBufferGeometry", e.parameters = {
                    radiusTop: _,
                    radiusBottom: y,
                    height: x,
                    radialSegments: b,
                    heightSegments: M,
                    openEnded: t,
                    thetaStart: w,
                    thetaLength: S
                };
                var A = _assertThisInitialized(e),
                    b = Math.floor(b),
                    M = Math.floor(M),
                    T = [],
                    E = [],
                    C = [],
                    L = [],
                    P = 0,
                    R = [],
                    D = x / 2,
                    O = 0;

                function n(e) {
                    for (var t = P, n = new vn, r = new Tn, i = 0, a = !0 === e ? _ : y, o = !0 === e ? 1 : -1, s = 1; s <= b; s++) E.push(0, D * o, 0), C.push(0, o, 0), L.push(.5, .5), P++;
                    for (var l = P, c = 0; c <= b; c++) {
                        var u = c / b * S + w,
                            d = Math.cos(u),
                            u = Math.sin(u);
                        r.x = a * u, r.y = D * o, r.z = a * d, E.push(r.x, r.y, r.z), C.push(0, o, 0), n.x = .5 * d + .5, n.y = .5 * u * o + .5, L.push(n.x, n.y), P++
                    }
                    for (var h = 0; h < b; h++) {
                        var f = t + h,
                            p = l + h;
                        !0 === e ? T.push(p, p + 1, f) : T.push(p + 1, p, f), i += 3
                    }
                    A.addGroup(O, i, !0 === e ? 1 : 2), O += i
                }
                return function() {
                    for (var e = new Tn, t = new Tn, n = 0, r = (y - _) / x, i = 0; i <= M; i++) {
                        for (var a = [], o = i / M, s = o * (y - _) + _, l = 0; l <= b; l++) {
                            var c = l / b,
                                u = c * S + w,
                                d = Math.sin(u),
                                u = Math.cos(u);
                            t.x = s * d, t.y = -o * x + D, t.z = s * u, E.push(t.x, t.y, t.z), e.set(d, r, u).normalize(), C.push(e.x, e.y, e.z), L.push(c, 1 - o), a.push(P++)
                        }
                        R.push(a)
                    }
                    for (var h = 0; h < b; h++)
                        for (var f = 0; f < M; f++) {
                            var p = R[f][h],
                                m = R[f + 1][h],
                                v = R[f + 1][h + 1],
                                g = R[f][h + 1];
                            T.push(p, m, g), T.push(m, v, g), n += 6
                        }
                    A.addGroup(O, n, 0), O += n
                }(), !1 === t && (0 < _ && n(!0), 0 < y && n(!1)), e.setIndex(T), e.setAttribute("position", new hi(E, 3)), e.setAttribute("normal", new hi(C, 3)), e.setAttribute("uv", new hi(L, 2)), e
            }
            return i
        }(),
        $l = function() {
            _inherits(u, ql);
            var c = _createSuper(u);

            function u(e, t, n, r, i, a, o, s) {
                var l;
                return _classCallCheck(this, u), (l = c.call(this)).type = "CylinderGeometry", l.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, l.fromBufferGeometry(new Jl(e, t, n, r, i, a, o, s)), l.mergeVertices(), l
            }
            return u
        }(),
        ec = function() {
            _inherits(c, $l);
            var l = _createSuper(c);

            function c(e, t, n, r, i, a, o) {
                var s;
                return _classCallCheck(this, c), (s = l.call(this, 0, e, t, n, r, i, a, o)).type = "ConeGeometry", s.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: a,
                    thetaLength: o
                }, s
            }
            return c
        }(),
        tc = function() {
            _inherits(c, Jl);
            var l = _createSuper(c);

            function c() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 8,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1,
                    a = 4 < arguments.length && void 0 !== arguments[4] && arguments[4],
                    o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0,
                    s = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 2 * Math.PI;
                return _classCallCheck(this, c), (e = l.call(this, 0, t, n, r, i, a, o, s)).type = "ConeBufferGeometry", e.parameters = {
                    radius: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, e
            }
            return c
        }(),
        nc = function() {
            _inherits(s, Oi);
            var o = _createSuper(s);

            function s(n, i) {
                var e, t = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                _classCallCheck(this, s), (e = o.call(this)).type = "PolyhedronBufferGeometry", e.parameters = {
                    vertices: n,
                    indices: i,
                    radius: t,
                    detail: r
                };
                var u = [],
                    d = [];

                function p(e) {
                    u.push(e.x, e.y, e.z)
                }

                function a(e, t) {
                    e *= 3;
                    t.x = n[0 + e], t.y = n[1 + e], t.z = n[2 + e]
                }

                function h(e, t, n, r) {
                    r < 0 && 1 === e.x && (d[t] = e.x - 1), 0 === n.x && 0 === n.z && (d[t] = r / 2 / Math.PI + .5)
                }

                function f(e) {
                    return Math.atan2(e.z, -e.x)
                }
                return function(f) {
                        for (var e = new Tn, t = new Tn, n = new Tn, r = 0; r < i.length; r += 3) a(i[r + 0], e), a(i[r + 1], t), a(i[r + 2], n),
                            function(e, t, n) {
                                for (var r = f + 1, i = [], a = 0; a <= r; a++) {
                                    i[a] = [];
                                    for (var o = e.clone().lerp(n, a / r), s = t.clone().lerp(n, a / r), l = r - a, c = 0; c <= l; c++) i[a][c] = 0 === c && a === r ? o : o.clone().lerp(s, c / l)
                                }
                                for (var u = 0; u < r; u++)
                                    for (var d = 0; d < 2 * (r - u) - 1; d++) {
                                        var h = Math.floor(d / 2);
                                        d % 2 == 0 ? (p(i[u][h + 1]), p(i[u + 1][h]), p(i[u][h])) : (p(i[u][h + 1]), p(i[u + 1][h + 1]), p(i[u + 1][h]))
                                    }
                            }(e, t, n)
                    }(r),
                    function(e) {
                        for (var t = new Tn, n = 0; n < u.length; n += 3) t.x = u[n + 0], t.y = u[n + 1], t.z = u[n + 2], t.normalize().multiplyScalar(e), u[n + 0] = t.x, u[n + 1] = t.y, u[n + 2] = t.z
                    }(t),
                    function() {
                        for (var e = new Tn, t = 0; t < u.length; t += 3) {
                            e.x = u[t + 0], e.y = u[t + 1], e.z = u[t + 2];
                            var n = f(e) / 2 / Math.PI + .5,
                                r = function(e) {
                                    return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
                                }(e) / Math.PI + .5;
                            d.push(n, 1 - r)
                        }(function() {
                            for (var e = new Tn, t = new Tn, n = new Tn, r = new Tn, i = new vn, a = new vn, o = new vn, s = 0, l = 0; s < u.length; s += 9, l += 6) {
                                e.set(u[s + 0], u[s + 1], u[s + 2]), t.set(u[s + 3], u[s + 4], u[s + 5]), n.set(u[s + 6], u[s + 7], u[s + 8]), i.set(d[l + 0], d[l + 1]), a.set(d[l + 2], d[l + 3]), o.set(d[l + 4], d[l + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                                var c = f(r);
                                h(i, l + 0, e, c), h(a, l + 2, t, c), h(o, l + 4, n, c)
                            }
                        })(),
                        function() {
                            for (var e = 0; e < d.length; e += 6) {
                                var t = d[e + 0],
                                    n = d[e + 2],
                                    r = d[e + 4],
                                    i = Math.max(t, n, r),
                                    a = Math.min(t, n, r);
                                .9 < i && a < .1 && (t < .2 && (d[e + 0] += 1), n < .2 && (d[e + 2] += 1), r < .2 && (d[e + 4] += 1))
                            }
                        }()
                    }(), e.setAttribute("position", new hi(u, 3)), e.setAttribute("normal", new hi(u.slice(), 3)), e.setAttribute("uv", new hi(d, 2)), 0 === r ? e.computeVertexNormals() : e.normalizeNormals(), e
            }
            return s
        }(),
        rc = function() {
            _inherits(a, nc);
            var i = _createSuper(a);

            function a() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, a);
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
                return (r = i.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t)).type = "DodecahedronBufferGeometry", r.parameters = {
                    radius: e,
                    detail: t
                }, r
            }
            return a
        }(),
        ic = function() {
            _inherits(i, ql);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = r.call(this)).type = "DodecahedronGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n.fromBufferGeometry(new rc(e, t)), n.mergeVertices(), n
            }
            return i
        }(),
        ac = new Tn,
        oc = new Tn,
        sc = new Tn,
        lc = new Gr,
        cc = function() {
            _inherits(C, Oi);
            var E = _createSuper(C);

            function C(e, t) {
                var n;
                _classCallCheck(this, C), (n = E.call(this)).type = "EdgesGeometry", n.parameters = {
                    thresholdAngle: t
                }, t = void 0 !== t ? t : 1, e.isGeometry && (e = (new Oi).fromGeometry(e));
                for (var r, i, a, o = Math.pow(10, 4), s = Math.cos(mn.DEG2RAD * t), l = e.getIndex(), c = e.getAttribute("position"), u = (l || c).count, d = [0, 0, 0], h = ["a", "b", "c"], f = new Array(3), p = {}, m = [], v = 0; v < u; v += 3) {
                    l ? (d[0] = l.getX(v), d[1] = l.getX(v + 1), d[2] = l.getX(v + 2)) : (d[0] = v, d[1] = v + 1, d[2] = v + 2);
                    var g = lc.a,
                        _ = lc.b,
                        y = lc.c;
                    if (g.fromBufferAttribute(c, d[0]), _.fromBufferAttribute(c, d[1]), y.fromBufferAttribute(c, d[2]), lc.getNormal(sc), f[0] = "".concat(Math.round(g.x * o), ",").concat(Math.round(g.y * o), ",").concat(Math.round(g.z * o)), f[1] = "".concat(Math.round(_.x * o), ",").concat(Math.round(_.y * o), ",").concat(Math.round(_.z * o)), f[2] = "".concat(Math.round(y.x * o), ",").concat(Math.round(y.y * o), ",").concat(Math.round(y.z * o)), f[0] !== f[1] && f[1] !== f[2] && f[2] !== f[0])
                        for (var x = 0; x < 3; x++) {
                            var b = (x + 1) % 3,
                                M = f[x],
                                w = f[b],
                                S = lc[h[x]],
                                A = lc[h[b]],
                                T = "".concat(M, "_").concat(w),
                                M = "".concat(w, "_").concat(M);
                            M in p && p[M] ? (sc.dot(p[M].normal) <= s && (m.push(S.x, S.y, S.z), m.push(A.x, A.y, A.z)), p[M] = null) : T in p || (p[T] = {
                                index0: d[x],
                                index1: d[b],
                                normal: sc.clone()
                            })
                        }
                }
                for (r in p) p[r] && (i = (a = p[r]).index0, a = a.index1, ac.fromBufferAttribute(c, i), oc.fromBufferAttribute(c, a), m.push(ac.x, ac.y, ac.z), m.push(oc.x, oc.y, oc.z));
                return n.setAttribute("position", new hi(m, 3)), n
            }
            return C
        }(),
        uc = function(e, t, n) {
            n = n || 2;
            var r, i, a, o, s, l, c, u = t && t.length,
                d = u ? t[0] * n : e.length,
                h = dc(e, 0, d, n, !0),
                f = [];
            if (!h || h.next === h.prev) return f;
            if (u && (h = function(e, t, n, r) {
                    var i, a, o, s, l = [];
                    for (i = 0, a = t.length; i < a; i++) o = t[i] * r, s = i < a - 1 ? t[i + 1] * r : e.length, (s = dc(e, o, s, r, !1)) === s.next && (s.steiner = !0), l.push(function(e) {
                        var t = e,
                            n = e;
                        for (;
                            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next, t !== e;);
                        return n
                    }(s));
                    for (l.sort(pc), i = 0; i < l.length; i++) ! function(e, t) {
                        (t = function(e, t) {
                            var n, r = t,
                                i = e.x,
                                a = e.y,
                                o = -1 / 0;
                            do {
                                if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                                    var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                    if (s <= i && o < s) {
                                        if ((o = s) === i) {
                                            if (a === r.y) return r;
                                            if (a === r.next.y) return r.next
                                        }
                                        n = r.x < r.next.x ? r : r.next
                                    }
                                }
                            } while (r = r.next, r !== t);
                            if (!n) return null;
                            if (i === o) return n;
                            var l, c = n,
                                u = n.x,
                                d = n.y,
                                h = 1 / 0;
                            r = n;
                            for (; i >= r.x && r.x >= u && i !== r.x && vc(a < d ? i : o, a, u, d, a < d ? o : i, a, r.x, r.y) && (l = Math.abs(a - r.y) / (i - r.x), Mc(r, e) && (l < h || l === h && (r.x > n.x || r.x === n.x && function(e, t) {
                                    return gc(e.prev, e, t.prev) < 0 && gc(t.next, e, e.next) < 0
                                }(n, r))) && (n = r, h = l)), r = r.next, r !== c;);
                            return n
                        }(e, t)) && (e = wc(t, e), hc(t, t.next), hc(e, e.next))
                    }(l[i], n), n = hc(n, n.next);
                    return n
                }(e, t, h, n)), e.length > 80 * n) {
                r = a = e[0], i = o = e[1];
                for (var p = n; p < d; p += n)(s = e[p]) < r && (r = s), (l = e[p + 1]) < i && (i = l), a < s && (a = s), o < l && (o = l);
                c = 0 !== (c = Math.max(a - r, o - i)) ? 1 / c : 0
            }
            return fc(h, f, n, r, i, c), f
        };

    function dc(e, t, n, r, i) {
        var a, o;
        if (i === 0 < function(e, t, n, r) {
                for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                return i
            }(e, t, n, r))
            for (a = t; a < n; a += r) o = Sc(a, e[a], e[a + 1], o);
        else
            for (a = n - r; t <= a; a -= r) o = Sc(a, e[a], e[a + 1], o);
        return o && _c(o, o.next) && (Ac(o), o = o.next), o
    }

    function hc(e, t) {
        if (!e) return e;
        t = t || e;
        var n, r = e;
        do {
            if (n = !1, r.steiner || !_c(r, r.next) && 0 !== gc(r.prev, r, r.next)) r = r.next;
            else {
                if (Ac(r), (r = t = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== t);
        return t
    }

    function fc(e, t, n, r, i, a, o) {
        if (e) {
            !o && a && function(e, t, n, r) {
                for (var i = e; null === i.z && (i.z = mc(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== e;);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(e) {
                        var t, n, r, i, a, o, s, l, c = 1;
                        do {
                            for (n = e, a = e = null, o = 0; n;) {
                                for (o++, r = n, t = s = 0; t < c && (s++, r = r.nextZ); t++);
                                for (l = c; 0 < s || 0 < l && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (n = (i = n).nextZ, s--) : (r = (i = r).nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
                                n = r
                            }
                        } while (a.nextZ = null, c *= 2, 1 < o)
                    }(i)
            }(e, r, i, a);
            for (var s, l, c = e; e.prev !== e.next;)
                if (s = e.prev, l = e.next, a ? function(e, t, n, r) {
                        var i = e.prev,
                            a = e,
                            o = e.next;
                        if (0 <= gc(i, a, o)) return !1;
                        var s = (i.x < a.x ? i.x < o.x ? i : o : a.x < o.x ? a : o).x,
                            l = (i.y < a.y ? i.y < o.y ? i : o : a.y < o.y ? a : o).y,
                            c = (i.x > a.x ? i.x > o.x ? i : o : a.x > o.x ? a : o).x,
                            u = (i.y > a.y ? i.y > o.y ? i : o : a.y > o.y ? a : o).y,
                            d = mc(s, l, t, n, r),
                            h = mc(c, u, t, n, r),
                            f = e.prevZ,
                            p = e.nextZ;
                        for (; f && f.z >= d && p && p.z <= h;) {
                            if (f !== e.prev && f !== e.next && vc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= gc(f.prev, f, f.next)) return !1;
                            if (f = f.prevZ, p !== e.prev && p !== e.next && vc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= gc(p.prev, p, p.next)) return !1;
                            p = p.nextZ
                        }
                        for (; f && f.z >= d;) {
                            if (f !== e.prev && f !== e.next && vc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= gc(f.prev, f, f.next)) return !1;
                            f = f.prevZ
                        }
                        for (; p && p.z <= h;) {
                            if (p !== e.prev && p !== e.next && vc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= gc(p.prev, p, p.next)) return !1;
                            p = p.nextZ
                        }
                        return !0
                    }(e, r, i, a) : function(e) {
                        var t = e.prev,
                            n = e,
                            r = e.next;
                        if (0 <= gc(t, n, r)) return !1;
                        var i = e.next.next;
                        for (; i !== e.prev;) {
                            if (vc(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= gc(i.prev, i, i.next)) return !1;
                            i = i.next
                        }
                        return !0
                    }(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), Ac(e), e = l.next, c = l.next;
                else if ((e = l) === c) {
                o ? 1 === o ? fc(e = function(e, t, n) {
                    var r = e;
                    do {
                        var i = r.prev,
                            a = r.next.next
                    } while (!_c(i, a) && yc(i, r, r.next, a) && Mc(i, a) && Mc(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), Ac(r), Ac(r.next), r = e = a), r = r.next, r !== e);
                    return hc(r)
                }(hc(e), t, n), t, n, r, i, a, 2) : 2 === o && function(e, t, n, r, i, a) {
                    var o = e;
                    do {
                        for (var s = o.next.next; s !== o.prev;) {
                            if (o.i !== s.i && function(e, t) {
                                    return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                                        var n = e;
                                        do {
                                            if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && yc(n, n.next, e, t)) return !0
                                        } while (n = n.next, n !== e);
                                        return !1
                                    }(e, t) && (Mc(e, t) && Mc(t, e) && function(e, t) {
                                        var n = e,
                                            r = !1,
                                            i = (e.x + t.x) / 2,
                                            a = (e.y + t.y) / 2;
                                        for (; n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== e;);
                                        return r
                                    }(e, t) && (gc(e.prev, e, t.prev) || gc(e, t.prev, t)) || _c(e, t) && 0 < gc(e.prev, e, e.next) && 0 < gc(t.prev, t, t.next))
                                }(o, s)) {
                                var l = wc(o, s);
                                return o = hc(o, o.next), l = hc(l, l.next), fc(o, t, n, r, i, a), fc(l, t, n, r, i, a)
                            }
                            s = s.next
                        }
                    } while ((o = o.next) !== e)
                }(e, t, n, r, i, a) : fc(hc(e), t, n, r, i, a, 1);
                break
            }
        }
    }

    function pc(e, t) {
        return e.x - t.x
    }

    function mc(e, t, n, r, i) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function vc(e, t, n, r, i, a, o, s) {
        return 0 <= (i - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (r - s) - (n - o) * (t - s) && 0 <= (n - o) * (a - s) - (i - o) * (r - s)
    }

    function gc(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
    }

    function _c(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function yc(e, t, n, r) {
        var i = bc(gc(e, t, n)),
            a = bc(gc(e, t, r)),
            o = bc(gc(n, r, e)),
            s = bc(gc(n, r, t));
        return i !== a && o !== s || (0 === i && xc(e, n, t) || (0 === a && xc(e, r, t) || (0 === o && xc(n, e, r) || !(0 !== s || !xc(n, t, r)))))
    }

    function xc(e, t, n) {
        return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
    }

    function bc(e) {
        return 0 < e ? 1 : e < 0 ? -1 : 0
    }

    function Mc(e, t) {
        return gc(e.prev, e, e.next) < 0 ? 0 <= gc(e, t, e.next) && 0 <= gc(e, e.prev, t) : gc(e, t, e.prev) < 0 || gc(e, e.next, t) < 0
    }

    function wc(e, t) {
        var n = new Tc(e.i, e.x, e.y),
            r = new Tc(t.i, t.x, t.y),
            i = e.next,
            a = t.prev;
        return (e.next = t).prev = e, (n.next = i).prev = n, (r.next = n).prev = r, (a.next = r).prev = a, r
    }

    function Sc(e, t, n, r) {
        n = new Tc(e, t, n);
        return r ? (n.next = r.next, (n.prev = r).next.prev = n, r.next = n) : (n.prev = n).next = n, n
    }

    function Ac(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Tc(e, t, n) {
        this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var Ec = {
        area: function(e) {
            for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
            return .5 * n
        },
        isClockWise: function(e) {
            return Ec.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var n = [],
                r = [],
                i = [];
            Cc(e), Lc(n, e);
            var a = e.length;
            t.forEach(Cc);
            for (var o = 0; o < t.length; o++) r.push(a), a += t[o].length, Lc(n, t[o]);
            for (var s = uc(n, r), l = 0; l < s.length; l += 3) i.push(s.slice(l, l + 3));
            return i
        }
    };

    function Cc(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function Lc(e, t) {
        for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
    }
    var Pc = function() {
            _inherits(a, Oi);
            var i = _createSuper(a);

            function a(e, Pe) {
                var t;
                _classCallCheck(this, a), (t = i.call(this)).type = "ExtrudeBufferGeometry", t.parameters = {
                    shapes: e,
                    options: Pe
                }, e = Array.isArray(e) ? e : [e];
                for (var Re = _assertThisInitialized(t), De = [], Oe = [], n = 0, r = e.length; n < r; n++) ! function(e) {
                    var r = [],
                        t = void 0 !== Pe.curveSegments ? Pe.curveSegments : 12,
                        d = void 0 !== Pe.steps ? Pe.steps : 1,
                        n = void 0 !== Pe.depth ? Pe.depth : 100,
                        u = void 0 === Pe.bevelEnabled || Pe.bevelEnabled,
                        i = void 0 !== Pe.bevelThickness ? Pe.bevelThickness : 6,
                        a = void 0 !== Pe.bevelSize ? Pe.bevelSize : i - 2,
                        o = void 0 !== Pe.bevelOffset ? Pe.bevelOffset : 0,
                        h = void 0 !== Pe.bevelSegments ? Pe.bevelSegments : 3,
                        s = Pe.extrudePath,
                        f = void 0 !== Pe.UVGenerator ? Pe.UVGenerator : Rc;
                    void 0 !== Pe.amount && (console.warn("v3d.ExtrudeBufferGeometry: amount has been renamed to depth."), n = Pe.amount);
                    var l, c, p, m, v, g = !1;
                    s && (l = s.getSpacedPoints(d), u = !(g = !0), c = s.computeFrenetFrames(d, !1), p = new Tn, m = new Tn, v = new Tn), u || (o = a = i = h = 0);
                    var _ = (t = e.extractPoints(t)).shape,
                        y = t.holes;
                    if (!Ec.isClockWise(_)) {
                        _ = _.reverse();
                        for (var x = 0, b = y.length; x < b; x++) {
                            var M = y[x];
                            Ec.isClockWise(M) && (y[x] = M.reverse())
                        }
                    }
                    for (var w = Ec.triangulateShape(_, y), S = _, A = 0, T = y.length; A < T; A++) {
                        var E = y[A];
                        _ = _.concat(E)
                    }

                    function C(e, t, n) {
                        return t || console.error("v3d.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                    }
                    var L = _.length,
                        P = w.length;

                    function R(e, t, n) {
                        var r = e.x - t.x,
                            i = e.y - t.y,
                            a = n.x - e.x,
                            o = n.y - e.y,
                            s = r * r + i * i,
                            l = r * o - i * a;
                        if (Math.abs(l) > Number.EPSILON) {
                            var c = Math.sqrt(s),
                                u = Math.sqrt(a * a + o * o),
                                d = t.x - i / c,
                                h = t.y + r / c,
                                c = ((n.x - o / u - d) * o - (n.y + a / u - h) * a) / (r * o - i * a),
                                h = (u = d + r * c - e.x) * u + (d = h + i * c - e.y) * d;
                            if (h <= 2) return new vn(u, d);
                            c = Math.sqrt(h / 2)
                        } else {
                            h = !1;
                            r > Number.EPSILON ? a > Number.EPSILON && (h = !0) : r < -Number.EPSILON ? a < -Number.EPSILON && (h = !0) : Math.sign(i) === Math.sign(o) && (h = !0), c = h ? (u = -i, d = r, Math.sqrt(s)) : (u = r, d = i, Math.sqrt(s / 2))
                        }
                        return new vn(u / c, d / c)
                    }
                    for (var D = [], O = 0, N = S.length, I = N - 1, F = O + 1; O < N; O++, I++, F++) I === N && (I = 0), F === N && (F = 0), D[O] = R(S[O], S[I], S[F]);
                    for (var k, B = [], z = D.concat(), U = 0, V = y.length; U < V; U++) {
                        var G = y[U];
                        k = [];
                        for (var j = 0, W = G.length, H = W - 1, X = j + 1; j < W; j++, H++, X++) H === W && (H = 0), X === W && (X = 0), k[j] = R(G[j], G[H], G[X]);
                        B.push(k), z = z.concat(k)
                    }
                    for (var Y = 0; Y < h; Y++) {
                        for (var q = Y / h, Z = i * Math.cos(q * Math.PI / 2), Q = a * Math.sin(q * Math.PI / 2) + o, K = 0, J = S.length; K < J; K++) {
                            var $ = C(S[K], D[K], Q);
                            Te($.x, $.y, -Z)
                        }
                        for (var ee = 0, te = y.length; ee < te; ee++) {
                            var ne = y[ee];
                            k = B[ee];
                            for (var re = 0, ie = ne.length; re < ie; re++) {
                                var ae = C(ne[re], k[re], Q);
                                Te(ae.x, ae.y, -Z)
                            }
                        }
                    }
                    for (var oe = a + o, se = 0; se < L; se++) {
                        var le = u ? C(_[se], z[se], oe) : _[se];
                        g ? (m.copy(c.normals[0]).multiplyScalar(le.x), p.copy(c.binormals[0]).multiplyScalar(le.y), v.copy(l[0]).add(m).add(p), Te(v.x, v.y, v.z)) : Te(le.x, le.y, 0)
                    }
                    for (var ce = 1; ce <= d; ce++)
                        for (var ue = 0; ue < L; ue++) {
                            var de = u ? C(_[ue], z[ue], oe) : _[ue];
                            g ? (m.copy(c.normals[ce]).multiplyScalar(de.x), p.copy(c.binormals[ce]).multiplyScalar(de.y), v.copy(l[ce]).add(m).add(p), Te(v.x, v.y, v.z)) : Te(de.x, de.y, n / d * ce)
                        }
                    for (var he = h - 1; 0 <= he; he--) {
                        for (var fe = he / h, pe = i * Math.cos(fe * Math.PI / 2), me = a * Math.sin(fe * Math.PI / 2) + o, ve = 0, ge = S.length; ve < ge; ve++) {
                            var _e = C(S[ve], D[ve], me);
                            Te(_e.x, _e.y, n + pe)
                        }
                        for (var ye = 0, xe = y.length; ye < xe; ye++) {
                            var be = y[ye];
                            k = B[ye];
                            for (var Me = 0, we = be.length; Me < we; Me++) {
                                var Se = C(be[Me], k[Me], me);
                                g ? Te(Se.x, Se.y + l[d - 1].y, l[d - 1].x + pe) : Te(Se.x, Se.y, n + pe)
                            }
                        }
                    }

                    function Ae(e, t) {
                        for (var n, r = e.length; 0 <= --r;) {
                            var i = r,
                                a = r - 1;
                            a < 0 && (a = e.length - 1);
                            for (var o = 0, s = d + 2 * h; o < s; o++) {
                                var l = L * o,
                                    c = L * (o + 1),
                                    u = t + i + l;
                                n = t + a + l, l = t + a + c, c = t + i + c, Ce(u), Ce(n), Ce(c), Ce(n), Ce(l), Ce(c), c = De.length / 3, Le((c = f.generateSideWallUV(Re, De, c - 6, c - 3, c - 2, c - 1))[0]), Le(c[1]), Le(c[3]), Le(c[1]), Le(c[2]), !void Le(c[3])
                            }
                        }
                    }

                    function Te(e, t, n) {
                        r.push(e), r.push(t), r.push(n)
                    }

                    function Ee(e, t, n) {
                        Ce(e), Ce(t), Ce(n);
                        n = De.length / 3, n = f.generateTopUV(Re, De, n - 3, n - 2, n - 1);
                        Le(n[0]), Le(n[1]), Le(n[2])
                    }

                    function Ce(e) {
                        De.push(r[3 * e + 0]), De.push(r[3 * e + 1]), De.push(r[3 * e + 2])
                    }

                    function Le(e) {
                        Oe.push(e.x), Oe.push(e.y)
                    }(function() {
                        var e = De.length / 3;
                        if (u) {
                            for (var t = 0 * L, n = 0; n < P; n++) {
                                var r = w[n];
                                Ee(r[2] + t, r[1] + t, r[0] + t)
                            }
                            t = L * (d + 2 * h);
                            for (var i = 0; i < P; i++) {
                                var a = w[i];
                                Ee(a[0] + t, a[1] + t, a[2] + t)
                            }
                        } else {
                            for (var o = 0; o < P; o++) {
                                var s = w[o];
                                Ee(s[2], s[1], s[0])
                            }
                            for (var l = 0; l < P; l++) {
                                var c = w[l];
                                Ee(c[0] + L * d, c[1] + L * d, c[2] + L * d)
                            }
                        }
                        Re.addGroup(e, De.length / 3 - e, 0)
                    })(),
                    function() {
                        var e = De.length / 3,
                            t = 0;
                        Ae(S, t), t += S.length;
                        for (var n = 0, r = y.length; n < r; n++) {
                            var i = y[n];
                            Ae(i, t), t += i.length
                        }
                        Re.addGroup(e, De.length / 3 - e, 1)
                    }()
                }(e[n]);
                return t.setAttribute("position", new hi(De, 3)), t.setAttribute("uv", new hi(Oe, 2)), t.computeVertexNormals(), t
            }
            return _createClass(a, [{
                key: "toJSON",
                value: function() {
                    var e = Oi.prototype.toJSON.call(this);
                    return function(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (var r = 0, i = e.length; r < i; r++) {
                                var a = e[r];
                                n.shapes.push(a.uuid)
                            } else n.shapes.push(e.uuid);
                        void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
                        return n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
            }]), a
        }(),
        Rc = {
            generateTopUV: function(e, t, n, r, i) {
                var a = t[3 * n],
                    o = t[3 * n + 1],
                    s = t[3 * r],
                    n = t[3 * r + 1],
                    r = t[3 * i],
                    i = t[3 * i + 1];
                return [new vn(a, o), new vn(s, n), new vn(r, i)]
            },
            generateSideWallUV: function(e, t, n, r, i, a) {
                var o = t[3 * n],
                    s = t[3 * n + 1],
                    l = t[3 * n + 2],
                    c = t[3 * r],
                    u = t[3 * r + 1],
                    d = t[3 * r + 2],
                    h = t[3 * i],
                    f = t[3 * i + 1],
                    n = t[3 * i + 2],
                    r = t[3 * a],
                    i = t[3 * a + 1],
                    a = t[3 * a + 2];
                return Math.abs(s - u) < .01 ? [new vn(o, 1 - l), new vn(c, 1 - d), new vn(h, 1 - n), new vn(r, 1 - a)] : [new vn(s, 1 - l), new vn(u, 1 - d), new vn(f, 1 - n), new vn(i, 1 - a)]
            }
        };
    var Dc = function() {
        _inherits(i, ql);
        var r = _createSuper(i);

        function i(e, t) {
            var n;
            return _classCallCheck(this, i), (n = r.call(this)).type = "ExtrudeGeometry", n.parameters = {
                shapes: e,
                options: t
            }, n.fromBufferGeometry(new Pc(e, t)), n.mergeVertices(), n
        }
        return _createClass(i, [{
            key: "toJSON",
            value: function() {
                var e = _get(_getPrototypeOf(i.prototype), "toJSON", this).call(this);
                return function(e, t, n) {
                    if (n.shapes = [], Array.isArray(e))
                        for (var r = 0, i = e.length; r < i; r++) {
                            var a = e[r];
                            n.shapes.push(a.uuid)
                        } else n.shapes.push(e.uuid);
                    void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, e)
            }
        }]), i
    }();
    var Oc = function() {
            _inherits(i, nc);
            var r = _createSuper(i);

            function i() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, i);
                var n = (1 + Math.sqrt(5)) / 2,
                    n = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                return (n = r.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t)).type = "IcosahedronBufferGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n
            }
            return i
        }(),
        Nc = function() {
            _inherits(i, ql);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = r.call(this)).type = "IcosahedronGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n.fromBufferGeometry(new Oc(e, t)), n.mergeVertices(), n
            }
            return i
        }(),
        Ic = function() {
            _inherits(P, Oi);
            var L = _createSuper(P);

            function P(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 12,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                _classCallCheck(this, P), (t = L.call(this)).type = "LatheBufferGeometry", t.parameters = {
                    points: e,
                    segments: n,
                    phiStart: r,
                    phiLength: i
                }, n = Math.floor(n), i = mn.clamp(i, 0, 2 * Math.PI);
                for (var a = [], o = [], s = [], l = 1 / n, c = new Tn, u = new vn, d = 0; d <= n; d++)
                    for (var h = r + d * l * i, f = Math.sin(h), p = Math.cos(h), m = 0; m <= e.length - 1; m++) c.x = e[m].x * f, c.y = e[m].y, c.z = e[m].x * p, o.push(c.x, c.y, c.z), u.x = d / n, u.y = m / (e.length - 1), s.push(u.x, u.y);
                for (var v = 0; v < n; v++)
                    for (var g = 0; g < e.length - 1; g++) {
                        var _ = g + v * e.length,
                            y = _ + e.length,
                            x = _ + e.length + 1,
                            b = _ + 1;
                        a.push(_, y, b), a.push(y, x, b)
                    }
                if (t.setIndex(a), t.setAttribute("position", new hi(o, 3)), t.setAttribute("uv", new hi(s, 2)), t.computeVertexNormals(), i === 2 * Math.PI)
                    for (var M = t.attributes.normal.array, w = new Tn, S = new Tn, A = new Tn, T = n * e.length * 3, E = 0, C = 0; E < e.length; E++, C += 3) w.x = M[C + 0], w.y = M[C + 1], w.z = M[C + 2], S.x = M[T + C + 0], S.y = M[T + C + 1], S.z = M[T + C + 2], A.addVectors(w, S).normalize(), M[C + 0] = M[T + C + 0] = A.x, M[C + 1] = M[T + C + 1] = A.y, M[C + 2] = M[T + C + 2] = A.z;
                return t
            }
            return P
        }(),
        Fc = function() {
            _inherits(o, ql);
            var a = _createSuper(o);

            function o(e, t, n, r) {
                var i;
                return _classCallCheck(this, o), (i = a.call(this)).type = "LatheGeometry", i.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, i.fromBufferGeometry(new Ic(e, t, n, r)), i.mergeVertices(), i
            }
            return o
        }(),
        kc = function() {
            _inherits(i, nc);
            var r = _createSuper(i);

            function i() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, i);
                var n;
                return (n = r.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t)).type = "OctahedronBufferGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n
            }
            return i
        }(),
        Bc = function() {
            _inherits(i, ql);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = r.call(this)).type = "OctahedronGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n.fromBufferGeometry(new kc(e, t)), n.mergeVertices(), n
            }
            return i
        }();

    function zc(e, t, n) {
        Oi.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        var r = [],
            i = [],
            a = [],
            o = [],
            s = new Tn,
            l = new Tn,
            c = new Tn,
            u = new Tn,
            d = new Tn;
        e.length < 3 && console.error("v3d.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        for (var h = t + 1, f = 0; f <= n; f++)
            for (var p = f / n, m = 0; m <= t; m++) {
                var v = m / t;
                e(v, p, l), i.push(l.x, l.y, l.z), 0 <= v - 1e-5 ? (e(v - 1e-5, p, c), u.subVectors(l, c)) : (e(1e-5 + v, p, c), u.subVectors(c, l)), 0 <= p - 1e-5 ? (e(v, p - 1e-5, c), d.subVectors(l, c)) : (e(v, 1e-5 + p, c), d.subVectors(c, l)), s.crossVectors(u, d).normalize(), a.push(s.x, s.y, s.z), o.push(v, p)
            }
        for (var g = 0; g < n; g++)
            for (var _ = 0; _ < t; _++) {
                var y = g * h + _,
                    x = g * h + _ + 1,
                    b = (g + 1) * h + _ + 1,
                    M = (g + 1) * h + _;
                r.push(y, x, M), r.push(x, b, M)
            }
        this.setIndex(r), this.setAttribute("position", new hi(i, 3)), this.setAttribute("normal", new hi(a, 3)), this.setAttribute("uv", new hi(o, 2))
    }

    function Uc(e, t, n) {
        ql.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        }, this.fromBufferGeometry(new zc(e, t, n)), this.mergeVertices()
    }(zc.prototype = Object.create(Oi.prototype)).constructor = zc, (Uc.prototype = Object.create(ql.prototype)).constructor = Uc;
    var Vc = function() {
            _inherits(o, ql);
            var a = _createSuper(o);

            function o(e, t, n, r) {
                var i;
                return _classCallCheck(this, o), (i = a.call(this)).type = "PlaneGeometry", i.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                }, i.fromBufferGeometry(new ba(e, t, n, r)), i.mergeVertices(), i
            }
            return o
        }(),
        Gc = function() {
            _inherits(o, ql);
            var a = _createSuper(o);

            function o(e, t, n, r) {
                var i;
                return _classCallCheck(this, o), (i = a.call(this)).type = "PolyhedronGeometry", i.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                }, i.fromBufferGeometry(new nc(e, t, n, r)), i.mergeVertices(), i
            }
            return o
        }(),
        jc = function() {
            _inherits(T, Oi);
            var A = _createSuper(T);

            function T() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : .5,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 8,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 1,
                    a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
                    o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI;
                _classCallCheck(this, T), (e = A.call(this)).type = "RingBufferGeometry", e.parameters = {
                    innerRadius: t,
                    outerRadius: n,
                    thetaSegments: r,
                    phiSegments: i,
                    thetaStart: a,
                    thetaLength: o
                }, r = Math.max(3, r);
                for (var s = [], l = [], c = [], u = [], d = t, h = (n - t) / (i = Math.max(1, i)), f = new Tn, p = new vn, m = 0; m <= i; m++) {
                    for (var v = 0; v <= r; v++) {
                        var g = a + v / r * o;
                        f.x = d * Math.cos(g), f.y = d * Math.sin(g), l.push(f.x, f.y, f.z), c.push(0, 0, 1), p.x = (f.x / n + 1) / 2, p.y = (f.y / n + 1) / 2, u.push(p.x, p.y)
                    }
                    d += h
                }
                for (var _ = 0; _ < i; _++)
                    for (var y = _ * (r + 1), x = 0; x < r; x++) {
                        var b = x + y,
                            M = b + r + 1,
                            w = b + r + 2,
                            S = b + 1;
                        s.push(b, M, S), s.push(M, w, S)
                    }
                return e.setIndex(s), e.setAttribute("position", new hi(l, 3)), e.setAttribute("normal", new hi(c, 3)), e.setAttribute("uv", new hi(u, 2)), e
            }
            return T
        }(),
        Wc = function() {
            _inherits(l, ql);
            var s = _createSuper(l);

            function l(e, t, n, r, i, a) {
                var o;
                return _classCallCheck(this, l), (o = s.call(this)).type = "RingGeometry", o.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: a
                }, o.fromBufferGeometry(new jc(e, t, n, r, i, a)), o.mergeVertices(), o
            }
            return l
        }(),
        Hc = function() {
            _inherits(o, Oi);
            var a = _createSuper(o);

            function o(e) {
                var t, y = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 12;
                _classCallCheck(this, o), (t = a.call(this)).type = "ShapeBufferGeometry", t.parameters = {
                    shapes: e,
                    curveSegments: y
                };
                var x = [],
                    b = [],
                    M = [],
                    w = [],
                    n = 0,
                    S = 0;
                if (!1 === Array.isArray(e)) i(e);
                else
                    for (var r = 0; r < e.length; r++) i(e[r]), t.addGroup(n, S, r), n += S, S = 0;

                function i(e) {
                    var t = b.length / 3,
                        e = e.extractPoints(y),
                        n = e.shape,
                        r = e.holes;
                    !1 === Ec.isClockWise(n) && (n = n.reverse());
                    for (var i = 0, a = r.length; i < a; i++) {
                        var o = r[i];
                        !0 === Ec.isClockWise(o) && (r[i] = o.reverse())
                    }
                    for (var s = Ec.triangulateShape(n, r), l = 0, c = r.length; l < c; l++) var u = r[l],
                        n = n.concat(u);
                    for (var d = 0, h = n.length; d < h; d++) {
                        var f = n[d];
                        b.push(f.x, f.y, 0), M.push(0, 0, 1), w.push(f.x, f.y)
                    }
                    for (var p = 0, m = s.length; p < m; p++) {
                        var v = s[p],
                            g = v[0] + t,
                            _ = v[1] + t,
                            v = v[2] + t;
                        x.push(g, _, v), S += 3
                    }
                }
                return t.setIndex(x), t.setAttribute("position", new hi(b, 3)), t.setAttribute("normal", new hi(M, 3)), t.setAttribute("uv", new hi(w, 2)), t
            }
            return _createClass(o, [{
                key: "toJSON",
                value: function() {
                    var e = Oi.prototype.toJSON.call(this);
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (var n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                t.shapes.push(i.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
            }]), o
        }();
    var Xc = function() {
        _inherits(i, ql);
        var r = _createSuper(i);

        function i(e, t) {
            var n;
            return _classCallCheck(this, i), (n = r.call(this)).type = "ShapeGeometry", "object" == typeof t && (console.warn("v3d.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), n.parameters = {
                shapes: e,
                curveSegments: t
            }, n.fromBufferGeometry(new Hc(e, t)), n.mergeVertices(), n
        }
        return _createClass(i, [{
            key: "toJSON",
            value: function() {
                var e = ql.prototype.toJSON.call(this);
                return function(e, t) {
                    if (t.shapes = [], Array.isArray(e))
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            t.shapes.push(i.uuid)
                        } else t.shapes.push(e.uuid);
                    return t
                }(this.parameters.shapes, e)
            }
        }]), i
    }();
    var Yc = function() {
            _inherits(P, Oi);
            var L = _createSuper(P);

            function P() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 8,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 6,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0,
                    a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI,
                    o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0,
                    s = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : Math.PI;
                _classCallCheck(this, P), (e = L.call(this)).type = "SphereBufferGeometry", e.parameters = {
                    radius: t,
                    widthSegments: n,
                    heightSegments: r,
                    phiStart: i,
                    phiLength: a,
                    thetaStart: o,
                    thetaLength: s
                }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
                for (var l = Math.min(o + s, Math.PI), c = 0, u = [], d = new Tn, h = new Tn, f = [], p = [], m = [], v = [], g = 0; g <= r; g++) {
                    var _ = [],
                        y = g / r,
                        x = 0;
                    0 == g && 0 == o ? x = .5 / n : g == r && l == Math.PI && (x = -.5 / n);
                    for (var b = 0; b <= n; b++) {
                        var M = b / n;
                        d.x = -t * Math.cos(i + M * a) * Math.sin(o + y * s), d.y = t * Math.cos(o + y * s), d.z = t * Math.sin(i + M * a) * Math.sin(o + y * s), p.push(d.x, d.y, d.z), h.copy(d).normalize(), m.push(h.x, h.y, h.z), v.push(M + x, 1 - y), _.push(c++)
                    }
                    u.push(_)
                }
                for (var w = 0; w < r; w++)
                    for (var S = 0; S < n; S++) {
                        var A = u[w][S + 1],
                            T = u[w][S],
                            E = u[w + 1][S],
                            C = u[w + 1][S + 1];
                        (0 !== w || 0 < o) && f.push(A, T, C), (w !== r - 1 || l < Math.PI) && f.push(T, E, C)
                    }
                return e.setIndex(f), e.setAttribute("position", new hi(p, 3)), e.setAttribute("normal", new hi(m, 3)), e.setAttribute("uv", new hi(v, 2)), e
            }
            return P
        }(),
        qc = function() {
            _inherits(c, ql);
            var l = _createSuper(c);

            function c(e, t, n, r, i, a, o) {
                var s;
                return _classCallCheck(this, c), (s = l.call(this)).type = "SphereGeometry", s.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: a,
                    thetaLength: o
                }, s.fromBufferGeometry(new Yc(e, t, n, r, i, a, o)), s.mergeVertices(), s
            }
            return c
        }(),
        Zc = function() {
            _inherits(i, nc);
            var r = _createSuper(i);

            function i() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, i);
                var n;
                return (n = r.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t)).type = "TetrahedronBufferGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n
            }
            return i
        }(),
        Qc = function() {
            _inherits(i, ql);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = r.call(this)).type = "TetrahedronGeometry", n.parameters = {
                    radius: e,
                    detail: t
                }, n.fromBufferGeometry(new Zc(e, t)), n.mergeVertices(), n
            }
            return i
        }(),
        Kc = function() {
            _inherits(a, Pc);
            var i = _createSuper(a);

            function a(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
                _classCallCheck(this, a);
                var r = n.font;
                if (!r || !r.isFont) return console.error("v3d.TextGeometry: font parameter is not an instance of v3d.Font."), _possibleConstructorReturn(t, new Oi);
                void 0 === n.alignX && (n.alignX = "left"), void 0 === n.alignY && (n.alignY = "topBaseline"), void 0 === n.lineHeight && (n.lineHeight = -1), void 0 === n.scaledEmSize && (n.scaledEmSize = !1);
                r = r.generateShapes(e, n.size, n.alignX, n.alignY, n.lineHeight, n.scaledEmSize);
                return n.depth = void 0 !== n.height ? n.height : 50, void 0 === n.bevelThickness && (n.bevelThickness = 10), void 0 === n.bevelSize && (n.bevelSize = 8), void 0 === n.bevelEnabled && (n.bevelEnabled = !1), (t = i.call(this, r, n)).type = "TextBufferGeometry", t.parameters = {
                    text: e,
                    parameters: n
                }, t
            }
            return _createClass(a, [{
                key: "cloneWithText",
                value: function(e) {
                    var t = this.parameters.parameters;
                    return new a(e, {
                        font: t.font,
                        size: t.size,
                        height: t.height,
                        curveSegments: t.curveSegments,
                        bevelEnabled: t.bevelEnabled,
                        bevelThickness: t.bevelThickness,
                        bevelSize: t.bevelSize,
                        alignX: t.alignX,
                        alignY: t.alignY,
                        lineHeight: t.lineHeight,
                        scaledEmSize: t.scaledEmSize
                    })
                }
            }]), a
        }(),
        Jc = function() {
            _inherits(i, ql);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = r.call(this)).type = "TextGeometry", n.parameters = {
                    text: e,
                    parameters: t
                }, n.fromBufferGeometry(new Kc(e, t)), n.mergeVertices(), n
            }
            return i
        }(),
        $c = function() {
            _inherits(S, Oi);
            var w = _createSuper(S);

            function S() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .4,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 8,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 6,
                    a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI;
                _classCallCheck(this, S), (e = w.call(this)).type = "TorusBufferGeometry", e.parameters = {
                    radius: t,
                    tube: n,
                    radialSegments: r,
                    tubularSegments: i,
                    arc: a
                }, r = Math.floor(r), i = Math.floor(i);
                for (var o = [], s = [], l = [], c = [], u = new Tn, d = new Tn, h = new Tn, f = 0; f <= r; f++)
                    for (var p = 0; p <= i; p++) {
                        var m = p / i * a,
                            v = f / r * Math.PI * 2;
                        d.x = (t + n * Math.cos(v)) * Math.cos(m), d.y = (t + n * Math.cos(v)) * Math.sin(m), d.z = n * Math.sin(v), s.push(d.x, d.y, d.z), u.x = t * Math.cos(m), u.y = t * Math.sin(m), h.subVectors(d, u).normalize(), l.push(h.x, h.y, h.z), c.push(p / i), c.push(f / r)
                    }
                for (var g = 1; g <= r; g++)
                    for (var _ = 1; _ <= i; _++) {
                        var y = (i + 1) * g + _ - 1,
                            x = (i + 1) * (g - 1) + _ - 1,
                            b = (i + 1) * (g - 1) + _,
                            M = (i + 1) * g + _;
                        o.push(y, x, M), o.push(x, b, M)
                    }
                return e.setIndex(o), e.setAttribute("position", new hi(s, 3)), e.setAttribute("normal", new hi(l, 3)), e.setAttribute("uv", new hi(c, 2)), e
            }
            return S
        }(),
        eu = function() {
            _inherits(s, ql);
            var o = _createSuper(s);

            function s(e, t, n, r, i) {
                var a;
                return _classCallCheck(this, s), (a = o.call(this)).type = "TorusGeometry", a.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, a.fromBufferGeometry(new $c(e, t, n, r, i)), a.mergeVertices(), a
            }
            return s
        }(),
        tu = function() {
            _inherits(R, Oi);
            var P = _createSuper(R);

            function R() {
                var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .4,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 64,
                    i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 8,
                    a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 2,
                    o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 3;
                _classCallCheck(this, R), (e = P.call(this)).type = "TorusKnotBufferGeometry", e.parameters = {
                    radius: t,
                    tube: n,
                    tubularSegments: r,
                    radialSegments: i,
                    p: a,
                    q: o
                }, r = Math.floor(r), i = Math.floor(i);
                for (var s = [], l = [], c = [], u = [], d = new Tn, h = new Tn, f = new Tn, p = new Tn, m = new Tn, v = new Tn, g = new Tn, _ = 0; _ <= r; ++_) {
                    var y = _ / r * a * Math.PI * 2;
                    L(y, a, o, t, f), L(.01 + y, a, o, t, p), v.subVectors(p, f), g.addVectors(p, f), m.crossVectors(v, g), g.crossVectors(m, v), m.normalize(), g.normalize();
                    for (var x = 0; x <= i; ++x) {
                        var b = x / i * Math.PI * 2,
                            M = -n * Math.cos(b),
                            b = n * Math.sin(b);
                        d.x = f.x + (M * g.x + b * m.x), d.y = f.y + (M * g.y + b * m.y), d.z = f.z + (M * g.z + b * m.z), l.push(d.x, d.y, d.z), h.subVectors(d, f).normalize(), c.push(h.x, h.y, h.z), u.push(_ / r), u.push(x / i)
                    }
                }
                for (var w = 1; w <= r; w++)
                    for (var S = 1; S <= i; S++) {
                        var A = (i + 1) * (w - 1) + (S - 1),
                            T = (i + 1) * w + (S - 1),
                            E = (i + 1) * w + S,
                            C = (i + 1) * (w - 1) + S;
                        s.push(A, T, C), s.push(T, E, C)
                    }

                function L(e, t, n, r, i) {
                    var a = Math.cos(e),
                        o = Math.sin(e),
                        t = n / t * e,
                        e = Math.cos(t);
                    i.x = r * (2 + e) * .5 * a, i.y = r * (2 + e) * o * .5, i.z = r * Math.sin(t) * .5
                }
                return e.setIndex(s), e.setAttribute("position", new hi(l, 3)), e.setAttribute("normal", new hi(c, 3)), e.setAttribute("uv", new hi(u, 2)), e
            }
            return R
        }(),
        nu = function() {
            _inherits(c, ql);
            var l = _createSuper(c);

            function c(e, t, n, r, i, a, o) {
                var s;
                return _classCallCheck(this, c), (s = l.call(this)).type = "TorusKnotGeometry", s.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: a
                }, void 0 !== o && console.warn("v3d.TorusKnotGeometry: heightScale has been deprecated. Use .scale(x, y, z) instead."), s.fromBufferGeometry(new tu(e, t, n, r, i, a)), s.mergeVertices(), s
            }
            return c
        }(),
        ru = function() {
            _inherits(g, Oi);
            var a = _createSuper(g);

            function g(o) {
                var e, s = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 64,
                    l = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                    c = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 8,
                    t = 4 < arguments.length && void 0 !== arguments[4] && arguments[4];
                _classCallCheck(this, g), (e = a.call(this)).type = "TubeBufferGeometry", e.parameters = {
                    path: o,
                    tubularSegments: s,
                    radius: l,
                    radialSegments: c,
                    closed: t
                };
                var u = o.computeFrenetFrames(s, t);
                e.tangents = u.tangents, e.normals = u.normals, e.binormals = u.binormals;
                var d = new Tn,
                    h = new Tn,
                    n = new vn,
                    f = new Tn,
                    p = [],
                    m = [],
                    r = [],
                    v = [];

                function i(e) {
                    f = o.getPointAt(e / s, f);
                    for (var t = u.normals[e], n = u.binormals[e], r = 0; r <= c; r++) {
                        var i = r / c * Math.PI * 2,
                            a = Math.sin(i),
                            i = -Math.cos(i);
                        h.x = i * t.x + a * n.x, h.y = i * t.y + a * n.y, h.z = i * t.z + a * n.z, h.normalize(), m.push(h.x, h.y, h.z), d.x = f.x + l * h.x, d.y = f.y + l * h.y, d.z = f.z + l * h.z, p.push(d.x, d.y, d.z)
                    }
                }
                return function() {
                    for (var e = 0; e < s; e++) i(e);
                    i(!1 === t ? s : 0),
                        function() {
                            for (var e = 0; e <= s; e++)
                                for (var t = 0; t <= c; t++) n.x = e / s, n.y = t / c, r.push(n.x, n.y)
                        }(),
                        function() {
                            for (var e = 1; e <= s; e++)
                                for (var t = 1; t <= c; t++) {
                                    var n = (c + 1) * (e - 1) + (t - 1),
                                        r = (c + 1) * e + (t - 1),
                                        i = (c + 1) * e + t,
                                        a = (c + 1) * (e - 1) + t;
                                    v.push(n, r, a), v.push(r, i, a)
                                }
                        }()
                }(), e.setIndex(v), e.setAttribute("position", new hi(p, 3)), e.setAttribute("normal", new hi(m, 3)), e.setAttribute("uv", new hi(r, 2)), e
            }
            return _createClass(g, [{
                key: "toJSON",
                value: function() {
                    var e = Oi.prototype.toJSON.call(this);
                    return e.path = this.parameters.path.toJSON(), e
                }
            }]), g
        }(),
        iu = function() {
            _inherits(l, ql);
            var s = _createSuper(l);

            function l(e, t, n, r, i, a) {
                var o;
                _classCallCheck(this, l), (o = s.call(this)).type = "TubeGeometry", o.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                }, void 0 !== a && console.warn("v3d.TubeGeometry: taper has been removed.");
                i = new ru(e, t, n, r, i);
                return o.tangents = i.tangents, o.normals = i.normals, o.binormals = i.binormals, o.fromBufferGeometry(i), o.mergeVertices(), o
            }
            return l
        }(),
        au = function() {
            _inherits(k, Oi);
            var F = _createSuper(k);

            function k(e) {
                var t;
                _classCallCheck(this, k), (t = F.call(this)).type = "WireframeGeometry";
                var n = [],
                    r = [0, 0],
                    i = {},
                    a = ["a", "b", "c"];
                if (e && e.isGeometry) {
                    for (var o, s = e.faces, l = 0, c = s.length; l < c; l++)
                        for (var u = s[l], d = 0; d < 3; d++) {
                            var h = u[a[d]],
                                f = u[a[(d + 1) % 3]];
                            r[0] = Math.min(h, f), r[1] = Math.max(h, f);
                            f = r[0] + "," + r[1];
                            void 0 === i[f] && (i[f] = {
                                index1: r[0],
                                index2: r[1]
                            })
                        }
                    for (o in i) {
                        var p = i[o],
                            m = e.vertices[p.index1];
                        n.push(m.x, m.y, m.z), m = e.vertices[p.index2], n.push(m.x, m.y, m.z)
                    }
                } else if (e && e.isBufferGeometry) {
                    var v = new Tn;
                    if (null !== e.index) {
                        var g = e.attributes.position,
                            _ = e.index,
                            y = e.groups;
                        0 === y.length && (y = [{
                            start: 0,
                            count: _.count,
                            materialIndex: 0
                        }]);
                        for (var x, b = 0, M = y.length; b < M; ++b)
                            for (var w = y[b], S = w.start, A = S, T = S + w.count; A < T; A += 3)
                                for (var E = 0; E < 3; E++) {
                                    var C = _.getX(A + E),
                                        L = _.getX(A + (E + 1) % 3);
                                    r[0] = Math.min(C, L), r[1] = Math.max(C, L);
                                    L = r[0] + "," + r[1];
                                    void 0 === i[L] && (i[L] = {
                                        index1: r[0],
                                        index2: r[1]
                                    })
                                }
                        for (x in i) {
                            var P = i[x];
                            v.fromBufferAttribute(g, P.index1), n.push(v.x, v.y, v.z), v.fromBufferAttribute(g, P.index2), n.push(v.x, v.y, v.z)
                        }
                    } else
                        for (var R = e.attributes.position, D = 0, O = R.count / 3; D < O; D++)
                            for (var N = 0; N < 3; N++) {
                                var I = 3 * D + N;
                                v.fromBufferAttribute(R, I), n.push(v.x, v.y, v.z);
                                I = 3 * D + (N + 1) % 3;
                                v.fromBufferAttribute(R, I), n.push(v.x, v.y, v.z)
                            }
                }
                return t.setAttribute("position", new hi(n, 3)), t
            }
            return k
        }();

    function ou(e, t, n, r, i) {
        e.computeBoundingBox();
        var a, o, s = r.split(/\r\n|\r|\n/).length,
            l = e.boundingBox.max.x - e.boundingBox.min.x,
            c = e.boundingBox.max.y - e.boundingBox.min.y,
            u = c / (s + s - 1);
        switch (t) {
            case "left":
                a = 0;
                break;
            case "center":
                a = -.5 * l;
                break;
            case "right":
                a = -l;
                break;
            default:
                o = 0
        }
        var d = u * Math.abs(i.data.descender) / i.data.ascender;
        switch (n) {
            case "topBaseline":
                o = 0;
                break;
            case "top":
                o = -u;
                break;
            case "center":
                o = 1 < s ? .5 * c - u : -.5 * u + .5 * d;
                break;
            case "bottom":
                o = c - u + d;
                break;
            case "bottomBaseline":
                o = 1 < s ? c - u - d : 0;
                break;
            default:
                o = 0
        }(0 < Math.abs(a) || 0 < Math.abs(o)) && e.translate(a, o, 0)
    }

    function su(e, t, n, r, i, a, o) {
        var s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27, 18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39, 30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12, 12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68, 27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77, 39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56, 56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104, 68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113, 77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154, 135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173, 173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193, 203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212, 203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218, 203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224, 203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209, 209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249, 218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258, 224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237, 265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113, 265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104, 265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95, 265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92],
            l = [1.4, 0, 2.4, 1.4, -.784, 2.4, .784, -1.4, 2.4, 0, -1.4, 2.4, 1.3375, 0, 2.53125, 1.3375, -.749, 2.53125, .749, -1.3375, 2.53125, 0, -1.3375, 2.53125, 1.4375, 0, 2.53125, 1.4375, -.805, 2.53125, .805, -1.4375, 2.53125, 0, -1.4375, 2.53125, 1.5, 0, 2.4, 1.5, -.84, 2.4, .84, -1.5, 2.4, 0, -1.5, 2.4, -.784, -1.4, 2.4, -1.4, -.784, 2.4, -1.4, 0, 2.4, -.749, -1.3375, 2.53125, -1.3375, -.749, 2.53125, -1.3375, 0, 2.53125, -.805, -1.4375, 2.53125, -1.4375, -.805, 2.53125, -1.4375, 0, 2.53125, -.84, -1.5, 2.4, -1.5, -.84, 2.4, -1.5, 0, 2.4, -1.4, .784, 2.4, -.784, 1.4, 2.4, 0, 1.4, 2.4, -1.3375, .749, 2.53125, -.749, 1.3375, 2.53125, 0, 1.3375, 2.53125, -1.4375, .805, 2.53125, -.805, 1.4375, 2.53125, 0, 1.4375, 2.53125, -1.5, .84, 2.4, -.84, 1.5, 2.4, 0, 1.5, 2.4, .784, 1.4, 2.4, 1.4, .784, 2.4, .749, 1.3375, 2.53125, 1.3375, .749, 2.53125, .805, 1.4375, 2.53125, 1.4375, .805, 2.53125, .84, 1.5, 2.4, 1.5, .84, 2.4, 1.75, 0, 1.875, 1.75, -.98, 1.875, .98, -1.75, 1.875, 0, -1.75, 1.875, 2, 0, 1.35, 2, -1.12, 1.35, 1.12, -2, 1.35, 0, -2, 1.35, 2, 0, .9, 2, -1.12, .9, 1.12, -2, .9, 0, -2, .9, -.98, -1.75, 1.875, -1.75, -.98, 1.875, -1.75, 0, 1.875, -1.12, -2, 1.35, -2, -1.12, 1.35, -2, 0, 1.35, -1.12, -2, .9, -2, -1.12, .9, -2, 0, .9, -1.75, .98, 1.875, -.98, 1.75, 1.875, 0, 1.75, 1.875, -2, 1.12, 1.35, -1.12, 2, 1.35, 0, 2, 1.35, -2, 1.12, .9, -1.12, 2, .9, 0, 2, .9, .98, 1.75, 1.875, 1.75, .98, 1.875, 1.12, 2, 1.35, 2, 1.12, 1.35, 1.12, 2, .9, 2, 1.12, .9, 2, 0, .45, 2, -1.12, .45, 1.12, -2, .45, 0, -2, .45, 1.5, 0, .225, 1.5, -.84, .225, .84, -1.5, .225, 0, -1.5, .225, 1.5, 0, .15, 1.5, -.84, .15, .84, -1.5, .15, 0, -1.5, .15, -1.12, -2, .45, -2, -1.12, .45, -2, 0, .45, -.84, -1.5, .225, -1.5, -.84, .225, -1.5, 0, .225, -.84, -1.5, .15, -1.5, -.84, .15, -1.5, 0, .15, -2, 1.12, .45, -1.12, 2, .45, 0, 2, .45, -1.5, .84, .225, -.84, 1.5, .225, 0, 1.5, .225, -1.5, .84, .15, -.84, 1.5, .15, 0, 1.5, .15, 1.12, 2, .45, 2, 1.12, .45, .84, 1.5, .225, 1.5, .84, .225, .84, 1.5, .15, 1.5, .84, .15, -1.6, 0, 2.025, -1.6, -.3, 2.025, -1.5, -.3, 2.25, -1.5, 0, 2.25, -2.3, 0, 2.025, -2.3, -.3, 2.025, -2.5, -.3, 2.25, -2.5, 0, 2.25, -2.7, 0, 2.025, -2.7, -.3, 2.025, -3, -.3, 2.25, -3, 0, 2.25, -2.7, 0, 1.8, -2.7, -.3, 1.8, -3, -.3, 1.8, -3, 0, 1.8, -1.5, .3, 2.25, -1.6, .3, 2.025, -2.5, .3, 2.25, -2.3, .3, 2.025, -3, .3, 2.25, -2.7, .3, 2.025, -3, .3, 1.8, -2.7, .3, 1.8, -2.7, 0, 1.575, -2.7, -.3, 1.575, -3, -.3, 1.35, -3, 0, 1.35, -2.5, 0, 1.125, -2.5, -.3, 1.125, -2.65, -.3, .9375, -2.65, 0, .9375, -2, -.3, .9, -1.9, -.3, .6, -1.9, 0, .6, -3, .3, 1.35, -2.7, .3, 1.575, -2.65, .3, .9375, -2.5, .3, 1.125, -1.9, .3, .6, -2, .3, .9, 1.7, 0, 1.425, 1.7, -.66, 1.425, 1.7, -.66, .6, 1.7, 0, .6, 2.6, 0, 1.425, 2.6, -.66, 1.425, 3.1, -.66, .825, 3.1, 0, .825, 2.3, 0, 2.1, 2.3, -.25, 2.1, 2.4, -.25, 2.025, 2.4, 0, 2.025, 2.7, 0, 2.4, 2.7, -.25, 2.4, 3.3, -.25, 2.4, 3.3, 0, 2.4, 1.7, .66, .6, 1.7, .66, 1.425, 3.1, .66, .825, 2.6, .66, 1.425, 2.4, .25, 2.025, 2.3, .25, 2.1, 3.3, .25, 2.4, 2.7, .25, 2.4, 2.8, 0, 2.475, 2.8, -.25, 2.475, 3.525, -.25, 2.49375, 3.525, 0, 2.49375, 2.9, 0, 2.475, 2.9, -.15, 2.475, 3.45, -.15, 2.5125, 3.45, 0, 2.5125, 2.8, 0, 2.4, 2.8, -.15, 2.4, 3.2, -.15, 2.4, 3.2, 0, 2.4, 3.525, .25, 2.49375, 2.8, .25, 2.475, 3.45, .15, 2.5125, 2.9, .15, 2.475, 3.2, .15, 2.4, 2.8, .15, 2.4, 0, 0, 3.15, .8, 0, 3.15, .8, -.45, 3.15, .45, -.8, 3.15, 0, -.8, 3.15, 0, 0, 2.85, .2, 0, 2.7, .2, -.112, 2.7, .112, -.2, 2.7, 0, -.2, 2.7, -.45, -.8, 3.15, -.8, -.45, 3.15, -.8, 0, 3.15, -.112, -.2, 2.7, -.2, -.112, 2.7, -.2, 0, 2.7, -.8, .45, 3.15, -.45, .8, 3.15, 0, .8, 3.15, -.2, .112, 2.7, -.112, .2, 2.7, 0, .2, 2.7, .45, .8, 3.15, .8, .45, 3.15, .112, .2, 2.7, .2, .112, 2.7, .4, 0, 2.55, .4, -.224, 2.55, .224, -.4, 2.55, 0, -.4, 2.55, 1.3, 0, 2.55, 1.3, -.728, 2.55, .728, -1.3, 2.55, 0, -1.3, 2.55, 1.3, 0, 2.4, 1.3, -.728, 2.4, .728, -1.3, 2.4, 0, -1.3, 2.4, -.224, -.4, 2.55, -.4, -.224, 2.55, -.4, 0, 2.55, -.728, -1.3, 2.55, -1.3, -.728, 2.55, -1.3, 0, 2.55, -.728, -1.3, 2.4, -1.3, -.728, 2.4, -1.3, 0, 2.4, -.4, .224, 2.55, -.224, .4, 2.55, 0, .4, 2.55, -1.3, .728, 2.55, -.728, 1.3, 2.55, 0, 1.3, 2.55, -1.3, .728, 2.4, -.728, 1.3, 2.4, 0, 1.3, 2.4, .224, .4, 2.55, .4, .224, 2.55, .728, 1.3, 2.55, 1.3, .728, 2.55, .728, 1.3, 2.4, 1.3, .728, 2.4, 0, 0, 0, 1.425, 0, 0, 1.425, .798, 0, .798, 1.425, 0, 0, 1.425, 0, 1.5, 0, .075, 1.5, .84, .075, .84, 1.5, .075, 0, 1.5, .075, -.798, 1.425, 0, -1.425, .798, 0, -1.425, 0, 0, -.84, 1.5, .075, -1.5, .84, .075, -1.5, 0, .075, -1.425, -.798, 0, -.798, -1.425, 0, 0, -1.425, 0, -1.5, -.84, .075, -.84, -1.5, .075, 0, -1.5, .075, .798, -1.425, 0, 1.425, -.798, 0, .84, -1.5, .075, 1.5, -.84, .075];
        Oi.call(this), e = e || 50, t = void 0 !== t ? Math.max(2, Math.floor(t) || 10) : 10, a = void 0 === a || a;
        var c = 3.15 * ((o = void 0 === o || o) ? 1 : 1.3) / 2,
            u = e / c,
            e = (n = void 0 === n || n) ? (8 * t - 4) * t : 0;
        e += (r = void 0 === r || r) ? (16 * t - 4) * t : 0, e += (i = void 0 === i || i) ? 40 * t * t : 0;
        var d = new Uint32Array(3 * e),
            e = n ? 4 : 0;
        e += r ? 8 : 0, e += i ? 20 : 0, e *= (t + 1) * (t + 1);
        var h = new Float32Array(3 * e),
            f = new Float32Array(3 * e),
            p = new Float32Array(2 * e),
            m = new nr;
        m.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);
        var v, g, _, y, x, b, M, w, S, A, T, E, C, L, P = [],
            R = [],
            D = [],
            O = [],
            N = [],
            I = [],
            F = [],
            k = [],
            B = [],
            z = new Tn,
            U = 0,
            V = 0,
            G = new Tn,
            j = new nr,
            W = new nr,
            H = new Mn,
            X = new Mn,
            Y = new Mn,
            q = new Mn,
            Z = new Tn,
            Q = new Tn,
            K = m.clone();
        K.transpose();
        for (var J = function(e, t, n) {
                return !(h[3 * e] === h[3 * t] && h[3 * e + 1] === h[3 * t + 1] && h[3 * e + 2] === h[3 * t + 2] || h[3 * e] === h[3 * n] && h[3 * e + 1] === h[3 * n + 1] && h[3 * e + 2] === h[3 * n + 2] || h[3 * t] === h[3 * n] && h[3 * t + 1] === h[3 * n + 1] && h[3 * t + 2] === h[3 * n + 2])
            }, $ = 0; $ < 3; $++) I[$] = new nr;
        for (var ee = n ? 32 : 28, te = t + 1, ne = 0, re = 0, ie = 0, ae = 0, oe = 0, se = i ? 0 : 20; se < ee; se++)
            if (r || se < 20 || 28 <= se) {
                for ($ = 0; $ < 3; $++) {
                    for (v = 0; v < 4; v++)
                        for (g = 0; g < 4; g++) P[4 * g + v] = l[3 * s[16 * se + 4 * v + g] + $], a && 20 <= se && se < 28 && 2 !== $ && (P[4 * g + v] *= 1.077), o || 2 !== $ || (P[4 * g + v] *= 1.3);
                    j.set(P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10], P[11], P[12], P[13], P[14], P[15]), W.multiplyMatrices(j, m), I[$].multiplyMatrices(K, W)
                }
                for (y = 0; y <= t; y++)
                    for (b = y / t, x = 0; x <= t; x++) {
                        for (M = x / t, A = 4, w = S = 1; A--;) R[A] = w, D[A] = S, w *= b, S *= M, 3 === A ? (O[A] = N[A] = 0, U = V = 1) : (O[A] = U * (3 - A), N[A] = V * (3 - A), U *= b, V *= M);
                        for (H.fromArray(R), X.fromArray(D), Y.fromArray(O), q.fromArray(N), $ = 0; $ < 3; $++)(_ = H.clone()).applyMatrix4(I[$]), F[$] = _.dot(X), (_ = Y.clone()).applyMatrix4(I[$]), k[$] = _.dot(X), (_ = H.clone()).applyMatrix4(I[$]), B[$] = _.dot(q);
                        Z.fromArray(k), Q.fromArray(B), z.crossVectors(Q, Z), z.normalize(), 0 === F[0] && 0 === F[1] ? G.set(0, F[2] > c ? 1 : -1, 0) : G.set(z.x, z.z, -z.y), h[re++] = u * F[0], h[re++] = u * (F[2] - c), h[re++] = -u * F[1], f[ie++] = G.x, f[ie++] = G.y, f[ie++] = G.z, p[ae++] = 1 - M, p[ae++] = 1 - b
                    }
                for (y = 0; y < t; y++)
                    for (x = 0; x < t; x++) L = (T = ne * te * te + y * te + x) + te, J(T, E = T + 1, C = E + te) && (d[oe++] = T, d[oe++] = E, d[oe++] = C), J(T, C, L) && (d[oe++] = T, d[oe++] = C, d[oe++] = L);
                ne++
            } this.setIndex(new ri(d, 1)), this.setAttribute("position", new ri(h, 3)), this.setAttribute("normal", new ri(f, 3)), this.setAttribute("uv", new ri(p, 2)), this.computeBoundingSphere()
    }
    var lu = function() {
            _inherits(i, Jc);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), ou(_assertThisInitialized(n = r.call(this, e, t)), t.alignX || "left", t.alignY || "bottom", e, t.font), n.type = "BlenderTextGeometry", n
            }
            return _createClass(i, [{
                key: "cloneWithText",
                value: function(e) {
                    var t = this.parameters.parameters;
                    return new i(e, {
                        font: t.font,
                        size: t.size,
                        height: t.height,
                        curveSegments: t.curveSegments,
                        bevelEnabled: t.bevelEnabled,
                        bevelThickness: t.bevelThickness,
                        bevelSize: t.bevelSize,
                        alignX: t.alignX,
                        alignY: t.alignY
                    })
                }
            }]), i
        }(),
        cu = function() {
            _inherits(i, Kc);
            var r = _createSuper(i);

            function i(e, t) {
                var n;
                return _classCallCheck(this, i), ou(_assertThisInitialized(n = r.call(this, e, t)), t.alignX || "left", t.alignY || "bottom", e, t.font), n.type = "BlenderTextBufferGeometry", n
            }
            return _createClass(i, [{
                key: "cloneWithText",
                value: function(e) {
                    var t = this.parameters.parameters;
                    return new i(e, {
                        font: t.font,
                        size: t.size,
                        height: t.height,
                        curveSegments: t.curveSegments,
                        bevelEnabled: t.bevelEnabled,
                        bevelThickness: t.bevelThickness,
                        bevelSize: t.bevelSize,
                        alignX: t.alignX,
                        alignY: t.alignY
                    })
                }
            }]), i
        }();
    (su.prototype = Object.create(Oi.prototype)).constructor = su;
    var uu = Object.freeze({
        __proto__: null,
        BoxGeometry: Zl,
        BoxBufferGeometry: ea,
        CircleGeometry: Kl,
        CircleBufferGeometry: Ql,
        ConeGeometry: ec,
        ConeBufferGeometry: tc,
        CylinderGeometry: $l,
        CylinderBufferGeometry: Jl,
        DodecahedronGeometry: ic,
        DodecahedronBufferGeometry: rc,
        EdgesGeometry: cc,
        ExtrudeGeometry: Dc,
        ExtrudeBufferGeometry: Pc,
        IcosahedronGeometry: Nc,
        IcosahedronBufferGeometry: Oc,
        LatheGeometry: Fc,
        LatheBufferGeometry: Ic,
        OctahedronGeometry: Bc,
        OctahedronBufferGeometry: kc,
        ParametricGeometry: Uc,
        ParametricBufferGeometry: zc,
        PlaneGeometry: Vc,
        PlaneBufferGeometry: ba,
        PolyhedronGeometry: Gc,
        PolyhedronBufferGeometry: nc,
        RingGeometry: Wc,
        RingBufferGeometry: jc,
        ShapeGeometry: Xc,
        ShapeBufferGeometry: Hc,
        SphereGeometry: qc,
        SphereBufferGeometry: Yc,
        TetrahedronGeometry: Qc,
        TetrahedronBufferGeometry: Zc,
        TextGeometry: Jc,
        TextBufferGeometry: Kc,
        TorusGeometry: eu,
        TorusBufferGeometry: $c,
        TorusKnotGeometry: nu,
        TorusKnotBufferGeometry: tu,
        TubeGeometry: iu,
        TubeBufferGeometry: ru,
        WireframeGeometry: au,
        BlenderTextGeometry: lu,
        BlenderTextBufferGeometry: cu,
        TeapotBufferGeometry: su
    });

    function du(e) {
        $r.call(this), this.type = "ShadowMaterial", this.color = new Qr(0), this.transparent = !0, this.setValues(e)
    }

    function hu(e) {
        oa.call(this, e), this.type = "RawShaderMaterial"
    }

    function fu(e) {
        $r.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Qr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jt, this.normalScale = new vn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e)
    }

    function pu(e) {
        fu.call(this), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new vn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
            get: function() {
                return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
            },
            set: function(e) {
                this.reflectivity = mn.clamp(2.5 * (e - 1) / (e + 1), 0, 1)
            }
        }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(e)
    }

    function mu(e) {
        $r.call(this), this.type = "MeshPhongMaterial", this.color = new Qr(16777215), this.specular = new Qr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jt, this.normalScale = new vn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = T, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function vu(e) {
        $r.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Qr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jt, this.normalScale = new vn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function gu(e) {
        $r.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jt, this.normalScale = new vn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function _u(e) {
        $r.call(this), this.type = "MeshLambertMaterial", this.color = new Qr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = T, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function yu(e) {
        $r.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Qr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Jt, this.normalScale = new vn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function xu(e) {
        Ml.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    function bu(e) {
        $r.call(this), this.type = "MeshMaskMaterial", this.skinning = !1, this.morphTargets = !1, this.side = oe, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.cameraNearFar = null, this.depthTexture = null, this.textureMatrix = null, this.setValues(e)
    }

    function Mu(e, t, n, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
    }

    function wu(e, t, n, r) {
        Mu.call(this, e, t, n, r)
    }((du.prototype = Object.create($r.prototype)).constructor = du).prototype.isShadowMaterial = !0, du.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, ((hu.prototype = Object.create(oa.prototype)).constructor = hu).prototype.isRawShaderMaterial = !0, ((fu.prototype = Object.create($r.prototype)).constructor = fu).prototype.isMeshStandardMaterial = !0, fu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this
    }, ((pu.prototype = Object.create(fu.prototype)).constructor = pu).prototype.isMeshPhysicalMaterial = !0, pu.prototype.copy = function(e) {
        return fu.prototype.copy.call(this, e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Qr).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this
    }, ((mu.prototype = Object.create($r.prototype)).constructor = mu).prototype.isMeshPhongMaterial = !0, mu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((vu.prototype = Object.create($r.prototype)).constructor = vu).prototype.isMeshToonMaterial = !0, vu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((gu.prototype = Object.create($r.prototype)).constructor = gu).prototype.isMeshNormalMaterial = !0, gu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((_u.prototype = Object.create($r.prototype)).constructor = _u).prototype.isMeshLambertMaterial = !0, _u.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((yu.prototype = Object.create($r.prototype)).constructor = yu).prototype.isMeshMatcapMaterial = !0, yu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((xu.prototype = Object.create(Ml.prototype)).constructor = xu).prototype.isLineDashedMaterial = !0, xu.prototype.copy = function(e) {
        return Ml.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }, ((bu.prototype = Object.create($r.prototype)).constructor = bu).prototype.isMeshMaskMaterial = !0, bu.prototype.copy = function(e) {
        return $r.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, e.cameraNearFar && (this.cameraNearFar = e.cameraNearFar.clone()), e.textureMatrix && (this.textureMatrix = e.textureMatrix.clone()), e.depthTexture && (this.depthTexture = e.depthTexture), this
    }, Object.assign(Mu.prototype, {
        evaluate: function(e) {
            var t, n = this.parameterPositions,
                r = this._cachedIndex,
                i = n[r],
                a = n[r - 1];
            e: {
                t: {
                    n: {
                        r: if (!(e < i)) {
                            for (var o = r + 2;;) {
                                if (void 0 === i) {
                                    if (e < a) break r;
                                    return r = n.length, this._cachedIndex = r, this.afterEnd_(r - 1, e, a)
                                }
                                if (r === o) break;
                                if (a = i, e < (i = n[++r])) break t
                            }
                            t = n.length;
                            break n
                        }if (a <= e) break e;
                        var s = n[1];e < s && (r = 2, a = s);
                        for (var l = r - 2;;) {
                            if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                            if (r === l) break;
                            if (i = a, (a = n[--r - 1]) <= e) break t
                        }
                        t = r,
                        r = 0
                    }
                    for (; r < t;) {
                        var c = r + t >>> 1;
                        e < n[c] ? t = c : r = 1 + c
                    }
                    if (i = n[r], void 0 === (a = n[r - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, e, i);
                    if (void 0 === i) return r = n.length,
                    this._cachedIndex = r,
                    this.afterEnd_(r - 1, a, e)
                }
                this._cachedIndex = r,
                this.intervalChanged_(r, a, i)
            }
            return this.interpolate_(r, a, e, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a) t[a] = n[i + a];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }), Object.assign(Mu.prototype, {
        beforeStart_: Mu.prototype.copySampleValue_,
        afterEnd_: Mu.prototype.copySampleValue_
    }), wu.prototype = Object.assign(Object.create(Mu.prototype), {
        constructor: wu,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    });
    var Su = {};
    ! function(c) {
        c.less = function(e, t, n) {
            return n(e, t) < 0
        }, c.exchange = function(e, t, n) {
            var r = e[t];
            e[t] = e[n], e[n] = r
        }, c.StackNode = function(e) {
            this.value = e, this.next = null
        };
        var e = function() {
            this.N = 0, this.first = null
        };

        function u(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [], this.edges = {};
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }

        function n(e, t, n) {
            this.v = e, this.w = t, this.weight = n
        }

        function t(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [];
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }
        e.prototype.push = function(e) {
            this.first = this._push(this.first, e)
        }, e.prototype._push = function(e, t) {
            if (null == e) return this.N++, new c.StackNode(t);
            var n = e;
            return this.N++, (e = new c.StackNode(t)).next = n, e
        }, e.prototype.pop = function() {
            if (null != this.first) {
                var e = this.first,
                    t = e.value;
                return this.first = e.next, this.N--, t
            }
        }, e.prototype.size = function() {
            return this.N
        }, e.prototype.isEmpty = function() {
            return 0 == this.N
        }, e.prototype.peep = function() {
            if (null != this.first) return this.first.value
        }, e.prototype.toArray = function() {
            for (var e = [], t = this.first; null != t;) e.push(t.value), t = t.next;
            return e
        }, c.Stack = e, c.QueueNode = function(e) {
            this.value = e, this.next = null
        }, (e = function() {
            this.first = null, this.last = null, this.N = 0
        }).prototype.enqueue = function(e) {
            var t = this.last;
            this.last = new c.QueueNode(e), null != t && (t.next = this.last), null == this.first && (this.first = this.last), this.N++
        }, e.prototype.dequeue = function() {
            if (null != this.first) {
                var e = this.first,
                    t = e.value;
                return this.first = e.next, null == this.first && (this.last = null), this.N--, t
            }
        }, e.prototype.size = function() {
            return this.N
        }, e.prototype.isEmpty = function() {
            return 0 == this.N
        }, e.prototype.toArray = function() {
            for (var e = [], t = this.first; null != t;) e.push(t.value), t = t.next;
            return e
        }, c.Queue = e, (e = function(e) {
            this.s = [], this.N = 0, e = e || function(e, t) {
                return e - t
            }, this.compare = e
        }).prototype.enqueue = function(e) {
            for (; this.s.lengh <= this.N + 1;) this.s.push(0);
            this.s[++this.N] = e, this.swim(this.N)
        }, e.prototype.swim = function(e) {
            for (; 1 < e;) {
                var t = Math.floor(e / 2);
                if (!c.less(this.s[e], this.s[t], this.compare)) break;
                c.exchange(this.s, e, t), e = t
            }
        }, e.prototype.delMin = function() {
            if (0 != this.N) {
                var e = this.s[1];
                return c.exchange(this.s, 1, this.N--), this.sink(1), e
            }
        }, e.prototype.sink = function(e) {
            for (; 2 * e <= this.N;) {
                var t = 2 * e;
                if (t < this.N && c.less(this.s[t + 1], this.s[t], this.compare) && t++, !c.less(this.s[t], this.s[e], this.compare)) break;
                c.exchange(this.s, t, e), e = t
            }
        }, e.prototype.size = function() {
            return this.N
        }, e.prototype.isEmpty = function() {
            return 0 == this.N
        }, c.MinPQ = e, (e = function(e) {
            this.id = [];
            for (var t = 0; t < e; ++t) this.id.push(t)
        }).prototype.union = function(e, t) {
            e = this.root(e), t = this.root(t);
            t != e && (this.id[t] = e)
        }, e.prototype.root = function(e) {
            for (; this.id[e] != e;) e = this.id[e];
            return e
        }, e.prototype.connected = function(e, t) {
            return this.root(e) == this.root(t)
        }, c.QuickUnion = e, (e = function(e, t) {
            this.keys = [], this.pq = [], this.qp = [];
            for (var n = 0; n <= e; ++n) this.keys.push(null), this.pq.push(0), this.qp.push(-1);
            this.N = 0, t = t || function(e, t) {
                return e - t
            }, this.compare = t
        }).prototype.insert = function(e, t) {
            this.keys[e] = t, this.pq[++this.N] = e, this.qp[e] = this.N, this.swim(this.N)
        }, e.prototype.decreaseKey = function(e, t) {
            c.less(t, this.keys[e], this.compare) && (this.keys[e] = t, this.swim(this.qp[e]))
        }, e.prototype.minKey = function() {
            return this.keys[this.pq[1]]
        }, e.prototype.min = function() {
            return this.pq[1]
        }, e.prototype.delMin = function() {
            var e = this.pq[1];
            return c.exchange(this.pq, 1, this.N), this.qp[this.pq[1]] = 1, this.qp[this.pq[this.N]] = -1, this.keys[this.pq[this.N]] = null, this.N--, this.sink(1), e
        }, e.prototype.swim = function(e) {
            for (; 1 < e;) {
                var t = Math.floor(e / 2);
                if (!c.less(this.keys[this.pq[e]], this.keys[this.pq[t]], this.compare)) break;
                c.exchange(this.pq, e, t), this.qp[this.pq[e]] = e, e = this.qp[this.pq[t]] = t
            }
        }, e.prototype.sink = function(e) {
            for (; 2 * e <= this.N;) {
                var t = 2 * e;
                if (t < this.N && c.less(this.keys[this.pq[t + 1]], this.keys[this.pq[t]], this.compare) && t++, !c.less(this.keys[this.pq[t]], this.keys[this.pq[e]], this.compare)) break;
                c.exchange(this.pq, e, t), this.qp[this.pq[e]] = e, e = this.qp[this.pq[t]] = t
            }
        }, e.prototype.containsIndex = function(e) {
            return -1 != this.qp[e]
        }, e.prototype.isEmpty = function() {
            return 0 == this.N
        }, e.prototype.size = function() {
            return this.N
        }, c.IndexMinPQ = e, c.LinkMapNode = function(e) {
            this.value = e, this.prev = null, this.next = null
        }, (e = function() {
            this.first = null, this.last = null, this.map = {}
        }).prototype.push = function(e, t) {
            this.map[t] = e, null === this.first ? this.first = e : (this.last.next = e).prev = this.last, this.last = e
        }, e.prototype.removeNodeByKey = function(e) {
            var t = this.map[e],
                n = t.prev,
                t = t.next;
            null !== n && null !== t ? (n.next = t).prev = n : null === n && null !== t ? (this.first = t).prev = null : null !== n && null === t ? (this.last = n).next = null : (this.first = null, this.last = null), delete this.map[e]
        }, c.LinkMap = e, (e = function(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [], this.edges = {};
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }).prototype.addNewEdge = function(e, t) {
            this.adjList[e].push(t), this.adjList[t].push(e);
            var n = t < e ? t + "_" + e : e + "_" + t;
            this.edges[n] = new c.Edge(e, t, 0)
        }, e.prototype.adj = function(e) {
            return this.adjList[e]
        }, e.prototype.node = function(e) {
            return this.nodeInfo[e]
        }, e.prototype.len = function() {
            return this.V
        }, e.prototype.edge = function(e, t) {
            t = t < e ? t + "_" + e : e + "_" + t;
            return t in this.edges ? this.edges[t] : null
        }, c.Graph = e, u.prototype.removeAll = function() {
            this.V = 0, this.adjList = [], this.nodeInfo = [], this.edges = {}
        }, u.prototype.addNode = function(e) {
            e = e || {}, this.V++, this.adjList.push([]), this.nodeInfo.push(e)
        }, u.prototype.addNewEdge = function(e, t) {
            this.adjList[e].push(t);
            var n = e + "_" + t,
                t = new c.Edge(e, t, 0);
            return this.edges[n] = t
        }, u.prototype.addEdge = function(e) {
            var t = e.v,
                n = e.w;
            this.adjList[t].push(n);
            n = t + "_" + n;
            this.edges[n] = e
        }, u.prototype.removeEdge = function(e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; r++) n[r] == t && (n.splice(r, 1), r--);
            e = e + "_" + t;
            e in this.edges && delete this.edges[e]
        }, u.prototype.edge = function(e, t) {
            t = e + "_" + t;
            return t in this.edges ? this.edges[t] : null
        }, u.prototype.adj = function(e) {
            return this.adjList[e]
        }, u.prototype.node = function(e) {
            return this.nodeInfo[e]
        }, u.prototype.nodeIndex = function(e) {
            for (var t = 0; t < this.V; ++t)
                if (this.nodeInfo[t] == e) return t;
            return -1
        }, u.prototype.reverse = function() {
            for (var e = new u(this.V), t = 0; t < this.V; ++t)
                for (var n = this.adjList[t], r = 0; r < n.length; ++r) {
                    var i = n[r];
                    e.addNewEdge(i, t)
                }
            return e
        }, u.prototype.len = function() {
            return this.V
        }, u.prototype.findInEdges = function(e) {
            for (var t = [], n = 0; n < this.V; n++)
                for (var r = this.adjList[n], i = 0; i < r.length; i++) r[i] == e && t.push(this.edge(n, e));
            return t
        }, u.prototype.findOutEdges = function(e) {
            for (var t = [], n = this.adjList[e], r = 0; r < n.length; r++) t.push(this.edge(e, n[r]));
            return t
        }, u.prototype.disconnect = function(e, t) {
            this.adjList[e].splice(0);
            for (var n = 0; n < this.V; n++) {
                for (var r = this.adjList[n], i = 0; i < r.length; i++) r[i] == e && (r.splice(i, 1), i--);
                var a = n + "_" + e;
                a in this.edges && delete this.edges[a], (a = e + "_" + n) in this.edges && delete this.edges[a]
            }
            if (t) {
                for (var o = new u(this.V - 1), n = 0; n < this.V; n++)
                    if (n != e)
                        for (r = this.adjList[n], i = 0; i < r.length; i++) {
                            var s = r[i],
                                l = e < n ? n - 1 : n,
                                c = e < s ? s - 1 : s,
                                s = this.edge(n, s).copy();
                            s.v = l, s.w = c, o.addEdge(s)
                        }
                this.V--, this.adjList = o.adjList, this.nodeInfo.splice(e, 1), this.edges = o.edges
            }
        }, u.prototype.insert = function(e, t, n) {
            for (var r = this.V, i = e.V, a = 0; a < i; a++) {
                this.adjList.push([]), this.nodeInfo.push(function(e) {
                    var t, n = {};
                    for (t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
                    return n
                }(e.nodeInfo[a]));
                for (var o = e.adjList[a], s = 0; s < o.length; s++) {
                    var l = o[s];
                    (c = e.edge(a, l).copy()).v += r, c.w += r, this.addEdge(c)
                }
            }
            this.V += i;
            for (s = 0; s < t.length; s++)(c = t[s].copy()).w += r, this.addEdge(c);
            for (var c, s = 0; s < n.length; s++)(c = n[s].copy()).v += r, this.addEdge(c)
        }, u.prototype.vis = function(e) {
            e = e || function(e, t) {
                return String(e)
            };
            for (var t = "digraph G {", n = 0; n < this.V; n++) {
                t += n + ' [label="' + e(n, this.nodeInfo[n]) + '"];';
                for (var r = this.adjList[n], i = 0; i < r.length; i++) t += n + " -> " + r[i] + ";"
            }
            t += "}", console.log(t)
        }, c.DiGraph = u, n.prototype.either = function() {
            return this.v
        }, n.prototype.other = function(e) {
            return e == this.v ? this.w : this.v
        }, n.prototype.from = function() {
            return this.v
        }, n.prototype.to = function() {
            return this.w
        }, n.prototype.copy = function() {
            var e, t = new n(0, 0, 0);
            for (e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
            return t
        }, c.Edge = n, t.prototype.adj = function(e) {
            return this.adjList[e]
        }, t.prototype.edge = function(e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r)
                if (n[r].other(e) == t) return n[r];
            return null
        }, t.prototype.node = function(e) {
            return this.nodeInfo[e]
        }, t.prototype.addNewEdge = function(e) {
            var t = e.either(),
                n = e.other(t);
            this.adjList[t].push(e), this.adjList[n].push(e)
        }, c.WeightedGraph = t, ((e = function(e) {
            t.call(this, e)
        }).prototype = Object.create(c.WeightedGraph.prototype)).addNewEdge = function(e) {
            var t = e.from();
            this.adjList[t].push(e)
        }, e.prototype.edge = function(e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r)
                if (n[r].other(e) == t) return n[r];
            return null
        }, e.prototype.toDiGraph = function() {
            for (var e = new c.DiGraph(this.V), t = 0; t < this.V; ++t)
                for (var n = this.adjList[t], r = 0; r < n.length; ++r) {
                    var i = n[r].other(t);
                    e.addNewEdge(t, i)
                }
            return e
        }, c.WeightedDiGraph = e, (e = function(e, t, n) {
            this.v = e, this.w = t, this.capacity = n, this.flow = 0
        }).prototype.residualCapacityTo = function(e) {
            return e == this.v ? this.flow : this.capacity - this.flow
        }, e.prototype.addResidualFlowTo = function(e, t) {
            e == this.v ? this.flow -= t : e == this.w && (this.flow += t)
        }, e.prototype.from = function() {
            return this.v
        }, e.prototype.to = function() {
            return this.w
        }, e.prototype.other = function(e) {
            return e == this.v ? this.w : this.v
        }, c.FlowEdge = e, (e = function(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [];
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }).prototype.node = function(e) {
            return this.nodeInfo[e]
        }, e.prototype.edge = function(e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r)
                if (n[r].other(e) == t) return n[r];
            return null
        }, e.prototype.addNewEdge = function(e) {
            var t = e.from();
            this.adjList[t].push(e);
            t = e.other(t);
            this.adjList[t].push(e)
        }, e.prototype.adj = function(e) {
            return this.adjList[e]
        }, c.FlowNetwork = e, (e = function(e, t) {
            this.s = t;
            var n = e.V;
            this.marked = [], this.edgeTo = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(-1);
            this.dfs(e, t)
        }).prototype.dfs = function(e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || (this.edgeTo[i] = t, this.dfs(e, i))
            }
        }, e.prototype.hasPathTo = function(e) {
            return this.marked[e]
        }, e.prototype.pathTo = function(e) {
            var t = new c.Stack;
            if (e == this.s) return [e];
            for (var n = e; n != this.s; n = this.edgeTo[n]) t.push(n);
            return t.push(this.s), t.toArray()
        }, c.DepthFirstSearch = e, (e = function(e, t) {
            var n = e.V;
            this.s = t;
            var r = new c.Queue;
            r.enqueue(t), this.marked = [], this.edgeTo = [];
            for (var i = 0; i < n; ++i) this.marked.push(!1), this.edgeTo.push(-1);
            for (; !r.isEmpty();) {
                i = r.dequeue();
                this.marked[i] = !0;
                for (var a = e.adj(i), o = 0; o < a.length; ++o) {
                    var s = a[o];
                    this.marked[s] || (this.edgeTo[s] = i, r.enqueue(s))
                }
            }
        }).prototype.hasPathTo = function(e) {
            return this.marked[e]
        }, e.prototype.pathTo = function(e) {
            var t = new c.Stack;
            if (e == this.s) return [e];
            for (var n = e; n != this.s; n = this.edgeTo[n]) t.push(n);
            return t.push(this.s), t.toArray()
        }, c.BreadthFirstSearch = e, (e = function(e) {
            this.count = 0;
            var t = e.V;
            this.marked = [], this.id = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.id.push(-1);
            for (n = 0; n < t; ++n) this.marked[n] || (this.dfs(e, n), this.count++)
        }).prototype.dfs = function(e, t) {
            this.marked[t] = !0, this.id[t] = this.count;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
        }, e.prototype.componentId = function(e) {
            return this.id[e]
        }, e.prototype.componentCount = function() {
            return this.count
        }, c.ConnectedComponents = e, (e = function(e) {
            this.postOrder = new c.Stack, this.marked = [];
            for (var t = e.V, n = 0; n < t; ++n) this.marked.push(!1);
            for (n = 0; n < t; ++n) this.marked[n] || this.dfs(e, n)
        }).prototype.dfs = function(e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
            this.postOrder.push(t)
        }, e.prototype.order = function() {
            return this.postOrder.toArray()
        }, c.TopologicalSort = e, (e = function(e) {
            var t = e.V;
            this.count = 0, this.marked = [], this.id = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.id.push(-1);
            for (var r = new c.TopologicalSort(e.reverse()).order(), i = 0; i < r.length; ++i) {
                n = r[i];
                this.marked[n] || (this.dfs(e, n), this.count++)
            }
        }).prototype.dfs = function(e, t) {
            this.marked[t] = !0, this.id[t] = this.count;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
        }, e.prototype.componentId = function(e) {
            return this.id[e]
        }, e.prototype.componentCount = function() {
            return this.count
        }, c.StronglyConnectedComponents = e, c.KruskalMST = function(e) {
            for (var t = e.V, n = new c.MinPQ(function(e, t) {
                    return e.weight - t.weight
                }), r = 0; r < e.V; ++r)
                for (var i = e.adj(r), a = 0; a < i.length; ++a)(s = i[a]).either() == r && n.enqueue(s);
            this.mst = [];
            for (var o = new c.QuickUnion(t); !n.isEmpty() && this.mst.length < t - 1;) {
                var s, r = (s = n.delMin()).either(),
                    l = s.other(r);
                o.connected(r, l) || (o.union(r, l), this.mst.push(s))
            }
        }, (e = function(e) {
            var t = e.V;
            this.marked = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1);
            for (this.pq = new c.MinPQ(function(e, t) {
                    return e.weight - t.weight
                }), this.mst = [], this.visit(e, 0); !this.pq.isEmpty() && this.mst.length < t - 1;) {
                var r = this.pq.delMin(),
                    n = r.either(),
                    i = r.other(n);
                this.marked[n] && this.marked[i] || (this.mst.push(r), this.marked[n] || this.visit(e, n), this.marked[i] || this.visit(e, i))
            }
        }).prototype.visit = function(e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i.other(t)] || this.pq.enqueue(i)
            }
        }, c.LazyPrimMST = e, (e = function(e) {
            var t = e.V;
            this.pq = new c.IndexMinPQ(t, function(e, t) {
                return e.weight - t.weight
            }), this.marked = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1);
            for (this.mst = [], this.visit(e, 0); !this.pq.isEmpty();) {
                var r = this.pq.minKey(),
                    i = this.pq.delMin();
                this.mst.push(r), this.marked[i] || this.visit(e, i)
            }
        }).prototype.visit = function(e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r],
                    a = i.other(t);
                this.marked[a] || (this.pq.containsIndex(a) ? this.pq.decreaseKey(a, i) : this.pq.insert(a, i))
            }
        }, c.EagerPrimMST = e, (e = function(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [], this.pq = new c.IndexMinPQ(n, function(e, t) {
                return t
            });
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            for (this.cost[t] = 0, this.pq.insert(t, this.cost[t]); !this.pq.isEmpty();) {
                r = this.pq.delMin();
                this.marked[r] = !0;
                for (var i = e.adj(r), a = 0; a < i.length; ++a) {
                    var o = i[a];
                    this.relax(o)
                }
            }
        }).prototype.relax = function(e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.edgeTo[n] = e, this.pq.containsIndex(n) ? this.pq.decreaseKey(n, this.cost[n]) : this.pq.insert(n, this.cost[n]))
        }, e.prototype.hasPathTo = function(e) {
            return this.marked[e]
        }, e.prototype.pathTo = function(e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, e.prototype.distanceTo = function(e) {
            return this.cost[e]
        }, c.Dijkstra = e, (e = function(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            this.cost[t] = 0, this.marked[t] = !0;
            for (var i = 0; i < n; ++i)
                for (r = 0; r < n; ++r)
                    for (var a = e.adj(r), o = 0; o < a.length; ++o) {
                        var s = a[o];
                        this.relax(s)
                    }
        }).prototype.relax = function(e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.marked[n] = !0, this.edgeTo[n] = e)
        }, e.prototype.hasPathTo = function(e) {
            return this.marked[e]
        }, e.prototype.pathTo = function(e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, e.prototype.distanceTo = function(e) {
            return this.cost[e]
        }, c.BellmanFord = e, (e = function(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            this.cost[t] = 0, this.marked[t] = !0;
            for (var i = new c.TopologicalSort(e.toDiGraph()).order(), a = 0; a < i.length; ++a)
                for (var r = i[a], o = e.adj(r), s = 0; s < o.length; ++s) {
                    var l = o[s];
                    this.relax(l)
                }
        }).prototype.relax = function(e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.marked[n] = !0, this.edgeTo[n] = e)
        }, e.prototype.hasPathTo = function(e) {
            return this.marked[e]
        }, e.prototype.pathTo = function(e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, e.prototype.distanceTo = function(e) {
            return this.cost[e]
        }, c.TopologicalSortShortestPaths = e, (e = function(e, t, n) {
            this.value = 0;
            e.V;
            var r = Number.MAX_VALUE;
            for (this.marked = null, this.edgeTo = null, this.s = t, this.t = n; this.hasAugmentedPath(e);) {
                for (var i = this.t; i != this.s; i = this.edgeTo[i].from()) r = Math.min(r, this.edgeTo[i].residualCapacityTo(i));
                for (i = this.t; i != this.s; i = this.edgeTo[i].from()) this.edgeTo[i].addResidualFlowTo(i, r);
                this.value += r
            }
        }).prototype.hasAugmentedPath = function(e) {
            var t = e.V;
            this.marked = [], this.edgeTo = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.edgeTo.push(null);
            var r = new c.Queue;
            for (r.enqueue(this.s), this.marked[this.s] = !0; !r.isEmpty();)
                for (var n = r.dequeue(), i = e.adj(n), a = 0; a < i.length; ++a) {
                    var o = i[a],
                        s = o.other(n);
                    if (!this.marked[s] && 0 < o.residualCapacityTo(s)) {
                        if (this.edgeTo[s] = o, this.marked[s] = !0, s == this.t) return !0;
                        r.enqueue(s)
                    }
                }
            return !1
        }, e.prototype.minCut = function(e) {
            for (var t = [], n = e.V, r = 0; r < n; ++r)
                for (var i = e.adj(r), a = 0; a < i.length; ++a) {
                    var o = i[a];
                    o.from() == r && 0 == o.residualCapacityTo(o.other(r)) && t.push(o)
                }
            return t
        }, c.FordFulkerson = e
    }(Su);
    var Au = [
            [-1.117001, -.1867262, -11.13505, 12.59865, -.03937339, 1.167571, .007100686, 3.592678, .6083296, -1.152006, -.1926669, 6.152049, -4.770802, -.08704701, .7483626, .03372718, 4.464592, .4036546, -1.072371, -.2696632, .2816168, 1.820571, -.3742666, 2.080607, -.07675295, -2.835366, 1.129329, -1.109935, -.1532764, 1.198787, -.9015183, .005173015, .5749178, .1075633, 4.387949, .2650413, -1.052297, -.2229452, 1.952347, .5727205, -4.88507, 1.984016, -.1106197, -.4898361, .8907873, -1.070108, -.1600465, 1.593886, -4479251e-11, -3.306541, .9390193, .09513168, 2.343583, .5335404, -1.113253, -.16996, -10.38822, 11.37513, -.04040911, 1.037455, .04991792, 4.801919, .630271, -1.135747, -.1678594, 4.970755, -4.43023, -.06657408, .3636161, .1558009, 6.01337, .3959601, -1.095892, -.2732595, .7666496, 1.350731, -.4401401, 2.470135, -.1707929, -3.260793, 1.170337, -1.073668, -.02603929, -.1944589, .4575207, .6878164, -.139077, .3690299, 7.885781, .1877694, -1.070091, -.2798957, 2.338478, -2.647221, -7.387808, 2.32921, -.1644639, -2.00371, .9874527, -1.06712, -.1418866, 1.25409, 6.053048, -2.918892, .5322812, .1613053, 3.018161, .527409, -1.129483, -.1890619, -9.065101, 9.659923, -.03607819, .8314359, .08181661, 4.768868, .6339777, -1.14642, -.1883579, 3.309173, -3.127882, -.06938176, .3987113, .1400581, 6.283042, .5267076, -1.128348, -.2641305, 1.223176, .05514952, -.3490649, 1.997784, -.04123709, -2.251251, .9483466, -1.02582, .0140469, -1.187406, 2.7299, .5877588, -.276114, .4602633, 8.305125, .3945001, -1.083957, -.2606679, 2.207108, -7.202803, -5.968103, 2.129455, -.07789512, -1.137688, .8871769, -1.062465, -.1512189, 1.042881, 14.27839, -4.242214, .40381, .199778, 2.814449, .5803196, -1.175099, -.2410789, -11.08587, 11.33404, -.018193, .6772942, .09605043, 4.231166, .6239972, -1.224207, -.2883527, 3.002206, -2.649612, -.04795418, .4984398, .03251434, 4.851611, .6551019, -1.136955, -.2423048, 1.058823, -.2489236, -.2462179, 1.93314, .09106828, -.1905869, .8171065, -1.014535, -.0082625, -1.448017, 2.295788, .3510334, -1.477418, .5432449, 5.762796, .4908751, -1.070666, -.237978, 1.844589, -5.442448, -4.012768, 2.945275, .009854725, .08455959, .814503, -1.071525, -.1777132, .807659, 9.925865, -3.324623, -.6367437, .2844581, 2.248384, .6544022, -1.218818, -.2952382, -13.45975, 13.47153, -.006814585, .5079068, .119723, 3.776949, .5836961, -1.409868, -.511433, 2.776539, -2.039001, -.02673769, .4145288, .0007829342, 2.275883, .6629691, -1.069151, -.09434247, .7293972, -1.222473, -.1533461, 2.160357, .04626837, 3.852415, .859357, -1.021306, -.1149551, -1.108414, 4.178343, .4013665, -2.222814, .6929462, 1.392652, .4401662, -1.074251, -.2224002, 1.372356, -8.858704, -3.92266, 3.020018, -.01458724, 1.511186, .8288064, -1.062048, -.1526582, .4921067, 14.85522, -3.229936, -.8426604, .3916243, 2.678994, .6689264, -1.257023, -.33647, -15.27795, 15.04223, .002717715, .302991, .1636851, 3.561663, .5283161, -1.635124, -.7329993, 3.523939, -2.566337, -.01902543, .5505483, -.06242176, 1.065992, .6654236, -.9295823, .04845834, -.299299, -.2001327, -.08019339, 1.807806, .09020277, 5.095372, .8639936, -1.09374, -.2148608, -.521624, 2.119777, .09506454, -1.831439, .6961204, .1102084, .4384319, -1.044181, -.1849257, .9071246, -4.648901, -2.279385, 2.356502, -.04169147, 1.932557, .829655, -1.061451, -.1458745, .2952267, 8.967214, -3.726228, -.5022316, .5684877, 3.102347, .6658443, -1.332391, -.4127769, -9.328643, 9.046194, .003457775, .3377425, .1530909, 3.301209, .4997917, -1.932002, -.9947777, -2.042329, 3.58694, -.05642182, .8130478, -.08195988, .1118294, .5617231, -.8707374, .1286999, 1.820054, -4.674706, .003317471, .5919018, .1975278, 6.686519, .9631727, -1.070378, -.3030579, -.9041938, 6.200201, .1232207, -.3650628, .5029403, -2.903162, .3811408, -1.063035, -.1637545, .5853072, -7.889906, -1.200641, 1.035018, .1192093, 3.267054, .8416151, -1.053655, -.1562286, .2423683, 11.28575, -4.363262, -.0731416, .5642088, 2.514023, .6670457, -1.366112, -.4718287, -7.876222, 7.7469, -.009182309, .4716076, .08320252, 3.165603, .5392334, -2.468204, -1.33634, -5.386723, 7.072672, -.08329266, .8636876, -.01978177, -.1326218, .2979222, -.9653522, -.02373416, 1.81025, -6.467262, .1410706, -.4753717, .3003095, 6.551163, 1.151083, -.8943186, -.2487152, -.230896, 8.512648, .1298402, 1.034705, .2303509, -3.924095, .2982717, -1.146999, -.2318784, .08992419, -9.933614, -.886092, -.03071656, .2852012, 3.046199, .8599001, -1.032399, -.1645145, .2683599, 13.27701, -4.40767, .07709869, .4951727, 1.957277, .6630943, -1.46907, -.6135092, -6.506263, 6.661315, -.03835383, .7150413, .007784318, 2.820577, .6756784, -2.501583, -1.247404, -15.23462, 16.33191, -.01204803, .5896471, -.02002023, 1.144647, .06177874, -2.438672, -1.127291, 5.731172, -10.2135, .0616561, -.7752641, .4708254, 4.176847, 1.200881, -.1513427, .09792731, -1.612349, 9.814289, .05188921, 1.716403, -.07039255, -2.815115, .3291874, -1.318511, -.3650554, .4221268, -9.294529, -.0439752, -.8100625, .3742719, 1.834166, .822345, -1.016009, -.1820264, .1278426, 11.82696, -4.801528, .4947899, .4660378, 1.601254, .6702359, -1.84131, -.9781779, -4.610903, 4.824662, -.05100806, .6463776, -6377724e-12, 2.216875, .861853, -2.376373, -1.108657, -14.89799, 15.46458, .04091025, .0976178, -.01048958, 2.165834, -.1609171, -4.710318, -2.261963, 6.947327, -10.34828, -.1325542, .7508674, .2247553, 2.873142, 1.2971, .216375, -.1944345, -2.43786, 10.11314, .44505, .3111492, .2751323, -1.627906, .2531213, -1.258794, -.3524641, .8425444, -10.85313, -1.154381, -.4638014, -.002781115, .4344498, .8507091, -1.018938, -.1804153, -.06354054, 15.7315, -4.386999, .6211115, .5294648, 1.580749, .6586655, -1.116416, -.1917524, -10.68233, 12.22221, -.03668978, 1.054022, .01592132, 3.180583, .562737, -1.132341, -.1671286, 5.976499, -4.227366, -.09542489, .8664938, .008351793, 4.876068, .4492779, -1.087635, -.3173679, .4314407, 1.100555, -.4410057, 1.677253, -.03005925, -4.201249, 1.070902, -1.083031, -.08847705, 1.291773, .4546776, .3091894, .726176, .04203659, 5.990615, .3704756, -1.057899, -.2246706, 2.329563, -1.219656, -5.33526, .8545378, -.03906209, -.9025499, .7797348, -1.073305, -.1522553, 1.767063, 1.90428, -3.101673, .3995856, .02905192, 2.563977, .5753067, -1.113674, -.1759694, -9.754125, 10.87391, -.03841093, .9524272, .05680219, 4.227034, .6029571, -1.126496, -.1680281, 5.332352, -4.575579, -.06761755, .3295335, .1194896, 5.570901, .4536185, -1.103074, -.2681801, .06571479, 2.396522, -.455128, 2.466331, -.1232022, -3.023201, 1.086379, -1.053299, -.02697173, .8379121, -.9681458, .5890692, -.4872027, .2936929, 7.510139, .3079122, -1.079553, -.2710448, 2.462379, -.3713554, -8.534512, 1.828242, -.1686398, -1.96134, .8941077, -1.069741, -.1396394, 1.657868, 3.236313, -2.706344, -.2948122, .1314816, 2.868457, .5413403, -1.131649, -.1954455, -7.751595, 8.685861, -.04910871, .8992952, .04710143, 4.254818, .6821116, -1.156689, -.1884324, 3.163519, -3.091522, -.06613927, -.02575883, .1640065, 6.073643, .4453468, -1.079224, -.2621389, .9446437, 1.448479, -.3969384, 2.626638, -.08101186, -3.016355, 1.076295, -1.080832, .01033057, -.3500156, -.03281419, .5655512, -1.156742, .453471, 8.774122, .2772869, -1.051202, -.2679975, 2.719109, -2.190316, -6.878798, 2.250481, -.2030252, -2.026527, .9701096, -1.089849, -.1598589, 1.564748, 6.869187, -3.05367, -.6110435, .1644472, 2.370452, .551177, -1.171419, -.2429746, -8.991334, 9.571216, -.02772861, .6688262, .07683478, 3.785611, .6347635, -1.228554, -.2917562, 2.753986, -2.49178, -.04663434, .3118303, .07546506, 4.463096, .5955071, -1.093124, -.2447767, .9097406, .5448296, -.2957824, 2.024167, -.0005152333, -1.069081, .9369565, -1.056994, .01569507, -.8217491, 1.870818, .706193, -1.483928, .5978206, 6.864902, .3673332, -1.054871, -.2758129, 2.712807, -5.95011, -6.554039, 2.447523, -.1895171, -1.454292, .9131738, -1.100218, -.1746241, 1.438505, 11.15481, -3.266076, -.8837357, .19701, 1.991595, .5907821, -1.207267, -.291361, -11.03767, 11.40724, -.014168, .5564047, .08476262, 3.371255, .6221335, -1.429698, -.5374218, 2.837524, -2.221936, -.02422337, .09313758, .0719025, 1.869022, .5609035, -1.002274, -.0697281, .4031308, -.3932997, -.1521923, 2.390646, -.0689399, 2.999661, 1.017843, -1.081168, -.1178666, -.496808, 3.919299, .6046866, -2.440615, .7891538, 2.140835, .274047, -1.050727, -.2307688, 2.276396, -9.454407, -5.505176, 2.99262, -.2450942, .6078372, .9606765, -1.103752, -.1810202, 1.375044, 15.89095, -3.438954, -1.265669, .2475172, 1.680768, .5978056, -1.244324, -.3378542, -11.11001, 11.37784, -.007896794, .4808023, .09249904, 3.025816, .5880239, -1.593165, -.7027621, 2.220896, -1.437709, -.01534738, .06286958, .06644555, 1.091727, .547008, -.9136506, .01344874, .7772636, -1.209396, -.1408978, 2.433718, -.1041938, 3.791244, 1.037916, -1.134968, -.1803315, -.9267335, 4.57667, .6851928, -2.805, .8687208, 1.161483, .2571688, -1.017037, -.2053943, 2.36164, -9.887818, -5.122889, 3.287088, -.2594102, .8578927, .959234, -1.118723, -.1934942, 1.226023, 16.7414, -3.277335, -1.629809, .2765232, 1.637713, .6113963, -1.314779, -.4119915, -12.4115, 12.41578, .002344284, .2980837, .1414613, 2.781731, .4998556, -1.926199, -1.020038, 2.5692, -1.081159, -.02266833, .3588668, .008750078, -.2452171, .4796758, -.7780002, .1850647, .04445456, -2.409297, -.07816346, 1.54679, -.02807227, 5.998176, 1.132396, -1.179326, -.357833, -.2392933, 6.467883, .5904596, -1.869975, .8045839, -2.498121, .1610633, -1.009956, -.1311896, 1.726577, -12.19356, -3.466239, 2.343602, -.2252205, 2.573681, 1.027109, -1.11246, -.2063093, 1.233051, 20.58946, -4.578074, -1.145643, .3160192, 1.420159, .5860212, -1.371689, -.4914196, -10.7661, 11.07405, -.01485077, .5936218, .03685482, 2.599968, .6002204, -2.436997, -1.377939, .02130141, 1.079593, -.01796232, -.03933248, .1610711, -.6901181, .1206416, -.8743368, .0733137, .8734259, -3.743126, -.03151167, 1.297596, -.07634926, 6.532873, 1.435737, -.9810197, -.3521634, -.2855205, 7.134674, .6839748, -1.394841, .6952036, -4.633104, -.02173401, -1.122958, -.1691536, 1.38236, -11.02913, -2.608171, 1.865111, -.1345154, 3.112342, 1.094134, -1.075586, -.2077415, 1.171477, 17.9327, -4.656858, -1.036839, .3338295, 1.042793, .5739374, -1.465871, -.6364486, -8.833718, 9.34365, -.032236, .7552848, -3121341e-12, 2.249164, .8094662, -2.448924, -1.270878, -4.823703, 5.853058, -.02149127, .03581132, -.001230276, .4892553, -.1597657, -2.419809, -1.071337, 1.575648, -4.98358, .009545185, .5032615, .4186266, 4.634147, 1.433517, -.1383278, -.02797095, -.1943067, 6.679623, .411828, -.2744289, -.02118722, -4.337025, .1505072, -1.341872, -.2518572, 1.027009, -6.527103, -1.081271, 1.015465, .2845789, 2.470371, .927812, -1.04064, -.2367454, 1.100744, 8.827253, -4.560794, -.7287017, .2842503, .6336593, .6327335, -1.877993, -1.025135, -4.311037, 4.715016, -.04711631, .6335844, -7665398e-12, 1.788017, .9001409, -2.28154, -1.137668, -10.36869, 11.36254, .01961739, -.09836174, -.006734567, 1.320918, -.2400807, -4.904054, -2.315781, 5.735999, -8.626257, -.1255643, 1.545446, .139686, 2.972897, 1.429934, .4077067, -.1833688, -2.450939, 9.119433, .4505361, -1.340828, .397369, -1.78537, .09628711, -1.296052, -.3250526, 1.813294, -10.31485, -1.38869, 1.239733, -.08989196, -.3389637, .963956, -1.062181, -.2423444, .7577592, 15.66938, -4.462264, -.574281, .3262259, .9461672, .6232887],
            [-1.127942, -.1905548, -12.52356, 13.75799, -.03624732, 1.055453, .01385036, 4.17697, .5928345, -1.15526, -.1778135, 6.216056, -5.254116, -.08787445, .8434621, .04025734, 6.195322, .3111856, -1.125624, -.3217593, .5043919, 1.686284, -.3536071, 1.476321, -.07899019, -4.522531, 1.271691, -1.081801, -.1033234, .999555, .007482946, -.06776018, 1.463141, .09492021, 5.612723, .1298846, -1.07532, -.2402711, 2.141284, -1.203359, -4.945188, 1.437221, -.0809675, -1.028378, 1.004164, -1.073337, -.1516517, 1.639379, 2.304669, -3.214244, 1.286245, .05613957, 2.480902, .4999363, -1.128399, -.1857793, -10.89863, 11.72984, -.03768099, .9439285, .04869335, 4.845114, .6119211, -1.114002, -.139928, 4.9638, -4.6855, -.07780879, .4049736, .1586297, 7.770264, .3449006, -1.185472, -.3403543, .6588322, 1.133713, -.4118674, 2.061191, -.1882768, -4.372586, 1.22353, -1.002272, .02000703, .07073269, 1.485075, .5005589, .4301494, .3626541, 7.921098, .1574766, -1.121006, -.3007777, 2.242051, -4.571561, -7.761071, 2.053404, -.1524018, -1.886162, 1.018208, -1.058864, -.1358673, 1.389667, 8.633409, -3.437249, .7295429, .15147, 2.842513, .5014325, -1.144464, -.2043799, -10.20188, 10.71247, -.03256693, .7860205, .06872719, 4.824771, .6259836, -1.170104, -.2118626, 4.391405, -4.1989, -.07111559, .3890442, .1024831, 6.282535, .5365688, -1.129171, -.255288, .2238298, .7314295, -.356273, 1.881931, -.03078716, -1.03912, .9096301, -1.042294, .004450203, -.5116033, 2.627589, .6098996, -.1264638, .4325281, 7.080503, .4583646, -1.082293, -.2723056, 2.065076, -8.143133, -7.892212, 2.142231, -.0710624, -1.122398, .8338505, -1.071715, -.1426568, 1.095351, 17.29783, -3.851931, .4360514, .211444, 2.970832, .5944389, -1.195909, -.2590449, -11.91037, 12.07947, -.01589842, .6297846, .09054772, 4.285959, .5933752, -1.245763, -.3316637, 4.29366, -3.694011, -.04699947, .4843684, .02130425, 4.097549, .6530809, -1.148742, -.1902509, -.2393233, -.2441254, -.2610918, 1.846988, .03532866, 2.660106, .8358294, -1.01608, -.0744496, -.5053436, 4.388855, .6054987, -1.2083, .5817215, 2.54357, .4726568, -1.072027, -.210144, 1.518378, -10.60119, -6.016546, 2.649475, -.05166992, 1.571269, .8344622, -1.072365, -.1511201, .747801, 19.00732, -3.950387, -.3473907, .3797211, 2.782949, .6296808, -1.239423, -.3136289, -13.511, 13.49468, -.007070423, .5012315, .1106008, 3.803619, .5577948, -1.452524, -.5676944, 2.993153, -2.277288, -.02168954, .305672, .01152338, 1.852697, .6427228, -1.061421, -.04590521, .6057022, -1.096835, -.1504952, 2.344921, -.05491832, 5.268322, .9082253, -1.042373, -.1769498, -1.075388, 3.831712, .315414, -2.416458, .7909032, -.01492892, .3854049, -1.064159, -.1892684, 1.438685, -8.166362, -3.616364, 3.275206, -.1203825, 2.039491, .8688057, -1.07012, -.1569508, .412476, 13.99683, -3.547085, -1.046326, .4973825, 2.791231, .6503286, -1.283579, -.3609518, -13.35397, 13.15248, -.0004431938, .3769526, .1429824, 3.573613, .4998696, -1.657952, -.7627948, 1.958222, -.7949816, -.02882837, .5356149, -.05191946, .8869955, .626332, -.95276, .06494189, .5361303, -2.12959, -.0925863, 1.604776, .0506777, 6.376055, .9138052, -1.080827, -.252312, -.7154262, 4.120085, .1878228, -1.492158, .6881655, -1.446611, .4040631, -1.054075, -.1665498, .9191052, -6.636943, -1.894826, 2.10781, -.03680499, 2.655452, .841384, -1.061127, -.1448849, .2667493, 10.34103, -4.285769, -.3874504, .5998752, 3.132426, .6652753, -1.347345, -.4287832, -9.305553, 9.133813, -.003173527, .3977564, .115142, 3.320564, .4998134, -1.927296, -.9901372, -2.593499, 4.087421, -.05833993, .8158929, -.04681279, .2423716, .4938052, -.9470092, .07325237, 2.064735, -5.16754, -.01313751, .4832169, .1126295, 6.970522, 1.035022, -1.022557, -.2762616, -.9375748, 6.696739, .2200765, -.1133253, .5492505, -3.109391, .3321914, -1.087444, -.1836263, .6225024, -8.576765, -1.107637, .7859427, .09910909, 3.112938, .8596261, -1.051544, -.1546262, .2371731, 12.00502, -4.527291, .07268862, .5571478, 2.532873, .6662, -1.375576, -.4840019, -8.12129, 8.05814, -.01445661, .5123314, .05813321, 3.203219, .5442318, -2.325221, -1.241463, -7.06343, 8.741369, -.0782995, .8844273, -.03471106, .1740583, .2814079, -1.2287, -.2013412, 2.949042, -7.371945, .1071753, -.249197, .2265223, 6.391504, 1.172389, -.7601786, -.1680631, -.7584444, 8.541356, .08222291, .6729633, .3206615, -3.70094, .2710054, -1.191166, -.2672347, .2927498, -9.713613, -.4783721, .2352803, .2161949, 2.691481, .8745447, -1.030135, -.1653301, .2263443, 12.96157, -4.650644, .007055709, .5091975, 2.00037, .6603839, -1.508018, -.6460933, -6.402745, 6.545995, -.0375032, .6921803, .003309819, 2.797527, .6978446, -2.333308, -1.167837, -17.46787, 18.6863, -.008948229, .5621946, -.03402626, 1.217943, .01149865, -2.665953, -1.226307, 7.169725, -11.59434, .0358342, -.3074378, .3412248, 4.422122, 1.283791, -.09705116, .08312991, -2.160462, 10.28235, .03543357, 1.032049, .105831, -2.972898, .2418628, -1.329617, -.3699557, .5560117, -9.730113, .09938865, -.3071488, .2510691, 1.777111, .8705142, -1.019387, -.1893247, .1194079, 12.39436, -4.799224, .2940213, .4841268, 1.529724, .6582615, -1.896737, -1.005442, -6.411032, 6.54822, -.03227596, .5717262, -8115192e-12, 2.296704, .9000749, -2.411116, -1.225587, -17.53629, 18.29393, .01247555, .2364616, -.005114637, 1.603778, -.2224156, -4.707121, -2.074977, 7.9423, -11.32407, -.05415654, .5446811, .1032493, 4.010235, 1.369802, .1010482, -.4013305, -2.674579, 9.779409, .1782506, .7053045, .4200002, -2.400671, .1953165, -1.243526, -.3391255, .8848882, -9.789025, -.3997324, -.9546227, -.1044017, .6010593, .8714462, -1.014633, -.1730009, -.07738934, 13.90903, -4.847307, 1.076059, .5685743, 1.572992, .6561432, -1.122998, -.1881183, -10.30709, 11.58932, -.04079495, .9603774, .03079436, 4.009235, .5060745, -1.13479, -.1539688, 5.478405, -4.21727, -.1043858, .7165008, .01524765, 6.473623, .4207882, -1.134957, -.3513318, .7393837, 1.354415, -.4764078, 1.690441, -.0549264, -5.563523, 1.145743, -1.058344, -.05758503, 1.16823, .3269824, .1795193, .7849011, .07441853, 6.904804, .281879, -1.075194, -.2355813, 2.463685, -1.536505, -7.505771, .9619712, -.06465851, -1.355492, .8489847, -1.07903, -.1465328, 1.773838, 2.310131, -3.136065, .3507952, .04435014, 2.819225, .5689008, -1.125833, -.1870849, -9.555833, 10.59713, -.04225402, .9164663, .04338796, 4.40098, .6056119, -1.12744, -.1551891, 4.755621, -4.408806, -.07851763, .2268284, .146007, 7.048003, .3525997, -1.143788, -.3170178, .5480669, 2.04183, -.4532139, 2.302233, -.1887419, -4.489221, 1.250967, -1.032849, .007376031, .5666073, -.2312203, .4862894, -.1748294, .357287, 8.380522, .1302333, -1.093728, -.2786977, 2.641272, -1.507494, -8.731243, 1.684055, -.2023377, -2.176398, 1.013249, -1.076578, -.1456205, 1.693935, 2.945003, -2.822673, -.2520033, .1517034, 2.649109, .5179094, -1.146417, -.2119353, -7.187525, 8.058599, -.05256438, .8375733, .03887093, 4.222111, .6695347, -1.173674, -.2067025, 2.899359, -2.804918, -.08473899, .003944225, .1340641, 6.160887, .4527141, -1.090098, -.2599633, .9180856, 1.09271, -.4215019, 2.42766, -.09277667, -2.123523, 1.058159, -1.08446, .008056181, -.245351, .6619567, .4668118, -.9526719, .4648454, 8.001572, .3054194, -1.053728, -.2765784, 2.792388, -3.489517, -8.150535, 2.195757, -.2017234, -2.128017, .9326589, -1.099348, -.1593939, 1.568292, 7.247853, -2.933, -.5890481, .172444, 2.433484, .5736558, -1.185983, -.2581184, -7.761056, 8.317053, -.03351773, .6676667, .05941733, 3.820727, .6324032, -1.268591, -.3398067, 2.348503, -2.023779, -.05368458, .1083282, .08402858, 3.910254, .5577481, -1.071353, -.1992459, .7878387, .1974702, -.3033058, 2.335298, -.08205259, .7954454, .9972312, -1.089513, -.03104364, -.5995746, 2.330281, .6581939, -1.821467, .6679973, 5.090195, .3125161, -1.040214, -.2570934, 2.660489, -6.506045, -7.053586, 2.763153, -.2433632, -.7648176, .9452937, -1.116052, -.1831993, 1.457694, 11.63608, -3.216426, -1.045594, .2285002, 1.817407, .5810396, -1.230134, -.3136264, -8.909301, 9.145006, -.01055387, .4467317, .1016826, 3.342964, .563384, -1.442907, -.5593147, 2.156447, -1.241657, -.0351213, .3050274, .01797175, 1.742358, .5977153, -1.027627, -.06481539, .4351975, -1.051677, -.2030672, 1.942684, -.03615993, 4.050266, .9801624, -1.08211, -.1578209, -.3397511, 4.163851, .6650368, -1.84173, .7062544, .6789881, .3172623, -1.047447, -.197756, 2.183364, -8.805249, -5.483962, 2.551309, -.177964, 1.519501, .9212536, -1.111853, -.1935736, 1.394408, 13.92405, -3.46543, -1.068432, .2388671, 1.455336, .6233425, -1.262238, -.3546341, -10.08703, 10.20084, -.001852187, .353758, .1239199, 3.056093, .5132052, -1.61381, -.7355585, 2.760123, -1.685253, -.02517552, .2914258, .004743448, .8689596, .5674192, -.9462336, .02950767, -.2613816, -.7398653, -.1315558, 1.901042, -.06447844, 4.969341, 1.027342, -1.111481, -.2194054, -.09004538, 3.983442, .4871278, -1.965315, .7956121, -.2363225, .2718037, -1.036397, -.1827106, 1.964747, -8.870759, -4.208011, 2.461215, -.2158905, 1.561676, .9436866, -1.113769, -.1947819, 1.30072, 15.16476, -4.088732, -1.069384, .2836434, 1.671451, .6229612, -1.328069, -.4244047, -8.41704, 8.552244, -.006813504, .4127422, .09619897, 2.854227, .505988, -1.927552, -1.02529, .9529576, .425595, -.03738779, .2584586, .04911004, -.2640913, .4138626, -.8488094, .1435988, .6356807, -2.895732, -.08473961, 1.701305, -.1323908, 6.499338, 1.210928, -1.128313, -.3397048, -.404314, 6.265097, .5482395, -2.057614, .8884087, -2.943879, .09760301, -1.039764, -.1494772, 1.781915, -11.53012, -3.379232, 2.517231, -.2764393, 2.588849, 1.05212, -1.108447, -.2012251, 1.19864, 19.25331, -4.423892, -1.257122, .339569, 1.48122, .5880175, -1.374185, -.4967434, -7.401318, 7.724021, -.02345723, .5979653, .02436346, 2.65897, .6014891, -2.310933, -1.29029, -1.301909, 2.557806, -.03744449, .08982861, .1090613, -.4398363, .1184329, -1.12473, -.0992183, 1.366902, -4.172489, -.05078016, 1.393597, -.09323843, 6.452721, 1.435913, -.8468477, -.2744819, -.43472, 6.713362, .6127133, -1.685634, .7360941, -4.535502, -.02920866, -1.165242, -.2008697, 1.438778, -10.08936, -2.214771, 2.102909, -.1763085, 2.859075, 1.09347, -1.074614, -.2066374, 1.131891, 16.30063, -4.801441, -1.11259, .3595785, 1.122227, .579461, -1.521515, -.6835604, -5.571044, 6.028774, -.04253715, .6875746, -5279456e-12, 2.18015, .8487705, -2.240415, -1.171166, -7.182771, 8.417068, -.01932866, .1101887, -.01098862, .6242195, -.2393875, -2.712354, -1.19883, 3.1802, -6.76813, -.002563386, .7984607, .2764376, 4.695358, 1.557045, -.03655172, -.02142321, -.913812, 7.932786, .3516542, -.7994343, .1786761, -4.208399, .01820576, -1.36861, -.2656212, 1.249397, -8.317818, -.8962772, 1.423249, .1478381, 2.19166, 1.007748, -1.041753, -.2453366, 1.061102, 11.30172, -4.739312, -.9223334, .2982776, .6162931, .6080302, -1.989159, -1.09516, -2.91555, 3.275339, -.05735765, .5742174, -7683288e-12, 1.7634, .9001342, -2.07002, -1.086338, -10.95898, 12.0696, .03780123, -.01774699, -.0005881348, 1.333819, -.2605423, -5.249653, -2.38304, 6.160406, -9.097138, -.1955319, 1.651785, .0006016463, 3.021824, 1.493574, .4685432, -.2358662, -2.666433, 9.685763, .5804928, -1.521875, .5668989, -1.548136, .01688642, -1.296891, -.3449031, 1.928548, -11.6756, -1.627615, 1.355603, -.1929074, -.6568952, 1.009774, -1.067288, -.2410392, .7147961, 17.8384, -4.374399, -.6588777, .3329831, 1.012066, .6118645],
            [-1.310023, -.4407658, -36.4034, 36.83292, -.008124762, .5297961, .01188633, 3.13832, .5134778, -1.4241, -.5501606, -17.5351, 18.22769, -.01539272, .6366826, .002661996, 2.659915, .4071138, -1.103436, -.1884105, 6.425322, -6.910579, -.02019861, .3553271, -.01589061, 5.345985, .8790218, -1.1862, -.4307514, -3.957947, 5.979352, -.05348869, 1.736117, .03491346, -2.692261, .5610506, -1.006038, -.1305995, 4.473513, -3.806719, .1419407, -.02148238, -.05081185, 3.735362, .535828, -1.078507, -.1633754, -3.812368, 4.3817, .02988122, 1.754224, .1472376, 3.722798, .4999157, -1.333582, -.4649908, -33.59528, 34.04375, -.009384242, .5587511, .00572631, 3.073145, .5425529, -1.562624, -.7107068, -14.7817, 15.59839, -.01462375, .5050133, .02516017, 1.604696, .2902403, -.8930158, .04068077, 1.373481, -2.342752, -.02098058, .6248686, -.05258363, 7.058214, 1.150373, -1.262823, -.4818353, 889261e-9, 1.92312, -.04979718, 1.040693, .1558103, -2.85248, .2420691, -.9968383, -.1200648, 1.324342, -.9430889, .1931098, .4436916, -.07320456, 4.215931, .7898019, -1.078185, -.1718192, -1.720191, 2.358918, .02765637, 1.260245, .2021941, 3.395483, .5173628, -1.353023, -.4813523, -31.0492, 31.40156, -.009510741, .554203, .008135471, 3.136646, .5215989, -1.624704, -.7990201, -21.67125, 22.46341, -.01163533, .5415746, .02618378, 1.139214, .3444357, -.798361, .1417476, 9.914841, -10.81503, -.01218845, .3411392, -.06137698, 7.445848, 1.18008, -1.266679, -.4288977, -5.818701, 6.986437, -.08180711, 1.397403, .2016916, -1.275731, .2592773, -1.009707, -.1537754, 3.496378, -3.013726, .242115, -.2831925, .03003395, 3.702862, .774632, -1.075646, -.1768747, -1.347762, 1.989004, .01375836, 1.76481, .1330018, 3.230864, .662621, -1.375269, -.5103569, -34.42661, 34.78703, -.008460009, .5408643, .004813323, 3.016078, .5062069, -1.821679, -.9766461, -19.26488, 19.97912, -.009822567, .3649556, .04316092, .893019, .4166527, -.6633542, .1997841, 2.395592, -3.117175, -.01080884, .8983814, -.1375825, 6.673463, 1.115663, -1.30324, -.3612712, .08292959, .3381364, -.06078648, .3229247, .3680987, .7046755, .3144924, -.9952598, -.2039076, .4026851, .2686684, .1640712, .5186341, -.0120552, 2.659613, .8030394, -1.098579, -.2151992, .6558198, -74369e-8, -.001421817, 1.073701, .1886875, 2.536857, .6673923, -1.457986, -.5906842, -38.12464, 38.38539, -.006024357, .4741484, .01209223, 2.818432, .5012433, -1.835728, -1.003405, -6.848129, 7.601943, -.01277375, .4785598, .03366853, 1.097701, .4636635, -.8491348, .009466365, -2.685226, 2.00406, -.01168708, .6752316, -.1543371, 5.674759, 1.039534, -1.083379, -.150679, .7328236, -.5095568, -.08609153, .444882, .4174662, 1.481556, .3942551, -1.117089, -.3337605, .2502281, .4036323, .2673899, .2829817, .0224245, 2.043207, .7706902, -1.071648, -.21262, .6069466, -.00145629, -.551596, 1.046755, .1985021, 2.290245, .6876058, -1.483903, -.6309647, -43.80213, 44.10537, -.005712161, .5195992, .002028428, 2.687114, .5098321, -2.053976, -1.141473, .5109183, .08060391, -.01033983, .4066532, .04869627, 1.161722, .4039525, -.6348185, .07651292, -10.31327, 10.07598, -.02083688, .7359516, -.2029459, 5.013257, 1.077649, -1.22863, -.1650496, .04077157, -.7189167, -.0509222, .2959814, .5111496, 2.540433, .361533, -1.041883, -.3278413, -.06691911, 1.307364, .2166663, .3000595, -.003157136, 1.389208, .7999026, -1.103556, -.2443602, .4705347, -.0009296482, -.530992, .9654511, .2142587, 2.244723, .6839976, -1.555684, -.6962113, -46.47983, 46.7427, -.005034895, .475509, -9.502561e-7, 2.626569, .5056194, -1.998288, -1.12472, -1.629586, 2.187993, -.008284384, .3845258, .0572624, 1.185644, .4255812, -1.03257, -.251385, -3.721112, 3.506967, -.02186561, .9436049, -.2451412, 4.725724, 1.039256, -.8597532, .09073332, -2.553741, 1.993237, -.04390891, -.2046928, .5515623, 1.909127, .3948212, -1.210482, -.4477622, -.2267805, 1.219488, .1336186, .6866897, .02808997, 1.600403, .7816409, -1.078168, -.2699261, .2537282, .3820684, -.4425103, .5298235, .2185217, 1.728679, .6882743, -1.697968, -.8391488, -57.90105, 58.1412, -.00340476, .426514, -1796301e-12, 2.368442, .5324429, -2.141552, -1.17223, 16.77872, -16.4147, -.005732425, .2002199, .06841834, 1.485338, .3215763, -1.442946, -.7264245, -9.503706, 9.650462, -.02120995, 1.419263, -.2893098, 3.860731, 1.120857, -.5696752, .3411279, -.2931035, -.6512552, -.1068437, -1.085661, .6107549, 1.459503, .3210336, -1.313839, -.5921371, -.2332222, 1.648196, .2492787, 1.381033, -.01993392, .981256, .8316329, -1.087464, -.3195534, .2902095, .3383709, -.8798482, .01494668, .2529703, 1.452644, .669387, -2.068582, -1.118605, -50.81598, 50.97486, -.003280669, .4067371, -2544951e-12, 2.179497, .5778017, -1.744693, -.8537207, 22.34361, -22.08318, -.005932616, .1035049, .05742772, 1.97788, .2124846, -3.287515, -2.140268, -12.49566, 12.40091, -.02409349, 1.397821, -.2371627, 2.771192, 1.170496, .5502311, 1.04663, 2.193517, -2.2204, -.1064394, -1.017926, .4795457, 1.030644, .3177516, -1.719734, -.9536198, -.6586821, 1.386361, -.02513065, 1.187011, .06542539, .5296055, .808266, -1.0057, -.3028096, .04470957, 1.00776, -.8119016, .03153338, .2311321, 1.182208, .6824758, -2.728867, -1.580388, -30.79627, 30.92586, -.004197673, .3154759, -3897675e-12, 1.920567, .6664791, -1.322495, -.7249275, 14.7766, -14.68154, -.009044857, .05624314, .06498392, 2.047389, .0636754, -6.102376, -3.473018, -9.926071, 9.637797, -.01097909, 1.103498, -.2424521, 2.520748, 1.24026, 1.351796, 1.018588, 2.009081, -1.333394, -.1979125, -.3318292, .4476624, .9095235, .2955611, -1.774467, -1.07988, -.0808468, .2577697, -.1149295, .4975303, .002931611, -.3803171, .8002794, -.9898401, -.2542513, -.07530911, 1.870355, -1.521918, .2405164, .2964615, 1.3348, .6789053, -1.27973, -.4290674, -42.77972, 43.43305, -.006541826, .4945086, .01425338, 2.685244, .5011313, -1.449506, -.5766374, -16.88496, 17.81118, -.01121649, .354502, .02287338, 1.904281, .4936998, -1.02198, -.1897574, 2.482462, -2.941725, -.01570448, .7532578, -.042568, 5.23966, .4983116, -1.162608, -.3428049, 3.974358, -1.527935, -.03919201, .8758593, .07291363, -3.455257, .8007426, -.9929985, -.08712006, -.7397313, 1.348372, .09511685, .3233584, -.07549148, 5.806452, .4990042, -1.084996, -.1739767, .1580475, .908818, .06871433, .5933079, .1188921, 3.074079, .4999327, -1.317009, -.4661946, -42.55347, 43.12782, -.005727235, .4285447, .02189854, 2.60831, .51907, -1.469236, -.6282139, -12.41404, 13.48765, -.0120477, .5070285, -.0007280216, 1.491533, .3635064, -.9713808, -.08138038, .3709854, -1.041174, -.01814075, .506086, -.02053756, 6.161431, 1.093736, -1.159057, -.3698074, 2.711209, -.6006479, -.04896926, .9273957, .1137712, -3.496828, .2867109, -1.011601, -.0820189, .2105725, .459752, .1478925, .213894, -.0566067, 6.057755, .7859121, -1.07802, -.181158, .1646622, .8348426, .1149064, .4985738, .1376605, 2.746607, .4999626, -1.325672, -.4769313, -41.11215, 41.68293, -.006274997, .4649469, .01119411, 2.631267, .5234546, -1.619391, -.8000253, -15.34098, 16.32706, -.01012023, .4242255, .02931597, .8925807, .3314765, -.7356979, .1368406, 2.972579, -3.535359, -.01318948, .460762, -.07182778, 6.2541, 1.236299, -1.316217, -.4194427, .03489902, 1.289849, -.0475596, 1.138222, .1975992, -.8991542, .2290572, -.9502188, -.1172703, 1.405202, -.3061919, .1058772, -.3760592, -.01983179, 3.562353, .7895959, -1.100117, -.1900567, .492503, .5250225, .1576804, 1.042701, .07330743, 2.796064, .6749783, -1.354183, -.5130625, -42.19268, 42.71772, -.005365373, .4136743, .01235172, 2.520122, .5187269, -1.741434, -.9589761, -8.230339, 9.296799, -.009600162, .4994969, .02955452, .3667099, .3526999, -.6917347, .2154887, -.8760264, .2334121, -.01909621, .4748033, -.1138514, 6.51536, 1.225097, -1.293189, -.42187, 1.620952, -.7858597, -.0376941, .6636786, .3364945, -.5341017, .2128347, -.9735521, -.1325495, 1.007517, .2598258, .06762169, .001421018, -.06915987, 3.185897, .8641956, -1.0948, -.1962062, .5755591, .2906259, .2625748, .7644049, .1347492, 2.677126, .646546, -1.393063, -.5578338, -41.85249, 42.33504, -.00543564, .4743765, .007422477, 2.442801, .5211707, -1.939487, -1.128509, -8.974257, 9.978383, -.007965597, .294883, .04436763, .2839868, .3440424, -.6011562, .2354877, -3.07982, 2.585094, -.02002701, .7793909, -.1598414, 5.834678, 1.202856, -1.315676, -.3903446, 1.7019, -1.304609, -.01045121, .2747707, .4143967, .3197102, .263758, -.9618628, -.1625841, 1.187138, .1497802, -5590954e-12, .03178475, -.04153145, 2.496096, .8195082, -1.111554, -.2365546, .7831875, .2018684, .2074369, .7395978, .122573, 1.876478, .6821167, -1.427879, -.5994879, -35.31016, 35.81581, -.006431497, .4554192, .0007348731, 2.334619, .5233377, -1.998177, -1.206633, -21.4651, 22.42237, -.005857596, .2755663, .06384795, .1358244, .3328437, -.644063, .2058571, 2.155499, -2.587968, -.01840023, .8826555, -.2222452, 5.847073, 1.228387, -1.229071, -.3360441, -.3429599, .6179469, .00202961, .08899319, .5041624, .1882964, .225204, -1.022905, -.2101621, 1.915689, -.6498794, -.03463651, .08954605, -.06797854, 2.417705, .8568618, -1.082538, -.2007723, .4731009, .4077267, .1324289, .651488, .1702912, 2.309383, .6600895, -1.472139, -.6499815, -34.28465, 34.69659, -.005747023, .4174167, .001688597, 2.323046, .5395191, -2.161176, -1.353089, -22.26827, 23.29138, -.005583808, .2364793, .06096656, .001944666, .2861624, -.6593044, .1393558, 4.698373, -5.193883, -.0199839, 1.095635, -.2391254, 5.598103, 1.236193, -1.195717, -.2972715, .04648953, .3024588, .005003313, -.3754741, .5247265, -.1381312, .2493896, -1.020139, -.2253524, .3548437, .7030485, -.02107076, .4581395, -.03243757, 2.453259, .8323623, -1.09877, -.243578, .8761614, .1941613, -.1990692, .3761139, .1657412, 1.590503, .6741417, -1.648007, -.8205121, -44.35106, 44.79801, -.004181353, .385483, -1842385e-12, 2.000281, .5518363, -2.140986, -1.282239, -3.979213, 4.672459, -.005008582, .242192, .06253602, .6612713, .2555851, -1.300502, -.5137898, .5179821, -.4032341, -.02066785, 1.087929, -.2615309, 4.225887, 1.229237, -.696334, .0924106, .06936356, -.3588571, -.05461843, -.5616643, .5484166, -.04776267, .2414935, -1.233179, -.4325498, .6479813, .8368356, .2458875, .6464752, -.02897097, 1.561773, .8518598, -1.051023, -.253369, 1.004294, .3028083, -1.520108, .1607013, .1619975, 1.131094, .6706655, -1.948249, -1.097383, -44.53697, 44.94902, -.003579939, .3491605, -2500253e-12, 1.740442, .6188022, -2.154253, -1.209559, 4.144894, -3.562411, -.005638843, .1067169, .07594858, 1.00528, .1072543, -2.513259, -1.507208, -1.602979, 1.404154, -.00556075, 1.24049, -.2852117, 3.485252, 1.349321, -.07832214, .3655626, .3856288, .6867894, -.1609523, -.6704306, .5357301, -.6457935, .1479503, -1.354784, -.5454375, .8797469, -1.466514, .713442, .5934903, -.02911178, .8643737, .9030724, -1.048324, -.2738736, .8783074, 3.246188, -4.435369, .1251791, .1783486, 1.064657, .6522878, -2.770408, -1.618911, -25.04031, 25.31674, -.004239279, .3241013, -3764484e-12, 1.586843, .7035906, -1.9135, -1.144014, -10.80587, 11.53677, -.01003197, .1577515, .05217789, 1.225278, .005172771, -5.293208, -2.876463, 2.087053, -3.201552, .003892964, .532393, -.2034512, 2.61776, 1.273597, .906034, .3773409, -.6399945, 3.213979, -.09112172, .6494055, .395328, .5047796, .2998695, -1.482179, -.677831, 1.161775, -3.004872, .4774797, -.4969248, -.003512074, -1.30719, .7927378, -.9863181, -.1803364, .5810824, 4.58057, -3.863454, .5328174, .2272821, 1.771114, .6791814]
        ],
        Tu = [
            [1.560219, 1.417388, 1.206927, 10.91949, 5.931416, 7.304788, 1.533049, 1.560532, .3685059, 13.5504, 5.543711, 7.792189, 1.471043, 1.746088, -.9299697, 17.20362, 5.473384, 8.336416, 1.355991, 2.109348, -3.295855, 22.64843, 5.454607, 9.304656, 1.244963, 2.547533, -5.841485, 27.56879, 5.576104, 10.43287, 1.175532, 2.784634, -7.212225, 29.75347, 6.47298, 10.92331, 1.082973, 3.118094, -8.934293, 31.86879, 8.473885, 11.74019, .96925, 3.349574, -10.0381, 31.47654, 13.38931, 12.72547, .8547044, 3.151538, -9.095567, 25.54995, 22.73219, 14.10398, .758034, 2.311153, -5.170814, 12.29669, 36.86529, 15.98882, 1.664273, 1.574468, 1.422078, 9.768247, 14.47338, 16.44988, 1.638295, 1.719586, .5786675, 12.39846, 14.15419, 17.28605, 1.572623, 1.921559, -.7714802, 16.09246, 14.20954, 18.25908, 1.468395, 2.21197, -2.845869, 20.75027, 15.24822, 19.37622, 1.355047, 2.556469, -4.96092, 24.60237, 16.4836, 20.65648, 1.291642, 2.742036, -6.061967, 26.02002, 18.19144, 21.16712, 1.194565, 2.97212, -7.295779, 26.91805, 21.2488, 22.01819, 1.083631, 3.047021, -7.766096, 24.96261, 27.44264, 22.91875, .9707994, 2.736459, -6.308284, 17.6086, 37.76291, 23.9215, .8574294, 1.865155, -2.364707, 4.337793, 50.92831, 25.23432],
            [1.632341, 1.39523, 1.375634, 12.38193, 5.921102, 7.766508, 1.597115, 1.554617, .3932382, 15.05284, 5.725234, 8.158155, 1.522034, 1.844545, -1.322862, 19.18382, 5.440769, 8.837119, 1.403048, 2.290852, -4.013792, 24.851, 5.521888, 9.845547, 1.286364, 2.774498, -6.648221, 29.64151, 5.923777, 10.97075, 1.213544, 3.040195, -8.092676, 31.86082, 6.789782, 11.58899, 1.122622, 3.347465, -9.649016, 33.43824, 9.347715, 12.31374, 1.007356, 3.543858, -10.5352, 32.39842, 14.83962, 13.31718, .8956642, 3.2787, -9.254933, 25.57923, 24.89677, 14.76166, .7985143, 2.340404, -4.928274, 11.41787, 39.61501, 16.82448, 1.745162, 1.639467, 1.342721, 11.66033, 14.90124, 17.74031, 1.708439, 1.819144, .2834399, 14.48066, 14.59214, 18.58679, 1.63172, 2.094799, -1.378825, 18.43198, 14.63173, 19.62881, 1.516536, 2.438729, -3.624121, 22.98621, 15.99782, 20.70027, 1.405863, 2.785191, -5.705236, 26.45121, 17.6833, 21.91903, 1.344052, 2.951807, -6.683851, 27.44271, 19.85706, 22.29452, 1.245827, 3.182923, -7.82296, 27.91395, 23.27254, 23.1591, 1.132305, 3.202593, -8.008429, 25.21093, 30.00014, 24.05306, 1.02033, 2.820556, -6.238704, 17.09276, 40.77916, 25.09949, .903157, 1.863917, -1.955738, 3.032665, 54.3429, 26.4178],
            [1.168084, 2.156455, -3.980314, 19.89302, 13.28335, 14.35621, 1.135488, 2.294701, -4.585886, 20.90208, 13.4784, 14.67658, 1.107408, 2.382765, -5.112357, 21.47823, 14.93128, 14.60882, 1.054193, 2.592891, -6.115, 22.68967, 16.35672, 15.18999, 1.006946, 2.70542, -6.69893, 22.9183, 18.34324, 15.70651, .9794044, 2.74244, -6.805283, 22.25271, 20.50797, 15.6313, .9413577, 2.722009, -6.760707, 20.98242, 23.42588, 16.05011, .8917923, 2.59278, -6.152635, 17.74141, 28.58324, 16.5791, .8288391, 2.153434, -4.118327, 10.78118, 36.8171, 17.38139, .7623528, 1.418187, -.8845235, .7590129, 46.29859, 19.21657, 1.352858, 2.048862, -2.053393, 14.05874, 30.45344, 30.4443, 1.330497, 2.126497, -2.466296, 14.67559, 30.90738, 30.69707, 1.286344, 2.200436, -2.877228, 14.92701, 32.36288, 30.77223, 1.234428, 2.289628, -3.404699, 14.99436, 34.6839, 30.84842, 1.17866, 2.306071, -3.549159, 14.11006, 37.54188, 30.7973, 1.151366, 2.333005, -3.728627, 13.63374, 39.05894, 30.92599, 1.101593, 2.299422, -3.565787, 11.96745, 41.88472, 31.02755, 1.038322, 2.083539, -2.649585, 8.037389, 47.00869, 30.65948, .9596146, 1.67147, -.8751538, 1.679772, 53.45784, 30.5452, .8640731, .9858301, 1.854956, -6.798097, 59.36468, 31.10255]
        ],
        Eu = {
            getTableValue: function(e, t, n, r, i) {
                return Au[e][540 * t + 54 * (n - 1) + 9 * r + i]
            },
            getTableValueRad: function(e, t, n, r) {
                return Tu[e][60 * t + 6 * (n - 1) + r]
            }
        };

    function Cu(e, r, i, a, o) {
        return Pu(e).reduce(function(e, t, n) {
            return e + t * Eu.getTableValue(r, i, a, n, o)
        }, 0)
    }

    function Lu(e, r, i, a) {
        return Pu(e).reduce(function(e, t, n) {
            return e + t * Eu.getTableValueRad(r, i, a, n)
        }, 0)
    }

    function Pu(e) {
        e = Math.pow(2 * e / Math.PI, 1 / 3);
        return [Math.pow(1 - e, 5), 5 * Math.pow(1 - e, 4) * e, 10 * Math.pow(1 - e, 3) * Math.pow(e, 2), 10 * Math.pow(1 - e, 2) * Math.pow(e, 3), 5 * (1 - e) * Math.pow(e, 4), Math.pow(e, 5)]
    }
    var Ru = {
        getDistParams: function(e, t, n, r) {
            for (var i = new Array(9), a = Math.trunc(e), o = e - a, s = 0; s < 9; s++) {
                var l = Cu(n, r, 0, a, s),
                    c = Cu(n, r, 1, a, s);
                i[s] = (1 - t) * (1 - o) * l + t * (1 - o) * c, 10 != a && (l = Cu(n, r, 0, a + 1, s), c = Cu(n, r, 1, a + 1, s), i[s] += (1 - t) * o * l + t * o * c)
            }
            return i
        },
        getRadiance: function(e, t, n, r) {
            var i = Math.trunc(e),
                a = e - i,
                e = (1 - t) * (1 - a) * Lu(n, r, 0, i) + t * (1 - a) * Lu(n, r, 1, i);
            return 10 != i && (e += (1 - t) * a * Lu(n, r, 0, i + 1) + t * a * Lu(n, r, 1, i + 1)), e
        }
    };

    function Du(e, t, n, r) {
        Mu.call(this, e, t, n, r)
    }
    Du.prototype = Object.assign(Object.create(Mu.prototype), {
        constructor: Du,
        interpolate_: function(e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (r - t), u = 1 - c, d = 0; d !== o; ++d) i[d] = a[l + d] * u + a[s + d] * c;
            return i
        }
    });
    var Ou = [
            [.1787, -1.463, -.3554, .4275, -.0227, 5.3251, .1206, -2.5771, -.067, .3703],
            [-.0193, -.2592, -.0665, 8e-4, -4e-4, .2125, -.0641, -.8989, -.0033, .0452],
            [-.0167, -.2608, -.095, .0092, -.0079, .2102, -.0441, -1.6537, -.0109, .0529]
        ],
        Nu = [
            [4.0453, -4.971, -.2155, 2.4192],
            [.00166, -.00375, .00209, 0, -.02903, .06377, -.03202, .00394, .11693, -.21196, .06052, .25886],
            [.00275, -.0061, .00317, 0, -.04214, .0897, -.04153, .00516, .15346, -.26756, .0667, .26688]
        ],
        Iu = function(e, t, n) {
            return Ou[e][2 * t + n]
        },
        Fu = function(e) {
            return Nu[e]
        };

    function ku(e, t, n) {
        return (1 + e[0] * Math.exp(e[1] / Math.cos(t))) * (1 + e[2] * Math.exp(e[3] * n) + e[4] * Math.pow(Math.cos(n), 2))
    }
    var Bu = {
            getDistParams: function(e, t) {
                for (var n = new Array(5), r = 0; r < 5; r++) n[r] = Iu(t, r, 0) * e + Iu(t, r, 1);
                return n
            },
            getZenithParams: function(e, t, n) {
                switch (n) {
                    case 0:
                        var r = Fu(n),
                            i = new Mn(r[0], r[1], r[2], r[3]),
                            a = Math.tan((4 / 9 - e / 120) * (Math.PI - 2 * t)),
                            o = new Mn(e * a, a, e, 1);
                        return .06 * i.dot(o) / ku(this.getDistParams(e, n), 0, t);
                    case 1:
                    case 2:
                        var r = Fu(n),
                            s = Math.pow(t, 2),
                            l = Math.pow(t, 3),
                            a = r[0] * l + r[1] * s + r[2] * t + r[3],
                            o = r[4] * l + r[5] * s + r[6] * t + r[7],
                            r = r[8] * l + r[9] * s + r[10] * t + r[11],
                            i = new Tn(a, o, r);
                        return new Tn(Math.pow(e, 2), e, 1).dot(i) / ku(this.getDistParams(e, n), 0, t)
                }
            },
            getSunIlluminance: function(e, t) {
                var n = [0, 0, 0];
                if (e[1] < 0) return n;
                for (var r, i = [.605, .54, .445], a = [12.25, 7.5, .3], o = .04608 * t - .04586, s = 1 / (e[1] + .15 * Math.pow(93.885 - Math.acos(e[1]) * (180 / Math.PI), -1.253)), l = [1.05513096, .993359745, .903543472], c = 0; c < 3; c++) {
                    var u = Math.exp(.008735 * -s * Math.pow(i[c], -4.08)),
                        d = Math.exp(-s * o * Math.pow(i[c], -1.3)),
                        h = Math.exp(.0035 * -a[c] * s);
                    n[c] = 128e3 * l[c] / (.212671 * (r = l[c]) + .71516 * r + .072169 * r), n[c] *= u * d * h
                }
                return n
            },
            getSunIntegral: function(e, t, n, r) {
                var i = e,
                    e = t,
                    t = n;

                function a(e) {
                    return e * e
                }
                n = 1 - cos(i), e = ((a(Math.PI) - 2 * a(i - e)) * cos(i) - a(Math.PI) * cos(e)) / (2 * (i - e + Math.PI) * (-i + e + Math.PI)), t = t * ((.0892351 - .00247875 * a(t)) * sin(t) + cube(t) + 24 * t + .029745 * t * cos(t)) / a(a(t) + 36);
                return 2 * Math.PI * (n + e + r * t)
            }
        },
        zu = function() {
            function r() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return _classCallCheck(this, r), this.radius = e, this.phi = t, this.theta = n, this
            }
            return _createClass(r, [{
                key: "set",
                value: function(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
            }, {
                key: "makeSafe",
                value: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
            }, {
                key: "setFromVector3",
                value: function(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
            }, {
                key: "setFromCartesianCoords",
                value: function(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(mn.clamp(t / this.radius, -1, 1))), this
                }
            }]), r
        }(),
        Uu = 2,
        Vu = 10,
        Gu = 12,
        ju = 21,
        Wu = 20,
        Hu = 6,
        Xu = 8,
        Yu = 0,
        qu = 5,
        Zu = 2,
        Qu = 8,
        Ku = 9,
        Ju = 10,
        $u = 18,
        ed = 21,
        td = 22,
        nd = 0,
        rd = 1,
        id = 3,
        ad = 1,
        od = 1,
        sd = 0,
        ld = 0,
        cd = 0,
        ud = 3,
        dd = 8,
        hd = 15,
        fd = 25,
        pd = 18,
        md = 256,
        vd = 512,
        gd = {
            BEVEL_BL: 1,
            BSDF_DIFFUSE_BL: 2,
            BSDF_GLASS_BL: 3,
            BSDF_GLOSSY_BL: 2,
            BSDF_PRINCIPLED_BL: 20,
            "BSDF_PRINCIPLED_<2.91.0_BL": 19,
            BSDF_REFRACTION_BL: 3,
            BSDF_TRANSLUCENT_BL: 1,
            BUMP_BL: 5,
            "BUMP_<2.81_BL": 3,
            EEVEE_SPECULAR_BL: 5,
            FRESNEL_BL: 1,
            LAYER_WEIGHT_BL: 1,
            STANDARD_SURFACE_MY: 24,
            SAMPLER_INFO_MY: 0,
            LAMBERT_MY: 5,
            BLINN_MY: 5,
            PHONG_MY: 5,
            PHONG_E_MY: 5
        };

    function _d(e) {
        $r.call(this);
        var t, n, ae = this;

        function _(e, t) {
            for (var n = e.node(t), r = (n.originData.type, 0); r < n.originData.inputs.length; r++) x(e, t, n.originData, r)
        }

        function x(e, t, n, r, i) {
            if (!de(e, t, r)) {
                i = i || "Input " + r;
                var a = n.inputs[r],
                    o = {
                        name: n.name + " " + i,
                        type: "",
                        inputs: [],
                        outputs: []
                    };
                switch (be(a)) {
                    case "float":
                        o.type = "VALUE" + n.type.slice(-3), o.outputs.push(a);
                        break;
                    case "vec3":
                        o.type = "RGB" + n.type.slice(-3);
                        var s = a.slice();
                        s.push(1), o.outputs.push(s);
                        break;
                    case "vec4":
                        o.type = "RGB" + n.type.slice(-3), o.outputs.push(a);
                        break;
                    default:
                        throw new Error("Unsupported group input")
                }
                e.addNode({
                    originData: o
                });
                t = new Su.Edge(e.len() - 1, t, 0);
                t.connections = [];
                r = {
                    from: 0,
                    to: r
                };
                return t.connections.push(r), e.addEdge(t), 1
            }
        }

        function b(e, t) {
            for (var n = 0; n < e.len(); n++)
                if (e.node(n).originData.type == t) return n;
            return -1
        }

        function oe(e, t) {
            Array.isArray(t) || (t = [t]);
            for (var n = 0, r = 0; r < e.len(); r++)
                for (var i = e.node(r), a = 0; a < t.length; a++) {
                    var o = t[a];
                    i.originData.type == o && n++
                }
            return n
        }

        function M(e, t, n) {
            for (var r = 0; r < e.length; r++) {
                var i = e[r];
                if (i.from() == t && i.to() == n) return i
            }
            return null
        }

        function w(e) {
            return !(!S(e) && "FALLOFF_MX" != e)
        }

        function S(e) {
            return "BITMAP_ENV_MX" == e || "REFLECT_REFRACT_MX" == e
        }

        function se(e, t) {
            switch (e) {
                case "BITMAP_ENV_MX":
                    return t == qu;
                case "FALLOFF_MX":
                    return t == Zu;
                case "MATERIAL_MX":
                    return t == Qu;
                case "PHYSICAL_MX":
                    return t == ed || t == td;
                case "REFLECT_REFRACT_MX":
                    return t == nd;
                default:
                    return !1
            }
        }

        function A(e) {
            return -1 < e.type.indexOf("uniform")
        }

        function T(e) {
            return -1 < e.type.indexOf("varying")
        }

        function le(e, t) {
            return t = _i(t) ? t : "color", ae.nodeVCAliases[e] || t
        }

        function ce(e, t, n, r) {
            r = new ha(e, t, 1, n, r, xn.DEFAULT_MAPPING, V, V, Ue, Ue);
            return r.needsUpdate = !0, r
        }

        function ue(e) {
            switch (e) {
                case Gt:
                    return "1";
                case jt:
                    return "2";
                default:
                    return "0"
            }
        }

        function r(e) {
            for (var t = 0, n = 0, r = 0, i = 0, a = 0; a < e.len(); a++) {
                var o = (Q = (Z = e.node(a)).originData).type;
                Z.attributes = [], Z.params = [], Z.inputFactors = [], Z.inputs = [], Z.outputs = [], _i(Q.inputFactors) && (Z.inputFactors = Q.inputFactors.slice(0));
                for (var s, l = 0; l < Q.outputs.length; l++) {
                    var c = Q.outputs[l],
                        c = Q.outputTypes ? Q.outputTypes[l] : be(c);
                    Z.outputs.push({
                        name: o.toLowerCase() + "_out" + l + "_n" + a,
                        type: c,
                        clamp: !1,
                        normalize: !1
                    })
                }
                switch ("OUTPUT_MATERIAL_BL" != o && "OUTPUT_WORLD_BL" != o && "OUTPUT_MX" != o && "OUTPUT_MY" != o && "SHADING_ENGINE_MY" != o && ("AI_SKYDOME_LIGHT_MY" != o || _i(Q.texture)) || Z.outputs.push({
                        name: "outgoingLight",
                        type: "",
                        clamp: !1,
                        normalize: !1
                    }), o) {
                    case "ATTRIBUTE_BL":
                        (q = le(Q.colorLayer, "")) ? (g = ye(q, 4), Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g)) : Z.params.push(_e("vec4(0.0, 0.0, 0.0, 1.0)"));
                        break;
                    case "BSDF_DIFFUSE_BL":
                    case "BSDF_GLASS_BL":
                    case "BSDF_GLOSSY_BL":
                        Z.params.push(_e("geometryNormal"));
                        break;
                    case "BSDF_PRINCIPLED_BL":
                        Z.params.push(_e("geometryNormal")), (0 < Q.inputs[Gu] || de(e, a, Gu)) && (ae.defines.CLEARCOAT = ""), (0 < Q.inputs[Vu] || de(e, a, Vu)) && (ae.defines.USE_SHEEN = "");
                        break;
                    case "BSDF_REFRACTION_BL":
                        Z.params.push(_e("geometryNormal")), Z.params.push(_e("BSDF_REFRACTION_" + Q.distribution));
                        break;
                    case "BUMP_BL":
                        Z.params.push(pe(Q.invert));
                        break;
                    case "CAMERA_BL":
                        Z.params.push(_e("vViewPosition")), 0 < oe(e, "OUTPUT_MATERIAL_BL") || 0 < oe(e, "OUTPUT_WORLD_BL") ? Z.params.push(_e("1")) : Z.params.push(_e("0"));
                        break;
                    case "CURVE_RGB_BL":
                    case "CURVE_VEC_BL":
                        L = ae.useFloatTex ? (C = new Float32Array(4 * md), 1) : (C = new Uint8Array(4 * md), 255);
                        for (var u, d, h, f, p = Q.curveData.length / md, l = 0; l < md; l++) f = 3 < p ? (u = L * Q.curveData[p * l], d = L * Q.curveData[p * l + 1], h = L * Q.curveData[p * l + 2], L * Q.curveData[p * l + 3]) : (u = L * (Q.curveData[p * l] / 2 + .5), d = L * (Q.curveData[p * l + 1] / 2 + .5), h = L * (Q.curveData[p * l + 2] / 2 + .5), L), C[4 * l] = mn.clamp(u, 0, L), C[4 * l + 1] = mn.clamp(d, 0, L), C[4 * l + 2] = mn.clamp(h, 0, L), C[4 * l + 3] = mn.clamp(f, 0, L);
                        var m = ce(C, md, Qe, ae.useFloatTex ? Xe : je),
                            v = _d.nodeTexUniName(o, t);
                        ae.nodeTextures[v] = m, Z.params.push(me(o, t)), t++;
                        break;
                    case "EEVEE_SPECULAR_BL":
                        Z.params.push(_e("geometryNormal")), (0 < Q.inputs[Hu] || de(e, a, Hu)) && (ae.defines.CLEARCOAT = "");
                        break;
                    case "FRESNEL_BL":
                    case "LAYER_WEIGHT_BL":
                        Z.params.push(_e("vViewPosition"));
                        break;
                    case "GRADIENT_RAMP_MX":
                        L = ae.useFloatTex ? (C = new Float32Array(4 * vd), 1) : (C = new Uint8Array(4 * vd), 255);
                        for (l = 0; l < vd; l++) u = L * Q.gradientData[3 * l], d = L * Q.gradientData[3 * l + 1], h = L * Q.gradientData[3 * l + 2], f = 1, C[4 * l] = mn.clamp(u, 0, L), C[4 * l + 1] = mn.clamp(d, 0, L), C[4 * l + 2] = mn.clamp(h, 0, L), C[4 * l + 3] = mn.clamp(f, 0, L);
                        m = ce(C, vd, Qe, ae.useFloatTex ? Xe : je), v = _d.nodeTexUniName(o, t);
                        ae.nodeTextures[v] = m, Z.params.push(me(o, t)), t++, Z.params.push(_e(we("int", Q.gradientType)));
                        var g = ye(q = Q.uvIndex ? "uv" + String(Q.uvIndex + 1) : "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g), Z.params.push(_e("geometryNormal")), Z.params.push(_e("vViewPosition")), -1 < ["SPHERICAL_ENVIRONMENT", "CYLINDRICAL_ENVIRONMENT", "SHRINK_WRAP_ENVIRONMENT", "SCREEN"].indexOf(Q.mapping) ? Z.params.push(_e("MAPPING_EXPLICIT_MAP_CHANNEL")) : Z.params.push(_e("MAPPING_" + Q.mapping)), Z.params.push(_e("AXIS_" + Q.axis));
                        var _ = we("ivec2", [xe(Q.clampToEdgeNoExtend[0]), xe(Q.clampToEdgeNoExtend[1])]);
                        Z.params.push(_e(_));
                        break;
                    case "MAPPING_BL":
                        if (Q.rotation) {
                            var y = new nr,
                                x = new ur;
                            switch (x.set(Q.rotation[0], Q.rotation[1], Q.rotation[2], "ZYX"), y.makeRotationFromEuler(x), y.scale((new Tn).fromArray(Q.scale)), Q.vectorType) {
                                case "TEXTURE":
                                    y.setPosition((new Tn).fromArray(Q.translation)), y.invert();
                                    break;
                                case "POINT":
                                    y.setPosition((new Tn).fromArray(Q.translation));
                                    break;
                                case "VECTOR":
                                    break;
                                case "NORMAL":
                                    Z.outputs[0].normalize = !0, y.invert(), y.transpose();
                                    break;
                                default:
                                    throw new Error("v3d.MeshNodeMaterial: Unknown MAPPING vector type")
                            }
                            Z.params.push(pe(y.toArray())), Z.params.push(pe(Q.min)), Z.params.push(pe(Q.max)), Z.params.push(pe(Q.useMin)), Z.params.push(pe(Q.useMax))
                        } else Z.params.push(_e("NODE_MAPPING_" + Q.vectorType));
                        break;
                    case "MAP_RANGE_BL":
                        Z.params.push(_e("NODE_MAP_RANGE_INTERP_LINEAR")), Z.params.push(_e(Q.clamp ? "1" : "0"));
                        break;
                    case "NEW_GEOMETRY_BL":
                        Z.params.push(_e("FRONT_FACING_VALUE")), Z.params.push(_e("vViewPosition")), Z.params.push(_e("normal")), he(e, a, Uu) && (ae.needsBoundingBox = !0);
                        break;
                    case "NORMAL_MAP_BL":
                        var g = ye(q = "tangent", 4);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g), Z.params.push(_e("vNormal"));
                        break;
                    case "TANGENT_BL":
                        "RADIAL" === Q.directionType ? (Z.params.push(_e("TANGENT_AXIS_" + Q.axis)), Z.params.push(_e("vViewPosition")), Z.params.push(_e("normal")), ae.needsBoundingBox = !0) : "UV_MAP" === Q.directionType && (g = ye(q = "tangent", 4), Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g));
                        break;
                    case "TEX_COORD_BL":
                        Z.params.push(_e("nodeTexCoordObjectMatrices[".concat(r, "]"))), Z.params.push(_e("vViewPosition")), Z.params.push(_e("normal"));
                        var g = ye(q = "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g), he(e, a, Yu) && (ae.needsBoundingBox = !0), ae.nodeTexCoordObject.push(null), ae.nodeTexCoordObjectMap[Q.name] = r, r++;
                        break;
                    case "TEX_ENVIRONMENT_BL":
                    case "TEX_ENVIRONMENT_MX":
                    case "TEX_IMAGE_BL":
                        var b = me(o, Q.texture);
                        Z.params.push(b);
                        var M, w = ae.nodeTextures[b.name].encoding;
                        Z.params.push(_e(ue(w))), "TEX_ENVIRONMENT_BL" == o ? (M = Q.projection, Z.params.push(_e("TEX_PROJ_" + M))) : "TEX_IMAGE_BL" == o && (Z.params.push(_e("normal")), M = Q.projection, Z.params.push(_e("TEX_PROJ_" + M)), Z.params.push(pe(Q.projectionBlend)), Z.params.push(ge(Q.clampToEdgeNoExtend)));
                        break;
                    case "TEX_GRADIENT_BL":
                        Z.params.push(_e("TEX_GRAD_" + Q.gradientType));
                        break;
                    case "TEX_NOISE_BL":
                        var x = _i(Q.falloffFactor) ? Q.falloffFactor : 0,
                            S = _i(Q.dispersionFactor) ? Q.dispersionFactor : 1;
                        Z.params.push(_e(we("float", x))), Z.params.push(_e(we("float", S)));
                        break;
                    case "TEX_SKY_BL":
                        var A = (new Tn).fromArray(Q.sunDirection).angleTo(new Tn(0, 0, 1));
                        "PREETHAM" == Q.skyType ? (V = Bu.getDistParams(Q.turbidity, 0).concat([0, 0, 0, 0]), G = Bu.getDistParams(Q.turbidity, 1).concat([0, 0, 0, 0]), j = Bu.getDistParams(Q.turbidity, 2).concat([0, 0, 0, 0]), W = Bu.getZenithParams(Q.turbidity, A, 0), H = Bu.getZenithParams(Q.turbidity, A, 1), X = Bu.getZenithParams(Q.turbidity, A, 2)) : "HOSEK_WILKIE" == Q.skyType ? (D = Math.max(Math.PI / 2 - A, 0), V = Ru.getDistParams(Q.turbidity, Q.groundAlbedo, D, 0), G = Ru.getDistParams(Q.turbidity, Q.groundAlbedo, D, 1), j = Ru.getDistParams(Q.turbidity, Q.groundAlbedo, D, 2), W = Ru.getRadiance(Q.turbidity, Q.groundAlbedo, D, 0), H = Ru.getRadiance(Q.turbidity, Q.groundAlbedo, D, 1), X = Ru.getRadiance(Q.turbidity, Q.groundAlbedo, D, 2)) : (V = G = j = new Array(9).fill(0), W = H = X = 0), Z.params.push(_e("TEX_SKY_" + Q.skyType)), Z.params.push(pe([V[0], G[0], j[0]])), Z.params.push(pe([V[1], G[1], j[1]])), Z.params.push(pe([V[2], G[2], j[2]])), Z.params.push(pe([V[3], G[3], j[3]])), Z.params.push(pe([V[4], G[4], j[4]])), Z.params.push(pe([V[5], G[5], j[5]])), Z.params.push(pe([V[6], G[6], j[6]])), Z.params.push(pe([V[7], G[7], j[7]])), Z.params.push(pe([V[8], G[8], j[8]])), Z.params.push(pe([W, H, X])), Z.params.push(pe(Q.sunDirection));
                        break;
                    case "TEX_VORONOI_BL":
                        void 0 !== Q.coloring && Z.params.push(_e("COLORING_" + Q.coloring)), Z.params.push(_e("DISTANCE_" + Q.distance)), Z.params.push(_e("FEATURE_" + Q.feature));
                        break;
                    case "TEX_WAVE_BL":
                        Z.params.push(_e("TEX_WAVE_TYPE_" + Q.waveType)), Z.params.push(_e("TEX_WAVE_PROFILE_" + Q.waveProfile)), void 0 === Q.bandsDirection && (Q.bandsDirection = "DIAGONAL"), void 0 === Q.ringsDirection && (Q.ringsDirection = "SPHERICAL"), Z.params.push(_e("TEX_WAVE_BANDS_DIR_".concat(Q.bandsDirection))), Z.params.push(_e("TEX_WAVE_RINGS_DIR_".concat(Q.ringsDirection)));
                        break;
                    case "MATH_BL":
                        Z.outputs[0].clamp = Q.useClamp;
                        break;
                    case "MIX_RGB_BL":
                        switch (Z.originData.blendType) {
                            case "HUE":
                            case "SATURATION":
                            case "VALUE":
                            case "COLOR":
                                ae.defines.HSV_NODES = ""
                        }
                        Z.outputs[0].clamp = Q.useClamp;
                        break;
                    case "MIX_SHADER_BL":
                        for (var T = -1, l = 1; l < 3; l++) {
                            var E = fe(e, a, l);
                            E && "BSDF_TRANSPARENT_BL" == E.originData.type && (T = l - 1)
                        }
                        Z.params.push(_e(String(T)));
                        break;
                    case "NORMAL_BL":
                        Z.params.push(pe(Q.outputs[0]));
                        break;
                    case "RGB_BL":
                    case "RGB_MX":
                        b = (new Mn).fromArray(Q.outputs[0]);
                        ae.nodeRGB.push(b), ae.nodeRGBMap[Q.name] = n, Z.params.push(_e("nodeRGB[" + n + "]")), n++;
                        break;
                    case "UVMAP_BL":
                        var g = ye(q = (O = Q.uvLayer, ae.nodeUVAliases[O] || "uv"), 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g);
                        break;
                    case "VALUE_BL":
                    case "VALUE_MX":
                    case "ANIM_CURVE_TA_MY":
                    case "ANIM_CURVE_TU_MY":
                    case "VALUE":
                        b = Q.outputs[0];
                        ae.nodeValue[i] = b, ae.nodeValueMap[Q.name] = i, Z.params.push(_e("nodeValue[" + i + "]")), i++;
                        break;
                    case "VALTORGB_BL":
                        var C, L, P = new("STEP" == (U = Q.curve).interpolation ? wu : Du)(new Float32Array(U.input), new Float32Array(U.output), 4);
                        L = ae.useFloatTex ? (C = new Float32Array(4 * md), 1) : (C = new Uint8Array(4 * md), 255);
                        for (l = 0; l < md; l++) {
                            var R = P.evaluate(l / (md - 1));
                            C[4 * l] = L * R[0], C[4 * l + 1] = L * R[1], C[4 * l + 2] = L * R[2], C[4 * l + 3] = L * R[3]
                        }
                        m = ce(C, md, Qe, ae.useFloatTex ? Xe : je);
                        "STEP" == U.interpolation && (m.minFilter = ke, m.magFilter = ke);
                        v = _d.nodeTexUniName(o, t);
                        ae.nodeTextures[v] = m, Z.params.push(me(o, t)), t++;
                        break;
                    case "VECTOR_ROTATE_BL":
                        void 0 === Q.rotationType && (Q.rotationType = "AXIS_ANGLE"), void 0 === Q.invert && (Q.invert = !1), Z.params.push(_e(we("float", Q.invert ? -1 : 1)));
                        break;
                    case "VECT_TRANSFORM_BL":
                        var S = Q.vectorType,
                            D = Q.convertFrom,
                            O = Q.convertTo;
                        "NORMAL" == S && (Z.outputs[0].normalize = !0);
                        var N = "";
                        D == O ? N = "VEC_TRANS_NONE" : (N = "VEC_TRANS_" + D[0] + "_" + O[0], "VECTOR" != S && "NORMAL" != S || (N += "_DIR")), Z.params.push(_e(N)), 0 < oe(e, "OUTPUT_MATERIAL_BL") || 0 < oe(e, "OUTPUT_WORLD_BL") ? Z.params.push(_e("1")) : Z.params.push(_e("0"));
                        break;
                    case "VERTEX_COLOR_BL":
                        (q = le(Q.colorLayer, "")) ? (g = ye(q, 4), Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g)) : Z.params.push(_e("vec4(0.0, 0.0, 0.0, 1.0)"));
                        break;
                    case "ARNOLD_MAP_TO_MTL_MX":
                        Z.params.push(ge(Q.opaqueEnabled));
                        break;
                    case "BITMAP_MX":
                    case "BITMAP_ENV_MX":
                    case "REFLECT_REFRACT_MX":
                        var I = me(o, Q.texture);
                        Z.params.push(I), "BITMAP_MX" == o ? (g = ye(q = Q.uvIndex ? "uv" + String(Q.uvIndex + 1) : "uv", 2), Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g), Z.params.push(_e("MAPPING_" + Q.mapping)), Z.params.push(_e("AXIS_" + Q.axis)), _ = we("ivec2", [xe(Q.clampToEdgeNoExtend[0]), xe(Q.clampToEdgeNoExtend[1])]), Z.params.push(_e(_))) : (Z.params.push(_e(Q.reflectMode)), Z.params.push(pe(Q.IOR)));
                        var w = ae.nodeTextures[I.name].encoding;
                        Z.params.push(_e(ue(w))), "BITMAP_MX" != o && "BITMAP_ENV_MX" != o || (Z.params.push(pe(Q.alphaAsMono)), Z.params.push(pe(Q.alphaAsRGB)), Z.outputs.push({
                            name: o.toLowerCase() + "_out1_n" + a,
                            type: "float",
                            clamp: !1,
                            normalize: !1
                        }));
                        break;
                    case "BLEND_MX":
                        Z.params.push(pe(Q.useCurve)), Z.params.push(pe(Q.curveLower)), Z.params.push(pe(Q.curveUpper));
                        break;
                    case "BUMP_MX":
                        var I = me("BITMAP_MX", Q.texture);
                        Z.params.push(I), Z.params.push(_e("-vViewPosition")), Z.params.push(_e("normal"));
                        g = ye(q = Q.uvIndex ? "uv" + String(Q.uvIndex + 1) : "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g);
                        break;
                    case "COLOR_CORRECTION_MX":
                        N = we("ivec4", [Q.rewireR, Q.rewireG, Q.rewireB, Q.rewireA]);
                        Z.params.push(_e(N));
                        break;
                    case "COMPOSITE_LAYER_MX":
                        Z.params.push(_e(we("int", Q.blendMode)));
                        var F = de(e, a, 1) ? Q.opacity : 0;
                        Z.params.push(pe(F));
                        break;
                    case "COLOR_MAP_MX":
                        Z.params.push(pe(Q.reverseGamma));
                        break;
                    case "FALLOFF_MX":
                        Z.params.push(_e("-vViewPosition")), Z.params.push(pe(Q.IOR));
                        break;
                    case "MASK_MX":
                        Z.params.push(pe(Q.maskInverted));
                        break;
                    case "MATERIAL_MX":
                        Z.params.push(pe(Q.inputFactors[Ku])), Z.params.push(pe(Q.inputFactors[Ju])), Q.inputFactors[Ku] = 1, Q.inputFactors[Ju] = 1, Z.params.push(pe(Q.selfIllumColorOn));
                        break;
                    case "MATTE_SHADOW_MX":
                        Z.params.push(_e("normal")), Z.params.push(ge(Q.receiveShadows)), Z.params.push(pe(Q.shadowBrightness)), Z.params.push(pe(Q.color));
                        break;
                    case "NOISE_MX":
                        2 == Q.coordType ? (g = ye(q = Q.uvIndex ? "uv" + String(Q.uvIndex + 1) : "uv", 2), Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g)) : Z.params.push(_e("vViewPosition")), Z.params.push(ve(Q.noiseType)), Z.params.push(ve(Q.coordType));
                        break;
                    case "NORMAL_BUMP_MX":
                        g = ye(q = "tangent", 4);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g), Z.params.push(_e("normal"));
                        F = "ivec2(" + xe(Q.flip[0]) + "," + xe(Q.flip[1]) + ")";
                        Z.params.push(_e(F));
                        break;
                    case "OUTPUT_MAP_MX":
                        if (Z.params.push(ge(Q.invert)), Z.params.push(ge(Q.clamp)), Z.params.push(ge(Q.alphaFromRGB)), Q.colorMap) {
                            L = ae.useFloatTex ? (s = Q.colorMap, C = new Float32Array(4 * md), 1) : (s = yi(Q.colorMap.slice(), 0, 1), C = new Uint8Array(4 * md), 255);
                            for (p = s.length / md, l = 0; l < md; l++) C[4 * l] = L * s[p * l], 3 == p ? (C[4 * l + 1] = L * s[p * l + 1], C[4 * l + 2] = L * s[p * l + 2]) : (C[4 * l + 1] = C[4 * l], C[4 * l + 2] = C[4 * l]), C[4 * l + 3] = L;
                            m = ce(C, md, Qe, ae.useFloatTex ? Xe : je), v = _d.nodeTexUniName(o, t);
                            ae.nodeTextures[v] = m, Z.params.push(me(o, t)), t++
                        }
                        break;
                    case "PHYSICAL_MX":
                        Z.params.push(_e("geometryNormal")), Z.params.push(pe(Q.emitLuminance));
                        var k = void 0 === Q.brdfMode || Q.brdfMode,
                            B = void 0 === Q.brdfLow ? 0 : Q.brdfLow,
                            z = void 0 === Q.brdfHigh ? 0 : Q.brdfHigh,
                            U = void 0 === Q.brdfCurve ? 0 : Q.brdfCurve;
                        Z.params.push(_e(k ? "0" : "1")), Z.params.push(_e(we("float", B))), Z.params.push(_e(we("float", z))), Z.params.push(_e(we("float", U))), Z.params.push(ge(_i(Q.roughnessInv) && Q.roughnessInv)), Z.params.push(ge(_i(Q.transRoughnessLock) && Q.transRoughnessLock)), Z.params.push(ge(_i(Q.transRoughnessInv) && Q.transRoughnessInv)), Z.params.push(ge(_i(Q.thinWalled) && Q.thinWalled)), (0 < Q.inputs[$u] || de(e, a, $u)) && (ae.defines.CLEARCOAT = "");
                        break;
                    case "PHY_SUN_SKY_ENV_MX":
                        k = 15 * Q.haze + 2, B = new zu, A = Math.PI / 2 - Q.sunPolarAngle, z = Math.PI - Q.sunAzimuthAngle;
                        B.phi = A, B.theta = z;
                        var B = (new Tn).setFromSpherical(B).toArray(),
                            V = Bu.getDistParams(k, 0),
                            G = Bu.getDistParams(k, 1),
                            j = Bu.getDistParams(k, 2),
                            W = Bu.getZenithParams(k, A, 0),
                            H = Bu.getZenithParams(k, A, 1),
                            X = Bu.getZenithParams(k, A, 2);
                        W /= .06, W *= 1e3, Z.params.push(pe([V[0], G[0], j[0]])), Z.params.push(pe([V[1], G[1], j[1]])), Z.params.push(pe([V[2], G[2], j[2]])), Z.params.push(pe([V[3], G[3], j[3]])), Z.params.push(pe([V[4], G[4], j[4]])), Z.params.push(pe([W, H, X]));
                        k = Bu.getSunIlluminance(B, k);
                        Z.params.push(pe(B)), Z.params.push(pe(k)), Z.params.push(pe([0, 0, 0]));
                        k = 1500 / Math.PI;
                        Z.params.push(pe(Q.globalIntensity / k)), Z.params.push(pe(Q.groundColor));
                        break;
                    case "REFLECT_REFRACT_COLOR_MX":
                        b = Q.outputs[0];
                        Z.params.push(pe(b));
                        break;
                    case "VERTEX_COLOR_MX":
                        g = ye(q = "color", 3);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec3"
                        }), Z.params.push(g);
                        break;
                    case "AI_MIX_SHADER_MY":
                        Z.params.push(_e(Q.mode));
                        break;
                    case "AI_FACING_RATIO_MY":
                        Z.params.push(_e("normal"));
                        break;
                    case "AI_NORMAL_MAP_MY":
                        g = ye(q = "tangent", 4);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g);
                        break;
                    case "AI_SHADOW_MATTE_MY":
                        Z.params.push(_e("normal"));
                        break;
                    case "AI_SKYDOME_LIGHT_MY":
                        _i(Q.texture) && (I = me(o, Q.texture), Z.params.push(I), w = ae.nodeTextures[I.name].encoding, Z.params.push(_e(ue(w))), Z.params.push(_e("normal")));
                        break;
                    case "BLINN_MY":
                        Z.params.push(_e("geometryNormal"));
                        break;
                    case "BUMP_2D_MY":
                        Z.params.push(_e("vNormal")), 0 < Q.bumpInterp && (g = ye(q = "tangent", 4), Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g));
                        break;
                    case "CHANNELS_MY":
                        Z.params.push(_e(Q.channelR)), Z.params.push(_e(Q.channelG)), Z.params.push(_e(Q.channelB)), Z.params.push(_e(Q.channelA));
                        break;
                    case "COLOR_COMPOSITE_MY":
                    case "COLOR_MATH_MY":
                    case "CONDITION_MY":
                        Z.params.push(_e(Q.operation));
                        break;
                    case "FILE_MY":
                    case "ENV_SPHERE_MY":
                        b = me("FILE_MY", Q.texture);
                        Z.params.push(b);
                        w = ae.nodeTextures[b.name].encoding;
                        Z.params.push(_e(ue(w))), "ENV_SPHERE_MY" == o && Z.params.push(_e("normal"));
                        break;
                    case "FLOAT_COMPOSITE_MY":
                    case "FLOAT_MATH_MY":
                        Z.params.push(_e(Q.operation));
                        break;
                    case "LAMBERT_MY":
                        Z.params.push(_e("geometryNormal"));
                        break;
                    case "MULTIPLY_DIVIDE_MY":
                        Z.params.push(_e(Q.operation));
                        break;
                    case "PHONG_MY":
                    case "PHONG_E_MY":
                        Z.params.push(_e("geometryNormal"));
                        break;
                    case "PLACE_2D_TEXTURE_MY":
                        g = ye(q = Q.uvIndex ? "uv" + String(Q.uvIndex + 1) : "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g);
                        break;
                    case "RAMP_MY":
                        L = ae.useFloatTex ? (C = new Float32Array(4 * vd), 1) : (C = new Uint8Array(4 * vd), 255);
                        for (l = 0; l < vd; l++) u = L * Q.rampData[3 * l], d = L * Q.rampData[3 * l + 1], h = L * Q.rampData[3 * l + 2], f = 1, C[4 * l] = mn.clamp(u, 0, L), C[4 * l + 1] = mn.clamp(d, 0, L), C[4 * l + 2] = mn.clamp(h, 0, L), C[4 * l + 3] = mn.clamp(f, 0, L);
                        m = ce(C, vd, Qe, ae.useFloatTex ? Xe : je), v = _d.nodeTexUniName(o, t);
                        ae.nodeTextures[v] = m, Z.params.push(me(o, t)), t++, Z.params.push(_e(we("int", Q.rampType)));
                        break;
                    case "SAMPLER_INFO_MY":
                        Z.params.push(_e("FRONT_FACING_VALUE"));
                        g = ye(q = "tangent", 4);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec4"
                        }), Z.params.push(g);
                        g = ye(q = "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g);
                        break;
                    case "STANDARD_SURFACE_MY":
                        Z.params.push(_e("geometryNormal"));
                        var Y = void 0 === Q.thinWalled || Q.thinWalled;
                        Z.params.push(ge(Y)), (0 < Q.inputs[hd] || de(e, a, hd)) && (ae.defines.CLEARCOAT = ""), (0 < Q.inputs[pd] || de(e, a, pd)) && (ae.defines.USE_SHEEN = "");
                        break;
                    case "UNIT_CONVERSION_MY":
                        Z.params.push(pe(Q.conversionFactor));
                        break;
                    case "VECTOR_PRODUCT_MY":
                        Z.params.push(_e(Q.operation)), Z.params.push(ge(Q.normalizeOutput));
                        break;
                    case "INCIDENT":
                        Z.params.push(_e("vViewPosition"));
                        break;
                    case "NORMAL":
                        Z.params.push(_e("normal"));
                        break;
                    case "OSL_NODE":
                        _i(Q.texture) && (I = me(o, Q.texture), Z.params.push(I));
                        Y = Q.globalVariables || []; - 1 < Y.indexOf("P") && Z.params.push(_e("oslGetP(vViewPosition)")), -1 < Y.indexOf("I") && Z.params.push(_e("oslGetI(vViewPosition)")), -1 < Y.indexOf("N") && Z.params.push(_e("oslGetN(normal)")), (-1 < Y.indexOf("u") || -1 < Y.indexOf("v")) && (q = "uv", Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), -1 < Y.indexOf("u") && Z.params.push(ye(q + "_u", 1, q + ".x")), -1 < Y.indexOf("v") && Z.params.push(ye(q + "_v", 1, "1.0 - " + q + ".y")));
                        break;
                    case "POSITION":
                        Z.params.push(_e("vViewPosition"));
                        break;
                    case "RGB_ALPHA":
                        b = (new Mn).fromArray(Q.outputs[0].concat([Q.outputs[1]]));
                        ae.nodeRGB.push(b), ae.nodeRGBMap[Q.name] = n, Z.params.push(_e("nodeRGB[" + n + "]")), n++;
                        break;
                    case "U_FLOAT":
                        var q, g = ye(q = "uv", 2);
                        Z.attributes.push({
                            name: q,
                            type: "attribute vec2"
                        }), Z.params.push(g)
                }
            }
            for (a = 0; a < e.len(); a++)
                for (var Z, Q, o = (Q = (Z = e.node(a)).originData).type, l = 0; l < Q.inputs.length; l++) {
                    var K = Q.inputs[l],
                        J = Q.inputTypes ? Q.inputTypes[l] : be(K),
                        $ = [],
                        ee = [];
                    ! function(e, t, n, r, i, a) {
                        for (var o in e.edges) {
                            var s = e.edges[o];
                            if (s.to() == t)
                                for (var l = e.node(s.from()), c = 0; c < s.connections.length; c++) {
                                    var u, d = s.connections[c];
                                    d.to == n && ("BITMAP_MX" != (u = l.originData.type) && "BITMAP_ENV_MX" != u || "float" != be(r) ? i.push(l.outputs[d.from]) : i.push(l.outputs[d.from + 1]), d.channelMatrix && a.push(d.channelMatrix))
                                }
                        }
                    }(e, a, l, K, $, ee);
                    var te, ne, re, ie = se(o, l);
                    $.length ? (te = Z.inputFactors.length ? Z.inputFactors[l] : 1, ne = ie ? "normal" : we(J, K), ee.length ? (re = $.map(function(e) {
                        return e.name
                    }), Z.inputs.push({
                        code: function(e, t, n, r, i) {
                            for (var a = [], o = Me(n), s = Me(r), l = 0; l < s; l++) {
                                for (var c = 1 == s ? i : i + "[" + l + "]", u = 0; u < e.length; u++)
                                    for (var d = e[u], h = t[u], f = 0; f < o; f++) h[f][l] && (c = 1 == o ? d : d + "[" + f + "]");
                                a.push(c)
                            }
                            return r + "(" + a.join(",") + ")"
                        }(re, ee, $[0].type, J, ne)
                    })) : 1 == $.length ? Z.inputs.push({
                        code: function(e, t, n, r, i) {
                            var a;
                            t == n ? a = e : "float" == t && "vec3" == n ? a = "vec3(" + [e, e, e].join(",") + ")" : "float" == t && "vec4" == n ? a = "vec4(" + [e, e, e, e].join(",") + ")" : "vec3" == t && "float" == n || "vec4" == t && "float" == n ? a = "(" + [e + "[0]", e + "[1]", e + "[2]"].join("+") + ")/3.0" : "vec3" == t && "vec4" == n ? a = "vec4(" + e + ", 1.0)" : "vec4" == t && "vec3" == n ? a = "vec3(" + [e + "[0]", e + "[1]", e + "[2]"].join(",") + ")" : "float" == t && "int" == n ? a = "int(" + e + ")" : "int" == t && "float" == n && (a = "float(" + e + ")");
                            (i < 1 || 1 != i && "normal" == r) && (a = "mix(" + r + "," + a + "," + Se(i) + ")", "normal" == r && (a = "normalize(" + a + ")"));
                            return a
                        }($[0].name, $[0].type, J, ne, te)
                    }) : console.error("MeshNodeMaterial: wrong node connections")) : ie ? Z.inputs.push({
                        code: "normal"
                    }) : Z.inputs.push({
                        code: we(J, K)
                    })
                }
        }

        function de(e, t, n) {
            for (var r = e.findInEdges(t), i = 0; i < r.length; i++)
                for (var a = r[i], o = 0; o < a.connections.length; o++)
                    if (a.connections[o].to == n) return 1
        }

        function he(e, t, n) {
            for (var r in e.edges) {
                var i = e.edges[r];
                if (i.from() == t)
                    for (var a = 0; a < i.connections.length; a++)
                        if (i.connections[a].from == n) return 1
            }
        }

        function fe(e, t, n) {
            for (var r in e.edges) {
                var i = e.edges[r];
                if (i.to() == t)
                    for (var a = e.node(i.from()), o = 0; o < i.connections.length; o++)
                        if (i.connections[o].to == n) return a
            }
            return null
        }

        function pe(e) {
            return {
                name: "",
                type: be(e),
                value: "boolean" == typeof e ? e ? 1 : 0 : e
            }
        }

        function me(e, t) {
            e = _d.nodeTexUniName(e, t);
            return {
                name: e,
                type: ae.nodeTextures[e].isCubeTexture ? "uniform samplerCube" : "uniform sampler2D",
                value: t
            }
        }

        function ve(e) {
            return {
                name: "",
                type: "int",
                value: e
            }
        }

        function ge(e) {
            return _e(e ? "true" : "false")
        }

        function _e(e) {
            return {
                name: e,
                type: "",
                value: null
            }
        }

        function ye(e, t, n) {
            return n = n || e, {
                name: "_vary_par_" + e,
                type: "varying " + i(t),
                value: null,
                attrBindName: n
            }
        }

        function xe(e) {
            return e ? 1 : 0
        }

        function be(e) {
            return "number" == typeof e ? "float" : "boolean" == typeof e ? "maya" == ae.profile ? "bool" : "int" : i(e.length)
        }

        function i(e) {
            switch (e) {
                case 1:
                    return "float";
                case 2:
                    return "vec2";
                case 3:
                    return "vec3";
                case 4:
                    return "vec4";
                case 9:
                    return "mat3";
                case 16:
                    return "mat4"
            }
        }

        function Me(e) {
            switch (e) {
                case "float":
                    return 1;
                case "vec2":
                    return 2;
                case "vec3":
                    return 3;
                case "vec4":
                    return 4;
                case "mat3":
                    return 9;
                case "mat4":
                    return 16
            }
        }

        function we(e, t) {
            switch (e) {
                case "float":
                    return Se(t);
                case "bool":
                case "int":
                    return String(t);
                default:
                    for (var n = [], r = 0; r < t.length; r++) n.push(Se(t[r]));
                    return e + "(" + n.join(",") + ")"
            }
        }

        function Se(e) {
            return e % 1 ? String(e) : String(e) + ".0"
        }
        this.type = "MeshNodeMaterial", this.defines = {
                LIGHT_PATH_IS_CAM_RAY: 1,
                WORLD_NODES: 0
            }, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.extensions = {
                derivatives: !0,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.profile = "blender", this.nodeTextures = {}, this.nodeRGB = [], this.nodeRGBMap = {}, this.nodeRGBArr = null, this.nodeTexCoordObject = [], this.nodeTexCoordObjectMap = {}, this.nodeTexCoordObjectArr = null, this.nodeValue = null, this.nodeValueMap = {}, this.needsBoundingBox = !1, this.useFloatTex = !1, this.nodeGraph = null, this.additionalNodeGraphs = {}, this.nodeChunks = {}, this.nodeChunksHash = 0, this.nodeVCAliases = {}, this.nodeUVAliases = {}, this.color = new Qr(16777215), this.envMap = null, this.envMapIntensity = 1, this.reflectivity = .5, _i(e) && this.setValues(e), this.nodeGraph || (this.nodeGraph = (t = new Su.DiGraph(1), n = ae.color, t.node(0).originData = {
                name: "ShadelessOutput",
                type: "OUTPUT_MATERIAL_BL",
                inputs: [
                    [n.r, n.g, n.b, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0]
                ],
                outputs: [],
                is_active_output: !0
            }, t)), this.updateNodeGraph = function() {
                ae.nodeRGB = [], ae.nodeRGBMap = {}, ae.nodeTexCoordObject = [], ae.nodeTexCoordObjectMap = {}, ae.nodeValueMap = {}, ae.needsBoundingBox = !1, ae.nodeChunks = {};
                var e = ae.nodeGraph;
                ae.nodeRGBArr = new Float32Array(4 * oe(e, ["RGB_BL", "RGB_MX", "RGB_ALPHA"])), ae.nodeTexCoordObjectArr = new Float32Array(16 * oe(e, "TEX_COORD_BL")), ae.nodeValue = new Float32Array(oe(e, ["VALUE_BL", "VALUE_MX", "ANIM_CURVE_TA_MY", "ANIM_CURVE_TU_MY", "VALUE"])), r(e),
                    function(e) {
                        var t = [],
                            n = [],
                            r = [],
                            i = [],
                            a = new Su.TopologicalSort(e).order();
                        ae.defines.NODE_RGB_NUM = ae.nodeRGB.length, ae.defines.NODE_VALUE_NUM = ae.nodeValue.length, ae.defines.NODE_TEX_COORD_NUM = ae.nodeTexCoordObject.length;
                        for (var o = 0; o < a.length; o++) {
                            var s, l = (p = e.node(a[o])).originData.type;
                            ae.defines["NODE_" + l] = "", "OUTPUT_MATERIAL_BL" != l && "PHYSICAL_MX" != l && "SHADING_ENGINE_MY" != l || (ae.defines.STANDARD = "", ae.defines.PHYSICAL = ""), "OSL_NODE" == l && (ae.defines.USE_OSL = ""), (d = "OSL_NODE" != l ? (s = "node_" + l.toLowerCase() + "_vert", Ma[s]) : p.originData.vertCode) && t.indexOf(d) < 0 && t.push(d), (h = "OSL_NODE" != l ? (s = "node_" + l.toLowerCase() + "_frag", Ma[s]) : p.originData.fragCode) && r.indexOf(h) < 0 && r.push(h);
                            for (var c = 0; c < p.attributes.length; c++) {
                                var u = p.attributes[c],
                                    d = u.type + " " + u.name + ";";
                                "uv" != u.name && t.indexOf(d) < 0 && t.push(d)
                            }
                            for (var h, f, c = 0; c < p.params.length; c++) A(v = p.params[c]) ? (h = v.type + " " + v.name + ";", r.indexOf(h) < 0 && r.push(h)) : T(v) && (f = v.type + " " + v.name + ";", t.indexOf(f) < 0 && t.push(f), f = v.type + " " + v.name + ";", r.indexOf(f) < 0 && r.push(f))
                        }
                        for (var p, o = 0; o < a.length; o++) {
                            if ("ATTRIBUTE_BL" == (l = (p = e.node(a[o])).originData.type) || "NEW_GEOMETRY_BL" == l || "NORMAL_MAP_BL" == l || "TANGENT_BL" == l || "TEX_COORD_BL" == l || "UVMAP_BL" == l || "VERTEX_COLOR_BL" == l || "BITMAP_MX" == l || "NOISE_MX" == l || "NORMAL_BUMP_MX" == l || "BUMP_MX" == l || "VERTEX_COLOR_MX" == l || "GRADIENT_RAMP_MX" == l || "BUMP_2D_MY" == l || "PLACE_2D_TEXTURE_MY" == l || "SAMPLER_INFO_MY" == l || "OSL_NODE" == l || "U_FLOAT" == l)
                                for (var m, c = 0; c < p.params.length; c++) T(v = p.params[c]) && (m = v.name + "=" + v.attrBindName + ";", n.indexOf(m) < 0 && n.push(m));
                            for (c = 0; c < p.outputs.length; c++)(x = p.outputs[c]).type && i.push(x.type + " " + x.name + ";");
                            for (var v, g = [], c = 0; c < p.params.length; c++) !(v = p.params[c]).type || A(v) || T(v) ? g.push(v.name) : g.push(we(v.type, v.value));
                            for (c = 0; c < p.inputs.length; c++) {
                                var _ = p.inputs[c];
                                g.push(_.code)
                            }
                            for (var y, c = 0; c < p.outputs.length; c++) {
                                var x = p.outputs[c];
                                g.push(x.name)
                            }
                            switch ("OSL_NODE" != l ? (y = "node_" + l.toLowerCase(), (l.endsWith("_BL") || l.endsWith("_MX") || l.endsWith("_MY")) && (y = y.slice(0, -3))) : y = p.originData.shaderName, l) {
                                case "MATH_BL":
                                case "VECT_MATH_BL":
                                    y += "_" + p.originData.operation.toLowerCase();
                                    break;
                                case "VECTOR_ROTATE_BL":
                                    y += "_" + p.originData.rotationType.toLowerCase();
                                    break;
                                case "MIX_RGB_BL":
                                    y += "_" + p.originData.blendType.toLowerCase()
                            }
                            i.push(y + "(" + g.join(",") + ");");
                            for (c = 0; c < p.outputs.length; c++) {
                                var b = (x = p.outputs[c]).name;
                                x.clamp && (l = x.type, i.push(b + "=clamp(" + b + "," + l + "(0.0)," + l + "(1.0));")), x.normalize && i.push(b + "=normalize(" + b + ");")
                            }
                        }
                        ae.nodeChunks.node_pars_vertex = t.join("\n"), ae.nodeChunks.node_vertex = n.join("\n"), ae.nodeChunks.node_pars_fragment = r.join("\n"), ae.nodeChunks.node_fragment = i.join("\n"), ae.nodeChunksHash = mn.hashString(JSON.stringify(ae.nodeChunks))
                    }(e)
            },
            function(e) {
                for (var t = 0; t < e.len(); t++) {
                    var n = e.node(t),
                        r = n.originData.type;
                    if ("GROUP_BL" == r) {
                        var i = n.originData.nodeGraph,
                            n = ae.additionalNodeGraphs[i];
                        if (_(e, t), n.len() <= 2) {
                            for (var a = e.findInEdges(t), o = e.findOutEdges(t), s = Math.min(a.length, o.length), l = 0; l < s; l++) {
                                var c = a[l],
                                    u = o[l];
                                (g = new Su.Edge(c.from(), u.to(), 0)).connections = [];
                                for (var d = Math.min(c.connections.length, u.connections.length), h = 0; h < d; h++) {
                                    var f = c.connections[h],
                                        p = u.connections[h],
                                        m = {
                                            from: f.from,
                                            to: p.to
                                        };
                                    g.connections.push(m)
                                }
                                e.addEdge(g)
                            }
                            e.disconnect(t, !0), t = -1
                        } else {
                            i = function(e, t, n) {
                                var r = {
                                    inputs: [],
                                    outputs: [],
                                    removedNodes: []
                                };
                                r.removedNodes.push(n);
                                var i = b(t, "GROUP_INPUT_BL");
                                if (-1 < i) {
                                    r.removedNodes.push(i + e.len());
                                    for (var a = e.findInEdges(n), o = t.findOutEdges(i), s = 0; s < a.length; s++)
                                        for (var l = a[s], c = 0; c < o.length; c++)
                                            for (var u = o[c], d = 0; d < l.connections.length; d++)
                                                for (var h = l.connections[d], f = 0; f < u.connections.length; f++) {
                                                    var p = u.connections[f];
                                                    h.to == p.from && ((y = M(r.inputs, l.from(), u.to())) || ((y = new Su.Edge(l.from(), u.to(), 0)).connections = [], r.inputs.push(y)), x = {
                                                        from: h.from,
                                                        to: p.to
                                                    }, y.connections.push(x))
                                                }
                                }
                                i = b(t, "GROUP_OUTPUT_BL");
                                r.removedNodes.push(i + e.len());
                                for (var m = e.findOutEdges(n), v = t.findInEdges(i), s = 0; s < m.length; s++)
                                    for (var g = m[s], c = 0; c < v.length; c++)
                                        for (var _ = v[c], d = 0; d < g.connections.length; d++)
                                            for (h = g.connections[d], f = 0; f < _.connections.length; f++) {
                                                var y, x, p = _.connections[f];
                                                h.from == p.to && ((y = M(r.outputs, _.from(), g.to())) || ((y = new Su.Edge(_.from(), g.to(), 0)).connections = [], r.outputs.push(y)), x = {
                                                    from: p.from,
                                                    to: h.to
                                                }, y.connections.push(x))
                                            }
                                return r
                            }(e, n, t);
                            e.insert(n, i.inputs, i.outputs);
                            for (var v = i.removedNodes.sort(function(e, t) {
                                    return t - e
                                }), l = 0; l < v.length; l++) e.disconnect(v[l], !0);
                            t = -1
                        }
                    } else if ("REROUTE_BL" != r) {
                        if ("OSL_OUTPUT_SELECTOR_MX" == r) {
                            for (a = e.findInEdges(t), o = e.findOutEdges(t), f = (c = a[0]).connections[0], l = 0; l < o.length; l++) {
                                u = o[l];
                                (g = new Su.Edge(c.from(), u.to(), 0)).connections = [];
                                for (h = 0; h < u.connections.length; h++) {
                                    p = u.connections[h], m = {
                                        from: f.from,
                                        to: p.to
                                    };
                                    g.connections.push(m)
                                }
                                e.addEdge(g)
                            }
                            e.disconnect(t, !0), t = -1
                        }
                    } else {
                        e.findInEdges(t).length < 1 && _(e, t);
                        for (var a = e.findInEdges(t), o = e.findOutEdges(t), f = (c = a[0]).connections[0], l = 0; l < o.length; l++) {
                            var g, u = o[l];
                            (g = new Su.Edge(c.from(), u.to(), 0)).connections = [];
                            for (var h = 0; h < u.connections.length; h++) {
                                var p = u.connections[h],
                                    m = {
                                        from: f.from,
                                        to: p.to
                                    };
                                g.connections.push(m)
                            }
                            e.addEdge(g)
                        }
                        e.disconnect(t, !0), t = -1
                    }
                }
            }(ae.nodeGraph),
            function(e) {
                for (var t, n = 0; n < e.len(); n++) {
                    "TEX_IMAGE_BL" != (p = (y = e.node(n).originData).type) || de(e, n, 0) || (e.addNode({
                        originData: {
                            name: "UVMapGenerated",
                            type: "UVMAP_BL",
                            uvLayer: "",
                            inputs: [],
                            outputs: [
                                [0, 0, 0]
                            ]
                        }
                    }), yd(e, e.len() - 1, 0, n, 0)), "TEX_CHECKER_BL" != p && "TEX_GRADIENT_BL" != p && "TEX_NOISE_BL" != p && "TEX_WAVE_BL" != p && "TEX_VORONOI_BL" != p && "TEX_SKY_BL" != p || de(e, n, 0) || (t = {
                        originData: {
                            name: "TexCoordGenerated",
                            type: "TEX_COORD_BL",
                            inputs: [],
                            outputs: [
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0]
                            ]
                        }
                    }, e.addNode(t), yd(e, e.len() - 1, 0, n, 0)), "TEX_ENVIRONMENT_BL" != p && "TEX_ENVIRONMENT_MX" != p || de(e, n, 0) || (t = {
                        originData: {
                            name: "TexCoordObject",
                            type: "TEX_COORD_BL",
                            inputs: [],
                            outputs: [
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0],
                                [0, 0, 0]
                            ]
                        }
                    }, e.addNode(t), yd(e, e.len() - 1, 3, n, 0));
                    var r, i, a = p;
                    if ("BSDF_PRINCIPLED_BL" == a && 22 === y.inputs.length && (a = "BSDF_PRINCIPLED_<2.91.0_BL"), "BUMP_BL" == a && 4 == y.inputs.length && (a = "BUMP_<2.81_BL"), "STANDARD_SURFACE_MY" == a && 25 == y.inputs.length && (console.warn("v3d.MeshNodeMaterial: adding missing params to standard surface node, please reexport your scene"), y.inputs.push([0, 0, 0])), "SAMPLER_INFO_MY" == a && 0 == y.inputs.length && (console.warn("v3d.MeshNodeMaterial: adding missing params to samplerInfo node, please reexport your scene"), y.inputs.push([0, 0, 0])), a in gd && !de(e, n, gd[a]) && (i = {
                            originData: {
                                name: "Normal",
                                type: "NORMAL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }, e.addNode(i), yd(e, e.len() - 1, 0, n, gd[a])), "BSDF_PRINCIPLED_<2.91.0_BL" == a && !de(e, n, Wu) && (0 < y.inputs[Gu] || de(e, n, Gu)) && (i = {
                            originData: {
                                name: "CoatNormal",
                                type: "NORMAL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }, e.addNode(i), yd(e, e.len() - 1, 0, n, Wu)), "BSDF_PRINCIPLED_BL" == a && !de(e, n, ju) && (0 < y.inputs[Gu] || de(e, n, Gu)) && (i = {
                            originData: {
                                name: "CoatNormal",
                                type: "NORMAL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }, e.addNode(i), yd(e, e.len() - 1, 0, n, ju)), "EEVEE_SPECULAR_BL" == a && !de(e, n, Xu) && (0 < y.inputs[Hu] || de(e, n, Hu)) && (i = {
                            originData: {
                                name: "CoatNormal",
                                type: "NORMAL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }, e.addNode(i), yd(e, e.len() - 1, 0, n, Xu)), "OSL_NODE" == a)
                        for (var o = y.initializers, s = 0; s < o.length; s++) {
                            var l = o[s];
                            l && !de(e, n, s) && (l = {
                                originData: {
                                    name: a + "init" + s,
                                    type: "OSL_NODE",
                                    shaderName: y.shaderName + "_init_" + s,
                                    inputs: [],
                                    outputs: [y.inputs[0]],
                                    fragCode: l[0],
                                    globalVariables: l[1],
                                    initializers: []
                                }
                            }, e.addNode(l), yd(e, e.len() - 1, 0, n, s))
                        }
                    if ("AI_NORMAL_MAP_MY" != a || de(e, n, rd) && de(e, n, id) || (e.addNode({
                            originData: {
                                name: "SamplerInfo",
                                type: "SAMPLER_INFO_MY",
                                inputs: [
                                    [0, 0, 0]
                                ],
                                outputs: [0, !1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0]
                                ]
                            }
                        }), de(e, n, rd) || yd(e, e.len() - 1, ud, n, rd), de(e, n, id) || yd(e, e.len() - 1, dd, n, id)), "FILE_MY" != a || de(e, n, sd) || (r = {
                            originData: {
                                name: "place2dTexture",
                                type: "PLACE_2D_TEXTURE_MY",
                                inputs: [
                                    [0, 0],
                                    [1, 1], 0
                                ],
                                outputs: [
                                    [0, 0]
                                ],
                                uvIndex: 0
                            }
                        }, e.addNode(r), yd(e, e.len() - 1, ld, n, sd)), "RAMP_MY" != a || de(e, n, cd) || (r = {
                            originData: {
                                name: "place2dTexture",
                                type: "PLACE_2D_TEXTURE_MY",
                                inputs: [
                                    [0, 0],
                                    [1, 1], 0
                                ],
                                outputs: [
                                    [0, 0]
                                ],
                                uvIndex: 0
                            }
                        }, e.addNode(r), yd(e, e.len() - 1, ld, n, cd)), "BITMAP_MX" != p && "BITMAP_ENV_MX" != p || _i(y.mapping) || (y.mapping = "EXPLICIT_MAP_CHANNEL", y.axis = "XY", y.clampToEdgeNoExtend = [!1, !1], console.warn("v3d.MeshNodeMaterial: adding missing params to bitmap node, please reexport your scene")), "GRADIENT_RAMP_MX" == p && (_i(y.mapping) || (y.mapping = "EXPLICIT_MAP_CHANNEL", y.axis = "XY", y.clampToEdgeNoExtend = [!1, !1], console.warn("v3d.MeshNodeMaterial: adding missing params to gradient ramp node, please reexport your scene"))), _i(y.output) && function(e, t, n) {
                            var r = n.output,
                                i = e.findInEdges(t),
                                a = e.findOutEdges(t),
                                o = {
                                    originData: {
                                        name: n.name + "Output",
                                        type: "OUTPUT_MAP_MX",
                                        invert: r.invert,
                                        clamp: r.clamp,
                                        alphaFromRGB: r.alphaFromRGB,
                                        inputs: [
                                            [0, 0, 0, 0], r.rgbLevel, r.rgbOffset, r.outputAmount, r.bumpAmount
                                        ],
                                        outputs: [
                                            [0, 0, 0, 0]
                                        ]
                                    }
                                };
                            _i(r.colorMap) && (o.originData.colorMap = r.colorMap), e.addNode(o);
                            for (var s = 0; s < a.length; s++)
                                for (var l = a[s], c = 0; c < l.connections.length; c++) {
                                    var u = l.connections[c];
                                    yd(e, e.len() - 1, 0, l.to(), u.to)
                                }
                            for (e.disconnect(t, !1), s = 0; s < i.length; s++) e.addEdge(i[s]);
                            yd(e, t, 0, e.len() - 1, 0), delete n.output
                        }(e, n, y), w(p)) {
                        if (!_i(y.inputFactors)) {
                            y.inputFactors = [];
                            for (s = 0; s < y.inputs.length; s++) y.inputFactors.push(1)
                        }
                        y.inputs.push([0, 0, 0]), y.inputFactors.push(0)
                    }
                    if ("STANDARD_SURFACE_MY" == a && !de(e, n, fd) && (0 < y.inputs[hd] || de(e, n, hd)) && (i = {
                            originData: {
                                name: "CoatNormal",
                                type: "NORMAL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }, e.addNode(i), yd(e, e.len() - 1, 0, n, fd)), "BUMP_2D_MY" == p && 0 < y.bumpInterp) {
                        y.inputs[ad] = [0, 0, 0];
                        for (var c = e.findInEdges(n), s = 0; s < c.length; s++)
                            for (var u = c[s], d = e.node(u.from()).originData, h = 0; h < u.connections.length; h++)(g = u.connections[h]).to == ad && "FILE_MY" == d.type && (g.from = od)
                    }
                    "COLOR_CONSTANT_MY" != p || de(e, n, 0) || de(e, n, 1) || (y.type = "RGB_ALPHA", y.inputs = []), "FLOAT_CONSTANT_MY" != p || de(e, n, 0) || (y.type = "VALUE", y.inputs = [])
                }
                for (var f = 0, n = 0; n < e.len(); n++) "MATERIAL_MX" != (p = (y = e.node(n).originData).type) && "PHYSICAL_MX" != p || (function(e, t, n) {
                    for (var r = n.type, i = e.findInEdges(t), a = 0; a < i.length; a++)
                        for (var o = i[a], s = e.node(o.from()).originData, l = 0; l < o.connections.length; l++) {
                            var c = o.connections[l];
                            if ("MATERIAL_MX" == r && S(s.type) && (c.to == Ku ? s.reflectMode = "MAX_ENV_COORDS_REFLECT" : c.to == Ju && (s.reflectMode = "MAX_ENV_COORDS_REFRACT")), se(r, c.to)) {
                                if ("BITMAP_MX" == s.type || "OUTPUT_MAP_MX" == s.type) {
                                    e.removeEdge(o.from(), o.to()), "OUTPUT_MAP_MX" == s.type && (s = fe(e, o.from(), 0).originData);
                                    var u = {
                                        originData: {
                                            name: s.name + "Bump" + a,
                                            type: "BUMP_MX",
                                            texture: s.texture,
                                            uvIndex: s.uvIndex,
                                            inputs: JSON.parse(JSON.stringify(s.inputs)),
                                            outputs: [
                                                [0, 0, 0]
                                            ]
                                        }
                                    };
                                    e.addNode(u), yd(e, e.len() - 1, 0, t, c.to), a = -1, i = e.findInEdges(t);
                                    break
                                }
                                for (var d = 0; d < e.len(); d++) {
                                    var h, f = e.node(d).originData;
                                    w(f.type) && (h = f.inputs.length - 1, yd(e, o.from(), c.from, d, h), f.inputFactors[h] = n.inputFactors[c.to])
                                }
                            }
                        }
                }(e, n, y), "MATERIAL_MX" == p && (f = y.IOR));
                for (var p, n = 0; n < e.len(); n++) S(p = (y = e.node(n).originData).type) && (y.IOR = f), S(p) && !_i(y.reflectMode) && (y.reflectMode = "MAX_ENV_COORDS_REFLECT");
                for (n = 0; n < e.len(); n++) "COMPOSITE_MX" == (y = e.node(n).originData).type && (function(e, t, n) {
                    for (var r = n.blendMode.length, i = e.findInEdges(t), a = e.findOutEdges(t), o = 0; o < r; o++) {
                        var s = {
                            originData: {
                                name: n.name + "Layer" + o,
                                type: "COMPOSITE_LAYER_MX",
                                blendMode: 0 != o ? n.blendMode[o] : 0,
                                opacity: n.opacity[o],
                                inputs: [
                                    [0, 0, 0, 0]
                                ].concat(n.inputs.slice(2 * o, 2 * o + 2)),
                                outputs: [n.outputs[o]]
                            }
                        };
                        e.addNode(s);
                        for (var l = 0; l < i.length; l++)
                            for (var c = i[l], u = 0; u < c.connections.length; u++)(h = c.connections[u]).to == 2 * o && n.mapEnabled[o] ? yd(e, c.from(), h.from, e.len() - 1, 1) : h.to == 2 * o + 1 && n.maskEnabled[o] && yd(e, c.from(), h.from, e.len() - 1, 2);
                        0 < o && yd(e, e.len() - 2, 0, e.len() - 1, 0)
                    }
                    for (o = 0; o < a.length; o++)
                        for (var d = a[o], l = 0; l < d.connections.length; l++) {
                            var h = d.connections[l];
                            yd(e, e.len() - 1, 0, d.to(), h.to)
                        }
                }(e, n, y), e.disconnect(n, !0));
                for (n = 0; n < e.len(); n++) "LAYERED_TEXTURE_MY" == (y = e.node(n).originData).type && (function(e, t, n) {
                    for (var r = n.inputs.length / 4, i = e.findInEdges(t), a = e.findOutEdges(t), o = 0; o < r; o++) {
                        var s = {
                            originData: {
                                name: n.name + "Layer" + o,
                                type: "LAYERED_TEXTURE_LAYER_MY",
                                inputs: [0, [0, 0, 0]].concat(n.inputs.slice(4 * o, 4 * o + 4)),
                                outputs: [0, [0, 0, 0]]
                            }
                        };
                        e.addNode(s);
                        for (var l = 0; l < i.length; l++)
                            for (var c = i[l], u = 0; u < c.connections.length; u++)(h = c.connections[u]).to == 4 * o ? yd(e, c.from(), h.from, e.len() - 1, 2, h.channelMatrix) : h.to == 4 * o + 1 ? yd(e, c.from(), h.from, e.len() - 1, 3, h.channelMatrix) : h.to == 4 * o + 2 ? yd(e, c.from(), h.from, e.len() - 1, 4, h.channelMatrix) : h.to == 4 * o + 3 && yd(e, c.from(), h.from, e.len() - 1, 5, h.channelMatrix);
                        0 < o && (yd(e, e.len() - 1, 0, e.len() - 2, 0), yd(e, e.len() - 1, 1, e.len() - 2, 1))
                    }
                    for (o = 0; o < a.length; o++)
                        for (var d = a[o], l = 0; l < d.connections.length; l++) {
                            var h = d.connections[l];
                            yd(e, e.len() - r, h.from, d.to(), h.to, h.channelMatrix)
                        }
                }(e, n, y), e.disconnect(n, !0));
                if (ae.hasNode("AI_SKYDOME_LIGHT_MY"))
                    for (n = 0; n < e.len(); n++)
                        if ("FILE_MY" == (y = e.node(n).originData).type) {
                            var m = {
                                originData: {
                                    name: "envSphere",
                                    type: "ENV_SPHERE_MY",
                                    inputs: [
                                        [-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                                    ],
                                    outputs: [0, [0, 0, 0]],
                                    texture: y.texture
                                }
                            };
                            e.addNode(m);
                            for (var v = e.findOutEdges(n), s = 0; s < v.length; s++)
                                for (var g, _ = v[s], h = 0; h < _.connections.length; h++)(g = _.connections[h]).from < 2 && yd(e, e.len() - 1, g.from, _.to(), g.to);
                            e.disconnect(n, !0), n = -1
                        } for (n = 0; n < e.len(); n++)
                    if ("ENV_SPHERE_MY" == (y = e.node(n).originData).type && 2 == y.inputs.length)
                        for (c = e.findInEdges(n), s = 0; s < c.length; s++) {
                            u = c[s];
                            "FILE_MY" == (d = e.node(u.from()).originData).type && (y.inputs.splice(0, 1), y.texture = d.texture, e.removeEdge(u.from(), u.to()))
                        }
                for (var y, n = 0; n < e.len(); n++) switch ((y = e.node(n).originData).type) {
                    case "BSDF_DIFFUSE_BL":
                    case "BSDF_GLOSSY_BL":
                    case "BSDF_TRANSLUCENT_BL":
                    case "BSDF_PRINCIPLED_BL":
                        x(e, n, y, 0, "Color");
                        break;
                    case "MATERIAL_MX":
                        x(e, n, y, 0, "Ambient Color") && (y.inputFactors[0] = 1), x(e, n, y, 1, "Diffuse Color") && (y.inputFactors[1] = 1);
                        break;
                    case "PHYSICAL_MX":
                        x(e, n, y, 1, "Base Color") && (y.inputFactors[1] = 1)
                }
            }(ae.nodeGraph), xd(ae.nodeGraph), this.updateNodeGraph()
    }

    function yd(e, t, n, r, i, a) {
        e.edge(t, r) || e.addNewEdge(t, r);
        r = e.edge(t, r);
        r.connections = r.connections || [];
        i = {
            from: n,
            to: i
        };
        a && (i.channelMatrix = a), r.connections.push(i)
    }

    function xd(t) {
        for (var e = -1, n = 0; n < t.len(); n++)
            if (t.node(n).originData.is_active_output) {
                e = n;
                break
            } if (-1 == e) t.removeAll();
        else {
            for (var r = new Su.DepthFirstSearch(t.reverse(), e), i = [], n = 0; n < t.len(); n++) r.hasPathTo(n) || i.push(t.node(n));
            i.forEach(function(e) {
                t.disconnect(t.nodeIndex(e), !0)
            })
        }
    }
    _d.nodeTexUniName = function(e, t) {
        return e.toLowerCase() + "_par_tex_idx" + t
    }, _d.nodeGraphFromExtGraph = function(e) {
        for (var t = e.nodes, n = e.edges, r = new Su.DiGraph(t.length), i = 0; i < t.length; i++) {
            t[i];
            r.node(i).originData = t[i];
            var a, o = r.node(i).originData,
                s = o.type;
            a = s.endsWith("_BL") || s.endsWith("_MX") || s.endsWith("_MY") ? s : s.endsWith("_MAX") ? s.replace("_MAX", "_MX") : "OSL_NODE" == s ? s : s + "_BL", s != (o.type = a) && console.warn("v3d.MeshNodeMaterial: converting node type: " + s + "->" + a + ", please reexport your scene")
        }
        for (i = 0; i < n.length; i++) {
            var l = n[i];
            r.edge(l.fromNode, l.toNode) || r.addNewEdge(l.fromNode, l.toNode);
            var c = r.edge(l.fromNode, l.toNode);
            if (c.connections = c.connections || [], _i(l.fromChannel) || _i(l.toChannel)) {
                for (var u = null, d = 0; d < c.connections.length; d++)
                    if ((p = c.connections[d]).from == l.fromOutput && p.to == l.toInput && p.channelMatrix) {
                        u = p.channelMatrix;
                        break
                    } u || (u = [
                    [0, 0, 0],
                    [0, 0, 0],
                    [0, 0, 0]
                ], p = {
                    from: l.fromOutput,
                    to: l.toInput,
                    channelMatrix: u
                }, c.connections.push(p));
                var h = l.fromChannel || 0,
                    f = l.toChannel || 0;
                u[h][f] = 1
            } else {
                var p = {
                    from: l.fromOutput,
                    to: l.toInput
                };
                c.connections.push(p)
            }
        }
        return xd(r), r
    }, _d.prototype = Object.assign(Object.create($r.prototype), {
        constructor: _d,
        isMeshNodeMaterial: !0,
        hasNode: function(e) {
            for (var t = 0; t < this.nodeGraph.len(); t++)
                if (this.nodeGraph.node(t).originData.type == e) return !0;
            return !1
        },
        traverseNodes: function(e) {
            for (var t = 0; t < this.nodeGraph.len(); t++) e(this.nodeGraph.node(t))
        },
        findNodeByName: function(e) {
            for (var t = 0; t < this.nodeGraph.len(); t++) {
                var n = this.nodeGraph.node(t);
                if (n.originData.name === e) return n
            }
            return null
        },
        needsLightPathDir: function() {
            return !!(this.hasNode("LIGHT_PATH_BL") || this.hasNode("LIGHT_PATH_MY") || this.hasNode("AI_RAY_SWITCH_MY") || "USE_OSL" in this.defines)
        },
        copy: function(e) {
            $r.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ra.clone(e.uniforms), this.defines = e.defines, this.linewidth = e.linewidth, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this.index0AttributeName = this.index0AttributeName, this.color.copy(e.color), this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.reflectivity = e.reflectivity, this.extensions = e.extensions, this.profile = e.profile, this.nodeTextures = e.nodeTextures, this.nodeRGB = e.nodeRGB.slice(), this.nodeRGBMap = Object.assign({}, e.nodeRGBMap), this.nodeRGBArr = e.nodeRGBArr.slice(), this.nodeTexCoordObject = e.nodeTexCoordObject.slice(), this.nodeTexCoordObjectMap = Object.assign({}, e.nodeTexCoordObjectMap), this.nodeTexCoordObjectArr = e.nodeTexCoordObjectArr.slice(), this.nodeValue = e.nodeValue.slice(), this.nodeValueMap = Object.assign({}, e.nodeValueMap), this.needsBoundingBox = e.needsBoundingBox, this.useFloatTex = e.useFloatTex, this.nodeGraph = new Su.DiGraph(e.nodeGraph.len());
            for (var t, n = 0; n < this.nodeGraph.len(); n++) this.nodeGraph.node(n).originData = e.nodeGraph.node(n).originData;
            for (t in e.nodeGraph.edges) {
                var r = e.nodeGraph.edges[t];
                this.nodeGraph.addNewEdge(r.from(), r.to()).connections = r.connections.slice()
            }
            return this.additionalNodeGraphs = Object.assign({}, e.additionalNodeGraphs), this.nodeChunks = Object.assign({}, e.nodeChunks), this.nodeChunksHash = e.nodeChunksHash, this.nodeVCAliases = Object.assign({}, e.nodeVCAliases), this.nodeUVAliases = Object.assign({}, e.nodeUVAliases), this
        },
        toJSON: function(e) {
            e = $r.prototype.toJSON.call(this, e);
            return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
        }
    });
    var bd = Object.freeze({
            __proto__: null,
            ShadowMaterial: du,
            SpriteMaterial: js,
            RawShaderMaterial: hu,
            ShaderMaterial: oa,
            PointsMaterial: Ol,
            MeshPhysicalMaterial: pu,
            MeshStandardMaterial: fu,
            MeshPhongMaterial: mu,
            MeshToonMaterial: vu,
            MeshNormalMaterial: gu,
            MeshLambertMaterial: _u,
            MeshDepthMaterial: ds,
            MeshDistanceMaterial: hs,
            MeshBasicMaterial: ei,
            MeshMatcapMaterial: yu,
            LineDashedMaterial: xu,
            LineBasicMaterial: Ml,
            Material: $r,
            MeshMaskMaterial: bu,
            MeshNodeMaterial: _d
        }),
        Md = {
            arraySlice: function(e, t, n) {
                return Md.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            },
            convertArray: function(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function(n) {
                for (var e = n.length, t = new Array(e), r = 0; r !== e; ++r) t[r] = r;
                return t.sort(function(e, t) {
                    return n[e] - n[t]
                }), t
            },
            sortedArray: function(e, t, n) {
                for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)
                    for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s + l];
                return i
            },
            flattenJSON: function(e, t, n, r) {
                for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a = e[i++];
                if (void 0 !== a) {
                    var o = a[r];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            for (; void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), a = e[i++], void 0 !== a;);
                        else if (void 0 !== o.toArray)
                        for (; void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), a = e[i++], void 0 !== a;);
                    else
                        for (; void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), a = e[i++], void 0 !== a;);
                }
            },
            subclip: function(e, t, n, r) {
                var i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 30,
                    a = e.clone();
                a.name = t;
                for (var o = [], s = 0; s < a.tracks.length; ++s) {
                    for (var l = a.tracks[s], c = l.getValueSize(), u = [], d = [], h = 0; h < l.times.length; ++h) {
                        var f = l.times[h] * i;
                        if (!(f < n || r <= f)) {
                            u.push(l.times[h]);
                            for (var p = 0; p < c; ++p) d.push(l.values[h * c + p])
                        }
                    }
                    0 !== u.length && (l.times = Md.convertArray(u, l.times.constructor), l.values = Md.convertArray(d, l.values.constructor), o.push(l))
                }
                a.tracks = o;
                for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v) m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
                for (var g = 0; g < a.tracks.length; ++g) a.tracks[g].shift(-1 * m);
                return a.resetDuration(), a
            },
            makeClipAdditive: function(v) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                    g = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : v,
                    t = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 30;
                t <= 0 && (t = 30);
                for (var n = g.tracks.length, _ = e / t, r = 0; r < n; ++r)(function(e) {
                    var t = g.tracks[e],
                        n = t.ValueTypeName;
                    if ("bool" === n || "string" === n) return;
                    var r = v.tracks.find(function(e) {
                        return e.name === t.name && e.ValueTypeName === n
                    });
                    if (void 0 === r) return;
                    var i = 0,
                        a = t.getValueSize();
                    t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (i = a / 3);
                    var o = 0,
                        s = r.getValueSize();
                    r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = s / 3);
                    var l, c = t.times.length - 1,
                        u = void 0;
                    u = _ <= t.times[0] ? (e = a - i, Md.arraySlice(t.values, i, e)) : _ >= t.times[c] ? (l = (c = c * a + i) + a - i, Md.arraySlice(t.values, c, l)) : (a = a - (l = i), (i = t.createInterpolant()).evaluate(_), Md.arraySlice(i.resultBuffer, l, a)), "quaternion" === n && (new An).fromArray(u).normalize().conjugate().toArray(u);
                    for (var d = r.times.length, h = 0; h < d; ++h) {
                        var f = h * s + o;
                        if ("quaternion" === n) An.multiplyQuaternionsFlat(r.values, f, u, 0, r.values, f);
                        else
                            for (var p = s - 2 * o, m = 0; m < p; ++m) r.values[f + m] -= u[m]
                    }
                })(r);
                return v.blendMode = 2501, v
            }
        };

    function wd(e, t, n, r) {
        Mu.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Sd(e, t, n, r) {
        if (void 0 === e) throw new Error("v3d.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("v3d.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Md.convertArray(t, this.TimeBufferType), this.values = Md.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    function Ad(e, t, n) {
        Sd.call(this, e, t, n)
    }

    function Td(e, t, n, r) {
        Sd.call(this, e, t, n, r)
    }

    function Ed(e, t, n, r) {
        Sd.call(this, e, t, n, r)
    }

    function Cd(e, t, n, r) {
        Mu.call(this, e, t, n, r)
    }

    function Ld(e, t, n, r) {
        Sd.call(this, e, t, n, r)
    }

    function Pd(e, t, n, r) {
        Sd.call(this, e, t, n, r)
    }

    function Rd(e, t, n, r) {
        Sd.call(this, e, t, n, r)
    }

    function Dd(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : -1,
            n = 2 < arguments.length ? arguments[2] : void 0,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 2500;
        this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = mn.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function Od(e) {
        if (void 0 === e.type) throw new Error("v3d.KeyframeTrack: track type undefined, can not parse");
        var t, n, r = function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Ed;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Rd;
                case "color":
                    return Td;
                case "quaternion":
                    return Ld;
                case "bool":
                case "boolean":
                    return Ad;
                case "string":
                    return Pd
            }
            throw new Error("v3d.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        return void 0 === e.times && (t = [], n = [], Md.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n), void 0 !== r.parse ? r.parse(e) : new r(e.name, e.times, e.values, e.interpolation)
    }
    wd.prototype = Object.assign(Object.create(Mu.prototype), {
        constructor: wd,
        DefaultSettings_: {
            endingStart: Bt,
            endingEnd: Bt
        },
        intervalChanged_: function(e, t, n) {
            var r = this.parameterPositions,
                i = e - 2,
                a = e + 1,
                o = r[i],
                s = r[a];
            if (void 0 === o) switch (this.getSettings_().endingStart) {
                case zt:
                    i = e, o = 2 * t - n;
                    break;
                case Ut:
                    o = t + r[i = r.length - 2] - r[i + 1];
                    break;
                default:
                    i = e, o = n
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case zt:
                    a = e, s = 2 * n - t;
                    break;
                case Ut:
                    s = n + r[a = 1] - r[0];
                    break;
                default:
                    a = e - 1, s = t
            }
            var l = .5 * (n - t),
                c = this.valueSize;
            this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = a * c
        },
        interpolate_: function(e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, e = this._weightNext, n = (n - t) / (r - t), r = n * n, t = r * n, h = -d * t + 2 * d * r - d * n, f = (1 + d) * t + (-1.5 - 2 * d) * r + (-.5 + d) * n + 1, p = (-1 - e) * t + (1.5 + e) * r + .5 * n, m = e * t - e * r, v = 0; v !== o; ++v) i[v] = h * a[c + v] + f * a[l + v] + p * a[s + v] + m * a[u + v];
            return i
        }
    }), Object.assign(Sd, {
        toJSON: function(e) {
            var t, n = e.constructor;
            return void 0 !== n.toJSON ? t = n.toJSON(e) : (t = {
                name: e.name,
                times: Md.convertArray(e.times, Array),
                values: Md.convertArray(e.values, Array)
            }, (n = e.getInterpolation()) !== e.DefaultInterpolation && (t.interpolation = n)), t.type = e.ValueTypeName, t
        }
    }), Object.assign(Sd.prototype, {
        constructor: Sd,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: Ft,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new wu(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new Du(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new wd(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
                case It:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Ft:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case kt:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== t) return this.createInterpolant = t, this;
            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(n);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("v3d.KeyframeTrack:", n), this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return It;
                case this.InterpolantFactoryMethodLinear:
                    return Ft;
                case this.InterpolantFactoryMethodSmooth:
                    return kt
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
            return this
        },
        trim: function(e, t) {
            for (var n, r = this.times, i = r.length, a = 0, o = i - 1; a !== i && r[a] < e;) ++a;
            for (; - 1 !== o && r[o] > t;) --o;
            return ++o, 0 === a && o === i || (o <= a && (a = (o = Math.max(o, 1)) - 1), n = this.getValueSize(), this.times = Md.arraySlice(r, a, o), this.values = Md.arraySlice(this.values, a * n, o * n)), this
        },
        validate: function() {
            var e = !0,
                t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("v3d.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var n = this.times,
                r = this.values,
                i = n.length;
            0 === i && (console.error("v3d.KeyframeTrack: Track is empty.", this), e = !1);
            for (var a = null, o = 0; o !== i; o++) {
                var s = n[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("v3d.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                    break
                }
                if (null !== a && s < a) {
                    console.error("v3d.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                    break
                }
                a = s
            }
            if (void 0 !== r && Md.isTypedArray(r))
                for (var l = 0, c = r.length; l !== c; ++l) {
                    var u = r[l];
                    if (isNaN(u)) {
                        console.error("v3d.KeyframeTrack: Value is not a valid number.", this, l, u), e = !1;
                        break
                    }
                }
            return e
        },
        optimize: function() {
            for (var e = Md.arraySlice(this.times), t = Md.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === kt, i = e.length - 1, a = 1, o = 1; o < i; ++o) {
                var s = !1,
                    l = e[o];
                if (l !== e[o + 1] && (1 !== o || l !== l[0]))
                    if (r) s = !0;
                    else
                        for (var c = o * n, u = c - n, d = c + n, h = 0; h !== n; ++h) {
                            var f = t[c + h];
                            if (f !== t[u + h] || f !== t[d + h]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== a) {
                        e[a] = e[o];
                        for (var p = o * n, m = a * n, v = 0; v !== n; ++v) t[m + v] = t[p + v]
                    }++a
                }
            }
            if (0 < i) {
                e[a] = e[i];
                for (var g = i * n, _ = a * n, y = 0; y !== n; ++y) t[_ + y] = t[g + y];
                ++a
            }
            return a !== e.length ? (this.times = Md.arraySlice(e, 0, a), this.values = Md.arraySlice(t, 0, a * n)) : (this.times = e, this.values = t), this
        },
        clone: function() {
            var e = Md.arraySlice(this.times, 0),
                t = Md.arraySlice(this.values, 0),
                t = new this.constructor(this.name, e, t);
            return t.createInterpolant = this.createInterpolant, t
        }
    }), Ad.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Ad,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: It,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Td.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Td,
        ValueTypeName: "color"
    }), Ed.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Ed,
        ValueTypeName: "number"
    }), Cd.prototype = Object.assign(Object.create(Mu.prototype), {
        constructor: Cd,
        interpolate_: function(e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - t) / (r - t), l = e * o, c = l + o; l !== c; l += 4) An.slerpFlat(i, 0, a, l - o, a, l, s);
            return i
        }
    }), Ld.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Ld,
        ValueTypeName: "quaternion",
        DefaultInterpolation: Ft,
        InterpolantFactoryMethodLinear: function(e) {
            return new Cd(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), Pd.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Pd,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: It,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Rd.prototype = Object.assign(Object.create(Sd.prototype), {
        constructor: Rd,
        ValueTypeName: "vector"
    }), Object.assign(Dd, {
        parse: function(e) {
            for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push(Od(n[i]).scale(r));
            var o = new Dd(e.name, e.duration, t, e.blendMode);
            return o.uuid = e.uuid, o
        },
        toJSON: function(e) {
            for (var t = [], n = e.tracks, e = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                }, r = 0, i = n.length; r !== i; ++r) t.push(Sd.toJSON(n[r]));
            return e
        },
        CreateFromMorphTargetSequence: function(e, t, n, r) {
            for (var i = t.length, a = [], o = 0; o < i; o++) {
                var s = [];
                (c = []).push((o + i - 1) % i, o, (o + 1) % i), s.push(0, 1, 0);
                var l = Md.getKeyframeOrder(c),
                    c = Md.sortedArray(c, 1, l),
                    s = Md.sortedArray(s, 1, l);
                r || 0 !== c[0] || (c.push(i), s.push(s[0])), a.push(new Ed(".morphTargetInfluences[" + t[o].name + "]", c, s).scale(1 / n))
            }
            return new Dd(e, -1, a)
        },
        findByName: function(e, t) {
            var n = e;
            Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations);
            for (var r = 0; r < n.length; r++)
                if (n[r].name === t) return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, n) {
            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s, l = e[a],
                    c = l.name.match(i);
                c && 1 < c.length && ((c = r[s = c[1]]) || (r[s] = c = []), c.push(l))
            }
            var u, d = [];
            for (u in r) d.push(Dd.CreateFromMorphTargetSequence(u, r[u], t, n));
            return d
        },
        parseAnimation: function(e, t) {
            if (!e) return console.error("v3d.AnimationClip: No animation in JSONLoader data."), null;
            for (var n = function(e, t, n, r, i) {
                    var a, o;
                    0 !== n.length && (a = [], o = [], Md.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o)))
                }, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1, l = e.hierarchy || [], c = 0; c < l.length; c++) {
                var u = l[c].keys;
                if (u && 0 !== u.length)
                    if (u[0].morphTargets) {
                        for (var d, h = {}, f = void 0, f = 0; f < u.length; f++)
                            if (u[f].morphTargets)
                                for (var p = 0; p < u[f].morphTargets.length; p++) h[u[f].morphTargets[p]] = -1;
                        for (d in h) {
                            for (var m = [], v = [], g = 0; g !== u[f].morphTargets.length; ++g) {
                                var _ = u[f];
                                m.push(_.time), v.push(_.morphTarget === d ? 1 : 0)
                            }
                            r.push(new Ed(".morphTargetInfluence[" + d + "]", m, v))
                        }
                        s = h.length * (a || 1)
                    } else {
                        var y = ".bones[" + t[c].name + "]";
                        n(Rd, y + ".position", u, "pos", r), n(Ld, y + ".quaternion", u, "rot", r), n(Rd, y + ".scale", u, "scl", r)
                    }
            }
            return 0 === r.length ? null : new Dd(i, s, r, o)
        }
    }), Object.assign(Dd.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) var r = this.tracks[t],
                e = Math.max(e, r.times[r.times.length - 1]);
            return this.duration = e, this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new Dd(this.name, this.duration, e, this.blendMode)
        },
        toJSON: function() {
            return Dd.toJSON(this)
        }
    });
    var Nd = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled) return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };

    function Id(e, t, n) {
        var r = this,
            i = !1,
            a = 0,
            o = 0,
            s = void 0,
            l = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
            o++, !1 === i && void 0 !== r.onStart && r.onStart(e, a, o), i = !0
        }, this.itemEnd = function(e) {
            a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function(e) {
            void 0 !== r.onError && r.onError(e)
        }, this.resolveURL = function(e) {
            return s ? s(e) : e
        }, this.setURLModifier = function(e) {
            return s = e, this
        }, this.addHandler = function(e, t) {
            return l.push(e, t), this
        }, this.removeHandler = function(e) {
            e = l.indexOf(e);
            return -1 !== e && l.splice(e, 2), this
        }, this.getHandler = function(e) {
            for (var t = 0, n = l.length; t < n; t += 2) {
                var r = l[t],
                    i = l[t + 1];
                if (r.global && (r.lastIndex = 0), r.test(e)) return i
            }
            return null
        }
    }
    var Fd = new Id;

    function kd(e) {
        this.manager = void 0 !== e ? e : Fd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    Object.assign(kd.prototype, {
        load: function() {},
        loadAsync: function(n, r) {
            var i = this;
            return new Promise(function(e, t) {
                i.load(n, e, r, t)
            })
        },
        parse: function() {},
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e, this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e, this
        }
    });
    var Bd = {};

    function zd(e) {
        kd.call(this, e)
    }

    function Ud(e) {
        kd.call(this, e)
    }

    function Vd(e) {
        kd.call(this, e)
    }

    function Gd(e) {
        kd.call(this, e)
    }

    function jd(e) {
        kd.call(this, e)
    }

    function Wd(e) {
        kd.call(this, e)
    }

    function Hd(e) {
        kd.call(this, e)
    }

    function Xd() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function Yd(e, t, n, r, i, a, o, s) {
        Xd.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
    }

    function qd(e, t, n, r, i, a) {
        Yd.call(this, e, t, n, n, r, i, a), this.type = "ArcCurve"
    }

    function Zd() {
        var i = 0,
            a = 0,
            o = 0,
            s = 0;

        function l(e, t, n, r) {
            o = -3 * (i = e) + 3 * t - 2 * (a = n) - r, s = 2 * e - 2 * t + n + r
        }
        return {
            initCatmullRom: function(e, t, n, r, i) {
                l(t, n, i * (n - e), i * (r - t))
            },
            initNonuniformCatmullRom: function(e, t, n, r, i, a, o) {
                i = (t - e) / i - (n - e) / (i + a) + (n - t) / a, o = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
                l(t, n, i *= a, o *= a)
            },
            calc: function(e) {
                var t = e * e;
                return i + a * e + o * t + s * (t * e)
            }
        }
    }
    zd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: zd,
        load: function(c, e, t, n) {
            void 0 === c && (c = ""), void 0 !== this.path && (c = this.path + c), c = this.manager.resolveURL(c);
            var u = this,
                r = Nd.get(c);
            if (void 0 !== r) return u.manager.itemStart(c), setTimeout(function() {
                e && e(r), u.manager.itemEnd(c)
            }, 0), r;
            if (void 0 === Bd[c]) {
                var i, a = c.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var o = a[1],
                        s = !!a[2],
                        l = a[3],
                        l = decodeURIComponent(l);
                    s && (l = atob(l));
                    try {
                        var d = (this.responseType || "").toLowerCase();
                        switch (d) {
                            case "arraybuffer":
                            case "blob":
                                for (var h = new Uint8Array(l.length), f = 0; f < l.length; f++) h[f] = l.charCodeAt(f);
                                p = "blob" === d ? new Blob([h.buffer], {
                                    type: o
                                }) : h.buffer;
                                break;
                            case "document":
                                var p = (new DOMParser).parseFromString(l, o);
                                break;
                            case "json":
                                p = JSON.parse(l);
                                break;
                            default:
                                p = l
                        }
                        setTimeout(function() {
                            e && e(p), u.manager.itemEnd(c)
                        }, 0)
                    } catch (e) {
                        setTimeout(function() {
                            n && n(e), u.manager.itemError(c), u.manager.itemEnd(c)
                        }, 0)
                    }
                } else {
                    for (var m in Bd[c] = [], Bd[c].push({
                            onLoad: e,
                            onProgress: t,
                            onError: n
                        }), (i = new XMLHttpRequest).open("GET", c, !0), i.addEventListener("load", function(e) {
                            var t = this.response,
                                n = Bd[c];
                            if (delete Bd[c], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("v3d.FileLoader: HTTP Status 0 received."), Nd.add(c, t);
                                for (var r = 0, i = n.length; r < i; r++) {
                                    var a = n[r];
                                    a.onLoad && a.onLoad(t)
                                }
                                u.manager.itemEnd(c)
                            } else {
                                for (var o = 0, s = n.length; o < s; o++) {
                                    var l = n[o];
                                    l.onError && l.onError(e)
                                }
                                u.manager.itemError(c), u.manager.itemEnd(c)
                            }
                        }, !1), i.addEventListener("progress", function(e) {
                            for (var t = Bd[c], n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onProgress && i.onProgress(e)
                            }
                        }, !1), i.addEventListener("error", function(e) {
                            var t = Bd[c];
                            delete Bd[c];
                            for (var n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onError && i.onError(e)
                            }
                            u.manager.itemError(c), u.manager.itemEnd(c)
                        }, !1), i.addEventListener("abort", function(e) {
                            var t = Bd[c];
                            delete Bd[c];
                            for (var n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onError && i.onError(e)
                            }
                            u.manager.itemError(c), u.manager.itemEnd(c)
                        }, !1), void 0 !== this.responseType && (i.responseType = this.responseType), void 0 !== this.withCredentials && (i.withCredentials = this.withCredentials), i.overrideMimeType && i.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) i.setRequestHeader(m, this.requestHeader[m]);
                    i.send(null)
                }
                return u.manager.itemStart(c), i
            }
            Bd[c].push({
                onLoad: e,
                onProgress: t,
                onError: n
            })
        },
        setResponseType: function(e) {
            return this.responseType = e, this
        },
        setMimeType: function(e) {
            return this.mimeType = e, this
        }
    }), Ud.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Ud,
        load: function(t, n, e, r) {
            var i = this,
                a = new zd(i.manager);
            a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function(e) {
                try {
                    n(i.parse(JSON.parse(e)))
                } catch (e) {
                    r ? r(e) : console.error(e), i.manager.itemError(t)
                }
            }, e, r)
        },
        parse: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = Dd.parse(e[n]);
                t.push(r)
            }
            return t
        }
    }), Vd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Vd,
        load: function(e, a, n, r) {
            var o = this,
                s = [],
                l = new Vl,
                i = new zd(this.manager);
            i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(o.withCredentials);
            var c = 0;
            if (Array.isArray(e))
                for (var t = 0, u = e.length; t < u; ++t) ! function(t) {
                    i.load(e[t], function(e) {
                        e = o.parse(e, !0);
                        s[t] = {
                            width: e.width,
                            height: e.height,
                            format: e.format,
                            mipmaps: e.mipmaps
                        }, 6 === (c += 1) && (1 === e.mipmapCount && (l.minFilter = Ue), l.image = s, l.format = e.format, l.needsUpdate = !0, a && a(l))
                    }, n, r)
                }(t);
            else i.load(e, function(e) {
                var t = o.parse(e, !0);
                if (t.isCubemap) {
                    for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                        s[r] = {
                            mipmaps: []
                        };
                        for (var i = 0; i < t.mipmapCount; i++) s[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + i]), s[r].format = t.format, s[r].width = t.width, s[r].height = t.height
                    }
                    l.image = s
                } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                1 === t.mipmapCount && (l.minFilter = Ue), l.format = t.format, l.needsUpdate = !0, a && a(l)
            }, n, r);
            return l
        }
    }), Gd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Gd,
        load: function(t, e, n, r) {
            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                a = Nd.get(t);
            if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function() {
                e && e(a), i.manager.itemEnd(t)
            }, 0), a;
            var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Nd.add(t, this), e && e(this), i.manager.itemEnd(t)
            }

            function l(e) {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
            }
            return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
        }
    }), jd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: jd,
        load: function(e, n, t, r) {
            var i = new ua,
                a = new Gd(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;
            for (var s = 0; s < e.length; ++s) ! function(t) {
                a.load(e[t], function(e) {
                    i.images[t] = e, 6 === ++o && (i.needsUpdate = !0, n && n(i))
                }, void 0, r)
            }(s);
            return i
        }
    }), Wd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Wd,
        load: function(e, t, n, r) {
            var i = this,
                a = new ha,
                o = new zd(this.manager);
            return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, function(e) {
                e = i.parse(e);
                e && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : V, a.wrapT = void 0 !== e.wrapT ? e.wrapT : V, a.magFilter = void 0 !== e.magFilter ? e.magFilter : Ue, a.minFilter = void 0 !== e.minFilter ? e.minFilter : Ue, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = Ge), 1 === e.mipmapCount && (a.minFilter = Ue), a.needsUpdate = !0, t && t(a, e))
            }, n, r), a
        }
    }), Hd.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Hd,
        load: function(t, n, e, r) {
            var i = new xn,
                a = new Gd(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function(e) {
                i.image = e;
                e = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data\:image\/jpeg/);
                i.format = e ? Ze : Qe, i.needsUpdate = !0, void 0 !== n && n(i)
            }, e, r), i
        }
    }), Object.assign(Xd.prototype, {
        getPoint: function() {
            return console.warn("v3d.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(e, t) {
            e = this.getUtoTmapping(e);
            return this.getPoint(e, t)
        },
        getPoints: function() {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function() {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, n = [],
                r = this.getPoint(0),
                i = 0;
            n.push(0);
            for (var a = 1; a <= e; a++) i += (t = this.getPoint(a / e)).distanceTo(r), n.push(i), r = t;
            return this.cacheArcLengths = n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            for (var n, r = this.getLengths(), i = 0, a = r.length, o = t || e * r[a - 1], s = 0, l = a - 1; s <= l;)
                if ((n = r[i = Math.floor(s + (l - s) / 2)] - o) < 0) s = i + 1;
                else {
                    if (!(0 < n)) {
                        l = i;
                        break
                    }
                    l = i - 1
                } if (r[i = l] === o) return i / (a - 1);
            e = r[i];
            return (i + (o - e) / (r[i + 1] - e)) / (a - 1)
        },
        getTangent: function(e, t) {
            var n = e - 1e-4,
                e = e + 1e-4;
            n < 0 && (n = 0), 1 < e && (e = 1);
            n = this.getPoint(n), e = this.getPoint(e), t = t || new(n.isVector2 ? vn : Tn);
            return t.copy(e).sub(n).normalize(), t
        },
        getTangentAt: function(e, t) {
            e = this.getUtoTmapping(e);
            return this.getTangent(e, t)
        },
        computeFrenetFrames: function(e, t) {
            for (var n = new Tn, r = [], i = [], a = [], o = new Tn, s = new nr, l = 0; l <= e; l++) {
                var c = l / e;
                r[l] = this.getTangentAt(c, new Tn), r[l].normalize()
            }
            i[0] = new Tn, a[0] = new Tn;
            var u = Number.MAX_VALUE,
                d = Math.abs(r[0].x),
                h = Math.abs(r[0].y),
                f = Math.abs(r[0].z);
            d <= u && (u = d, n.set(1, 0, 0)), h <= u && (u = h, n.set(0, 1, 0)), f <= u && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]);
            for (var p, m = 1; m <= e; m++) i[m] = i[m - 1].clone(), a[m] = a[m - 1].clone(), o.crossVectors(r[m - 1], r[m]), o.length() > Number.EPSILON && (o.normalize(), p = Math.acos(mn.clamp(r[m - 1].dot(r[m]), -1, 1)), i[m].applyMatrix4(s.makeRotationAxis(o, p))), a[m].crossVectors(r[m], i[m]);
            if (!0 === t) {
                var v = Math.acos(mn.clamp(i[0].dot(i[e]), -1, 1));
                v /= e, 0 < r[0].dot(o.crossVectors(i[0], i[e])) && (v = -v);
                for (var g = 1; g <= e; g++) i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)), a[g].crossVectors(r[g], i[g])
            }
            return {
                tangents: r,
                normals: i,
                binormals: a
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), ((Yd.prototype = Object.create(Xd.prototype)).constructor = Yd).prototype.isEllipseCurve = !0, Yd.prototype.getPoint = function(e, t) {
        for (var n = t || new vn, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
        for (; r < i;) i -= r;
        i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
        var o = this.aStartAngle + e * i,
            s = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
        return 0 !== this.aRotation && (t = Math.cos(this.aRotation), a = Math.sin(this.aRotation), s = (e = s - this.aX) * t - (o = l - this.aY) * a + this.aX, l = e * a + o * t + this.aY), n.set(s, l)
    }, Yd.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, Yd.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, Yd.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, ((qd.prototype = Object.create(Yd.prototype)).constructor = qd).prototype.isArcCurve = !0;
    var Qd = new Tn,
        Kd = new Zd,
        Jd = new Zd,
        $d = new Zd;

    function eh() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
            t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "centripetal",
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : .5;
        Xd.call(this), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
    }

    function th(e, t, n, r, i) {
        var a = .5 * (r - t),
            t = .5 * (i - n),
            i = e * e;
        return (2 * n - 2 * r + a + t) * (e * i) + (-3 * n + 3 * r - 2 * a - t) * i + a * e + n
    }

    function nh(e, t, n, r) {
        return (i = 1 - (i = e)) * i * t + 2 * (1 - (t = e)) * t * n + (e = e) * e * r;
        var i
    }

    function rh(e, t, n, r, i) {
        return (a = 1 - (a = e)) * a * a * t + 3 * (t = 1 - (a = e)) * t * a * n + 3 * (1 - (n = e)) * n * n * r + (e = e) * e * e * i;
        var a
    }

    function ih() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new vn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new vn,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : new vn;
        Xd.call(this), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
    }

    function ah() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Tn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new Tn,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : new Tn;
        Xd.call(this), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
    }

    function oh() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new vn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn;
        Xd.call(this), this.type = "LineCurve", this.v1 = e, this.v2 = t
    }

    function sh() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Tn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn;
        Xd.call(this), this.type = "LineCurve3", this.v1 = e, this.v2 = t
    }

    function lh() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new vn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new vn;
        Xd.call(this), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
    }

    function ch() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : new Tn,
            t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : new Tn;
        Xd.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
    }

    function uh() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [];
        Xd.call(this), this.type = "SplineCurve", this.points = e
    }((eh.prototype = Object.create(Xd.prototype)).constructor = eh).prototype.isCatmullRomCurve3 = !0, eh.prototype.getPoint = function(e) {
        var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn,
            r = this.points,
            i = r.length,
            a = (i - (this.closed ? 0 : 1)) * e,
            o = Math.floor(a),
            s = a - o;
        this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / i) + 1) * i : 0 === s && o === i - 1 && (o = i - 2, s = 1), t = this.closed || 0 < o ? r[(o - 1) % i] : (Qd.subVectors(r[0], r[1]).add(r[0]), Qd);
        var l = r[o % i],
            e = r[(o + 1) % i],
            a = this.closed || o + 2 < i ? r[(o + 2) % i] : (Qd.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), Qd);
        return "centripetal" === this.curveType || "chordal" === this.curveType ? (o = "chordal" === this.curveType ? .5 : .25, r = Math.pow(t.distanceToSquared(l), o), (i = Math.pow(l.distanceToSquared(e), o)) < 1e-4 && (i = 1), r < 1e-4 && (r = i), (o = Math.pow(e.distanceToSquared(a), o)) < 1e-4 && (o = i), Kd.initNonuniformCatmullRom(t.x, l.x, e.x, a.x, r, i, o), Jd.initNonuniformCatmullRom(t.y, l.y, e.y, a.y, r, i, o), $d.initNonuniformCatmullRom(t.z, l.z, e.z, a.z, r, i, o)) : "catmullrom" === this.curveType && (Kd.initCatmullRom(t.x, l.x, e.x, a.x, this.tension), Jd.initCatmullRom(t.y, l.y, e.y, a.y, this.tension), $d.initCatmullRom(t.z, l.z, e.z, a.z, this.tension)), n.set(Kd.calc(s), Jd.calc(s), $d.calc(s)), n
    }, eh.prototype.copy = function(e) {
        Xd.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, eh.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, eh.prototype.fromJSON = function(e) {
        Xd.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new Tn).fromArray(r))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, ((ih.prototype = Object.create(Xd.prototype)).constructor = ih).prototype.isCubicBezierCurve = !0, ih.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn,
            n = this.v0,
            r = this.v1,
            i = this.v2,
            a = this.v3;
        return t.set(rh(e, n.x, r.x, i.x, a.x), rh(e, n.y, r.y, i.y, a.y)), t
    }, ih.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, ih.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, ih.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, ((ah.prototype = Object.create(Xd.prototype)).constructor = ah).prototype.isCubicBezierCurve3 = !0, ah.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn,
            n = this.v0,
            r = this.v1,
            i = this.v2,
            a = this.v3;
        return t.set(rh(e, n.x, r.x, i.x, a.x), rh(e, n.y, r.y, i.y, a.y), rh(e, n.z, r.z, i.z, a.z)), t
    }, ah.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, ah.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, ah.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, ((oh.prototype = Object.create(Xd.prototype)).constructor = oh).prototype.isLineCurve = !0, oh.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn;
        return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, oh.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, oh.prototype.getTangent = function(e, t) {
        t = t || new vn;
        return t.copy(this.v2).sub(this.v1).normalize(), t
    }, oh.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, oh.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, oh.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((sh.prototype = Object.create(Xd.prototype)).constructor = sh).prototype.isLineCurve3 = !0, sh.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn;
        return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
    }, sh.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, sh.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, sh.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, sh.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((lh.prototype = Object.create(Xd.prototype)).constructor = lh).prototype.isQuadraticBezierCurve = !0, lh.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn,
            n = this.v0,
            r = this.v1,
            i = this.v2;
        return t.set(nh(e, n.x, r.x, i.x), nh(e, n.y, r.y, i.y)), t
    }, lh.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, lh.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, lh.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((ch.prototype = Object.create(Xd.prototype)).constructor = ch).prototype.isQuadraticBezierCurve3 = !0, ch.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new Tn,
            n = this.v0,
            r = this.v1,
            i = this.v2;
        return t.set(nh(e, n.x, r.x, i.x), nh(e, n.y, r.y, i.y), nh(e, n.z, r.z, i.z)), t
    }, ch.prototype.copy = function(e) {
        return Xd.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, ch.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, ch.prototype.fromJSON = function(e) {
        return Xd.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((uh.prototype = Object.create(Xd.prototype)).constructor = uh).prototype.isSplineCurve = !0, uh.prototype.getPoint = function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : new vn,
            n = this.points,
            r = (n.length - 1) * e,
            i = Math.floor(r),
            a = r - i,
            o = n[0 === i ? i : i - 1],
            e = n[i],
            r = n[i > n.length - 2 ? n.length - 1 : i + 1],
            i = n[i > n.length - 3 ? n.length - 1 : i + 2];
        return t.set(th(a, o.x, e.x, r.x, i.x), th(a, o.y, e.y, r.y, i.y)), t
    }, uh.prototype.copy = function(e) {
        Xd.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }, uh.prototype.toJSON = function() {
        var e = Xd.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }, uh.prototype.fromJSON = function(e) {
        Xd.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new vn).fromArray(r))
        }
        return this
    };
    var dh, hh, fh = Object.freeze({
        __proto__: null,
        ArcCurve: qd,
        CatmullRomCurve3: eh,
        CubicBezierCurve: ih,
        CubicBezierCurve3: ah,
        EllipseCurve: Yd,
        LineCurve: oh,
        LineCurve3: sh,
        QuadraticBezierCurve: lh,
        QuadraticBezierCurve3: ch,
        SplineCurve: uh
    });

    function ph() {
        Xd.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function mh(e) {
        ph.call(this), this.type = "Path", this.currentPoint = new vn, e && this.setFromPoints(e)
    }

    function vh(e) {
        mh.call(this, e), this.uuid = mn.generateUUID(), this.type = "Shape", this.holes = []
    }

    function gh(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
        Er.call(this), this.type = "Light", this.color = new Qr(e), this.intensity = t, this.isFreeLight = void 0
    }

    function _h(e, t, n) {
        gh.call(this, e, n), this.type = "HemisphereLight", this.position.copy(Er.DefaultUp), this.updateMatrix(), this.groundColor = new Qr(t)
    }

    function yh(e, t, n, r, i, a) {
        gh.call(this, e, t), this.type = "SpotLight", this.position.copy(Er.DefaultUp), this.updateMatrix(), this.target = new Er, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new is
    }

    function xh() {
        ns.call(this, new la(90, 1, .5, 500)), this._frameExtents = new vn(4, 2), this._viewportCount = 6, this._viewports = [new Mn(2, 1, 1, 1), new Mn(0, 1, 1, 1), new Mn(3, 1, 1, 1), new Mn(1, 1, 1, 1), new Mn(3, 0, 1, 1), new Mn(1, 0, 1, 1)], this._cubeDirections = [new Tn(1, 0, 0), new Tn(-1, 0, 0), new Tn(0, 0, 1), new Tn(0, 0, -1), new Tn(0, 1, 0), new Tn(0, -1, 0)], this._cubeUps = [new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 1, 0), new Tn(0, 0, 1), new Tn(0, 0, -1)]
    }

    function bh(e, t, n, r) {
        gh.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new xh
    }

    function Mh() {
        ns.call(this, new ms(-5, 5, 5, -5, .5, 500))
    }

    function wh() {
        ns.call(this, new ms(-5, 5, 5, -5, .5, 500)), this.maxDistance = 10
    }

    function Sh(e, t) {
        gh.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Er.DefaultUp), this.updateMatrix(), this.target = new Er, this.shadow = new Mh
    }

    function Ah(e, t) {
        gh.call(this, e, t), this.type = "AmbientLight"
    }

    function Th(e, t, n, r) {
        gh.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
    }
    ph.prototype = Object.assign(Object.create(Xd.prototype), {
        constructor: ph,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new oh(t, e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= t) {
                    var i = n[r] - t,
                        a = this.curves[r],
                        o = a.getLength(),
                        o = 0 === o ? 0 : 1 - i / o;
                    return a.getPointAt(o)
                }
                r++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function() {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 40, t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function() {
            for (var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 12, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var a = i[r], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), l = 0; l < s.length; l++) {
                    var c = s[l];
                    e && e.equals(c) || (n.push(c), e = c)
                }
            return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function(e) {
            Xd.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push(r.clone())
            }
            return this.autoClose = e.autoClose, this
        },
        toJSON: function() {
            var e = Xd.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, n = this.curves.length; t < n; t++) {
                var r = this.curves[t];
                e.curves.push(r.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            Xd.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push((new fh[r.type]).fromJSON(r))
            }
            return this
        }
    }), mh.prototype = Object.assign(Object.create(ph.prototype), {
        constructor: mh,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
            return this
        },
        moveTo: function(e, t) {
            return this.currentPoint.set(e, t), this
        },
        lineTo: function(e, t) {
            var n = new oh(this.currentPoint.clone(), new vn(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this
        },
        quadraticCurveTo: function(e, t, n, r) {
            t = new lh(this.currentPoint.clone(), new vn(e, t), new vn(n, r));
            return this.curves.push(t), this.currentPoint.set(n, r), this
        },
        bezierCurveTo: function(e, t, n, r, i, a) {
            r = new ih(this.currentPoint.clone(), new vn(e, t), new vn(n, r), new vn(i, a));
            return this.curves.push(r), this.currentPoint.set(i, a), this
        },
        splineThru: function(e) {
            var t = new uh([this.currentPoint.clone()].concat(e));
            return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
        },
        arc: function(e, t, n, r, i, a) {
            var o = this.currentPoint.x,
                s = this.currentPoint.y;
            return this.absarc(e + o, t + s, n, r, i, a), this
        },
        absarc: function(e, t, n, r, i, a) {
            return this.absellipse(e, t, n, n, r, i, a), this
        },
        ellipse: function(e, t, n, r, i, a, o, s) {
            var l = this.currentPoint.x,
                c = this.currentPoint.y;
            return this.absellipse(e + l, t + c, n, r, i, a, o, s), this
        },
        absellipse: function(e, t, n, r, i, a, o, s) {
            o = new Yd(e, t, n, r, i, a, o, s);
            0 < this.curves.length && ((s = o.getPoint(0)).equals(this.currentPoint) || this.lineTo(s.x, s.y)), this.curves.push(o);
            o = o.getPoint(1);
            return this.currentPoint.copy(o), this
        },
        copy: function(e) {
            return ph.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function() {
            var e = ph.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function(e) {
            return ph.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), vh.prototype = Object.assign(Object.create(mh.prototype), {
        constructor: vh,
        getPointsHoles: function(e) {
            for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            mh.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function() {
            var e = mh.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, n = this.holes.length; t < n; t++) {
                var r = this.holes[t];
                e.holes.push(r.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            mh.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push((new mh).fromJSON(r))
            }
            return this
        }
    }), gh.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: gh,
        isLight: !0,
        copy: function(e) {
            return Er.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this.isFreeLight = e.isFreeLight, this
        },
        getWorldDirection: function(e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        toJSON: function(e) {
            e = Er.prototype.toJSON.call(this, e);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), _h.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: _h,
        isHemisphereLight: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), yh.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: yh,
        isSpotLight: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        },
        updateMatrixWorld: function(e) {
            Er.prototype.updateMatrixWorld.call(this, e), this.isFreeLight && this.updateFreeLightTarget()
        },
        updateFreeLightTarget: (dh = new Tn, function() {
            dh.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, dh), this.target.updateMatrix()
        })
    }), xh.prototype = Object.assign(Object.create(ns.prototype), {
        constructor: xh,
        isPointLightShadow: !0,
        updateMatrices: function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                n = this.camera,
                r = this.matrix,
                i = this._lightPositionWorld,
                a = this._lookTarget,
                o = this._projScreenMatrix;
            i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
        }
    }), bh.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: bh,
        isPointLight: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), Mh.prototype = Object.assign(Object.create(ns.prototype), {
        constructor: Mh,
        isDirectionalLightShadow: !0,
        updateMatrices: function(e) {
            ns.prototype.updateMatrices.call(this, e)
        }
    }), wh.prototype = Object.assign(Object.create(ns.prototype), {
        constructor: wh,
        isDirectionalLightShadowCSM: !0,
        copy: function(e) {
            return ns.prototype.copy.call(this, e), this.maxDistance = e.maxDistance, this
        }
    }), Sh.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: Sh,
        isDirectionalLight: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        },
        updateMatrixWorld: function(e) {
            Er.prototype.updateMatrixWorld.call(this, e), this.isFreeLight && this.updateFreeLightTarget()
        },
        updateFreeLightTarget: (hh = new Tn, function() {
            hh.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, hh), this.target.updateMatrix()
        })
    }), Ah.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: Ah,
        isAmbientLight: !0
    }), Th.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: Th,
        isRectAreaLight: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function(e) {
            e = gh.prototype.toJSON.call(this, e);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    });
    var Eh = function() {
        function t() {
            _classCallCheck(this, t), Object.defineProperty(this, "isSphericalHarmonics3", {
                value: !0
            }), this.coefficients = [];
            for (var e = 0; e < 9; e++) this.coefficients.push(new Tn)
        }
        return _createClass(t, [{
            key: "set",
            value: function(e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                return this
            }
        }, {
            key: "zero",
            value: function() {
                for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            }
        }, {
            key: "getAt",
            value: function(e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z,
                    e = this.coefficients;
                return t.copy(e[0]).multiplyScalar(.282095), t.addScaledVector(e[1], .488603 * r), t.addScaledVector(e[2], .488603 * i), t.addScaledVector(e[3], .488603 * n), t.addScaledVector(e[4], n * r * 1.092548), t.addScaledVector(e[5], r * i * 1.092548), t.addScaledVector(e[6], .315392 * (3 * i * i - 1)), t.addScaledVector(e[7], n * i * 1.092548), t.addScaledVector(e[8], .546274 * (n * n - r * r)), t
            }
        }, {
            key: "getIrradianceAt",
            value: function(e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z,
                    e = this.coefficients;
                return t.copy(e[0]).multiplyScalar(.886227), t.addScaledVector(e[1], 1.023328 * r), t.addScaledVector(e[2], 1.023328 * i), t.addScaledVector(e[3], 1.023328 * n), t.addScaledVector(e[4], .858086 * n * r), t.addScaledVector(e[5], .858086 * r * i), t.addScaledVector(e[6], .743125 * i * i - .247708), t.addScaledVector(e[7], .858086 * n * i), t.addScaledVector(e[8], .429043 * (n * n - r * r)), t
            }
        }, {
            key: "add",
            value: function(e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                return this
            }
        }, {
            key: "addScaledSH",
            value: function(e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            }
        }, {
            key: "scale",
            value: function(e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                return this
            }
        }, {
            key: "lerp",
            value: function(e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            }
        }, {
            key: "equals",
            value: function(e) {
                for (var t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                return !0
            }
        }, {
            key: "copy",
            value: function(e) {
                return this.set(e.coefficients)
            }
        }, {
            key: "clone",
            value: function() {
                return (new this.constructor).copy(this)
            }
        }, {
            key: "fromArray",
            value: function(e) {
                for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                return this
            }
        }, {
            key: "toArray",
            value: function() {
                for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                return e
            }
        }], [{
            key: "getBasisAt",
            value: function(e, t) {
                var n = e.x,
                    r = e.y,
                    e = e.z;
                t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * e, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * n * e, t[8] = .546274 * (n * n - r * r)
            }
        }]), t
    }();

    function Ch(e, t) {
        gh.call(this, void 0, t), this.type = "LightProbe", this.sh = void 0 !== e ? e : new Eh
    }

    function Lh(e) {
        kd.call(this, e), this.textures = {}
    }
    Ch.prototype = Object.assign(Object.create(gh.prototype), {
        constructor: Ch,
        isLightProbe: !0,
        copy: function(e) {
            return gh.prototype.copy.call(this, e), this.sh.copy(e.sh), this
        },
        fromJSON: function(e) {
            return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
        },
        toJSON: function(e) {
            e = gh.prototype.toJSON.call(this, e);
            return e.object.sh = this.sh.toArray(), e
        }
    }), Lh.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Lh,
        load: function(t, n, e, r) {
            var i = this,
                a = new zd(i.manager);
            a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function(e) {
                try {
                    n(i.parse(JSON.parse(e)))
                } catch (e) {
                    r ? r(e) : console.error(e), i.manager.itemError(t)
                }
            }, e, r)
        },
        parse: function(e) {
            var t = this.textures;

            function n(e) {
                return void 0 === t[e] && console.warn("v3d.MaterialLoader: Undefined texture", e), t[e]
            }
            var r, i = new bd[e.type];
            if (void 0 !== e.uuid && (i.uuid = e.uuid), void 0 !== e.name && (i.name = e.name), void 0 !== e.color && void 0 !== i.color && i.color.setHex(e.color), void 0 !== e.roughness && (i.roughness = e.roughness), void 0 !== e.metalness && (i.metalness = e.metalness), void 0 !== e.sheen && (i.sheen = (new Qr).setHex(e.sheen)), void 0 !== e.emissive && void 0 !== i.emissive && i.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== i.specular && i.specular.setHex(e.specular), void 0 !== e.shininess && (i.shininess = e.shininess), void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (i.fog = e.fog), void 0 !== e.flatShading && (i.flatShading = e.flatShading), void 0 !== e.blending && (i.blending = e.blending), void 0 !== e.combine && (i.combine = e.combine), void 0 !== e.side && (i.side = e.side), void 0 !== e.opacity && (i.opacity = e.opacity), void 0 !== e.transparent && (i.transparent = e.transparent), void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest), void 0 !== e.depthTest && (i.depthTest = e.depthTest), void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (i.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (i.rotation = e.rotation), 1 !== e.linewidth && (i.linewidth = e.linewidth), void 0 !== e.dashSize && (i.dashSize = e.dashSize), void 0 !== e.gapSize && (i.gapSize = e.gapSize), void 0 !== e.scale && (i.scale = e.scale), void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (i.skinning = e.skinning), void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals), void 0 !== e.dithering && (i.dithering = e.dithering), void 0 !== e.vertexTangents && (i.vertexTangents = e.vertexTangents), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? i.vertexColors = 0 < e.vertexColors : i.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                for (var a in e.uniforms) {
                    var o = e.uniforms[a];
                    switch (i.uniforms[a] = {}, o.type) {
                        case "t":
                            i.uniforms[a].value = n(o.value);
                            break;
                        case "c":
                            i.uniforms[a].value = (new Qr).setHex(o.value);
                            break;
                        case "v2":
                            i.uniforms[a].value = (new vn).fromArray(o.value);
                            break;
                        case "v3":
                            i.uniforms[a].value = (new Tn).fromArray(o.value);
                            break;
                        case "v4":
                            i.uniforms[a].value = (new Mn).fromArray(o.value);
                            break;
                        case "m3":
                            i.uniforms[a].value = (new gn).fromArray(o.value);
                            break;
                        case "m4":
                            i.uniforms[a].value = (new nr).fromArray(o.value);
                            break;
                        default:
                            i.uniforms[a].value = o.value
                    }
                }
            if (void 0 !== e.defines && (i.defines = e.defines), void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var s in e.extensions) i.extensions[s] = e.extensions[s];
            return void 0 !== e.shading && (i.flatShading = 1 === e.shading), void 0 !== e.size && (i.size = e.size), void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (i.map = n(e.map)), void 0 !== e.matcap && (i.matcap = n(e.matcap)), void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale), void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType), void 0 !== e.normalScale && (r = e.normalScale, !1 === Array.isArray(r) && (r = [r, r]), i.normalScale = (new vn).fromArray(r)), void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)), void 0 !== e.envMap && (i.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = (new vn).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmission && (i.transmission = e.transmission), void 0 !== e.transmissionMap && (i.transmissionMap = n(e.transmissionMap)), i
        },
        setTextures: function(e) {
            return this.textures = e, this
        }
    });
    var Ph = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };

    function Rh() {
        Oi.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }

    function Dh(e, t, n, r) {
        "number" == typeof n && (r = n, n = !1, console.error("v3d.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), ri.call(this, e, t, n), this.meshPerAttribute = r || 1
    }

    function Oh(e) {
        kd.call(this, e)
    }
    Rh.prototype = Object.assign(Object.create(Oi.prototype), {
        constructor: Rh,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return Oi.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = Oi.prototype.toJSON.call(this);
            return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
        }
    }), Dh.prototype = Object.assign(Object.create(ri.prototype), {
        constructor: Dh,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return ri.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function() {
            var e = ri.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Oh.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Oh,
        load: function(t, n, e, r) {
            var i = this,
                a = new zd(i.manager);
            a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function(e) {
                try {
                    n(i.parse(JSON.parse(e)))
                } catch (e) {
                    r ? r(e) : console.error(e), i.manager.itemError(t)
                }
            }, e, r)
        },
        parse: function(e) {
            var r = {},
                i = {};

            function t(e, t) {
                if (void 0 !== r[t]) return r[t];
                var n = e.interleavedBuffers[t],
                    e = function(e, t) {
                        if (void 0 !== i[t]) return i[t];
                        e = e.arrayBuffers[t], e = new Uint32Array(e).buffer;
                        return i[t] = e
                    }(e, n.buffer),
                    e = new zs(gi(n.type, e), n.stride);
                return e.uuid = n.uuid, r[t] = e
            }
            var n = new(e.isInstancedBufferGeometry ? Rh : Oi),
                a = e.data.index;
            void 0 !== a && (w = gi(a.type, a.array), n.setIndex(new ri(w, 1)));
            var o, s = e.data.attributes;
            for (o in s) {
                var l, c = s[o],
                    u = void 0;
                u = c.isInterleavedBufferAttribute ? new Gs(t(e.data, c.data), c.itemSize, c.offset, c.normalized) : (l = gi(c.type, c.array), new(c.isInstancedBufferAttribute ? Dh : ri)(l, c.itemSize, c.normalized)), void 0 !== c.name && (u.name = c.name), n.setAttribute(o, u)
            }
            var d = e.data.morphAttributes;
            if (d)
                for (var h in d) {
                    for (var f = d[h], p = [], m = 0, v = f.length; m < v; m++) {
                        var g = f[m],
                            _ = void 0;
                        _ = g.isInterleavedBufferAttribute ? new Gs(t(e.data, g.data), g.itemSize, g.offset, g.normalized) : new ri(gi(g.type, g.array), g.itemSize, g.normalized), void 0 !== g.name && (_.name = g.name), p.push(_)
                    }
                    n.morphAttributes[h] = p
                }
            e.data.morphTargetsRelative && (n.morphTargetsRelative = !0);
            var y = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== y)
                for (var x = 0, b = y.length; x !== b; ++x) {
                    var M = y[x];
                    n.addGroup(M.start, M.count, M.materialIndex)
                }
            var w, a = e.data.boundingSphere;
            return void 0 !== a && (w = new Tn, void 0 !== a.center && w.fromArray(a.center), n.boundingSphere = new Yn(w, a.radius)), e.name && (n.name = e.name), e.userData && (n.userData = e.userData), n
        }
    });
    var Nh, Ih = function() {
            _inherits(n, kd);
            var t = _createSuper(n);

            function n(e) {
                return _classCallCheck(this, n), t.call(this, e)
            }
            return _createClass(n, [{
                key: "load",
                value: function(r, i, e, a) {
                    var o = this,
                        t = "" === this.path ? Ph.extractUrlBase(r) : this.path;
                    this.resourcePath = this.resourcePath || t;
                    t = new zd(this.manager);
                    t.setPath(this.path), t.setRequestHeader(this.requestHeader), t.setWithCredentials(this.withCredentials), t.load(r, function(e) {
                        var t = null;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            return void 0 !== a && a(e), void console.error("v3d:ObjectLoader: Can't parse " + r + ".", e.message)
                        }
                        var n = t.metadata;
                        void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? o.parse(t, i) : console.error("v3d.ObjectLoader: Can't load " + r)
                    }, e, a)
                }
            }, {
                key: "parse",
                value: function(e, t) {
                    var n = this.parseAnimations(e.animations),
                        r = this.parseShapes(e.shapes),
                        i = this.parseGeometries(e.geometries, r),
                        a = this.parseImages(e.images, function() {
                            void 0 !== t && t(o)
                        }),
                        r = this.parseTextures(e.textures, a),
                        r = this.parseMaterials(e.materials, r),
                        o = this.parseObject(e.object, i, r, n),
                        e = this.parseSkeletons(e.skeletons, o);
                    if (this.bindSkeletons(o, e), void 0 !== t) {
                        var s, l = !1;
                        for (s in a)
                            if (a[s] instanceof HTMLImageElement) {
                                l = !0;
                                break
                            }! 1 === l && t(o)
                    }
                    return o
                }
            }, {
                key: "parseShapes",
                value: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var i = (new vh).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                }
            }, {
                key: "parseSkeletons",
                value: function(e, t) {
                    var n = {},
                        r = {};
                    if (t.traverse(function(e) {
                            e.isBone && (r[e.uuid] = e)
                        }), void 0 !== e)
                        for (var i = 0, a = e.length; i < a; i++) {
                            var o = (new vl).fromJSON(e[i], r);
                            n[o.uuid] = o
                        }
                    return n
                }
            }, {
                key: "parseGeometries",
                value: function(e, t) {
                    var n, r = {};
                    if (void 0 !== e)
                        for (var i = new Oh, a = 0, o = e.length; a < o; a++) {
                            var s = void 0,
                                l = e[a];
                            switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new uu[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new uu[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new uu[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new uu[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new uu[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new uu[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new uu[l.type](l.radius, l.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new uu[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new uu[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new uu[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    s = new uu[l.type]((new fh[l.path.type]).fromJSON(l.path), l.tubularSegments, l.radius, l.radialSegments, l.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new uu[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new uu[l.type](l.vertices, l.indices, l.radius, l.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    n = [];
                                    for (var c = 0, u = l.shapes.length; c < u; c++) {
                                        var d = t[l.shapes[c]];
                                        n.push(d)
                                    }
                                    s = new uu[l.type](n, l.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    n = [];
                                    for (var h = 0, f = l.shapes.length; h < f; h++) {
                                        var p = t[l.shapes[h]];
                                        n.push(p)
                                    }
                                    var m = l.options.extrudePath;
                                    void 0 !== m && (l.options.extrudePath = (new fh[m.type]).fromJSON(m)), s = new uu[l.type](n, l.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = i.parse(l);
                                    break;
                                case "Geometry":
                                    console.error('v3d.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                    break;
                                default:
                                    console.warn('v3d.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                                    continue
                            }
                            s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), !0 === s.isBufferGeometry && void 0 !== l.userData && (s.userData = l.userData), r[l.uuid] = s
                        }
                    return r
                }
            }, {
                key: "parseMaterials",
                value: function(e, t) {
                    var n = {},
                        r = {};
                    if (void 0 !== e) {
                        var i = new Lh;
                        i.setTextures(t);
                        for (var a = 0, o = e.length; a < o; a++) {
                            var s = e[a];
                            if ("MultiMaterial" === s.type) {
                                for (var l = [], c = 0; c < s.materials.length; c++) {
                                    var u = s.materials[c];
                                    void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)), l.push(n[u.uuid])
                                }
                                r[s.uuid] = l
                            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                        }
                    }
                    return r
                }
            }, {
                key: "parseAnimations",
                value: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n],
                                r = Dd.parse(r);
                            t[r.uuid] = r
                        }
                    return t
                }
            }, {
                key: "parseImages",
                value: function(e, t) {
                    var n = this,
                        r = {};

                    function i(e) {
                        if ("string" != typeof e) return e.data ? {
                            data: gi(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null;
                        var t, e = e,
                            e = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
                        return t = e, n.manager.itemStart(t), a.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemError(t), n.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== e && 0 < e.length) {
                        var a, t = new Id(t);
                        (a = new Gd(t)).setCrossOrigin(this.crossOrigin);
                        for (var o = 0, s = e.length; o < s; o++) {
                            var l = e[o],
                                c = l.url;
                            if (Array.isArray(c)) {
                                r[l.uuid] = [];
                                for (var u = 0, d = c.length; u < d; u++) {
                                    var h = i(c[u]);
                                    null !== h && (h instanceof HTMLImageElement ? r[l.uuid].push(h) : r[l.uuid].push(new ha(h.data, h.width, h.height)))
                                }
                            } else {
                                var f = i(l.url);
                                null !== f && (r[l.uuid] = f)
                            }
                        }
                    }
                    return r
                }
            }, {
                key: "parseTextures",
                value: function(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("v3d.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    var r = {};
                    if (void 0 !== e)
                        for (var i = 0, a = e.length; i < a; i++) {
                            var o = e[i];
                            void 0 === o.image && console.warn('v3d.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("v3d.ObjectLoader: Undefined image", o.image);
                            var s = void 0,
                                l = t[o.image];
                            Array.isArray(l) ? (s = new ua(l), 6 === l.length && (s.needsUpdate = !0)) : (s = l && l.data ? new ha(l.data, l.width, l.height) : new xn(l), l && (s.needsUpdate = !0)), s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, Fh)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], kh), s.wrapT = n(o.wrap[1], kh)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Bh)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Bh)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), r[o.uuid] = s
                        }
                    return r
                }
            }, {
                key: "parseObject",
                value: function(e, t, a, n) {
                    var r, i;

                    function o(e) {
                        return void 0 === t[e] && console.warn("v3d.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function s(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], n = 0, r = e.length; n < r; n++) {
                                    var i = e[n];
                                    void 0 === a[i] && console.warn("v3d.ObjectLoader: Undefined material", i), t.push(a[i])
                                }
                                return t
                            }
                            return void 0 === a[e] && console.warn("v3d.ObjectLoader: Undefined material", e), a[e]
                        }
                    }
                    switch (e.type) {
                        case "Scene":
                            l = new _a, void 0 !== e.background && Number.isInteger(e.background) && (l.background = new Qr(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? l.fog = new Bs(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (l.fog = new ks(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            l = new la(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (l.focus = e.focus), void 0 !== e.zoom && (l.zoom = e.zoom), void 0 !== e.filmGauge && (l.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (l.filmOffset = e.filmOffset), void 0 !== e.view && (l.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            l = new ms(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (l.zoom = e.zoom), void 0 !== e.view && (l.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            l = new Ah(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            l = new Sh(e.color, e.intensity);
                            break;
                        case "PointLight":
                            l = new bh(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            l = new Th(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            l = new yh(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            l = new _h(e.color, e.groundColor, e.intensity);
                            break;
                        case "LightProbe":
                            l = (new Ch).fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            l = new hl(r = o(e.geometry), i = s(e.material)), void 0 !== e.bindMode && (l.bindMode = e.bindMode), void 0 !== e.bindMatrix && l.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (l.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            l = new Ki(r = o(e.geometry), i = s(e.material));
                            break;
                        case "InstancedMesh":
                            r = o(e.geometry), i = s(e.material);
                            var l, c = e.count,
                                u = e.instanceMatrix;
                            (l = new bl(r, i, c)).instanceMatrix = new ri(new Float32Array(u.array), 16);
                            break;
                        case "LOD":
                            l = new ol;
                            break;
                        case "Line":
                            l = new Cl(o(e.geometry), s(e.material));
                            break;
                        case "LineLoop":
                            l = new Dl(o(e.geometry), s(e.material));
                            break;
                        case "LineSegments":
                            l = new Rl(o(e.geometry), s(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            l = new Bl(o(e.geometry), s(e.material));
                            break;
                        case "Sprite":
                            l = new nl(s(e.material));
                            break;
                        case "Group":
                            l = new As;
                            break;
                        case "Bone":
                            l = new fl;
                            break;
                        default:
                            l = new Er
                    }
                    if (l.uuid = e.uuid, void 0 !== e.name && (l.name = e.name), void 0 !== e.matrix ? (l.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (void 0 !== e.position && l.position.fromArray(e.position), void 0 !== e.rotation && l.rotation.fromArray(e.rotation), void 0 !== e.quaternion && l.quaternion.fromArray(e.quaternion), void 0 !== e.scale && l.scale.fromArray(e.scale)), void 0 !== e.castShadow && (l.castShadow = e.castShadow), void 0 !== e.receiveShadow && (l.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (l.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (l.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (l.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && l.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (l.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (l.visible = e.visible), void 0 !== e.frustumCulled && (l.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (l.renderOrder = e.renderOrder), void 0 !== e.userData && (l.userData = e.userData), void 0 !== e.layers && (l.layers.mask = e.layers), void 0 !== e.children)
                        for (var d = e.children, h = 0; h < d.length; h++) l.add(this.parseObject(d[h], t, a, n));
                    if (void 0 !== e.animations)
                        for (var f = e.animations, p = 0; p < f.length; p++) {
                            var m = f[p];
                            l.animations.push(n[m])
                        }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (l.autoUpdate = e.autoUpdate);
                        for (var v = e.levels, g = 0; g < v.length; g++) {
                            var _ = v[g],
                                y = l.getObjectByProperty("uuid", _.object);
                            void 0 !== y && l.addLevel(y, _.distance)
                        }
                    }
                    return l
                }
            }, {
                key: "bindSkeletons",
                value: function(e, n) {
                    0 !== Object.keys(n).length && e.traverse(function(e) {
                        var t;
                        !0 === e.isSkinnedMesh && void 0 !== e.skeleton && (void 0 === (t = n[e.skeleton]) ? console.warn("v3d.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(t, e.bindMatrix))
                    })
                }
            }, {
                key: "setTexturePath",
                value: function(e) {
                    return console.warn("v3d.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }]), n
        }(),
        Fh = {
            UVMapping: o,
            CubeReflectionMapping: N,
            CubeRefractionMapping: I,
            EquirectangularReflectionMapping: F,
            EquirectangularRefractionMapping: k,
            CubeUVReflectionMapping: B,
            CubeUVRefractionMapping: z
        },
        kh = {
            RepeatWrapping: U,
            ClampToEdgeWrapping: V,
            MirroredRepeatWrapping: Fe
        },
        Bh = {
            NearestFilter: ke,
            NearestMipmapNearestFilter: Be,
            NearestMipmapLinearFilter: ze,
            LinearFilter: Ue,
            LinearMipmapNearestFilter: Ve,
            LinearMipmapLinearFilter: Ge
        };

    function zh(e) {
        "undefined" == typeof createImageBitmap && console.warn("v3d.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("v3d.ImageBitmapLoader: fetch() not supported."), kd.call(this, e), this.options = {
            premultiplyAlpha: "none"
        }
    }

    function Uh() {
        this.type = "ShapePath", this.color = new Qr, this.subPaths = [], this.currentPath = null
    }

    function Vh(e) {
        this.type = "Font", this.data = e
    }

    function Gh(e, t, n) {
        for (var r = 0, i = 0; i < e.length; i++) {
            var a = e[i];
            r += (n.glyphs[a] || n.glyphs["?"]).ha * t
        }
        return r
    }

    function jh(e) {
        kd.call(this, e)
    }
    zh.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: zh,
        isImageBitmapLoader: !0,
        setOptions: function(e) {
            return this.options = e, this
        },
        load: function(t, n, e, r) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                a = Nd.get(t);
            if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function() {
                n && n(a), i.manager.itemEnd(t)
            }, 0), a;
            var o = {};
            o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, o).then(function(e) {
                return e.blob()
            }).then(function(e) {
                return createImageBitmap(e, i.options)
            }).then(function(e) {
                Nd.add(t, e), n && n(e), i.manager.itemEnd(t)
            }).catch(function(e) {
                r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
            }), i.manager.itemStart(t)
        }
    }), Object.assign(Uh.prototype, {
        moveTo: function(e, t) {
            return this.currentPath = new mh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
        },
        lineTo: function(e, t) {
            return this.currentPath.lineTo(e, t), this
        },
        quadraticCurveTo: function(e, t, n, r) {
            return this.currentPath.quadraticCurveTo(e, t, n, r), this
        },
        bezierCurveTo: function(e, t, n, r, i, a) {
            return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this
        },
        splineThru: function(e) {
            return this.currentPath.splineThru(e), this
        },
        toShapes: function(e, t) {
            function n(e) {
                for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n],
                        a = new vh;
                    a.curves = i.curves, t.push(a)
                }
                return t
            }
            var r, i, a, o = Ec.isClockWise,
                s = this.subPaths;
            if (0 === s.length) return [];
            if (!0 === t) return n(s);
            var l = [];
            if (1 === s.length) return i = s[0], (a = new vh).curves = i.curves, l.push(a), l;
            var c, u = !o(s[0].getPoints()),
                u = e ? !u : u,
                d = [],
                h = [],
                f = [],
                p = 0;
            h[p] = void 0, f[p] = [];
            for (var m, v = 0, g = s.length; v < g; v++) r = o(c = (i = s[v]).getPoints()), (r = e ? !r : r) ? (!u && h[p] && p++, h[p] = {
                s: new vh,
                p: c
            }, h[p].s.curves = i.curves, u && p++, f[p] = []) : f[p].push({
                h: i,
                p: c[0]
            });
            if (!h[0]) return n(s);
            if (1 < h.length) {
                for (var _ = !1, y = [], x = 0, b = h.length; x < b; x++) d[x] = [];
                for (var M = 0, w = h.length; M < w; M++)
                    for (var S = f[M], A = 0; A < S.length; A++) {
                        for (var T = S[A], E = !0, C = 0; C < h.length; C++) ! function(e, t) {
                            for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
                                var o = t[i],
                                    s = t[a],
                                    l = s.x - o.x,
                                    c = s.y - o.y;
                                if (Math.abs(c) > Number.EPSILON) {
                                    if (c < 0 && (o = t[a], l = -l, s = t[i], c = -c), !(e.y < o.y || e.y > s.y))
                                        if (e.y === o.y) {
                                            if (e.x === o.x) return 1
                                        } else {
                                            l = c * (e.x - o.x) - l * (e.y - o.y);
                                            if (0 == l) return 1;
                                            l < 0 || (r = !r)
                                        }
                                } else if (e.y === o.y && (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x)) return 1
                            }
                            return r
                        }(T.p, h[C].p) || (M !== C && y.push({
                            froms: M,
                            tos: C,
                            hole: A
                        }), E ? (E = !1, d[C].push(T)) : _ = !0);
                        E && d[M].push(T)
                    }
                0 < y.length && (_ || (f = d))
            }
            for (var L = 0, P = h.length; L < P; L++) {
                a = h[L].s, l.push(a);
                for (var R = 0, D = (m = f[L]).length; R < D; R++) a.holes.push(m[R].h)
            }
            return l
        }
    }), Object.assign(Vh.prototype, {
        isFont: !0,
        generateShapes: function(e) {
            for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 100, n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "left", r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : "topBaseline", i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : -1, a = 5 < arguments.length && void 0 !== arguments[5] && arguments[5], o = [], s = function(e, t, n, r, i, a, o) {
                    for (var s = String(e).split("\n"), l = [], c = 0; c < s.length; c++) {
                        var u = s[c];
                        l[c] = Array.from ? Array.from(u) : String(u).split("")
                    }
                    var d = t / n.resolution;
                    o && (d *= (n.ascender - n.descender) / (n.boundingBox.yMax - n.boundingBox.yMin));
                    n.lineGap = n.lineGap || 0, -1 === a ? a = (n.ascender - n.descender + n.lineGap) * d : a *= t;
                    var h = [],
                        f = 0,
                        p = 0,
                        m = l.length,
                        v = a * m,
                        t = a * Math.abs(n.descender) / n.ascender,
                        g = a - t;
                    switch (i) {
                        case "topBaseline":
                            p = 0;
                            break;
                        case "top":
                            p = -g;
                            break;
                        case "center":
                            p = 1 < m ? .5 * v - g : -n.ascender / 2 * d;
                            break;
                        case "bottom":
                            p = v - a - n.descender * d;
                            break;
                        case "bottomBaseline":
                            p = v - a;
                            break;
                        default:
                            p = 0
                    }
                    for (var _ = 0; _ < l.length; _++) {
                        var y = l[_];
                        switch (r) {
                            case "left":
                                f = 0;
                                break;
                            case "center":
                                f = -Gh(y, d, n) / 2;
                                break;
                            case "right":
                                f = -Gh(y, d, n);
                                break;
                            default:
                                f = 0
                        }
                        for (var x = 0; x < y.length; x++) {
                            var b = function(e, t, n, r, i) {
                                var a = i.glyphs[e] || i.glyphs["?"];
                                if (!a) return void console.error('v3d.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".");
                                var o, s, l, c, u, d, h, f, p = new Uh;
                                if (a.o)
                                    for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) switch (m[v++]) {
                                        case "m":
                                            o = m[v++] * t + n, s = m[v++] * t + r, p.moveTo(o, s);
                                            break;
                                        case "l":
                                            o = m[v++] * t + n, s = m[v++] * t + r, p.lineTo(o, s);
                                            break;
                                        case "q":
                                            l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, d = m[v++] * t + r, p.quadraticCurveTo(u, d, l, c);
                                            break;
                                        case "b":
                                            l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, d = m[v++] * t + r, h = m[v++] * t + n, f = m[v++] * t + r, p.bezierCurveTo(u, d, h, f, l, c)
                                    }
                                return {
                                    offsetX: a.ha * t,
                                    path: p
                                }
                            }(y[x], d, f, p, n);
                            f += b.offsetX, h.push(b.path)
                        }
                        p -= a
                    }
                    return h
                }(e, t, this.data, n, r, i, a), l = 0, c = s.length; l < c; l++) Array.prototype.push.apply(o, s[l].toShapes());
            return o
        }
    }), jh.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: jh,
        load: function(e, r, t, n) {
            var i = this,
                a = new zd(this.manager);
            a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function(t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("v3d.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                }
                var e = i.parse(n);
                r && r(e)
            }, t, n)
        },
        parse: function(e) {
            return new Vh(e)
        }
    });
    var Wh = {
        getContext: function() {
            return void 0 === Nh && (Nh = new(window.AudioContext || window.webkitAudioContext)), Nh
        },
        setContext: function(e) {
            Nh = e
        }
    };

    function Hh(e) {
        kd.call(this, e)
    }

    function Xh(e, t, n) {
        Ch.call(this, void 0, n);
        var r = (new Qr).set(e),
            n = (new Qr).set(t),
            e = new Tn(r.r, r.g, r.b),
            t = new Tn(n.r, n.g, n.b),
            r = Math.sqrt(Math.PI),
            n = r * Math.sqrt(.75);
        this.sh.coefficients[0].copy(e).add(t).multiplyScalar(r), this.sh.coefficients[1].copy(e).sub(t).multiplyScalar(n)
    }

    function Yh(e, t) {
        Ch.call(this, void 0, t);
        e = (new Qr).set(e);
        this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Hh.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: Hh,
        load: function(n, r, e, i) {
            var a = this,
                t = new zd(a.manager);
            t.setResponseType("arraybuffer"), t.setPath(a.path), t.setRequestHeader(a.requestHeader), t.setWithCredentials(a.withCredentials), t.load(n, function(e) {
                try {
                    var t = e.slice(0);
                    Wh.getContext().decodeAudioData(t, function(e) {
                        r(e)
                    })
                } catch (e) {
                    i ? i(e) : console.error(e), a.manager.itemError(n)
                }
            }, e, i)
        }
    }), Xh.prototype = Object.assign(Object.create(Ch.prototype), {
        constructor: Xh,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return Ch.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return Ch.prototype.toJSON.call(this, e)
        }
    }), Yh.prototype = Object.assign(Object.create(Ch.prototype), {
        constructor: Yh,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return Ch.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return Ch.prototype.toJSON.call(this, e)
        }
    });
    var qh = new nr,
        Zh = new nr;

    function Qh() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new la, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new la, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    Object.assign(Qh.prototype, {
        update: function(e) {
            var t, n, r, i, a, o = this._cache;
            o.focus === e.focus && o.fov === e.fov && o.aspect === e.aspect * this.aspect && o.near === e.near && o.far === e.far && o.zoom === e.zoom && o.eyeSep === this.eyeSep || (o.focus = e.focus, o.fov = e.fov, o.aspect = e.aspect * this.aspect, o.near = e.near, o.far = e.far, o.zoom = e.zoom, o.eyeSep = this.eyeSep, t = e.projectionMatrix.clone(), n = (a = o.eyeSep / 2) * o.near / o.focus, r = o.near * Math.tan(mn.DEG2RAD * o.fov * .5) / o.zoom, Zh.elements[12] = -a, qh.elements[12] = a, i = -r * o.aspect + n, a = r * o.aspect + n, t.elements[0] = 2 * o.near / (a - i), t.elements[8] = (a + i) / (a - i), this.cameraL.projectionMatrix.copy(t), i = -r * o.aspect - n, a = r * o.aspect - n, t.elements[0] = 2 * o.near / (a - i), t.elements[8] = (a + i) / (a - i), this.cameraR.projectionMatrix.copy(t)), this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Zh), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(qh)
        }
    });
    var Kh = function() {
        function t(e) {
            _classCallCheck(this, t), this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }
        return _createClass(t, [{
            key: "start",
            value: function() {
                this.startTime = Jh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
        }, {
            key: "stop",
            value: function() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
        }, {
            key: "getElapsedTime",
            value: function() {
                return this.getDelta(), this.elapsedTime
            }
        }, {
            key: "getDelta",
            value: function() {
                var e, t = 0;
                return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (t = ((e = Jh()) - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t), t)
            }
        }]), t
    }();

    function Jh() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }
    var $h = new Tn,
        ef = new An,
        tf = new Tn,
        nf = new Tn,
        rf = function() {
            _inherits(r, Er);
            var t = _createSuper(r);

            function r() {
                var e;
                return _classCallCheck(this, r), (e = t.call(this)).type = "AudioListener", e.context = Wh.getContext(), e.gain = e.context.createGain(), e.gain.connect(e.context.destination), e.filter = null, e.timeDelta = 0, e._clock = new Kh, e
            }
            return _createClass(r, [{
                key: "getInput",
                value: function() {
                    return this.gain
                }
            }, {
                key: "removeFilter",
                value: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
            }, {
                key: "getFilter",
                value: function() {
                    return this.filter
                }
            }, {
                key: "setFilter",
                value: function(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
            }, {
                key: "getMasterVolume",
                value: function() {
                    return this.gain.gain.value
                }
            }, {
                key: "setMasterVolume",
                value: function(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }, {
                key: "updateMatrixWorld",
                value: function(e) {
                    _get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e);
                    var t = this.context.listener,
                        n = this.up;
                    this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose($h, ef, tf), nf.set(0, 0, -1).applyQuaternion(ef), t.positionX ? (e = this.context.currentTime + this.timeDelta, t.positionX.linearRampToValueAtTime($h.x, e), t.positionY.linearRampToValueAtTime($h.y, e), t.positionZ.linearRampToValueAtTime($h.z, e), t.forwardX.linearRampToValueAtTime(nf.x, e), t.forwardY.linearRampToValueAtTime(nf.y, e), t.forwardZ.linearRampToValueAtTime(nf.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)) : (t.setPosition($h.x, $h.y, $h.z), t.setOrientation(nf.x, nf.y, nf.z, n.x, n.y, n.z))
                }
            }]), r
        }(),
        af = function() {
            _inherits(r, Er);
            var n = _createSuper(r);

            function r(e) {
                var t;
                return _classCallCheck(this, r), (t = n.call(this)).type = "Audio", t.listener = e, t.context = e.context, t.gain = t.context.createGain(), t.gain.connect(e.getInput()), t.autoplay = !1, t.buffer = null, t.detune = 0, t.loop = !1, t.loopStart = 0, t.loopEnd = 0, t.offset = 0, t.duration = void 0, t.playbackRate = 1, t.isPlaying = !1, t.hasPlaybackControl = !0, t.source = null, t.sourceType = "empty", t._startedAt = 0, t._progress = 0, t._connected = !1, t.filters = [], t
            }
            return _createClass(r, [{
                key: "getOutput",
                value: function() {
                    return this.gain
                }
            }, {
                key: "setNodeSource",
                value: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
            }, {
                key: "setMediaElementSource",
                value: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
            }, {
                key: "setMediaStreamSource",
                value: function(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
            }, {
                key: "setBuffer",
                value: function(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
            }, {
                key: "play",
                value: function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            this._startedAt = this.context.currentTime + e;
                            e = this.context.createBufferSource();
                            return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        console.warn("v3d.Audio: this Audio has no playback control.")
                    } else console.warn("v3d.Audio: Audio is already playing.")
                }
            }, {
                key: "pause",
                value: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("v3d.Audio: this Audio has no playback control.")
                }
            }, {
                key: "stop",
                value: function() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("v3d.Audio: this Audio has no playback control.")
                }
            }, {
                key: "connect",
                value: function() {
                    if (0 < this.filters.length) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
            }, {
                key: "disconnect",
                value: function() {
                    if (0 < this.filters.length) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
            }, {
                key: "getFilters",
                value: function() {
                    return this.filters
                }
            }, {
                key: "setFilters",
                value: function(e) {
                    return e = e || [], !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
            }, {
                key: "setDetune",
                value: function(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
            }, {
                key: "getDetune",
                value: function() {
                    return this.detune
                }
            }, {
                key: "getFilter",
                value: function() {
                    return this.getFilters()[0]
                }
            }, {
                key: "setFilter",
                value: function(e) {
                    return this.setFilters(e ? [e] : [])
                }
            }, {
                key: "setPlaybackRate",
                value: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("v3d.Audio: this Audio has no playback control.")
                }
            }, {
                key: "getPlaybackRate",
                value: function() {
                    return this.playbackRate
                }
            }, {
                key: "onEnded",
                value: function() {
                    this.isPlaying = !1
                }
            }, {
                key: "getLoop",
                value: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("v3d.Audio: this Audio has no playback control."), !1) : this.loop
                }
            }, {
                key: "setLoop",
                value: function(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("v3d.Audio: this Audio has no playback control.")
                }
            }, {
                key: "setLoopStart",
                value: function(e) {
                    return this.loopStart = e, this
                }
            }, {
                key: "setLoopEnd",
                value: function(e) {
                    return this.loopEnd = e, this
                }
            }, {
                key: "getVolume",
                value: function() {
                    return this.gain.gain.value
                }
            }, {
                key: "setVolume",
                value: function(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }]), r
        }(),
        of = new Tn,
        sf = new An,
        lf = new Tn,
        cf = new Tn,
        uf = function() {
            _inherits(n, af);
            var t = _createSuper(n);

            function n(e) {
                return _classCallCheck(this, n), (e = t.call(this, e)).panner = e.context.createPanner(), e.panner.panningModel = "HRTF", e.panner.connect(e.gain), e
            }
            return _createClass(n, [{
                key: "getOutput",
                value: function() {
                    return this.panner
                }
            }, {
                key: "getRefDistance",
                value: function() {
                    return this.panner.refDistance
                }
            }, {
                key: "setRefDistance",
                value: function(e) {
                    return this.panner.refDistance = e, this
                }
            }, {
                key: "getRolloffFactor",
                value: function() {
                    return this.panner.rolloffFactor
                }
            }, {
                key: "setRolloffFactor",
                value: function(e) {
                    return this.panner.rolloffFactor = e, this
                }
            }, {
                key: "getDistanceModel",
                value: function() {
                    return this.panner.distanceModel
                }
            }, {
                key: "setDistanceModel",
                value: function(e) {
                    return this.panner.distanceModel = e, this
                }
            }, {
                key: "getMaxDistance",
                value: function() {
                    return this.panner.maxDistance
                }
            }, {
                key: "setMaxDistance",
                value: function(e) {
                    return this.panner.maxDistance = e, this
                }
            }, {
                key: "setDirectionalCone",
                value: function(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
            }, {
                key: "updateMatrixWorld",
                value: function(e) {
                    var t;
                    _get(_getPrototypeOf(n.prototype), "updateMatrixWorld", this).call(this, e), !0 === this.hasPlaybackControl && !1 === this.isPlaying || (this.matrixWorld.decompose( of , sf, lf), cf.set(0, 0, 1).applyQuaternion(sf), (t = this.panner).positionX ? (e = this.context.currentTime + this.listener.timeDelta, t.positionX.linearRampToValueAtTime( of .x, e), t.positionY.linearRampToValueAtTime( of .y, e), t.positionZ.linearRampToValueAtTime( of .z, e), t.orientationX.linearRampToValueAtTime(cf.x, e), t.orientationY.linearRampToValueAtTime(cf.y, e), t.orientationZ.linearRampToValueAtTime(cf.z, e)) : (t.setPosition( of .x, of .y, of .z), t.setOrientation(cf.x, cf.y, cf.z)))
                }
            }]), n
        }(),
        df = function() {
            function n(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 2048;
                _classCallCheck(this, n), this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }
            return _createClass(n, [{
                key: "getFrequencyData",
                value: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
            }, {
                key: "getAverageFrequency",
                value: function() {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }]), n
        }();

    function hf(e, t, n) {
        var r, i, a;
        switch (this.binding = e, this.valueSize = n, t) {
            case "quaternion":
                r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                break;
            default:
                r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    Object.assign(hf.prototype, {
        accumulate: function(e, t) {
            var n = this.buffer,
                r = this.valueSize,
                i = e * r + r,
                e = this.cumulativeWeight;
            if (0 === e) {
                for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                e = t
            } else {
                t = t / (e += t);
                this._mixBufferRegion(n, i, 0, t, r)
            }
            this.cumulativeWeight = e
        },
        accumulateAdditive: function(e) {
            var t = this.buffer,
                n = this.valueSize,
                r = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
        },
        apply: function(e) {
            var t = this.valueSize,
                n = this.buffer,
                r = e * t + t,
                i = this.cumulativeWeight,
                a = this.cumulativeWeightAdditive,
                o = this.binding;
            this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1 && (e = t * this._origIndex, this._mixBufferRegion(n, r, e, 1 - i, t)), 0 < a && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
            for (var s = t, l = t + t; s !== l; ++s)
                if (n[s] !== n[s + t]) {
                    o.setValue(n, r);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding,
                t = this.buffer,
                n = this.valueSize,
                r = n * this._origIndex;
            e.getValue(t, r);
            for (var i = n, a = r; i !== a; ++i) t[i] = t[r + i % n];
            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _setAdditiveIdentityNumeric: function() {
            for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, n = e; n < t; n++) this.buffer[n] = 0
        },
        _setAdditiveIdentityQuaternion: function() {
            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
        },
        _setAdditiveIdentityOther: function() {
            for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
        },
        _select: function(e, t, n, r, i) {
            if (.5 <= r)
                for (var a = 0; a !== i; ++a) e[t + a] = e[n + a]
        },
        _slerp: function(e, t, n, r) {
            An.slerpFlat(e, t, e, t, e, n, r)
        },
        _slerpAdditive: function(e, t, n, r, i) {
            i = this._workIndex * i;
            An.multiplyQuaternionsFlat(e, i, e, t, e, n), An.slerpFlat(e, t, e, t, e, i, r)
        },
        _lerp: function(e, t, n, r, i) {
            for (var a = 1 - r, o = 0; o !== i; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[n + o] * r
            }
        },
        _lerpAdditive: function(e, t, n, r, i) {
            for (var a = 0; a !== i; ++a) {
                var o = t + a;
                e[o] = e[o] + e[n + a] * r
            }
        }
    });
    var ff = "\\[\\]\\.",
        pf = new RegExp("[" + ff + "]", "g"),
        mf = "[^" + ff + "]",
        vf = "[^" + ff.replace("\\.", "") + "]",
        gf = (/((?:WC+[\/:])*)/.source.replace("WC", mf), /(WCOD+)?/.source.replace("WCOD", vf)),
        _f = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mf),
        yf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mf),
        xf = new RegExp("^" + gf + _f + yf + "$"),
        bf = ["material", "materials", "bones"];

    function Mf(e, t, n) {
        n = n || wf.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, n)
    }

    function wf(e, t, n) {
        this.path = t, this.parsedPath = n || wf.parseTrackName(t), this.node = wf.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function Sf() {
        this.uuid = mn.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {
                get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }
    Object.assign(Mf.prototype, {
        getValue: function(e, t) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_,
                n = this._bindings[n];
            void 0 !== n && n.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }), Object.assign(wf, {
        Composite: Mf,
        create: function(e, t, n) {
            return new(e && e.isAnimationObjectGroup ? wf.Composite : wf)(e, t, n)
        },
        sanitizeNodeName: function(e) {
            return e.replace(/\s/g, "_").replace(pf, "")
        },
        parseTrackName: function(e) {
            var t = xf.exec(e);
            if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var n = {
                    nodeName: t[1],
                    objectName: t[2],
                    objectIndex: t[3],
                    propertyName: t[4],
                    propertyIndex: t[5]
                },
                r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r && (t = n.nodeName.substring(r + 1), -1 !== bf.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)), null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        },
        findNode: function(e, r) {
            if (!r || "" === r || "." === r || -1 === r || r === e.name || r === e.uuid) return e;
            if (e.skeleton) {
                var t = e.skeleton.getBoneByName(r);
                if (void 0 !== t) return t
            }
            if (e.children) {
                var i = function(e) {
                        for (var t = 0; t < e.length; t++) {
                            var n = e[t];
                            if (n.name === r || n.uuid === r) return n;
                            n = i(n.children);
                            if (n) return n
                        }
                        return null
                    },
                    e = i(e.children);
                if (e) return e
            }
            return null
        }
    }), Object.assign(wf.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }, function(e, t) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
        }, function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
            }, function(e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function(e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function() {
            var e = this.node,
                t = this.parsedPath,
                n = t.objectName,
                r = t.propertyName,
                i = t.propertyIndex;
            if (e || (e = wf.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (n) {
                    var a = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("v3d.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("v3d.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (var o = 0; o < e.length; o++)
                                if (e[o].name === a) {
                                    a = o;
                                    break
                                } break;
                        default:
                            if (void 0 === e[n]) return void console.error("v3d.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a]) return void console.error("v3d.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[a]
                    }
                }
                var s = e[r];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    void 0 !== (this.targetObject = e).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.isBufferGeometry) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences on v3d.Geometry. Use v3d.BufferGeometry instead.", this);
                            if (!e.geometry.morphAttributes) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                        } else if ("nodeValue" == r) {
                            if (i = i.replace(/"/g, ""), !e.nodeValueMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
                            if (void 0 === (i = e.nodeValueMap[i])) return void console.error("v3d.PropertyBinding: Animated node not found ", this)
                        }
                        if (c = this.BindingType.ArrayElement, "nodeRGB" == r) {
                            if (i = i.replace(/"/g, ""), !e.nodeRGBMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
                            if (void 0 === (i = e.nodeRGBMap[i])) return void console.error("v3d.PropertyBinding: Animated node not found ", this);
                            c = this.BindingType.HasFromToArray, s = e.nodeRGB[i]
                        }
                        this.resolvedProperty = s, this.propertyIndex = i
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                } else {
                    t = t.nodeName;
                    console.error("v3d.PropertyBinding: Trying to update property for track: " + t + "." + r + " but it wasn't found.", e)
                }
            } else console.error("v3d.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(wf.prototype, {
        _getValue_unbound: wf.prototype.getValue,
        _setValue_unbound: wf.prototype.setValue
    }), Object.assign(Sf.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length, o = void 0, s = e.length, l = this.nCachedObjects_, c = 0, u = arguments.length; c !== u; ++c) {
                var d = arguments[c],
                    h = d.uuid,
                    f = t[h];
                if (void 0 === f) {
                    f = s++, t[h] = f, e.push(d);
                    for (var p = 0, m = a; p !== m; ++p) i[p].push(new wf(d, n[p], r[p]))
                } else if (f < l) {
                    o = e[f];
                    var v = --l,
                        g = e[v];
                    e[t[g.uuid] = f] = g, e[t[h] = v] = d;
                    for (var _ = 0, y = a; _ !== y; ++_) {
                        var x = i[_],
                            b = x[v],
                            M = x[f];
                        x[f] = b, void 0 === M && (M = new wf(d, n[_], r[_])), x[v] = M
                    }
                } else e[f] !== o && console.error("v3d.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = l
        },
        remove: function() {
            for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a],
                    l = s.uuid,
                    c = t[l];
                if (void 0 !== c && i <= c) {
                    var u = i++,
                        d = e[u];
                    e[t[d.uuid] = c] = d, e[t[l] = u] = s;
                    for (var h = 0, f = r; h !== f; ++h) {
                        var p = n[h],
                            m = p[u],
                            v = p[c];
                        p[c] = m, p[u] = v
                    }
                }
            }
            this.nCachedObjects_ = i
        },
        uncache: function() {
            for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = e.length, o = 0, s = arguments.length; o !== s; ++o) {
                var l = arguments[o].uuid,
                    c = t[l];
                if (void 0 !== c)
                    if (delete t[l], c < i) {
                        var u = --i,
                            l = e[u],
                            d = --a,
                            h = e[d];
                        e[t[l.uuid] = c] = l, e[t[h.uuid] = u] = h, e.pop();
                        for (var f = 0, p = r; f !== p; ++f) {
                            var m = n[f],
                                v = m[u],
                                g = m[d];
                            m[c] = v, m[u] = g, m.pop()
                        }
                    } else {
                        var _ = --a,
                            h = e[_];
                        0 < _ && (t[h.uuid] = c), e[c] = h, e.pop();
                        for (var y = 0, x = r; y !== x; ++y) {
                            var b = n[y];
                            b[c] = b[_], b.pop()
                        }
                    }
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(e, t) {
            var n = this._bindingsIndicesByPath,
                r = n[e],
                i = this._bindings;
            if (void 0 !== r) return i[r];
            var a = this._paths,
                o = this._parsedPaths,
                s = this._objects,
                l = s.length,
                c = this.nCachedObjects_,
                u = new Array(l),
                r = i.length;
            n[e] = r, a.push(e), o.push(t), i.push(u);
            for (var d = c, h = s.length; d !== h; ++d) {
                var f = s[d];
                u[d] = new wf(f, e, t)
            }
            return u
        },
        unsubscribe_: function(e) {
            var t, n, r, i, a, o = this._bindingsIndicesByPath,
                s = o[e];
            void 0 !== s && (t = this._paths, n = this._parsedPaths, a = (r = this._bindings)[i = r.length - 1], r[o[e[i]] = s] = a, r.pop(), n[s] = n[i], n.pop(), t[s] = t[i], t.pop())
        }
    });
    var Af = function() {
        function u(e, t) {
            var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null,
                r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : t.blendMode;
            _classCallCheck(this, u), this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
            for (var i = t.tracks, a = i.length, o = new Array(a), s = {
                    endingStart: Bt,
                    endingEnd: Bt
                }, l = 0; l !== a; ++l) {
                var c = i[l].createInterpolant(null);
                (o[l] = c).settings = s
            }
            this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Nt, this._loopCount = -1, this._pingIsEven = !0, this._startTime = null, this.time = 0, this.timeStart = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }
        return _createClass(u, [{
            key: "play",
            value: function() {
                return this._mixer._activateAction(this), this
            }
        }, {
            key: "stop",
            value: function() {
                return this._mixer._deactivateAction(this), this.reset()
            }
        }, {
            key: "reset",
            value: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this._pingIsEven = !0, this.stopFading().stopWarping()
            }
        }, {
            key: "isRunning",
            value: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
        }, {
            key: "isScheduled",
            value: function() {
                return this._mixer._isActiveAction(this)
            }
        }, {
            key: "startAt",
            value: function(e) {
                return this._startTime = e, this
            }
        }, {
            key: "setLoop",
            value: function(e, t) {
                return this.loop = e, this.repetitions = t, this
            }
        }, {
            key: "setEffectiveWeight",
            value: function(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            }
        }, {
            key: "getEffectiveWeight",
            value: function() {
                return this._effectiveWeight
            }
        }, {
            key: "fadeIn",
            value: function(e) {
                return this._scheduleFading(e, 0, 1)
            }
        }, {
            key: "fadeOut",
            value: function(e) {
                return this._scheduleFading(e, 1, 0)
            }
        }, {
            key: "crossFadeFrom",
            value: function(e, t, n) {
                var r, i;
                return e.fadeOut(t), this.fadeIn(t), n && (r = this._clip.duration, n = (i = e._clip.duration) / r, i = r / i, e.warp(1, n, t), this.warp(i, 1, t)), this
            }
        }, {
            key: "crossFadeTo",
            value: function(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
        }, {
            key: "stopFading",
            value: function() {
                var e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
        }, {
            key: "setEffectiveTimeScale",
            value: function(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            }
        }, {
            key: "getEffectiveTimeScale",
            value: function() {
                return this._effectiveTimeScale
            }
        }, {
            key: "setDuration",
            value: function(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            }
        }, {
            key: "syncWith",
            value: function(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            }
        }, {
            key: "halt",
            value: function(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
        }, {
            key: "warp",
            value: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    a = this.timeScale,
                    o = this._timeScaleInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                r = o.parameterPositions, o = o.sampleValues;
                return r[0] = i, r[1] = i + n, o[0] = e / a, o[1] = t / a, this
            }
        }, {
            key: "stopWarping",
            value: function() {
                var e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
        }, {
            key: "getMixer",
            value: function() {
                return this._mixer
            }
        }, {
            key: "getClip",
            value: function() {
                return this._clip
            }
        }, {
            key: "getRoot",
            value: function() {
                return this._localRoot || this._mixer._root
            }
        }, {
            key: "_update",
            value: function(e, t, n, r) {
                if (this.enabled) {
                    var i = this._startTime;
                    if (null !== i) {
                        i = (e - i) * n;
                        if (i < 0 || 0 === n) return;
                        this._startTime = null, t = n * i
                    }
                    t *= this._updateTimeScale(e);
                    var a = this._updateTime(t),
                        o = this._updateWeight(e);
                    if (0 < o) {
                        var s = this._interpolants,
                            l = this._propertyBindings;
                        switch (this.blendMode) {
                            case 2501:
                                for (var c = 0, u = s.length; c !== u; ++c) s[c].evaluate(a), l[c].accumulateAdditive(o);
                                break;
                            case 2500:
                            default:
                                for (var d = 0, h = s.length; d !== h; ++d) s[d].evaluate(a), l[d].accumulate(r, o)
                        }
                    }
                } else this._updateWeight(e)
            }
        }, {
            key: "_updateWeight",
            value: function(e) {
                var t, n, r = 0;
                return this.enabled && (r = this.weight, null !== (t = this._weightInterpolant) && (r *= n = t.evaluate(e)[0], e > t.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)))), this._effectiveWeight = r
            }
        }, {
            key: "_updateTimeScale",
            value: function(e) {
                var t, n = 0;
                return this.paused || (n = this.timeScale, null !== (t = this._timeScaleInterpolant) && (n *= t.evaluate(e)[0], e > t.parameterPositions[1] && (this.stopWarping(), 0 === n ? this.paused = !0 : this.timeScale = n))), this._effectiveTimeScale = n
            }
        }, {
            key: "_loopIsPing",
            value: function(e) {
                return 2202 !== this.loop || (-1 == e || 0 == (1 & e) === this._pingIsEven)
            }
        }, {
            key: "_updateTime",
            value: function(e) {
                if (0 === e) return this.time;
                if (2200 !== this.loop && this.repetitions <= 0) return this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                }), this.time;
                var t = this.timeStart,
                    n = Math.max(t, this._clip.duration),
                    r = n - t;
                if (2200 === this.loop) return this.time += e, -1 === this._loopCount && (this._loopCount = 0, this._setEndings(!0, !0, !1)), (this.time < t || this.time > n) && (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = mn.clamp(this.time, t, n), this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })), this.time;
                var i = 2202 === this.loop,
                    a = this._loopIsPing(this._loopCount) ? 1 : -1;
                this.time += a * e;
                var o, s = this.time < t || this.time > n,
                    l = !1;
                return -1 === this._loopCount && (l = s, this._loopCount = l ? -1 : 0, this._pingIsEven = !l, 0 <= e ? this._setEndings(!0, 0 === this.repetitions, i) : this._setEndings(0 === this.repetitions, !0, i)), s && (a = Math.floor((this.time - t) / r), this._loopCount += Math.abs(a), (s = this.repetitions - this._loopCount) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = mn.clamp(this.time, t, n), this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })) : (1 == s ? (o = e < 0, this._setEndings(o, !o, i)) : this._setEndings(!1, !1, i), (o = (this.time - t) % r) < 0 && (o += r), this.time = i ? n - o : o + t, l || this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a
                }))), this.time
            }
        }, {
            key: "_setEndings",
            value: function(e, t, n) {
                var r = this._interpolantSettings;
                n ? (r.endingStart = zt, r.endingEnd = zt) : (r.endingStart = e ? this.zeroSlopeAtStart ? zt : Bt : Ut, r.endingEnd = t ? this.zeroSlopeAtEnd ? zt : Bt : Ut)
            }
        }, {
            key: "_scheduleFading",
            value: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    a = this._weightInterpolant;
                null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
                r = a.parameterPositions, a = a.sampleValues;
                return r[0] = i, a[0] = t, r[1] = i + e, a[1] = n, this
            }
        }]), u
    }();

    function Tf(e) {
        this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    Tf.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Tf,
        _bindAction: function(e, t) {
            var n = e._localRoot || this._root,
                r = e._clip.tracks,
                i = r.length,
                a = e._propertyBindings,
                o = e._interpolants,
                s = n.uuid,
                e = this._bindingsByRootAndName,
                l = e[s];
            void 0 === l && (l = {}, e[s] = l);
            for (var c = 0; c !== i; ++c) {
                var u = r[c],
                    d = u.name;
                if (void 0 !== (h = l[d])) a[c] = h;
                else {
                    if (void 0 !== (h = a[c])) {
                        null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, s, d));
                        continue
                    }
                    var h, f = t && t._propertyBindings[c].binding.parsedPath;
                    ++(h = new hf(wf.create(n, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(h, s, d), a[c] = h
                }
                o[c].resultBuffer = h.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                var t, n, r;
                null === e._cacheIndex && (t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n], this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t));
                for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
                    var s = i[a];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                    var i = t[n];
                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            e = e._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(e, t, n) {
            var r = this._actions,
                i = this._actionsByClip,
                a = i[t];
            void 0 === a ? (a = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, i[t] = a) : (t = a.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions,
                n = t[t.length - 1],
                r = e._cacheIndex;
            t[n._cacheIndex = r] = n, t.pop(), e._cacheIndex = null;
            var i = e._clip.uuid,
                a = this._actionsByClip,
                o = a[i],
                r = o.knownActions,
                n = r[r.length - 1],
                t = e._byClipCacheIndex;
            r[n._byClipCacheIndex = t] = n, r.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete a[i], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                var i = t[n];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function(e) {
            var t = this._actions,
                n = e._cacheIndex,
                r = this._nActiveActions++,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _takeBackAction: function(e) {
            var t = this._actions,
                n = e._cacheIndex,
                r = --this._nActiveActions,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _addInactiveBinding: function(e, t, n) {
            var r = this._bindingsByRootAndName,
                i = this._bindings,
                a = r[t];
            void 0 === a && (a = {}, r[t] = a), (a[n] = e)._cacheIndex = i.length, i.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings,
                n = e.binding,
                r = n.rootNode.uuid,
                i = n.path,
                a = this._bindingsByRootAndName,
                o = a[r],
                n = t[t.length - 1],
                e = e._cacheIndex;
            t[n._cacheIndex = e] = n, t.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r]
        },
        _lendBinding: function(e) {
            var t = this._bindings,
                n = e._cacheIndex,
                r = this._nActiveBindings++,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _takeBackBinding: function(e) {
            var t = this._bindings,
                n = e._cacheIndex,
                r = --this._nActiveBindings,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                n = e[t];
            return void 0 === n && (e[(n = new Du(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = n), n
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants,
                n = e.__cacheIndex,
                r = --this._nActiveControlInterpolants,
                i = t[r];
            t[e.__cacheIndex = r] = e, t[i.__cacheIndex = n] = i
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t, n) {
            var r = t || this._root,
                i = r.uuid,
                a = "string" == typeof e ? Dd.findByName(r, e) : e,
                o = null !== a ? a.uuid : e,
                s = this._actionsByClip[o],
                r = null;
            if (void 0 === n && (n = null !== a ? a.blendMode : 2500), void 0 !== s) {
                e = s.actionByRoot[i];
                if (void 0 !== e && e.blendMode === n) return e;
                r = s.knownActions[0], null === a && (a = r._clip)
            }
            if (null === a) return null;
            n = new Af(this, a, t, n);
            return this._bindAction(n, r), this._addInactiveAction(n, o, i), n
        },
        existingAction: function(e, t) {
            var n = t || this._root,
                t = n.uuid,
                n = "string" == typeof e ? Dd.findByName(n, e) : e,
                e = n ? n.uuid : e,
                e = this._actionsByClip[e];
            return void 0 !== e && e.actionByRoot[t] || null
        },
        stopAllAction: function() {
            for (var e = this._actions, t = this._nActiveActions - 1; 0 <= t; --t) e[t].stop();
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) t[o]._update(r, e, i, a);
            for (var s = this._bindings, l = this._nActiveBindings, c = 0; c !== l; ++c) s[c].apply(a);
            return this
        },
        setTime: function(e) {
            for (var t = this.time = 0; t < this._actions.length; t++) this._actions[t].time = 0;
            return this.update(e)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions,
                n = e.uuid,
                r = this._actionsByClip,
                e = r[n];
            if (void 0 !== e) {
                for (var i = e.knownActions, a = 0, o = i.length; a !== o; ++a) {
                    var s = i[a];
                    this._deactivateAction(s);
                    var l = s._cacheIndex,
                        c = t[t.length - 1];
                    s._cacheIndex = null, s._byClipCacheIndex = null, t[c._cacheIndex = l] = c, t.pop(), this._removeInactiveBindingsForAction(s)
                }
                delete r[n]
            }
        },
        uncacheRoot: function(e) {
            var t, n = e.uuid,
                r = this._actionsByClip;
            for (t in r) {
                var i = r[t].actionByRoot[n];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var a = this._bindingsByRootAndName[n];
            if (void 0 !== a)
                for (var o in a) {
                    var s = a[o];
                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(e, t) {
            t = this.existingAction(e, t);
            null !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
        }
    });
    var Ef = function() {
        function t(e) {
            _classCallCheck(this, t), "string" == typeof e && (console.warn("v3d.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
        }
        return _createClass(t, [{
            key: "clone",
            value: function() {
                return new t(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }]), t
    }();

    function Cf(e, t, n) {
        zs.call(this, e, t), this.meshPerAttribute = n || 1
    }

    function Lf(e, t, n, r, i) {
        this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
    }
    Cf.prototype = Object.assign(Object.create(zs.prototype), {
        constructor: Cf,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return zs.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        clone: function(e) {
            e = zs.prototype.clone.call(this, e);
            return e.meshPerAttribute = this.meshPerAttribute, e
        },
        toJSON: function(e) {
            e = zs.prototype.toJSON.call(this, e);
            return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
        }
    }), Object.defineProperty(Lf.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(Lf.prototype, {
        isGLBufferAttribute: !0,
        setBuffer: function(e) {
            return this.buffer = e, this
        },
        setType: function(e, t) {
            return this.type = e, this.elementSize = t, this
        },
        setItemSize: function(e) {
            return this.itemSize = e, this
        },
        setCount: function(e) {
            return this.count = e, this
        }
    });
    var Pf = function() {
            function r(e, t, n) {
                return _classCallCheck(this, r), this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
            }
            return _createClass(r, [{
                key: "set",
                value: function(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
            }, {
                key: "setFromVector3",
                value: function(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
            }, {
                key: "setFromCartesianCoords",
                value: function(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
            }]), r
        }(),
        Rf = new vn,
        Df = function() {
            function n(e, t) {
                _classCallCheck(this, n), Object.defineProperty(this, "isBox2", {
                    value: !0
                }), this.min = void 0 !== e ? e : new vn(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new vn(-1 / 0, -1 / 0)
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
            }, {
                key: "setFromPoints",
                value: function(e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
            }, {
                key: "setFromCenterAndSize",
                value: function(e, t) {
                    t = Rf.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(t), this.max.copy(e).add(t), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
            }, {
                key: "makeEmpty",
                value: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
            }, {
                key: "isEmpty",
                value: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
            }, {
                key: "getCenter",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Box2: .getCenter() target is now required"), e = new vn), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
            }, {
                key: "getSize",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Box2: .getSize() target is now required"), e = new vn), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
            }, {
                key: "expandByPoint",
                value: function(e) {
                    return this.min.min(e), this.max.max(e), this
                }
            }, {
                key: "expandByVector",
                value: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
            }, {
                key: "expandByScalar",
                value: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
            }, {
                key: "containsPoint",
                value: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                }
            }, {
                key: "containsBox",
                value: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
            }, {
                key: "getParameter",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Box2: .getParameter() target is now required"), t = new vn), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
            }, {
                key: "intersectsBox",
                value: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                }
            }, {
                key: "clampPoint",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Box2: .clampPoint() target is now required"), t = new vn), t.copy(e).clamp(this.min, this.max)
                }
            }, {
                key: "distanceToPoint",
                value: function(e) {
                    return Rf.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }, {
                key: "intersect",
                value: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
            }, {
                key: "union",
                value: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
            }, {
                key: "translate",
                value: function(e) {
                    return this.min.add(e), this.max.add(e), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }]), n
        }(),
        Of = new Tn,
        Nf = new Tn,
        If = function() {
            function n(e, t) {
                _classCallCheck(this, n), this.start = void 0 !== e ? e : new Tn, this.end = void 0 !== t ? t : new Tn
            }
            return _createClass(n, [{
                key: "set",
                value: function(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
            }, {
                key: "clone",
                value: function() {
                    return (new this.constructor).copy(this)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
            }, {
                key: "getCenter",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Line3: .getCenter() target is now required"), e = new Tn), e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
            }, {
                key: "delta",
                value: function(e) {
                    return void 0 === e && (console.warn("v3d.Line3: .delta() target is now required"), e = new Tn), e.subVectors(this.end, this.start)
                }
            }, {
                key: "distanceSq",
                value: function() {
                    return this.start.distanceToSquared(this.end)
                }
            }, {
                key: "distance",
                value: function() {
                    return this.start.distanceTo(this.end)
                }
            }, {
                key: "at",
                value: function(e, t) {
                    return void 0 === t && (console.warn("v3d.Line3: .at() target is now required"), t = new Tn), this.delta(t).multiplyScalar(e).add(this.start)
                }
            }, {
                key: "closestPointToPointParameter",
                value: function(e, t) {
                    Of.subVectors(e, this.start), Nf.subVectors(this.end, this.start);
                    e = Nf.dot(Nf), e = Nf.dot(Of) / e;
                    return t && (e = mn.clamp(e, 0, 1)), e
                }
            }, {
                key: "closestPointToPoint",
                value: function(e, t, n) {
                    t = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (console.warn("v3d.Line3: .closestPointToPoint() target is now required"), n = new Tn), this.delta(n).multiplyScalar(t).add(this.start)
                }
            }, {
                key: "applyMatrix4",
                value: function(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
            }, {
                key: "equals",
                value: function(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }]), n
        }();

    function Ff(e) {
        Er.call(this), this.material = e, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
    }((Ff.prototype = Object.create(Er.prototype)).constructor = Ff).prototype.isImmediateRenderObject = !0;
    var kf = new Tn,
        Bf = function() {
            _inherits(c, Er);
            var l = _createSuper(c);

            function c(e, t) {
                var n;
                _classCallCheck(this, c), (n = l.call(this)).light = e, n.light.updateMatrixWorld(), n.matrix = e.matrixWorld, n.matrixAutoUpdate = !1, n.color = t;
                for (var e = new Oi, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, a = 1; i < 32; i++, a++) {
                    var o = i / 32 * Math.PI * 2,
                        s = a / 32 * Math.PI * 2;
                    r.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
                }
                e.setAttribute("position", new hi(r, 3));
                t = new Ml({
                    fog: !1,
                    toneMapped: !1
                });
                return n.cone = new Rl(e, t), n.add(n.cone), n.update(), n
            }
            return _createClass(c, [{
                key: "dispose",
                value: function() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
            }, {
                key: "update",
                value: function() {
                    this.light.updateMatrixWorld();
                    var e = this.light.distance || 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), kf.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(kf), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }]), c
        }(),
        zf = new Tn,
        Uf = new nr,
        Vf = new nr,
        Gf = function() {
            _inherits(d, Rl);
            var u = _createSuper(d);

            function d(e) {
                _classCallCheck(this, d);
                for (var t = function e(t) {
                        var n = [];
                        t && t.isBone && n.push(t);
                        for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                        return n
                    }(e), n = new Oi, r = [], i = [], a = new Qr(0, 0, 1), o = new Qr(0, 1, 0), s = 0; s < t.length; s++) {
                    var l = t[s];
                    l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b))
                }
                n.setAttribute("position", new hi(r, 3)), n.setAttribute("color", new hi(i, 3));
                var c = new Ml({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                });
                return (c = u.call(this, n, c)).type = "SkeletonHelper", c.isSkeletonHelper = !0, c.root = e, c.bones = t, c.matrix = e.matrixWorld, c.matrixAutoUpdate = !1, c
            }
            return _createClass(d, [{
                key: "updateMatrixWorld",
                value: function(e) {
                    var t = this.bones,
                        n = this.geometry,
                        r = n.getAttribute("position");
                    Vf.copy(this.root.matrixWorld).invert();
                    for (var i = 0, a = 0; i < t.length; i++) {
                        var o = t[i];
                        o.parent && o.parent.isBone && (Uf.multiplyMatrices(Vf, o.matrixWorld), zf.setFromMatrixPosition(Uf), r.setXYZ(a, zf.x, zf.y, zf.z), Uf.multiplyMatrices(Vf, o.parent.matrixWorld), zf.setFromMatrixPosition(Uf), r.setXYZ(a + 1, zf.x, zf.y, zf.z), a += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, _get(_getPrototypeOf(d.prototype), "updateMatrixWorld", this).call(this, e)
                }
            }]), d
        }();
    var jf = function() {
            _inherits(a, Ki);
            var i = _createSuper(a);

            function a(e, t, n) {
                _classCallCheck(this, a);
                var r = new Yc(t, 4, 2),
                    t = new ei({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    });
                return (t = i.call(this, r, t)).light = e, t.light.updateMatrixWorld(), t.color = n, t.type = "PointLightHelper", t.matrix = t.light.matrixWorld, t.matrixAutoUpdate = !1, t.update(), t
            }
            return _createClass(a, [{
                key: "dispose",
                value: function() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }, {
                key: "update",
                value: function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }]), a
        }(),
        Wf = new Tn,
        Hf = new Qr,
        Xf = new Qr,
        Yf = function() {
            _inherits(a, Er);
            var i = _createSuper(a);

            function a(e, t, n) {
                var r;
                _classCallCheck(this, a), (r = i.call(this)).light = e, r.light.updateMatrixWorld(), r.matrix = e.matrixWorld, r.matrixAutoUpdate = !1, r.color = n;
                n = new kc(t);
                n.rotateY(.5 * Math.PI), r.material = new ei({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }), void 0 === r.color && (r.material.vertexColors = !0);
                t = n.getAttribute("position"), t = new Float32Array(3 * t.count);
                return n.setAttribute("color", new ri(t, 3)), r.add(new Ki(n, r.material)), r.update(), r
            }
            return _createClass(a, [{
                key: "dispose",
                value: function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
            }, {
                key: "update",
                value: function() {
                    var e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var t = e.geometry.getAttribute("color");
                        Hf.copy(this.light.color), Xf.copy(this.light.groundColor);
                        for (var n = 0, r = t.count; n < r; n++) {
                            var i = n < r / 2 ? Hf : Xf;
                            t.setXYZ(n, i.r, i.g, i.b)
                        }
                        t.needsUpdate = !0
                    }
                    e.lookAt(Wf.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }]), a
        }(),
        qf = function() {
            _inherits(m, Rl);
            var p = _createSuper(m);

            function m() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 4473924,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 8947848;
                _classCallCheck(this, m), n = new Qr(n), r = new Qr(r);
                for (var i = t / 2, a = e / t, o = e / 2, s = [], l = [], c = 0, u = 0, d = -o; c <= t; c++, d += a) {
                    s.push(-o, 0, d, o, 0, d), s.push(d, 0, -o, d, 0, o);
                    var h = c === i ? n : r;
                    h.toArray(l, u), u += 3, h.toArray(l, u), u += 3, h.toArray(l, u), u += 3, h.toArray(l, u), u += 3
                }
                var f = new Oi;
                f.setAttribute("position", new hi(s, 3)), f.setAttribute("color", new hi(l, 3));
                var e = new Ml({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (e = p.call(this, f, e)).type = "GridHelper", e
            }
            return m
        }(),
        Zf = function() {
            _inherits(b, Rl);
            var x = _createSuper(b);

            function b() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10,
                    t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 16,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 8,
                    r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 64,
                    i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 4473924,
                    a = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 8947848;
                _classCallCheck(this, b), i = new Qr(i), a = new Qr(a);
                for (var o = [], s = [], l = 0; l <= t; l++) {
                    var c = l / t * (2 * Math.PI),
                        u = Math.sin(c) * e,
                        c = Math.cos(c) * e;
                    o.push(0, 0, 0), o.push(u, 0, c);
                    c = 1 & l ? i : a;
                    s.push(c.r, c.g, c.b), s.push(c.r, c.g, c.b)
                }
                for (var d = 0; d <= n; d++)
                    for (var h = 1 & d ? i : a, f = e - e / n * d, p = 0; p < r; p++) {
                        var m = p / r * (2 * Math.PI),
                            v = Math.sin(m) * f,
                            g = Math.cos(m) * f;
                        o.push(v, 0, g), s.push(h.r, h.g, h.b), m = (p + 1) / r * (2 * Math.PI), v = Math.sin(m) * f, g = Math.cos(m) * f, o.push(v, 0, g), s.push(h.r, h.g, h.b)
                    }
                var _ = new Oi;
                _.setAttribute("position", new hi(o, 3)), _.setAttribute("color", new hi(s, 3));
                var y = new Ml({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (y = x.call(this, _, y)).type = "PolarGridHelper", y
            }
            return b
        }(),
        Qf = new Tn,
        Kf = new Tn,
        Jf = new Tn,
        $f = function() {
            _inherits(a, Er);
            var i = _createSuper(a);

            function a(e, t, n) {
                var r;
                _classCallCheck(this, a), (r = i.call(this)).light = e, r.light.updateMatrixWorld(), r.matrix = e.matrixWorld, r.matrixAutoUpdate = !1, r.color = n, void 0 === t && (t = 1);
                n = new Oi;
                n.setAttribute("position", new hi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                t = new Ml({
                    fog: !1,
                    toneMapped: !1
                });
                return r.lightPlane = new Cl(n, t), r.add(r.lightPlane), (n = new Oi).setAttribute("position", new hi([0, 0, 0, 0, 0, 1], 3)), r.targetLine = new Cl(n, t), r.add(r.targetLine), r.update(), r
            }
            return _createClass(a, [{
                key: "dispose",
                value: function() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
            }, {
                key: "update",
                value: function() {
                    Qf.setFromMatrixPosition(this.light.matrixWorld), Kf.setFromMatrixPosition(this.light.target.matrixWorld), Jf.subVectors(Kf, Qf), this.lightPlane.lookAt(Kf), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Kf), this.targetLine.scale.z = Jf.length()
                }
            }]), a
        }(),
        ep = new Tn,
        tp = new sa,
        np = function() {
            _inherits(p, Rl);
            var f = _createSuper(p);

            function p(e) {
                _classCallCheck(this, p);
                var t = new Oi,
                    n = new Ml({
                        color: 16777215,
                        vertexColors: !0,
                        toneMapped: !1
                    }),
                    r = [],
                    i = [],
                    a = {},
                    o = new Qr(16755200),
                    s = new Qr(16711680),
                    l = new Qr(43775),
                    c = new Qr(16777215),
                    u = new Qr(3355443);

                function d(e, t, n) {
                    h(e, n), h(t, n)
                }

                function h(e, t) {
                    r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1)
                }
                return d("n1", "n2", o), d("n2", "n4", o), d("n4", "n3", o), d("n3", "n1", o), d("f1", "f2", o), d("f2", "f4", o), d("f4", "f3", o), d("f3", "f1", o), d("n1", "f1", o), d("n2", "f2", o), d("n3", "f3", o), d("n4", "f4", o), d("p", "n1", s), d("p", "n2", s), d("p", "n3", s), d("p", "n4", s), d("u1", "u2", l), d("u2", "u3", l), d("u3", "u1", l), d("c", "t", c), d("p", "c", u), d("cn1", "cn2", u), d("cn3", "cn4", u), d("cf1", "cf2", u), d("cf3", "cf4", u), t.setAttribute("position", new hi(r, 3)), t.setAttribute("color", new hi(i, 3)), (n = f.call(this, t, n)).type = "CameraHelper", n.camera = e, n.camera.updateProjectionMatrix && n.camera.updateProjectionMatrix(), n.matrix = e.matrixWorld, n.matrixAutoUpdate = !1, n.pointMap = a, n.update(), n
            }
            return _createClass(p, [{
                key: "update",
                value: function() {
                    var e = this.geometry,
                        t = this.pointMap;
                    tp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), rp("c", t, e, tp, 0, 0, -1), rp("t", t, e, tp, 0, 0, 1), rp("n1", t, e, tp, -1, -1, -1), rp("n2", t, e, tp, 1, -1, -1), rp("n3", t, e, tp, -1, 1, -1), rp("n4", t, e, tp, 1, 1, -1), rp("f1", t, e, tp, -1, -1, 1), rp("f2", t, e, tp, 1, -1, 1), rp("f3", t, e, tp, -1, 1, 1), rp("f4", t, e, tp, 1, 1, 1), rp("u1", t, e, tp, .7, 1.1, -1), rp("u2", t, e, tp, -.7, 1.1, -1), rp("u3", t, e, tp, 0, 2, -1), rp("cf1", t, e, tp, -1, 0, 1), rp("cf2", t, e, tp, 1, 0, 1), rp("cf3", t, e, tp, 0, -1, 1), rp("cf4", t, e, tp, 0, 1, 1), rp("cn1", t, e, tp, -1, 0, -1), rp("cn2", t, e, tp, 1, 0, -1), rp("cn3", t, e, tp, 0, -1, -1), rp("cn4", t, e, tp, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
            }]), p
        }();

    function rp(e, t, n, r, i, a, o) {
        ep.set(i, a, o).unproject(r);
        var s = t[e];
        if (void 0 !== s)
            for (var l = n.getAttribute("position"), c = 0, u = s.length; c < u; c++) l.setXYZ(s[c], ep.x, ep.y, ep.z)
    }
    var ip, ap, op = new Ln,
        sp = function() {
            _inherits(o, Rl);
            var a = _createSuper(o);

            function o(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 16776960;
                _classCallCheck(this, o);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Oi;
                return i.setIndex(new ri(n, 1)), i.setAttribute("position", new ri(r, 3)), (t = a.call(this, i, new Ml({
                    color: t,
                    toneMapped: !1
                }))).object = e, t.type = "BoxHelper", t.matrixAutoUpdate = !1, t.update(), t
            }
            return _createClass(o, [{
                key: "update",
                value: function(e) {
                    var t, n, r;
                    void 0 !== e && console.warn("v3d.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && op.setFromObject(this.object), op.isEmpty() || (t = op.min, n = op.max, (e = (r = this.geometry.attributes.position).array)[0] = n.x, e[1] = n.y, e[2] = n.z, e[3] = t.x, e[4] = n.y, e[5] = n.z, e[6] = t.x, e[7] = t.y, e[8] = n.z, e[9] = n.x, e[10] = t.y, e[11] = n.z, e[12] = n.x, e[13] = n.y, e[14] = t.z, e[15] = t.x, e[16] = n.y, e[17] = t.z, e[18] = t.x, e[19] = t.y, e[20] = t.z, e[21] = n.x, e[22] = t.y, e[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere())
                }
            }, {
                key: "setFromObject",
                value: function(e) {
                    return this.object = e, this.update(), this
                }
            }, {
                key: "copy",
                value: function(e) {
                    return Rl.prototype.copy.call(this, e), this.object = e.object, this
                }
            }]), o
        }(),
        lp = function() {
            _inherits(a, Rl);
            var i = _createSuper(a);

            function a(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 16776960;
                _classCallCheck(this, a);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Oi;
                return r.setIndex(new ri(n, 1)), r.setAttribute("position", new hi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), (t = i.call(this, r, new Ml({
                    color: t,
                    toneMapped: !1
                }))).box = e, t.type = "Box3Helper", t.geometry.computeBoundingSphere(), t
            }
            return _createClass(a, [{
                key: "updateMatrixWorld",
                value: function(e) {
                    var t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), _get(_getPrototypeOf(a.prototype), "updateMatrixWorld", this).call(this, e))
                }
            }]), a
        }(),
        cp = function() {
            _inherits(a, Cl);
            var i = _createSuper(a);

            function a(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 16776960;
                _classCallCheck(this, a);
                var r = n,
                    n = new Oi;
                n.setAttribute("position", new hi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), (n = i.call(this, n, new Ml({
                    color: r,
                    toneMapped: !1
                }))).type = "PlaneHelper", n.plane = e, n.size = t;
                t = new Oi;
                return t.setAttribute("position", new hi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), n.add(new Ki(t, new ei({
                    color: r,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                }))), n
            }
            return _createClass(a, [{
                key: "updateMatrixWorld",
                value: function(e) {
                    var t = -this.plane.constant;
                    Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? ae : ie, this.lookAt(this.plane.normal), _get(_getPrototypeOf(a.prototype), "updateMatrixWorld", this).call(this, e)
                }
            }]), a
        }(),
        up = new Tn,
        dp = function() {
            _inherits(l, Er);
            var s = _createSuper(l);

            function l(e, t, n, r, i, a) {
                var o;
                return _classCallCheck(this, l), (o = s.call(this)).type = "ArrowHelper", void 0 === e && (e = new Tn(0, 0, 1)), void 0 === t && (t = new Tn(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === a && (a = .2 * i), void 0 === ip && ((ip = new Oi).setAttribute("position", new hi([0, 0, 0, 0, 1, 0], 3)), (ap = new Jl(0, .5, 1, 5, 1)).translate(0, -.5, 0)), o.position.copy(t), o.line = new Cl(ip, new Ml({
                    color: r,
                    toneMapped: !1
                })), o.line.matrixAutoUpdate = !1, o.add(o.line), o.cone = new Ki(ap, new ei({
                    color: r,
                    toneMapped: !1
                })), o.cone.matrixAutoUpdate = !1, o.add(o.cone), o.setDirection(e), o.setLength(n, i, a), o
            }
            return _createClass(l, [{
                key: "setDirection",
                value: function(e) {
                    .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (up.set(e.z, 0, -e.x).normalize(), e = Math.acos(e.y), this.quaternion.setFromAxisAngle(up, e))
                }
            }, {
                key: "setLength",
                value: function(e, t, n) {
                    void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
            }, {
                key: "setColor",
                value: function(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
            }, {
                key: "copy",
                value: function(e) {
                    return _get(_getPrototypeOf(l.prototype), "copy", this).call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
            }]), l
        }(),
        hp = function() {
            _inherits(r, Rl);
            var n = _createSuper(r);

            function r() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
                _classCallCheck(this, r);
                var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    e = new Oi;
                e.setAttribute("position", new hi(t, 3)), e.setAttribute("color", new hi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var t = new Ml({
                    vertexColors: !0,
                    toneMapped: !1
                });
                return (t = n.call(this, e, t)).type = "AxesHelper", t
            }
            return r
        }(),
        fp = new Float32Array(1),
        pp = new Int32Array(fp.buffer),
        mp = {
            toHalfFloat: function(e) {
                fp[0] = e;
                var t = pp[0],
                    n = t >> 16 & 32768,
                    r = t >> 12 & 2047,
                    e = t >> 23 & 255;
                return e < 103 ? n : 142 < e ? (n |= 31744, n |= (255 == e ? 0 : 1) && 8388607 & t) : e < 113 ? n |= ((r |= 2048) >> 114 - e) + (r >> 113 - e & 1) : (n |= e - 112 << 10 | r >> 1, n += 1 & r)
            }
        };

    function vp(e) {
        console.warn("v3d.ClosedSplineCurve3 has been deprecated. Use v3d.CatmullRomCurve3 instead."), eh.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function gp(e) {
        console.warn("v3d.SplineCurve3 has been deprecated. Use v3d.CatmullRomCurve3 instead."), eh.call(this, e), this.type = "catmullrom"
    }

    function _p(e) {
        console.warn("v3d.Spline has been removed. Use v3d.CatmullRomCurve3 instead."), eh.call(this, e), this.type = "catmullrom"
    }
    Xd.create = function(e, t) {
        return console.log("v3d.Curve.create() has been deprecated"), e.prototype = Object.create(Xd.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e
    }, Object.assign(ph.prototype, {
        createPointsGeometry: function(e) {
            console.warn("v3d.CurvePath: .createPointsGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            e = this.getPoints(e);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(e) {
            console.warn("v3d.CurvePath: .createSpacedPointsGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            e = this.getSpacedPoints(e);
            return this.createGeometry(e)
        },
        createGeometry: function(e) {
            console.warn("v3d.CurvePath: .createGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            for (var t = new ql, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.vertices.push(new Tn(i.x, i.y, i.z || 0))
            }
            return t
        }
    }), Object.assign(mh.prototype, {
        fromPoints: function(e) {
            return console.warn("v3d.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), vp.prototype = Object.create(eh.prototype), gp.prototype = Object.create(eh.prototype), _p.prototype = Object.create(eh.prototype), Object.assign(_p.prototype, {
        initFromArray: function() {
            console.error("v3d.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("v3d.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("v3d.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), qf.prototype.setColors = function() {
        console.error("v3d.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Gf.prototype.update = function() {
        console.error("v3d.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(kd.prototype, {
        extractUrlBase: function(e) {
            return console.warn("v3d.Loader: .extractUrlBase() has been deprecated. Use v3d.LoaderUtils.extractUrlBase() instead."), Ph.extractUrlBase(e)
        }
    }), kd.Handlers = {
        add: function() {
            console.error("v3d.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("v3d.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, Object.assign(Df.prototype, {
        center: function(e) {
            return console.warn("v3d.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("v3d.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("v3d.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("v3d.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(Ln.prototype, {
        center: function(e) {
            return console.warn("v3d.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("v3d.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("v3d.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("v3d.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("v3d.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(Yn.prototype, {
        empty: function() {
            return console.warn("v3d.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }
    }), ma.prototype.setFromMatrix = function(e) {
        return console.warn("v3d.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
    }, If.prototype.center = function(e) {
        return console.warn("v3d.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(mn, {
        random16: function() {
            return console.warn("v3d.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("v3d.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), mn.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("v3d.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), mn.ceilPowerOfTwo(e)
        }
    }), Object.assign(gn.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("v3d.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("v3d.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3(matrix) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("v3d.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function(e) {
            return console.warn("v3d.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3(matrix) instead."), e.applyMatrix3(this)
        },
        applyToVector3Array: function() {
            console.error("v3d.Matrix3: .applyToVector3Array() has been removed.")
        },
        getInverse: function(e) {
            return console.warn("v3d.Matrix3: .getInverse() has been removed. Use matrixInv.copy(matrix).invert(); instead."), this.copy(e).invert()
        }
    }), Object.assign(nr.prototype, {
        extractPosition: function(e) {
            return console.warn("v3d.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("v3d.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function() {
            return console.warn("v3d.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition(matrix) instead."), (new Tn).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(e) {
            return console.warn("v3d.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("v3d.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("v3d.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("v3d.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("v3d.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("v3d.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection(matrix) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("v3d.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        translate: function() {
            console.error("v3d.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("v3d.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("v3d.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("v3d.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("v3d.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function(e) {
            return console.warn("v3d.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        applyToVector3Array: function() {
            console.error("v3d.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, n, r, i, a) {
            return console.warn("v3d.Matrix4: .makeFrustum() has been removed. Use .makePerspective(left, right, top, bottom, near, far) instead."), this.makePerspective(e, t, r, n, i, a)
        },
        getInverse: function(e) {
            return console.warn("v3d.Matrix4: .getInverse() has been removed. Use matrixInv.copy(matrix).invert(); instead."), this.copy(e).invert()
        }
    }), Rr.prototype.isIntersectionLine = function(e) {
        return console.warn("v3d.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, Object.assign(An.prototype, {
        multiplyVector3: function(e) {
            return console.warn("v3d.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion(quaternion) instead."), e.applyQuaternion(this)
        },
        inverse: function() {
            return console.warn("v3d.Quaternion: .inverse() has been renamed to invert()."), this.invert()
        }
    }), Object.assign(tr.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("v3d.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("v3d.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("v3d.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(Gr.prototype, {
        area: function() {
            return console.warn("v3d.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("v3d.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("v3d.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("v3d.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("v3d.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(Gr, {
        barycoordFromPoint: function(e, t, n, r, i) {
            return console.warn("v3d.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Gr.getBarycoord(e, t, n, r, i)
        },
        normal: function(e, t, n, r) {
            return console.warn("v3d.Triangle: .normal() has been renamed to .getNormal()."), Gr.getNormal(e, t, n, r)
        }
    }), Object.assign(vh.prototype, {
        extractAllPoints: function(e) {
            return console.warn("v3d.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("v3d.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Dc(this, e)
        },
        makeGeometry: function(e) {
            return console.warn("v3d.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Xc(this, e)
        }
    }), Object.assign(vn.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("v3d.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("v3d.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("v3d.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Tn.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("v3d.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("v3d.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("v3d.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("v3d.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("v3d.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("v3d.Vector3: .applyProjection() has been removed. Use .applyMatrix4(m) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, n) {
            return console.warn("v3d.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("v3d.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("v3d.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Mn.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("v3d.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        lengthManhattan: function() {
            return console.warn("v3d.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(ql.prototype, {
        computeTangents: function() {
            console.error("v3d.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("v3d.Geometry: .computeLineDistances() has been removed. Use v3d.Line.computeLineDistances() instead.")
        },
        applyMatrix: function(e) {
            return console.warn("v3d.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.assign(Er.prototype, {
        getChildByName: function(e) {
            return console.warn("v3d.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("v3d.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("v3d.Object3D: .translate() has been removed. Use .translateOnAxis(axis, distance) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("v3d.Object3D: .getWorldRotation() has been removed. Use v3d.Object3D.getWorldQuaternion(target) instead.")
        },
        applyMatrix: function(e) {
            return console.warn("v3d.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.defineProperties(Er.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("v3d.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(e) {
                console.warn("v3d.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("v3d.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("v3d.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.assign(Ki.prototype, {
        setDrawMode: function() {
            console.error("v3d.Mesh: .setDrawMode() has been removed. The renderer now always assumes v3d.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }), Object.defineProperties(Ki.prototype, {
        drawMode: {
            get: function() {
                return console.error("v3d.Mesh: .drawMode has been removed. The renderer now always assumes v3d.TrianglesDrawMode."), 0
            },
            set: function() {
                console.error("v3d.Mesh: .drawMode has been removed. The renderer now always assumes v3d.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }), Object.defineProperties(ol.prototype, {
        objects: {
            get: function() {
                return console.warn("v3d.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(vl.prototype, "useVertexTexture", {
        get: function() {
            console.warn("v3d.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("v3d.Skeleton: useVertexTexture has been removed.")
        }
    }), hl.prototype.initBones = function() {
        console.error("v3d.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Xd.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("v3d.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("v3d.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), la.prototype.setLens = function(e, t) {
        console.warn("v3d.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(gh.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("v3d.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("v3d.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("v3d.Light: .shadowCameraVisible has been removed. Use new v3d.CameraHelper(light.shadow.camera) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("v3d.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("v3d.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("v3d.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("v3d.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(ri.prototype, {
        length: {
            get: function() {
                return console.warn("v3d.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("v3d.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === rn
            },
            set: function() {
                console.warn("v3d.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(rn)
            }
        }
    }), Object.assign(ri.prototype, {
        setDynamic: function(e) {
            return console.warn("v3d.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? rn : nn), this
        },
        copyIndicesArray: function() {
            console.error("v3d.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function() {
            console.error("v3d.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(Oi.prototype, {
        addIndex: function(e) {
            console.warn("v3d.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addAttribute: function(e, t) {
            return console.warn("v3d.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("v3d.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("v3d.BufferGeometry: .addAttribute() now expects (name, attribute)."), this.setAttribute(e, new ri(t, arguments[2])))
        },
        addDrawCall: function(e, t, n) {
            void 0 !== n && console.warn("v3d.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("v3d.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("v3d.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("v3d.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("v3d.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function(e) {
            return console.warn("v3d.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
        },
        applyMatrix: function(e) {
            return console.warn("v3d.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.defineProperties(Oi.prototype, {
        drawcalls: {
            get: function() {
                return console.error("v3d.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("v3d.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Rh.prototype, {
        maxInstancedCount: {
            get: function() {
                return console.warn("v3d.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
            },
            set: function(e) {
                console.warn("v3d.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e
            }
        }
    }), Object.defineProperties(Cs.prototype, {
        linePrecision: {
            get: function() {
                return console.warn("v3d.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
            },
            set: function(e) {
                console.warn("v3d.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e
            }
        }
    }), Object.defineProperties(zs.prototype, {
        dynamic: {
            get: function() {
                return console.warn("v3d.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === rn
            },
            set: function(e) {
                console.warn("v3d.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e)
            }
        }
    }), Object.assign(zs.prototype, {
        setDynamic: function(e) {
            return console.warn("v3d.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? rn : nn), this
        },
        setArray: function() {
            console.error("v3d.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(Pc.prototype, {
        getArrays: function() {
            console.error("v3d.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("v3d.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("v3d.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.assign(_a.prototype, {
        dispose: function() {
            console.error("v3d.Scene: .dispose() has been removed.")
        }
    }), Object.defineProperties(Ef.prototype, {
        dynamic: {
            set: function() {
                console.warn("v3d.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("v3d.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties($r.prototype, {
        wrapAround: {
            get: function() {
                console.warn("v3d.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("v3d.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("v3d.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("v3d.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("v3d.Material: .wrapRGB has been removed."), new Qr
            }
        },
        shading: {
            get: function() {
                console.error("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("v3d." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            },
            set: function(e) {
                console.warn("v3d." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
            }
        }
    }), Object.defineProperties(mu.prototype, {
        metal: {
            get: function() {
                return console.warn("v3d.MeshPhongMaterial: .metal has been removed. Use v3d.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("v3d.MeshPhongMaterial: .metal has been removed. Use v3d.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(pu.prototype, {
        transparency: {
            get: function() {
                return console.warn("v3d.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission
            },
            set: function(e) {
                console.warn("v3d.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = e
            }
        }
    }), Object.defineProperties(oa.prototype, {
        derivatives: {
            get: function() {
                return console.warn("v3d.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(e) {
                console.warn("v3d. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(Is.prototype, {
        clearTarget: function(e, t, n, r) {
            console.warn("v3d.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
        },
        animate: function(e) {
            console.warn("v3d.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("v3d.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("v3d.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("v3d.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("v3d.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("v3d.WebGLRenderer: .supportsFloatTextures() is now .extensions.get('OES_texture_float')."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("v3d.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get('OES_texture_half_float')."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("v3d.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get('OES_standard_derivatives')."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("v3d.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get('WEBGL_compressed_texture_s3tc')."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("v3d.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get('WEBGL_compressed_texture_pvrtc')."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("v3d.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get('EXT_blend_minmax')."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("v3d.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("v3d.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get('ANGLE_instanced_arrays')."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("v3d.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("v3d.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("v3d.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("v3d.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("v3d.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("v3d.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("v3d.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("v3d.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("v3d.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("v3d.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("v3d.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }
    }), Object.defineProperties(Is.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("v3d.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("v3d.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("v3d.WebGLRenderer: .vr has been renamed to .xr"), this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("v3d.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("v3d.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Gt : Vt
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("v3d.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }), Object.defineProperties(xs.prototype, {
        cullFace: {
            get: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(wn.prototype, {
        wrapS: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("v3d.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("v3d.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(af.prototype, {
        load: {
            value: function(e) {
                console.warn("v3d.Audio: .load has been deprecated. Use v3d.AudioLoader instead.");
                var t = this;
                return (new Hh).load(e, function(e) {
                    t.setBuffer(e)
                }), this
            }
        },
        startTime: {
            set: function() {
                console.warn("v3d.Audio: .startTime is now .play(delay).")
            }
        }
    }), df.prototype.getData = function() {
        return console.warn("v3d.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, ca.prototype.updateCubeMap = function(e, t) {
        return console.warn("v3d.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    }, ca.prototype.clear = function(e, t, n, r) {
        return console.warn("v3d.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, r)
    };
    var yp = {
        merge: function(e, t, n) {
            var r;
            console.warn("v3d.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge(geometry2, matrix, materialIndexOffset) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
        },
        center: function(e) {
            return console.warn("v3d.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    };
    _n.crossOrigin = void 0, _n.loadTexture = function(e, t, n, r) {
        console.warn("v3d.ImageUtils.loadTexture has been deprecated. Use v3d.TextureLoader() instead.");
        var i = new Hd;
        i.setCrossOrigin(this.crossOrigin);
        r = i.load(e, n, void 0, r);
        return t && (r.mapping = t), r
    }, _n.loadTextureCube = function(e, t, n, r) {
        console.warn("v3d.ImageUtils.loadTextureCube has been deprecated. Use v3d.CubeTextureLoader() instead.");
        var i = new jd;
        i.setCrossOrigin(this.crossOrigin);
        r = i.load(e, n, void 0, r);
        return t && (r.mapping = t), r
    }, _n.loadCompressedTexture = function() {
        console.error("v3d.ImageUtils.loadCompressedTexture has been removed. Use v3d.DDSLoader instead.")
    }, _n.loadCompressedTextureCube = function() {
        console.error("v3d.ImageUtils.loadCompressedTextureCube has been removed. Use v3d.DDSLoader instead.")
    };
    var xp = new Tn,
        bp = new Tn,
        Mp = new Tn,
        wp = new vn,
        Sp = new vn,
        Ap = new vn,
        Tp = new Tn,
        Ep = new Tn;

    function Cp(e, t, n, r, i, a, o, s) {
        xp.fromBufferAttribute(r, a), bp.fromBufferAttribute(r, o), Mp.fromBufferAttribute(r, s);
        var l, c, u, d, l = (c = (l = e).material, u = t, d = n, r = xp, e = bp, t = Mp, n = Tp, null === (c = c.side === ae ? d.intersectTriangle(t, e, r, !0, n) : d.intersectTriangle(r, e, t, c.side !== oe, n)) ? null : (Ep.copy(n), Ep.applyMatrix4(l.matrixWorld), (n = u.ray.origin.distanceTo(Ep)) < u.near || n > u.far ? null : {
            distance: n,
            point: Ep.clone(),
            object: l
        }));
        return l && (i && (wp.fromBufferAttribute(i, a), Sp.fromBufferAttribute(i, o), Ap.fromBufferAttribute(i, s), l.uv = Gr.getUV(Tp, xp, bp, Mp, wp, Sp, Ap, new vn)), i = new Tn, l.face = new Kr(a, o, s, Gr.getNormal(xp, bp, Mp, i)), l.faceIndex = a), l
    }

    function Lp(e, t, n, r, i, a) {
        var o = 3 * i,
            s = t.index.getX(o),
            l = t.index.getX(1 + o),
            o = t.index.getX(2 + o),
            o = Cp(e, n, r, t.attributes.position, t.attributes.uv, s, l, o);
        return o ? (o.faceIndex = i, a && a.push(o), o) : null
    }

    function Pp(e, t) {
        return t.min.x = e[0], t.min.y = e[1], t.min.z = e[2], t.max.x = e[3], t.max.y = e[4], t.max.z = e[5], t
    }

    function Rp(e) {
        for (var t = -1, n = -1 / 0, r = 0; r < 3; r++) {
            var i = e[r + 3] - e[r];
            n < i && (n = i, t = r)
        }
        return t
    }
    var Dp, Op = function() {
        function e() {
            _classCallCheck(this, e), this.min = 1 / 0, this.max = -1 / 0
        }
        return _createClass(e, [{
            key: "setFromPointsField",
            value: function(e, t) {
                for (var n = 1 / 0, r = -1 / 0, i = 0, a = e.length; i < a; i++) var o = e[i][t],
                    n = Math.min(o, n),
                    r = Math.max(o, r);
                this.min = n, this.max = r
            }
        }, {
            key: "setFromPoints",
            value: function(e, t) {
                for (var n = 1 / 0, r = -1 / 0, i = 0, a = t.length; i < a; i++) var o = t[i],
                    o = e.dot(o),
                    n = Math.min(o, n),
                    r = Math.max(o, r);
                this.min = n, this.max = r
            }
        }, {
            key: "isSeparated",
            value: function(e) {
                return this.min > e.max || e.min > this.max
            }
        }]), e
    }();
    Op.prototype.setFromBox = (Dp = new Tn, function(e, t) {
        for (var n = t.min, r = t.max, i = 1 / 0, a = -1 / 0, o = 0; o <= 1; o++)
            for (var s = 0; s <= 1; s++)
                for (var l = 0; l <= 1; l++) {
                    Dp.x = n.x * o + r.x * (1 - o), Dp.y = n.y * s + r.y * (1 - s), Dp.z = n.z * l + r.z * (1 - l);
                    var c = e.dot(Dp),
                        i = Math.min(c, i),
                        a = Math.max(c, a)
                }
        this.min = i, this.max = a
    });
    var Np, Ip, Fp, kp, Bp, zp, Up, Vp, Gp, jp, Wp, Hp, Xp, Yp, qp, Zp, Qp, Kp, Jp, $p, em, tm, nm, rm = (Np = new Tn, Ip = new Tn, Fp = new Tn, function(e, t, n) {
            var r = e.start,
                i = Np,
                a = t.start,
                o = Ip;
            Fp.subVectors(r, a), Np.subVectors(e.end, t.start), Ip.subVectors(t.end, t.start);
            a = Fp.dot(o), e = o.dot(i), t = o.dot(o), o = Fp.dot(i), i = i.dot(i) * t - e * e, i = 0 != i ? (a * e - o * t) / i : 0, t = (a + i * e) / t;
            n.x = i, n.y = t
        }),
        im = (kp = new vn, Bp = new Tn, zp = new Tn, function(e, t, n, r) {
            rm(e, t, kp);
            var i, a, o = kp.x,
                s = kp.y;
            0 <= o && o <= 1 && 0 <= s && s <= 1 ? (e.at(o, n), t.at(s, r)) : 0 <= o && o <= 1 ? (s < 0 ? t.at(0, r) : t.at(1, r), e.closestPointToPoint(r, !0, n)) : 0 <= s && s <= 1 ? (o < 0 ? e.at(0, n) : e.at(1, n), t.closestPointToPoint(n, !0, r)) : (i = o < 0 ? e.start : e.end, a = s < 0 ? t.start : t.end, o = Bp, s = zp, e.closestPointToPoint(a, !0, Bp), t.closestPointToPoint(i, !0, zp), o.distanceToSquared(a) <= s.distanceToSquared(i) ? (n.copy(o), r.copy(a)) : (n.copy(i), r.copy(s)))
        }),
        am = (Up = new Tn, Vp = new Tn, Gp = new Rr, jp = new If, function(e, t) {
            var n = e.radius,
                r = e.center,
                i = t.a,
                a = t.b,
                e = t.c;
            if (jp.start = i, jp.end = a, jp.closestPointToPoint(r, !0, Up).distanceTo(r) <= n) return !0;
            if (jp.start = i, jp.end = e, jp.closestPointToPoint(r, !0, Up).distanceTo(r) <= n) return !0;
            if (jp.start = a, jp.end = e, jp.closestPointToPoint(r, !0, Up).distanceTo(r) <= n) return !0;
            e = t.getPlane(Gp);
            if (Math.abs(e.distanceToPoint(r)) <= n) {
                r = e.projectPoint(r, Vp);
                if (t.containsPoint(r)) return !0
            }
            return !1
        }),
        om = function() {
            _inherits(a, Gr);
            var i = _createSuper(a);

            function a() {
                var e;
                _classCallCheck(this, a);
                for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                return (e = i.call.apply(i, [this].concat(n))).isSeparatingAxisTriangle = !0, e.satAxes = new Array(4).fill().map(function() {
                    return new Tn
                }), e.satBounds = new Array(4).fill().map(function() {
                    return new Op
                }), e.points = [e.a, e.b, e.c], e.sphere = new Yn, e
            }
            return a
        }();
    om.prototype.update = (Wp = new Array(3), function() {
        var e = this.a,
            t = this.b,
            n = this.c;
        Wp[0] = this.a, Wp[1] = this.b, Wp[2] = this.c;
        var r = this.satAxes,
            i = this.satBounds,
            a = r[0],
            o = i[0];
        this.getNormal(a), o.setFromPoints(a, Wp);
        o = r[1], a = i[1];
        o.subVectors(e, t), a.setFromPoints(o, Wp);
        a = r[2], o = i[2];
        a.subVectors(t, n), o.setFromPoints(a, Wp);
        r = r[3], i = i[3];
        r.subVectors(n, e), i.setFromPoints(r, Wp), this.sphere.setFromPoints(this.points)
    }), om.prototype.intersectsTriangle = (Hp = new om, Xp = new Array(3), Yp = new Array(3), qp = new Op, Zp = new Op, Qp = new Tn, function(e) {
        e.isSeparatingAxisTriangle || (Hp.copy(e), Hp.update(), e = Hp);
        var t = this.satBounds,
            n = this.satAxes;
        Yp[0] = e.a, Yp[1] = e.b, Yp[2] = e.c;
        for (var r = 0; r < 4; r++) {
            var i = t[r],
                a = n[r];
            if (qp.setFromPoints(a, Yp), i.isSeparated(qp)) return !1
        }
        var o = e.satBounds,
            s = e.satAxes;
        Xp[0] = this.a, Xp[1] = this.b, Xp[2] = this.c;
        for (var l = 0; l < 4; l++) {
            var c = o[l],
                u = s[l];
            if (qp.setFromPoints(u, Xp), c.isSeparated(qp)) return !1
        }
        for (var d = 0; d < 4; d++)
            for (var h = n[d], f = 0; f < 4; f++) {
                var p = s[f];
                if (Qp.crossVectors(h, p), qp.setFromPoints(Qp, Xp), Zp.setFromPoints(Qp, Yp), qp.isSeparated(Zp)) return !1
            }
        return !0
    }), om.prototype.distanceToPoint = (Kp = new Tn, function(e) {
        return this.closestPointToPoint(e, Kp), e.distanceTo(Kp)
    }), om.prototype.distanceToTriangle = (Jp = new Tn, $p = new Tn, em = ["a", "b", "c"], tm = new If, nm = new If, function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (this.intersectsTriangle(e)) return (t || n) && (this.getMidpoint(Jp), e.closestPointToPoint(Jp, $p), this.closestPointToPoint($p, Jp), t && t.copy(Jp), n && n.copy($p)), 0;
        for (var r = 1 / 0, i = 0; i < 3; i++) {
            var a = void 0,
                o = em[i],
                s = e[o];
            this.closestPointToPoint(s, Jp), (a = s.distanceToSquared(Jp)) < r && (r = a, t && t.copy(Jp), n && n.copy(s));
            o = this[o];
            e.closestPointToPoint(o, Jp), (a = o.distanceToSquared(Jp)) < r && (r = a, t && t.copy(o), n && n.copy(Jp))
        }
        for (var l = 0; l < 3; l++) {
            var c = em[l],
                u = em[(l + 1) % 3];
            tm.set(this[c], this[u]);
            for (var d = 0; d < 3; d++) {
                var h = em[d],
                    f = em[(d + 1) % 3];
                nm.set(e[h], e[f]), im(tm, nm, Jp, $p);
                f = Jp.distanceToSquared($p);
                f < r && (r = f, t && t.copy(Jp), n && n.copy($p))
            }
        }
        return Math.sqrt(r)
    });
    var sm, lm, cm, um, dm, hm, fm, pm, mm, vm, gm, _m, ym = function() {
        _inherits(a, Ln);
        var i = _createSuper(a);

        function a() {
            var e;
            _classCallCheck(this, a);
            for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
            return (e = i.call.apply(i, [this].concat(n))).isOrientedBox = !0, e.matrix = new nr, e.invMatrix = new nr, e.points = new Array(8).fill().map(function() {
                return new Tn
            }), e.satAxes = new Array(3).fill().map(function() {
                return new Tn
            }), e.satBounds = new Array(3).fill().map(function() {
                return new Op
            }), e.alignedSatBounds = new Array(3).fill().map(function() {
                return new Op
            }), e.sphere = new Yn, e
        }
        return _createClass(a, [{
            key: "set",
            value: function(e, t, n) {
                _get(_getPrototypeOf(a.prototype), "set", this).call(this, e, t), this.matrix = n
            }
        }, {
            key: "copy",
            value: function(e) {
                _get(_getPrototypeOf(a.prototype), "copy", this).call(this, e), this.matrix.copy(e.matrix)
            }
        }]), a
    }();
    ym.prototype.update = function() {
        for (var e = this.matrix, t = this.min, n = this.max, r = this.points, i = 0; i <= 1; i++)
            for (var a = 0; a <= 1; a++)
                for (var o = 0; o <= 1; o++) {
                    var s = r[+i | 2 * a | 4 * o];
                    s.x = (i ? n : t).x, s.y = (a ? n : t).y, s.z = (o ? n : t).z, s.applyMatrix4(e)
                }
        this.sphere.setFromPoints(this.points);
        for (var l = this.satBounds, c = this.satAxes, u = r[0], d = 0; d < 3; d++) {
            var h = c[d],
                f = l[d],
                p = r[1 << d];
            h.subVectors(u, p), f.setFromPoints(h, r)
        }
        var m = this.alignedSatBounds;
        m[0].setFromPointsField(r, "x"), m[1].setFromPointsField(r, "y"), m[2].setFromPointsField(r, "z"), this.invMatrix.copy(this.matrix).invert()
    }, ym.prototype.intersectsBox = (sm = new Op, function(e) {
        if (!e.intersectsSphere(this.sphere)) return !1;
        var t = e.min,
            n = e.max,
            r = this.satBounds,
            i = this.satAxes,
            a = this.alignedSatBounds;
        if (sm.min = t.x, sm.max = n.x, a[0].isSeparated(sm)) return !1;
        if (sm.min = t.y, sm.max = n.y, a[1].isSeparated(sm)) return !1;
        if (sm.min = t.z, sm.max = n.z, a[2].isSeparated(sm)) return !1;
        for (var o = 0; o < 3; o++) {
            var s = i[o],
                l = r[o];
            if (sm.setFromBox(s, e), l.isSeparated(sm)) return !1
        }
        return !0
    }), ym.prototype.intersectsTriangle = (lm = new om, cm = new Array(3), um = new Op, dm = new Op, hm = new Tn, function(e) {
        e.isSeparatingAxisTriangle || (lm.copy(e), lm.update(), e = lm);
        var t = this.satBounds,
            n = this.satAxes;
        cm[0] = e.a, cm[1] = e.b, cm[2] = e.c;
        for (var r = 0; r < 3; r++) {
            var i = t[r],
                a = n[r];
            if (um.setFromPoints(a, cm), i.isSeparated(um)) return !1
        }
        for (var o = e.satBounds, s = e.satAxes, l = this.points, c = 0; c < 3; c++) {
            var u = o[c],
                d = s[c];
            if (um.setFromPoints(d, l), u.isSeparated(um)) return !1
        }
        for (var h = 0; h < 3; h++)
            for (var f = n[h], p = 0; p < 4; p++) {
                var m = s[p];
                if (hm.crossVectors(f, m), um.setFromPoints(hm, cm), dm.setFromPoints(hm, l), um.isSeparated(dm)) return !1
            }
        return !0
    }), ym.prototype.closestPointToPoint = function(e, t) {
        return t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t
    }, ym.prototype.distanceToPoint = (fm = new Tn, function(e) {
        return this.closestPointToPoint(e, fm), e.distanceTo(fm)
    }), ym.prototype.distanceToBox = (pm = ["x", "y", "z"], mm = new Array(12).fill().map(function() {
        return new If
    }), vm = new Array(12).fill().map(function() {
        return new If
    }), gm = new Tn, _m = new Tn, function(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
            n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        if (this.intersectsBox(e)) return (n || r) && (e.getCenter(_m), this.closestPointToPoint(_m, gm), e.closestPointToPoint(gm, _m), n && n.copy(gm), r && r.copy(_m)), 0;
        for (var i = t * t, a = e.min, o = e.max, s = this.points, l = 1 / 0, c = 0; c < 8; c++) {
            var u = s[c];
            _m.copy(u).clamp(a, o);
            var d = u.distanceToSquared(_m);
            if (d < l && (l = d, n && n.copy(u), r && r.copy(_m), d < i)) return Math.sqrt(d)
        }
        for (var h = 0, f = 0; f < 3; f++)
            for (var p = 0; p <= 1; p++)
                for (var m = 0; m <= 1; m++) {
                    var v = (f + 1) % 3,
                        g = (f + 2) % 3,
                        _ = 1 << f | p << v | m << g,
                        y = s[p << v | m << g],
                        x = s[_];
                    mm[h].set(y, x);
                    _ = pm[f], y = pm[v], x = pm[g], v = vm[h], g = v.start, v = v.end;
                    g[_] = a[_], g[y] = (p ? a : o)[y], g[x] = m ? a[x] : o[y], v[_] = o[_], v[y] = (p ? a : o)[y], v[x] = m ? a[x] : o[y], h++
                }
        for (var b = 0; b <= 1; b++)
            for (var M = 0; M <= 1; M++)
                for (var w = 0; w <= 1; w++) {
                    _m.x = (b ? o : a).x, _m.y = (M ? o : a).y, _m.z = (w ? o : a).z, this.closestPointToPoint(_m, gm);
                    var S = _m.distanceToSquared(gm);
                    if (S < l && (l = S, n && n.copy(gm), r && r.copy(_m), S < i)) return Math.sqrt(S)
                }
        for (var A = 0; A < 12; A++)
            for (var T = mm[A], E = 0; E < 12; E++) {
                var C = vm[E];
                im(T, C, gm, _m);
                C = gm.distanceToSquared(_m);
                if (C < l && (l = C, n && n.copy(gm), r && r.copy(_m), C < i)) return Math.sqrt(C)
            }
        return Math.sqrt(l)
    });
    var xm = new Ln,
        bm = new Tn,
        Mm = ["x", "y", "z"];

    function wm(e, t, n, r) {
        var i = e.a,
            a = e.b,
            o = e.c,
            e = n.getX(t);
        i.x = r.getX(e), i.y = r.getY(e), i.z = r.getZ(e), e = n.getX(t + 1), a.x = r.getX(e), a.y = r.getY(e), a.z = r.getZ(e), e = n.getX(t + 2), o.x = r.getX(e), o.y = r.getY(e), o.z = r.getZ(e)
    }
    var Sm, Am, Tm, Em, Cm, Lm, Pm, Rm, Dm, Om, Nm, Im, Fm, km, Bm, zm = function() {
        function e() {
            _classCallCheck(this, e)
        }
        return _createClass(e, [{
            key: "intersectRay",
            value: function(e, t) {
                return Pp(this.boundingData, xm), e.intersectBox(xm, t)
            }
        }, {
            key: "raycast",
            value: function(e, t, n, r) {
                this.count ? function(e, t, n, r, i, a, o) {
                    for (var s = i, l = i + a; s < l; s++) Lp(e, t, n, r, s, o)
                }(e, e.geometry, t, n, this.offset, this.count, r) : (this.left.intersectRay(n, bm) && this.left.raycast(e, t, n, r), this.right.intersectRay(n, bm) && this.right.raycast(e, t, n, r))
            }
        }, {
            key: "raycastFirst",
            value: function(e, t, n) {
                if (this.count) return function(e, t, n, r, i, a) {
                    for (var o = 1 / 0, s = null, l = i, c = i + a; l < c; l++) {
                        var u = Lp(e, t, n, r, l);
                        u && u.distance < o && (o = (s = u).distance)
                    }
                    return s
                }(e, e.geometry, t, n, this.offset, this.count);
                var r = this.splitAxis,
                    i = Mm[r],
                    a = 0 <= n.direction[i] ? (l = this.left, this.right) : (l = this.right, this.left),
                    o = l.intersectRay(n, bm) ? l.raycastFirst(e, t, n) : null;
                if (o) {
                    var s = n.origin[i],
                        l = s - o.point[i],
                        i = s - a.boundingData[r],
                        r = s - a.boundingData[r + 3],
                        l = l * l;
                    if (l <= i * i && l <= r * r) return o
                }
                n = a.intersectRay(n, bm) ? a.raycastFirst(e, t, n) : null;
                return o && n ? o.distance <= n.distance ? o : n : o || n || null
            }
        }]), e
    }();
    zm.prototype.shapecast = (Sm = new om, Am = new Ln, Tm = new Ln, function(e, t) {
        var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        if (this.count && n) {
            for (var i = e.geometry, a = i.index, o = i.attributes.position, s = this.offset, l = 3 * s, c = 3 * (this.count + s); l < c; l += 3)
                if (wm(Sm, l, a, o), Sm.update(), n(Sm, l, l + 1, l + 2)) return !0;
            return !1
        }
        var u, d, h, f, p = this.left,
            m = this.right,
            i = p,
            s = m;
        return r && (h = Am, f = Tm, Pp(i.boundingData, h), Pp(s.boundingData, f), u = r(h), (d = r(f)) < u && (i = m, s = p, p = u, u = d, d = p, p = h, h = f, f = p)), h || (h = Am, Pp(i.boundingData, h)), !(!t(h, !!i.count, u, i) || !i.shapecast(e, t, n, r)) || (f || (f = Tm, Pp(s.boundingData, f)), !(!t(f, !!s.count, d, s) || !s.shapecast(e, t, n, r)))
    }), zm.prototype.intersectsGeometry = (Em = new om, Cm = new om, Lm = new Ki, Pm = new nr, Rm = new ym, Dm = new ym, function(e, t, r) {
        var n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        if (null === n && (t.boundingBox || t.computeBoundingBox(), Rm.set(t.boundingBox.min, t.boundingBox.max, r), Rm.update(), n = Rm), !this.count) {
            var i = this.left,
                a = this.right;
            return (Pp(i.boundingData, xm), n.intersectsBox(xm) && i.intersectsGeometry(e, t, r, n)) ? !0 : (Pp(a.boundingData, xm), !(!n.intersectsBox(xm) || !a.intersectsGeometry(e, t, r, n)))
        }
        var e = e.geometry,
            o = e.index,
            s = e.attributes.position,
            l = t.index,
            c = t.attributes.position,
            u = this.offset,
            d = this.count;
        if (Pm.copy(r).invert(), t.boundsTree) {
            Pp(this.boundingData, Dm), Dm.matrix.copy(Pm), Dm.update();
            t = (Lm.geometry = t).boundsTree.shapecast(Lm, function(e) {
                return Dm.intersectsBox(e)
            }, function(e) {
                e.a.applyMatrix4(r), e.b.applyMatrix4(r), e.c.applyMatrix4(r), e.update();
                for (var t = 3 * u, n = 3 * (d + u); t < n; t += 3)
                    if (wm(Cm, t, o, s), Cm.update(), e.intersectsTriangle(Cm)) return !0;
                return !1
            });
            return Lm.geometry = null, t
        }
        for (var h = 3 * u, f = d + 3 * u; h < f; h += 3) {
            wm(Em, h, o, s), Em.a.applyMatrix4(Pm), Em.b.applyMatrix4(Pm), Em.c.applyMatrix4(Pm), Em.update();
            for (var p = 0, m = l.count; p < m; p += 3)
                if (wm(Cm, p, l, c), Cm.update(), Em.intersectsTriangle(Cm)) return !0
        }
    }), zm.prototype.intersectsBox = (Om = new ym, function(e, t, n) {
        return Om.set(t.min, t.max, n), Om.update(), this.shapecast(e, function(e) {
            return Om.intersectsBox(e)
        }, function(e) {
            return Om.intersectsTriangle(e)
        })
    }), zm.prototype.intersectsSphere = function(e, t) {
        return this.shapecast(e, function(e) {
            return t.intersectsBox(e)
        }, function(e) {
            return am(t, e)
        })
    }, zm.prototype.closestPointToPoint = (Nm = new Tn, function(e, t) {
        var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null,
            r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0,
            i = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 1 / 0,
            a = 1 / 0;
        return this.shapecast(e, function(e, t, n) {
            return n < a && n < i
        }, function(e) {
            e.closestPointToPoint(t, Nm);
            e = t.distanceTo(Nm);
            return e < a && (n && n.copy(Nm), a = e), e < r
        }, function(e) {
            return e.distanceToPoint(t)
        }), a
    }), zm.prototype.closestPointToGeometry = (Im = new om, Fm = new ym, km = new Tn, Bm = new Tn, function(e, t, a) {
        var o = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null,
            s = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : null,
            l = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0,
            r = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 1 / 0;
        t.boundingBox || t.computeBoundingBox(), Fm.set(t.boundingBox.min, t.boundingBox.max, a), Fm.update();
        var c, u, d = t.attributes.position,
            h = t.index;
        o && (c = km), s && (u = Bm);
        var f = 1 / 0;
        return this.shapecast(e, function(e, t, n) {
            return n < f && n < r
        }, function(e) {
            for (var t = e.sphere, n = 0, r = h.count; n < r; n += 3) {
                wm(Im, n, h, d), Im.a.applyMatrix4(a), Im.b.applyMatrix4(a), Im.c.applyMatrix4(a), Im.sphere.setFromPoints(Im.points);
                var i = Im.sphere,
                    i = i.center.distanceTo(t.center) - i.radius - t.radius;
                if (!(f < i)) {
                    Im.update();
                    i = e.distanceToTriangle(Im, c, u);
                    if (i < f && (o && o.copy(c), s && s.copy(u), f = i), i < l) return !0
                }
            }
            return !1
        }, function(e) {
            return Fm.distanceToBox(e, Math.min(f, r))
        }), f
    });
    var Um = 0,
        Vm = 2,
        Gm = ["x", "y", "z"];
    var jm = new Ln,
        Wm = function() {
            function a(e, t) {
                if (_classCallCheck(this, a), this.geo = e, this.options = t, this.bounds = function(e) {
                        for (var t = e.attributes.position.array, n = e.index.array, r = n.length / 3, i = new Float32Array(6 * r), a = 0; a < r; a++)
                            for (var o = 3 * n[3 * a + 0], s = 3 * n[3 * a + 1], l = 3 * n[3 * a + 2], c = 0; c < 3; c++) {
                                var u = t[o + c],
                                    d = t[s + c],
                                    h = t[l + c],
                                    f = Math.min(u, d, h),
                                    h = (Math.max(u, d, h) - f) / 2;
                                i[6 * a + 2 * c] = f + h, i[6 * a + 2 * c + 1] = h
                            }
                        return i
                    }(e), this.sahplanes = null, t.strategy === Vm) {
                    var n = e.index.count / 3;
                    this.sahplanes = [new Array(n), new Array(n), new Array(n)];
                    for (var r = 0; r < n; r++)
                        for (var i = 0; i < 3; i++) this.sahplanes[i][r] = {
                            p: this.bounds[6 * r + 2 * i],
                            tri: r
                        }
                }
            }
            return _createClass(a, [{
                key: "getAverage",
                value: function(e, t, n) {
                    for (var r = 0, i = this.bounds, a = e, o = e + t; a < o; a++) r += i[6 * a + 2 * n];
                    return r / t
                }
            }, {
                key: "getBounds",
                value: function(e, t, n) {
                    for (var r = 1 / 0, i = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, c = this.bounds, u = e, d = e + t; u < d; u++) var h = c[6 * u + 0],
                        f = c[6 * u + 1],
                        r = Math.min(r, h - f),
                        o = Math.max(o, h + f),
                        h = c[6 * u + 2],
                        f = c[6 * u + 3],
                        i = Math.min(i, h - f),
                        s = Math.max(s, h + f),
                        h = c[6 * u + 4],
                        f = c[6 * u + 5],
                        a = Math.min(a, h - f),
                        l = Math.max(l, h + f);
                    return n[0] = r, n[1] = i, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n
                }
            }, {
                key: "partition",
                value: function(e, t, n) {
                    for (var r = e, i = e + t - 1, a = n.pos, o = 2 * n.axis, s = this.geo.index.array, l = this.bounds, c = this.sahplanes;;) {
                        for (; r <= i && l[6 * r + o] < a;) r++;
                        for (; r <= i && l[6 * i + o] >= a;) i--;
                        if (!(r < i)) return r;
                        for (var u = 0; u < 3; u++) {
                            var d = s[3 * r + u];
                            s[3 * r + u] = s[3 * i + u], s[3 * i + u] = d;
                            d = l[6 * r + 2 * u];
                            l[6 * r + 2 * u] = l[6 * i + 2 * u], l[6 * i + 2 * u] = d;
                            d = l[6 * r + 2 * u + 1];
                            l[6 * r + 2 * u + 1] = l[6 * i + 2 * u + 1], l[6 * i + 2 * u + 1] = d
                        }
                        if (c)
                            for (var h = 0; h < 3; h++) {
                                var f = c[h][r];
                                c[h][r] = c[h][i], c[h][i] = f
                            }
                        r++, i--
                    }
                }
            }, {
                key: "getOptimalSplit",
                value: function(e, t, n, r) {
                    var i, a = -1,
                        o = 0;
                    if (r === Um) - 1 !== (a = Rp(e)) && (o = (e[a + 3] + e[a]) / 2);
                    else if (1 === r) - 1 !== (a = Rp(e)) && (o = this.getAverage(t, n, a));
                    else if (r === Vm) {
                        for (var s = Pp(e, jm), l = [s.max.x - s.min.x, s.max.y - s.min.y, s.max.z - s.min.z], c = 2 * (l[0] * l[1] + l[0] * l[2] + l[1] * l[2]), u = [
                                [],
                                [],
                                []
                            ], d = t, h = t + n; d < h; d++)
                            for (var f = 0; f < 3; f++) u[f].push(this.sahplanes[f][d]);
                        u.forEach(function(e) {
                            return e.sort(function(e, t) {
                                return e.p - t.p
                            })
                        });
                        for (var a = -1, p = +n, m = 0; m < 3; m++)
                            for (var v = (m + 1) % 3, g = (m + 2) % 3, _ = s.min[Gm[m]], y = s.max[Gm[m]], x = u[m], b = 0, M = n, w = 0; w < x.length; w++) {
                                var S = x[w];
                                b++, M--;
                                var A = S.p - _,
                                    T = y - S.p,
                                    E = l[v],
                                    C = l[v],
                                    L = l[g],
                                    P = l[g],
                                    R = 2 * (E * L + E * A + L * A) / (i = c) * b + 2 * (C * P + C * T + P * T) / i * M + 3;
                                R < p && (a = m, o = S.p, p = R)
                            }
                    }
                    return {
                        axis: a,
                        pos: o
                    }
                }
            }]), a
        }(),
        Hm = function() {
            function n(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
                if (_classCallCheck(this, n), !e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
                if (e.attributes.position.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.");
                if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
                (t = Object.assign({
                    strategy: Um,
                    maxDepth: 40,
                    maxLeafTris: 10,
                    verbose: !0
                }, t)).strategy = Math.max(0, Math.min(2, t.strategy)), this._roots = this._buildTree(e, t)
            }
            return _createClass(n, [{
                key: "_ensureIndex",
                value: function(e) {
                    if (!e.index) {
                        var t = e.attributes.position.count,
                            n = new(65535 < t ? Uint32Array : Uint16Array)(t);
                        e.setIndex(new ri(n, 1));
                        for (var r = 0; r < t; r++) n[r] = r
                    }
                }
            }, {
                key: "_getRootIndexRanges",
                value: function(e) {
                    if (!e.groups || !e.groups.length) return [{
                        offset: 0,
                        count: e.index.count / 3
                    }];
                    for (var t = [], n = new Set, r = 0, i = e.groups; r < i.length; r++) {
                        var a = i[r];
                        n.add(a.start), n.add(a.start + a.count)
                    }
                    for (var o = Array.from(n.values()).sort(function(e, t) {
                            return e - t
                        }), s = 0; s < o.length - 1; s++) {
                        var l = o[s],
                            c = o[s + 1];
                        t.push({
                            offset: l / 3,
                            count: (c - l) / 3
                        })
                    }
                    return t
                }
            }, {
                key: "_buildTree",
                value: function(e, s) {
                    this._ensureIndex(e);
                    var t, n, l = new Wm(e, s),
                        c = !1,
                        u = function(e, t, n) {
                            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                            if (r >= s.maxDepth && (c = !0), n <= s.maxLeafTris || r >= s.maxDepth) return e.offset = t, e.count = n, e;
                            var i = l.getOptimalSplit(e.boundingData, t, n, s.strategy);
                            if (-1 === i.axis) return e.offset = t, e.count = n, e;
                            var a, o = l.partition(t, n, i);
                            return o === t || o === t + n ? (e.offset = t, e.count = n) : (e.splitAxis = i.axis, i = o - (a = t), (t = e.left = new zm).boundingData = l.getBounds(a, i, new Float32Array(6)), u(t, a, i, r + 1), o = o, n = n - i, (i = e.right = new zm).boundingData = l.getBounds(o, n, new Float32Array(6)), u(i, o, n, r + 1)), e
                        },
                        r = [],
                        i = this._getRootIndexRanges(e);
                    if (1 === i.length) {
                        var a = new zm,
                            o = i[0];
                        null != e.boundingBox ? a.boundingData = (t = e.boundingBox, (n = new Float32Array(6))[0] = t.min.x, n[1] = t.min.y, n[2] = t.min.z, n[3] = t.max.x, n[4] = t.max.y, n[5] = t.max.z, n) : a.boundingData = l.getBounds(o.offset, o.count, new Float32Array(6)), u(a, o.offset, o.count), r.push(a)
                    } else
                        for (var d = 0; d < i.length; d++) {
                            var h = i[d],
                                f = new zm;
                            f.boundingData = l.getBounds(h.offset, h.count, new Float32Array(6)), u(f, h.offset, h.count), r.push(f)
                        }
                    if (c && s.verbose && (console.warn("MeshBVH: Max depth of ".concat(s.maxDepth, " reached when generating BVH. Consider increasing maxDepth.")), console.warn(this, e)), null == e.boundingBox) {
                        var p = new Ln;
                        e.boundingBox = new Ln;
                        for (var m = 0; m < r.length; m++) {
                            var v = r[m];
                            e.boundingBox.union(Pp(v.boundingData, p))
                        }
                    }
                    return r
                }
            }, {
                key: "raycast",
                value: function(e, t, n, r) {
                    for (var i = 0, a = this._roots; i < a.length; i++) a[i].raycast(e, t, n, r)
                }
            }, {
                key: "raycastFirst",
                value: function(e, t, n) {
                    for (var r = null, i = 0, a = this._roots; i < a.length; i++) {
                        var o = a[i].raycastFirst(e, t, n);
                        null != o && (null == r || o.distance < r.distance) && (r = o)
                    }
                    return r
                }
            }, {
                key: "intersectsGeometry",
                value: function(e, t, n) {
                    for (var r = 0, i = this._roots; r < i.length; r++)
                        if (i[r].intersectsGeometry(e, t, n)) return !0;
                    return !1
                }
            }, {
                key: "shapecast",
                value: function(e, t) {
                    for (var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null, i = 0, a = this._roots; i < a.length; i++)
                        if (a[i].shapecast(e, t, n, r)) return !0;
                    return !1
                }
            }, {
                key: "intersectsBox",
                value: function(e, t, n) {
                    for (var r = 0, i = this._roots; r < i.length; r++)
                        if (i[r].intersectsBox(e, t, n)) return !0;
                    return !1
                }
            }, {
                key: "intersectsSphere",
                value: function(e, t) {
                    for (var n = 0, r = this._roots; n < r.length; n++)
                        if (r[n].intersectsSphere(e, t)) return !0;
                    return !1
                }
            }, {
                key: "closestPointToGeometry",
                value: function(e, t, n, r, i, a, o) {
                    for (var s = 1 / 0, l = 0, c = this._roots; l < c.length; l++) {
                        var u = c[l].closestPointToGeometry(e, t, n, r, i, a, o);
                        if (u < s && (s = u), u < a) return u
                    }
                    return s
                }
            }, {
                key: "distanceToGeometry",
                value: function(e, t, n, r, i) {
                    return this.closestPointToGeometry(e, t, n, null, null, r, i)
                }
            }, {
                key: "closestPointToPoint",
                value: function(e, t, n, r, i) {
                    for (var a = 1 / 0, o = 0, s = this._roots; o < s.length; o++) {
                        var l = s[o].closestPointToPoint(e, t, n, r, i);
                        if (l < a && (a = l), l < r) return l
                    }
                    return a
                }
            }, {
                key: "distanceToPoint",
                value: function(e, t, n, r) {
                    return this.closestPointToPoint(e, t, null, n, r)
                }
            }]), n
        }(),
        Xm = new Ml({
            color: 65416,
            transparent: !0,
            opacity: .3
        }),
        Ym = (new lp).geometry,
        qm = new Ln,
        Zm = function() {
            _inherits(a, Er);
            var i = _createSuper(a);

            function a(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return _classCallCheck(this, a), (t = i.call(this, "MeshBVHRootVisualizer")).depth = n, t._oldDepth = -1, t._mesh = e, t._boundsTree = null, t._group = r, t.update(), t
            }
            return _createClass(a, [{
                key: "update",
                value: function() {
                    var i = this;
                    if (this._mesh.geometry.boundsTree !== this._boundsTree || this._oldDepth !== this.depth) {
                        this._oldDepth = this.depth, this._boundsTree = this._mesh.geometry.boundsTree;
                        var a, o = 0;
                        for (this._boundsTree && (a = function(e, t) {
                                var n, r = "count" in e;
                                t !== i.depth && (t !== i.depth - 1 && !r || ((n = o < i.children.length ? i.children[o] : null) || ((n = new Rl(Ym, Xm)).raycast = function() {
                                    return []
                                }, i.add(n)), o++, Pp(e.boundingData, qm), qm.getCenter(n.position), n.scale.subVectors(qm.max, qm.min).multiplyScalar(.5), 0 === n.scale.x && (n.scale.x = Number.EPSILON), 0 === n.scale.y && (n.scale.y = Number.EPSILON), 0 === n.scale.z && (n.scale.z = Number.EPSILON)), r || (a(e.left, t + 1), a(e.right, t + 1)))
                            })(this._boundsTree._roots[this._group], 0); this.children.length > o;) this.remove(this.children.pop())
                    }
                }
            }]), a
        }(),
        Qm = function() {
            _inherits(i, Er);
            var r = _createSuper(i);

            function i(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10;
                return _classCallCheck(this, i), (t = r.call(this, "MeshBVHVisualizer")).depth = n, t._mesh = e, t._roots = [], t.update(), t
            }
            return _createClass(i, [{
                key: "update",
                value: function() {
                    for (var e = this._mesh.geometry.boundsTree, t = e ? e._roots.length : 0; this._roots.length > t;) this._roots.pop();
                    for (var n, r = 0; r < t; r++) r >= this._roots.length ? (n = new Zm(this._mesh, this.depth, r), this.add(n), this._roots.push(n)) : ((n = this._roots[r]).depth = this.depth, n.update());
                    this.position.copy(this._mesh.position), this.rotation.copy(this._mesh.rotation), this.scale.copy(this._mesh.scale)
                }
            }]), i
        }(),
        Km = new tr,
        Jm = new nr,
        $m = Ki.prototype.raycast;

    function ev(e, t) {
        if (this.geometry.boundsTree) {
            if (void 0 !== this.material) {
                try {
                    Jm.copy(this.matrixWorld).invert()
                } catch (e) {
                    return
                }
                var n;
                Km.copy(e.ray).applyMatrix4(Jm), !0 === e.firstHitOnly ? (n = this.geometry.boundsTree.raycastFirst(this, e, Km)) && t.push(n) : this.geometry.boundsTree.raycast(this, e, Km, t)
            }
        } else $m.call(this, e, t)
    }

    function tv(e) {
        return this.boundsTree = new Hm(this, e), this.boundsTree
    }

    function nv() {
        this.boundsTree = null
    }
    var rv, iv, av, ov, sv, lv, cv, uv, dv, hv, fv, pv, mv, vv, gv, _v, yv, xv, bv, Mv, wv, Sv, Av, Tv, Ev, Cv, Lv, Pv, Rv, Dv, Ov = ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "envMap", "gradientMap", "lightMap", "map", "metalnessMap", "normalMap", "roughnessMap", "specularMap"],
        Nv = {
            disposeTextures: function(t) {
                if (Ov.forEach(function(e) {
                        t[e] && t[e].isTexture && t[e].dispose()
                    }), "MeshNodeMaterial" == t.type)
                    for (var e in t.nodeTextures) t.nodeTextures[e] && t.nodeTextures[e].dispose()
            }
        };

    function Iv() {
        this.name = "", this.type = "Constraint", this.mute = !1
    }

    function Fv(e) {
        Iv.call(this), this.type = "TargetConstraint", this.target = e
    }

    function kv(e) {
        Fv.call(this, e), this.type = "ChildOfConstraint", this.offsetMatrix = new nr
    }

    function Bv(e) {
        Fv.call(this, e), this.type = "CopyLocationConstraint"
    }

    function zv(e) {
        Fv.call(this, e), this.type = "CopyRotationConstraint"
    }

    function Uv(e) {
        Fv.call(this, e), this.type = "CopyScaleConstraint"
    }

    function Vv(e) {
        Fv.call(this, e), this.type = "FloorConstraint", this.floorLocation = "Y", this.offset = 0
    }

    function Gv() {
        Iv.call(this), this.type = "LimitLocationConstraint", this.min = (new Tn).setScalar(-1 / 0), this.max = (new Tn).setScalar(1 / 0)
    }

    function jv() {
        Iv.call(this), this.type = "LimitRotationConstraint", this.axis = "Y", this.min = 0, this.max = 2 * Math.PI
    }

    function Wv() {
        Iv.call(this), this.type = "LimitScaleConstraint", this.min = (new Tn).setScalar(-1 / 0), this.max = (new Tn).setScalar(1 / 0)
    }

    function Hv(e) {
        Fv.call(this, e), this.type = "LockedTrackConstraint", this.trackAxis = "X", this.lockAxis = "Y"
    }

    function Xv(e) {
        Fv.call(this, e), this.type = "TrackToConstraint", this.trackAxis = "X", this.upAxis = "Y"
    }
    Object.assign(Iv.prototype, {
        isConstraint: !0,
        update: function(e) {
            this.mute
        },
        copy: function(e) {
            return this.name = e.name, this.mute = e.mute, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Fv.prototype = Object.assign(Object.create(Iv.prototype), {
        constructor: Fv,
        isTargetConstraint: !0,
        copy: function(e) {
            Iv.prototype.copy.call(this, e), this.target = e.target
        }
    }), kv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: kv,
        isChildOfConstraint: !0,
        copy: function(e) {
            Fv.prototype.copy.call(this, e), this.offsetMatrix.copy(e.offsetMatrix)
        },
        update: (rv = new nr, iv = (new An).setFromAxisAngle(new Tn(1, 0, 0), -Math.PI / 2), function(e) {
            Fv.prototype.update.call(this, e), this.mute || (rv.multiplyMatrices(this.target.matrixWorld, this.offsetMatrix), rv.decompose(e.position, e.quaternion, e.scale), e.isCamera && e.quaternion.multiply(iv))
        })
    }), Bv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: Bv,
        isCopyLocationConstraint: !0,
        update: (av = new An, ov = new Tn, function(e) {
            Fv.prototype.update.call(this, e), this.mute || (this.target.matrixWorld.decompose(e.position, av, ov), e.parent && e.parent.worldToLocal(e.position))
        })
    }), zv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: zv,
        isCopyRotationConstraint: !0,
        update: (sv = new Tn, lv = new An, cv = new Tn, uv = (new An).setFromAxisAngle(new Tn(1, 0, 0), -Math.PI / 2), function(e) {
            Fv.prototype.update.call(this, e), this.mute || (this.target.matrixWorld.decompose(sv, e.quaternion, cv), e.parent && (e.parent.matrixWorld.decompose(sv, lv, cv), e.quaternion.premultiply(lv.invert())), e.isCamera && e.quaternion.multiply(uv))
        })
    }), Uv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: Uv,
        isCopyScaleConstraint: !0,
        update: function(e) {
            Fv.prototype.update.call(this, e), this.mute || e.scale.copy(this.target.scale)
        }
    }), Vv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: Vv,
        isFloorConstraint: !0,
        copy: function(e) {
            Fv.prototype.copy.call(this, e), this.floorLocation = e.floorLocation, this.offset = e.offset
        },
        update: function(e) {
            if (Fv.prototype.update.call(this, e), !this.mute) {
                var t = e.position,
                    n = this.target.position,
                    r = this.offset;
                switch (this.floorLocation) {
                    case "X":
                        t.x = Math.max(t.x, n.x + r);
                        break;
                    case "Y":
                        t.y = Math.max(t.y, n.y + r);
                        break;
                    case "Z":
                        t.z = Math.max(t.z, n.z + r);
                        break;
                    case "-X":
                        t.x = Math.min(t.x, n.x + r);
                        break;
                    case "-Y":
                        t.y = Math.min(t.y, n.y + r);
                        break;
                    case "-Z":
                        t.z = Math.min(t.z, n.z + r)
                }
            }
        }
    }), Gv.prototype = Object.assign(Object.create(Iv.prototype), {
        constructor: Gv,
        isLimitLocationConstraint: !0,
        copy: function(e) {
            Iv.prototype.copy.call(this, e), this.min.copy(e.min), this.max.copy(e.max)
        },
        update: function(e) {
            Iv.prototype.update.call(this, e), this.mute || e.position.clamp(this.min, this.max)
        }
    }), jv.prototype = Object.assign(Object.create(Iv.prototype), {
        constructor: jv,
        isLimitRotationConstraint: !0,
        copy: function(e) {
            Iv.prototype.copy.call(this, e), this.axis = e.axis, this.min = e.min, this.max = e.max
        },
        update: (dv = new ur, function(e) {
            Iv.prototype.update.call(this, e), this.mute || ("X" == this.axis ? (dv.setFromQuaternion(e.quaternion, "XYZ"), dv.x = this._clampAngle(dv.x, this.min, this.max)) : "Y" == this.axis ? (dv.setFromQuaternion(e.quaternion, "YZX"), dv.y = this._clampAngle(dv.y, this.min, this.max)) : "Z" == this.axis && (dv.setFromQuaternion(e.quaternion, "ZXY"), dv.z = this._clampAngle(dv.z, this.min, this.max)), e.quaternion.setFromEuler(dv))
        }),
        _clampAngle: function(e, t, n) {
            return Math.abs(n - t) < 2 * Math.PI && (e = mn.clampAngle(e, t, n)), e
        }
    }), Wv.prototype = Object.assign(Object.create(Iv.prototype), {
        constructor: Wv,
        isLimitScaleConstraint: !0,
        copy: function(e) {
            Iv.prototype.copy.call(this, e), this.min.copy(e.min), this.max.copy(e.max)
        },
        update: function(e) {
            Iv.prototype.update.call(this, e), this.mute || e.scale.clamp(this.min, this.max)
        }
    }), Hv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: Hv,
        isLockedTrackConstraint: !0,
        copy: function(e) {
            Fv.prototype.copy.call(this, e), this.trackAxis = e.trackAxis, this.lockAxis = e.lockAxis
        },
        update: (hv = new Tn, fv = new Tn, pv = new Tn, mv = new Tn, vv = new Tn, gv = new Rr, _v = new Tn, yv = new Tn, xv = new An, bv = (new An).setFromAxisAngle(new Tn(1, 0, 0), -Math.PI / 2), function(e) {
            var t;
            Fv.prototype.update.call(this, e), this.mute || (pv.set("X" == this.trackAxis ? 1 : "-X" == this.trackAxis ? -1 : 0, "Y" == this.trackAxis ? 1 : "-Y" == this.trackAxis ? -1 : 0, "Z" == this.trackAxis ? 1 : "-Z" == this.trackAxis ? -1 : 0), mv.set("X" == this.lockAxis ? 1 : 0, "Y" == this.lockAxis ? 1 : 0, "Z" == this.lockAxis ? 1 : 0), 1 != Math.abs(pv.dot(mv)) && (hv.setFromMatrixPosition(e.matrixWorld), fv.setFromMatrixPosition(this.target.matrixWorld), gv.setFromNormalAndCoplanarPoint(mv, hv), gv.projectPoint(fv, vv).sub(hv), t = 0 < _v.crossVectors(pv, vv).dot(mv) ? 1 : -1, e.setRotationFromAxisAngle(gv.normal, t * pv.angleTo(vv)), e.parent && (e.parent.matrixWorld.decompose(yv, xv, yv), e.quaternion.premultiply(xv.invert())), e.isCamera && e.quaternion.multiply(bv)))
        })
    }), Xv.prototype = Object.assign(Object.create(Fv.prototype), {
        constructor: Xv,
        isTrackToConstraint: !0,
        copy: function(e) {
            Fv.prototype.copy.call(this, e), this.trackAxis = e.trackAxis, this.upAxis = e.upAxis
        },
        update: (Mv = new Rr, wv = new Tn, Sv = new Tn, Av = new Tn, Tv = new Tn, Ev = new Tn, Cv = new nr, Lv = new Tn, Pv = new An, Rv = new Tn(0, 1, 0), Dv = (new An).setFromAxisAngle(new Tn(1, 0, 0), -Math.PI / 2), function(e) {
            var t, n, r, i;
            Fv.prototype.update.call(this, e), this.mute || (t = this.trackAxis[this.trackAxis.length - 1], n = this.upAxis[this.upAxis.length - 1], r = "-" == this.trackAxis[0], i = "-" == this.upAxis[0], t != n && (wv.setFromMatrixPosition(e.matrixWorld), Sv.setFromMatrixPosition(this.target.matrixWorld), Av.subVectors(Sv, wv), Av.lengthSq() ? Av.normalize() : Av.set(0, -1, 0), Mv.set(Av, 0), 1 != Math.abs(Av.dot(Rv)) ? Mv.projectPoint(Rv, Tv).normalize() : Tv.set(0, 0, -1), r && Av.negate(), i && Tv.negate(), r = "Y" == t ? Av : "Y" == n ? Tv : null, i = "Z" == t ? Av : "Z" == n ? Tv : null, (n = "X" == t ? Av : "X" == n ? Tv : null) ? r ? i = i || Ev.crossVectors(n, r) : r = Ev.crossVectors(i, n) : n = Ev.crossVectors(r, i), Cv.makeBasis(n, r, i), e.setRotationFromMatrix(Cv), e.parent && (e.parent.matrixWorld.decompose(Lv, Pv, Lv), e.quaternion.premultiply(Pv.invert())), e.isCamera && e.quaternion.multiply(Dv)))
        })
    });
    var Yv, qv, Zv, Qv = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAUSE_BREAK: 19,
        CAPS_LOCK: 20,
        ESCAPE: 27,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        LEFT_WINDOW_KEY: 91,
        RIGHT_WINDOW_KEY: 92,
        SELECT_KEY: 93,
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        MULTIPLY: 106,
        ADD: 107,
        SUBTRACT: 109,
        DECIMAL_POINT: 110,
        DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        NUM_LOCK: 144,
        SCROLL_LOCK: 145,
        SEMI_COLON: 186,
        EQUAL_SIGN: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        FORWARD_SLASH: 191,
        GRAVE_ACCENT: 192,
        OPEN_BRACKET: 219,
        BACK_SLASH: 220,
        CLOSE_BRAKET: 221,
        SINGLE_QUOTE: 222
    };

    function Kv(e) {
        for (var t in this.isKeyDown = {}, Qv) this.isKeyDown[Qv[t]] = !1;
        this.onKeyDown = null, this.onKeyUp = null, this._domElement = e, this._keydownCb = function(e) {
            this.isKeyDown[e.keyCode] = !0, this.onKeyDown && this.onKeyDown(e)
        }.bind(this), this._keyupCb = function(e) {
            this.isKeyDown[e.keyCode] = !1, this.onKeyUp && this.onKeyUp(e)
        }.bind(this), this._domElement.addEventListener("keydown", this._keydownCb, !1), this._domElement.addEventListener("keyup", this._keyupCb, !1)
    }

    function Jv() {
        this.posFrom = new Tn, this.targetFrom = new Tn, this.posTo = new Tn, this.targetTo = new Tn, this.sphericalFrom = new zu, this.sphericalTo = new zu, this.finishCb = function() {}, this.movementType = un, this.active = !1, this.duration = 0, this.clock = new Kh
    }
    Object.assign(Kv.prototype, {
        dispose: function() {
            this._domElement.removeEventListener("keydown", this._keydownCb, !1), this._domElement.removeEventListener("keyup", this._keyupCb, !1)
        }
    }), Object.assign(Jv.prototype, {
        setup: (Zv = new Tn, function(e) {
            var t = e.posFrom,
                n = void 0 === t ? new Tn : t,
                r = e.targetFrom,
                i = void 0 === r ? new Tn : r,
                a = e.posTo,
                t = void 0 === a ? new Tn : a,
                r = e.targetTo,
                a = void 0 === r ? new Tn : r,
                r = e.finishCb,
                r = void 0 === r ? function() {} : r,
                e = e.movementType,
                e = void 0 === e ? un : e;
            return this.posFrom.copy(n), this.targetFrom.copy(i), this.posTo.copy(t), this.targetTo.copy(a), this.finishCb = r, this.movementType = e, 1 === this.movementType && (Zv.copy(this.posFrom).sub(this.targetFrom), this.sphericalFrom.setFromVector3(Zv), Zv.copy(this.posTo).sub(this.targetTo), this.sphericalTo.setFromVector3(Zv), a = mn.angleToRange_0_2Pi(this.sphericalFrom.theta), r = mn.angleToRange_0_2Pi(this.sphericalTo.theta), (e = Math.abs(a - r)) > Math.PI && (r = a + Math.sign(a - r) * (2 * Math.PI - e)), this.sphericalFrom.theta = a, this.sphericalTo.theta = r), this
        }),
        start: function(e) {
            this.active = !0, this.duration = e, this.clock.start()
        },
        update: (Yv = new Tn, qv = new Tn, function() {
            var e, t, n, r = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : function(e, t, n) {},
                i = this.clock.getElapsedTime() / this.duration,
                i = mn.smootherstep(i, 0, 1);
            qv.lerpVectors(this.targetFrom, this.targetTo, i), this.movementType === un ? Yv.lerpVectors(this.posFrom, this.posTo, i) : 1 === this.movementType && (e = mn.lerp(this.sphericalFrom.radius, this.sphericalTo.radius, i), t = mn.lerp(this.sphericalFrom.phi, this.sphericalTo.phi, i), n = mn.lerp(this.sphericalFrom.theta, this.sphericalTo.theta, i), Yv.setFromSphericalCoords(e, t, n), Yv.add(qv)), r(i, Yv, qv), 1 <= i && (this.active = !1, this.finishCb())
        })
    });

    function $v(e, t) {
        var s = this;
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        }, this.enableDamping = !0, this.enableRotate = !0, this.rotateSpeed = .9, this.rotateSpeedTouch = .75, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enableZoom = !0, this.zoomSpeed = 30, this.zoomSpeedKey = .2, this.zoomInertia = .05, this.enablePan = !0, this.panSpeedKey = .15, this.panInertia = .05, this.gazeLevel = 1.8, this.storyHeight = 3, this.collisionMeshes = [], Object.defineProperty(this, "inTween", {
            get: function() {
                return P.active
            }
        });
        var l = new Kh,
            n = new Tn,
            r = new Tn,
            i = new Tn,
            a = new Tn,
            o = new An,
            c = new Tn,
            u = {};
        u[Qv.W] = u[Qv.S] = u[Qv.A] = u[Qv.D] = u[Qv.UP_ARROW] = u[Qv.DOWN_ARROW] = u[Qv.LEFT_ARROW] = u[Qv.RIGHT_ARROW] = 0;
        var d = new Kv(window),
            h = !(d.onKeyDown = function(e) {
                e.keyCode in u && (u[e.keyCode] = 1)
            }),
            f = new zu,
            p = new zu,
            m = new vn,
            v = 1,
            g = 1,
            _ = new vn,
            y = new vn,
            x = 0,
            b = 0,
            M = 1,
            w = 1,
            S = new vn,
            A = new vn,
            T = 1,
            E = 1,
            C = new Cs(new Tn, new Tn(0, -1, 0)),
            L = C.params.checkVisibility = !1,
            P = new Jv,
            R = {
                type: "change"
            },
            D = {
                type: "start"
            },
            O = {
                type: "end"
            };
        this.handleResize = function() {
            var e, t;
            this.domElement === document ? (this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight) : (e = this.domElement.getBoundingClientRect(), t = this.domElement.ownerDocument.documentElement, this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height)
        }, this.handleEvent = function(e) {
            "function" == typeof this[e.type] && this[e.type](e)
        };
        var N, I, F, k, B = (N = new vn, function(e, t) {
            return N.set((e - .5 * s.screen.width - s.screen.left) / (.5 * s.screen.width), (s.screen.height + 2 * (s.screen.top - t)) / s.screen.width), N
        });

        function z(e) {
            !1 !== s.enabled && (e.preventDefault(), !1 !== s.enableRotate && (y.copy(B(e.pageX, e.pageY).negate()), _.copy(y), h = !0, document.addEventListener("mousemove", U, !1), document.addEventListener("mouseup", V, !1), document.addEventListener("mouseleave", V, !1), s.dispatchEvent(D)))
        }

        function U(e) {
            !1 !== s.enabled && (e.preventDefault(), h && !1 !== s.enableRotate && (y.copy(B(e.pageX, e.pageY).negate()), m.add(y).sub(_), _.copy(y), v = s.rotateSpeed, g = s.rotateInertia))
        }

        function V(e) {
            !1 !== s.enabled && (e.preventDefault(), h = !1, document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", V), document.removeEventListener("mouseleave", V), s.dispatchEvent(O))
        }

        function G(e) {
            if (!1 !== s.enabled && !1 !== s.enableZoom) {
                switch (e.preventDefault(), e.stopPropagation(), e.deltaMode) {
                    case 2:
                        b -= .025 * e.deltaY, M = s.zoomSpeed, w = s.zoomInertia;
                        break;
                    case 1:
                        b -= .01 * e.deltaY, M = s.zoomSpeed, w = s.zoomInertia;
                        break;
                    default:
                        b -= 25e-5 * e.deltaY, M = s.zoomSpeed, w = s.zoomInertia
                }
                s.dispatchEvent(D), s.dispatchEvent(O)
            }
        }

        function j(e) {
            !1 !== s.enabled && (e = e.touches[0], h = !0, y.copy(B(e.pageX, e.pageY).negate()), _.copy(y), s.dispatchEvent(D))
        }

        function W(e) {
            !1 !== s.enabled && (e.preventDefault(), e = e.touches[0], !1 !== s.enableRotate && (y.copy(B(e.pageX, e.pageY).negate()), m.add(y).sub(_), _.copy(y), v = s.rotateSpeedTouch, g = s.rotateInertiaTouch))
        }

        function H(e) {
            if (!1 !== s.enabled) {
                if (0 === e.touches.length) h = !1;
                else {
                    if (!1 === s.enableRotate) return;
                    h = !0, y.copy(B(e.touches[0].pageX, e.touches[0].pageY).negate()), _.copy(y)
                }
                s.dispatchEvent(O)
            }
        }

        function X(e) {
            !1 !== s.enabled && e.preventDefault()
        }
        this.update = function() {
            new Tn;
            return function() {
                var e;
                P.active ? P.update(function(e, t, n) {
                    if (s.object.position.copy(t), s.object.lookAt(n), 1 <= e) {
                        for (var r in p.set(0, 0, 0), m.set(0, 0), b = x = 0, S.set(0, 0), A.set(0, 0), u) u[r] = 0;
                        l.getDelta()
                    }
                }) : (s.object.getLocalDirection(c), f.setFromVector3(c), f.theta += p.theta * v, f.phi += p.phi * v, f.makeSafe(), c.setFromSpherical(f), n.copy(c).add(s.object.position), s.object.lookAtLocal(n), s.object.isPerspectiveCamera ? s.object.position.addScaledVector(c, x) : s.object.isOrthographicCamera && (s.object.zoom *= 1 + .15 * x, s.object.updateProjectionMatrix()), r.copy(c).cross(s.object.up).setLength(-S.x), r.add(i.copy(s.object.up).setLength(S.y)), s.object.position.add(r), function() {
                    var e, t = l.getDelta();
                    for (e in p.set(p.radius, m.y, m.x), m.x = s.enableDamping ? mn.expAverageClamp(m.x, 0, t, g, .001) : 0, m.y = s.enableDamping ? mn.expAverageClamp(m.y, 0, t, g, .001) : 0, p.set(p.radius, p.phi - m.y, p.theta - m.x), S.copy(A), A.x = s.enableDamping ? mn.expAverageClamp(A.x, 0, t, E, .001) : 0, A.y = s.enableDamping ? mn.expAverageClamp(A.y, 0, t, E, .001) : 0, S.sub(A), S.multiplyScalar(T), x = b, b = s.enableDamping ? mn.expAverageClamp(b, 0, t, w, .001) : 0, x -= b, x *= M, u) {
                        var n, r = e == Qv.A || e == Qv.LEFT_ARROW || e == Qv.D || e == Qv.RIGHT_ARROW,
                            i = e == Qv.W || e == Qv.UP_ARROW || e == Qv.S || e == Qv.DOWN_ARROW,
                            a = r ? s.panInertia : s.zoomInertia,
                            o = r ? s.panSpeedKey : s.zoomSpeedKey;
                        n = d.isKeyDown[e] ? u[e] = 1 : (n = u[e], u[e] = mn.expAverageClamp(u[e], 0, t, a, .001), n - u[e]), s.enabled && (r && !s.enablePan || i && !s.enableZoom || (n *= 60 * t * o, e == Qv.A || e == Qv.LEFT_ARROW ? S.x += n : e == Qv.D || e == Qv.RIGHT_ARROW ? S.x -= n : e == Qv.W || e == Qv.UP_ARROW ? x += n : e != Qv.S && e != Qv.DOWN_ARROW || (x -= n)))
                    }
                }()), s.collisionMeshes.length && (C.ray.origin.copy(s.object.position), C.far = s.storyHeight, 0 < (e = C.intersectObjects(s.collisionMeshes)).length ? (t = e[0], s.object.position.y = t.point.y + s.gazeLevel, L = !0) : L && s.object.position.copy(a));
                var t = !1;
                1e-6 < a.distanceToSquared(s.object.position) && (a.copy(s.object.position), t = !0), o.dot(s.object.quaternion) < 1 - 1e-6 && (o.copy(s.object.quaternion), t = !0), t && s.dispatchEvent(R)
            }
        }(), this.forceMouseUp = function() {
            V({
                preventDefault: function() {}
            })
        }, this.dispose = function() {
            this.domElement.removeEventListener("contextmenu", X, !1), this.domElement.removeEventListener("mousedown", z, !1), this.domElement.removeEventListener("wheel", G, !1), this.domElement.removeEventListener("touchstart", j, !1), this.domElement.removeEventListener("touchend", H, !1), this.domElement.removeEventListener("touchmove", W, !1), document.removeEventListener("mousemove", U, !1), document.removeEventListener("mouseup", V, !1), document.removeEventListener("mouseleave", V, !1), d.dispose()
        }, this.releaseFromCollision = function() {
            L = !1
        }, this.tween = (I = new Tn, F = new Tn, k = new Tn, function(e, t, n, r, i) {
            s.object.parent && (e = I.copy(e), s.object.parent.worldToLocal(e));
            var a = s.object.getWorldPosition(F),
                o = k.subVectors(t, a).length(),
                a = s.object.getWorldDirection(k).multiplyScalar(o).add(a);
            e.manhattanDistanceTo(s.object.position) < 1e-5 && t.manhattanDistanceTo(a) < 1e-5 ? void 0 !== r && r() : P.setup({
                posFrom: s.object.position,
                targetFrom: a,
                posTo: e,
                targetTo: t,
                finishCb: r,
                movementType: i
            }).start(n)
        }), this.domElement.addEventListener("contextmenu", X, !1), this.domElement.addEventListener("mousedown", z, !1), this.domElement.addEventListener("wheel", G, !1), this.domElement.addEventListener("touchstart", j, !1), this.domElement.addEventListener("touchend", H, !1), this.domElement.addEventListener("touchmove", W, !1), this.handleResize(), this.update()
    }
    Object.assign($v.prototype, n.prototype);

    function eg(e, t) {
        var s = this,
            r = {
                NONE: -1,
                ROTATE: 0,
                ZOOM: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_ZOOM_PAN: 4
            };
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        }, this.enableDamping = !0, this.enableRotate = !0, this.rotateSpeed = .9, this.rotateSpeedTouch = .75, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enableZoom = !0, this.zoomSpeed = 150, this.zoomSpeedKey = .5, this.zoomSpeedTouch = 20, this.zoomInertia = .05, this.zoomInertiaTouch = .05, this.enablePan = !0, this.panSpeed = 20, this.panSpeedKey = .15, this.panSpeedTouch = 15, this.panInertia = .05, this.panInertiaTouch = .05, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.mouseButtons = {
            ROTATE: de.LEFT,
            ZOOM: de.MIDDLE,
            PAN: de.RIGHT
        }, Object.defineProperty(this, "inTween", {
            get: function() {
                return N.active
            }
        });
        var l = new Kh,
            n = new Tn,
            i = new Tn,
            a = new Tn,
            o = new vn,
            c = new Tn,
            u = new An,
            d = r.NONE,
            h = new Tn,
            f = {};
        f[Qv.W] = f[Qv.S] = f[Qv.A] = f[Qv.D] = f[Qv.UP_ARROW] = f[Qv.DOWN_ARROW] = f[Qv.LEFT_ARROW] = f[Qv.RIGHT_ARROW] = 0;
        var p = new Kv(window);
        p.onKeyDown = function(e) {
            e.keyCode in f && (f[e.keyCode] = 1)
        };
        var m = new zu,
            v = new zu,
            g = new vn,
            _ = 1,
            y = 1,
            x = new vn,
            b = new vn,
            M = 0,
            w = 0,
            S = 1,
            A = 1,
            T = 0,
            E = 0,
            C = new vn,
            L = new vn,
            P = 1,
            R = 1,
            D = new vn,
            O = new vn,
            N = new Jv,
            I = {
                type: "change"
            },
            F = {
                type: "start"
            },
            k = {
                type: "end"
            };
        this.handleResize = function() {
            var e, t;
            this.domElement === document ? (this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight) : (e = this.domElement.getBoundingClientRect(), t = this.domElement.ownerDocument.documentElement, this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height)
        }, this.handleEvent = function(e) {
            "function" == typeof this[e.type] && this[e.type](e)
        };
        var B, z, U, V, G, j = (B = new vn, function(e, t) {
                return B.set((e - s.screen.left) / s.screen.width, (t - s.screen.top) / s.screen.height), B
            }),
            W = (z = new vn, function(e, t) {
                return z.set((e - .5 * s.screen.width - s.screen.left) / (.5 * s.screen.width), (s.screen.height + 2 * (s.screen.top - t)) / s.screen.width), z
            });

        function H(e) {
            if (!1 !== s.enabled) {
                switch (e.preventDefault(), e.button) {
                    case s.mouseButtons.ROTATE:
                        if (!1 === s.enableRotate) return;
                        b.copy(W(e.pageX, e.pageY).negate()), x.copy(b), d = r.ROTATE;
                        break;
                    case s.mouseButtons.ZOOM:
                    case s.mouseButtons.PAN:
                        if (!1 === s.enablePan) return;
                        D.copy(j(e.pageX, e.pageY)), O.copy(D), d = e.button == s.mouseButtons.PAN ? r.PAN : r.ZOOM
                }
                document.addEventListener("mousemove", X, !1), document.addEventListener("mouseup", Y, !1), document.addEventListener("mouseleave", Y, !1), s.dispatchEvent(F)
            }
        }

        function X(e) {
            !1 !== s.enabled && (e.preventDefault(), d === r.ROTATE ? !1 !== s.enableRotate && (b.copy(W(e.pageX, e.pageY).negate()), g.add(b).sub(x), x.copy(b), _ = s.rotateSpeed, y = s.rotateInertia) : d !== r.PAN && d !== r.ZOOM || !1 !== s.enablePan && (O.copy(j(e.pageX, e.pageY)), L.add(O).sub(D), D.copy(O), P = s.panSpeed, R = s.panInertia))
        }

        function Y(e) {
            !1 !== s.enabled && (e.preventDefault(), d = r.NONE, document.removeEventListener("mousemove", X), document.removeEventListener("mouseup", Y), document.removeEventListener("mouseleave", Y), s.dispatchEvent(k))
        }

        function q(e) {
            if (!1 !== s.enabled && !1 !== s.enableZoom) {
                switch (e.preventDefault(), e.stopPropagation(), e.deltaMode) {
                    case 2:
                        w -= .025 * e.deltaY, S = s.zoomSpeed, A = s.zoomInertia;
                        break;
                    case 1:
                        w -= .01 * e.deltaY, S = s.zoomSpeed, A = s.zoomInertia;
                        break;
                    default:
                        w -= 25e-5 * e.deltaY, S = s.zoomSpeed, A = s.zoomInertia
                }
                s.dispatchEvent(F), s.dispatchEvent(k)
            }
        }

        function Z(e) {
            if (!1 !== s.enabled) {
                var t = e.touches[0],
                    n = e.touches[1];
                if (1 === e.touches.length) {
                    if (!1 === s.enableRotate) return;
                    d = r.TOUCH_ROTATE, b.copy(W(t.pageX, t.pageY).negate()), x.copy(b)
                } else {
                    if (!1 === s.enableZoom && !1 === s.enablePan) return;
                    d = r.TOUCH_ZOOM_PAN, s.enableZoom && (e = j(t.pageX - n.pageX, t.pageY - n.pageY), T = E = e.length()), s.enablePan && (n = j((t.pageX + n.pageX) / 2, (t.pageY + n.pageY) / 2), D.copy(n), O.copy(D))
                }
                s.dispatchEvent(F)
            }
        }

        function Q(e) {
            if (!1 !== s.enabled) {
                e.preventDefault();
                var t = e.touches[0],
                    n = e.touches[1];
                if (1 === e.touches.length) !1 !== s.enableRotate && (b.copy(W(t.pageX, t.pageY).negate()), g.add(b).sub(x), x.copy(b), _ = s.rotateSpeedTouch, y = s.rotateInertiaTouch);
                else !1 === s.enableZoom && !1 === s.enablePan || (e = j(t.pageX - n.pageX, t.pageY - n.pageY), e = (E = e.length()) - T, T = E, t = j((t.pageX + n.pageX) / 2, (t.pageY + n.pageY) / 2), O.copy(t), t = (n = o.subVectors(O, D)).length(), D.copy(O), s.enableZoom && Math.abs(e) > Math.abs(t) && (w += e, S = s.zoomSpeedTouch, A = s.zoomInertiaTouch), s.enablePan && Math.abs(e) <= Math.abs(t) && (L.add(n), P = s.panSpeedTouch, R = s.panInertiaTouch))
            }
        }

        function K(e) {
            if (!1 !== s.enabled) {
                switch (e.touches.length) {
                    case 0:
                        d = r.NONE;
                        break;
                    case 1:
                        if (!1 === s.enableRotate) return;
                        d = r.TOUCH_ROTATE, b.copy(W(e.touches[0].pageX, e.touches[0].pageY).negate()), x.copy(b)
                }
                s.dispatchEvent(k)
            }
        }

        function J(e) {
            !1 !== s.enabled && e.preventDefault()
        }
        this.update = function() {
            new Tn;
            return function() {
                N.active ? N.update(function(e, t, n) {
                    if (s.object.position.copy(t), s.object.lookAt(n), 1 <= e) {
                        for (var r in v.set(0, 0, 0), g.set(0, 0), w = M = 0, C.set(0, 0), L.set(0, 0), f) f[r] = 0;
                        l.getDelta()
                    }
                }) : (s.object.getLocalDirection(h), m.setFromVector3(h), m.theta += v.theta * _, m.phi += v.phi * _, m.theta = Math.max(s.minAzimuthAngle, Math.min(s.maxAzimuthAngle, m.theta)), m.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, m.phi)), m.makeSafe(), h.setFromSpherical(m), n.copy(h).add(s.object.position), s.object.lookAtLocal(n), s.object.isPerspectiveCamera ? s.object.position.addScaledVector(h, M) : s.object.isOrthographicCamera && (s.object.zoom *= 1 + .15 * M, s.object.updateProjectionMatrix()), i.copy(h).cross(s.object.up).setLength(-C.x), i.add(a.copy(s.object.up).setLength(C.y)), s.object.position.add(i), function() {
                    var e, t = l.getDelta();
                    for (e in v.set(v.radius, g.y, g.x), g.x = s.enableDamping ? mn.expAverageClamp(g.x, 0, t, y, .001) : 0, g.y = s.enableDamping ? mn.expAverageClamp(g.y, 0, t, y, .001) : 0, v.set(v.radius, v.phi - g.y, v.theta - g.x), C.copy(L), L.x = s.enableDamping ? mn.expAverageClamp(L.x, 0, t, R, .001) : 0, L.y = s.enableDamping ? mn.expAverageClamp(L.y, 0, t, R, .001) : 0, C.sub(L), C.multiplyScalar(P), M = w, w = s.enableDamping ? mn.expAverageClamp(w, 0, t, A, .001) : 0, M -= w, M *= S, f) {
                        var n, r = e == Qv.A || e == Qv.LEFT_ARROW || e == Qv.D || e == Qv.RIGHT_ARROW,
                            i = e == Qv.W || e == Qv.UP_ARROW || e == Qv.S || e == Qv.DOWN_ARROW,
                            a = r ? s.panInertia : s.zoomInertia,
                            o = r ? s.panSpeedKey : s.zoomSpeedKey;
                        n = p.isKeyDown[e] ? f[e] = 1 : (n = f[e], f[e] = mn.expAverageClamp(f[e], 0, t, a, .001), n - f[e]), s.enabled && (r && !s.enablePan || i && !s.enableZoom || (n *= 60 * t * o, e == Qv.A || e == Qv.LEFT_ARROW ? C.x += n : e == Qv.D || e == Qv.RIGHT_ARROW ? C.x -= n : e == Qv.W || e == Qv.UP_ARROW ? M += n : e != Qv.S && e != Qv.DOWN_ARROW || (M -= n)))
                    }
                }());
                var e = !1;
                1e-6 < c.distanceToSquared(s.object.position) && (c.copy(s.object.position), e = !0), u.dot(s.object.quaternion) < 1 - 1e-6 && (u.copy(s.object.quaternion), e = !0), e && s.dispatchEvent(I)
            }
        }(), this.forceMouseUp = function() {
            Y({
                preventDefault: function() {}
            })
        }, this.dispose = function() {
            this.domElement.removeEventListener("contextmenu", J, !1), this.domElement.removeEventListener("mousedown", H, !1), this.domElement.removeEventListener("wheel", q, !1), this.domElement.removeEventListener("touchstart", Z, !1), this.domElement.removeEventListener("touchend", K, !1), this.domElement.removeEventListener("touchmove", Q, !1), document.removeEventListener("mousemove", X, !1), document.removeEventListener("mouseup", Y, !1), document.removeEventListener("mouseleave", Y, !1), p.dispose()
        }, this.tween = (U = new Tn, V = new Tn, G = new Tn, function(e, t, n, r, i) {
            s.object.parent && (e = U.copy(e), s.object.parent.worldToLocal(e));
            var a = s.object.getWorldPosition(V),
                o = G.subVectors(t, a).length(),
                a = s.object.getWorldDirection(G).multiplyScalar(o).add(a);
            e.manhattanDistanceTo(s.object.position) < 1e-5 && t.manhattanDistanceTo(a) < 1e-5 ? void 0 !== r && r() : N.setup({
                posFrom: s.object.position,
                targetFrom: a,
                posTo: e,
                targetTo: t,
                finishCb: r,
                movementType: i
            }).start(n)
        }), this.domElement.addEventListener("contextmenu", J, !1), this.domElement.addEventListener("mousedown", H, !1), this.domElement.addEventListener("wheel", q, !1), this.domElement.addEventListener("touchstart", Z, !1), this.domElement.addEventListener("touchend", K, !1), this.domElement.addEventListener("touchmove", Q, !1), this.handleResize(), this.update()
    }
    Object.assign(eg.prototype, n.prototype);
    var tg, ng;

    function rg(e, t) {
        var n, r, a, o, s, l, c, u, d, h;
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.targetObj = new Er, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !0, this.enableZoom = !0, this.zoomSpeed = 5, this.zoomSpeedTouch = 1, this.zoomInertia = .05, this.zoomInertiaTouch = .05, this.enableRotate = !0, this.rotateSpeed = 1.2, this.rotateSpeedTouch = .7, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enablePan = !0, this.panSpeed = 1.3, this.screenSpacePanning = !0, this.panSpeedKey = 15, this.panInertia = .05, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.mouseButtons = {
            ROTATE: de.LEFT,
            ZOOM: de.MIDDLE,
            PAN: de.RIGHT
        }, this.target0 = this.targetObj.position.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, Object.defineProperty(this, "inTween", {
            get: function() {
                return j.active
            },
            set: function(e) {
                j.active = e
            }
        }), this.getPolarAngle = function() {
            return y.phi
        }, this.getAzimuthalAngle = function() {
            return y.theta
        }, this.saveState = function() {
            f.targetObj.updateWorldMatrix(!0, !1), f.target0.setFromMatrixPosition(f.targetObj.matrixWorld), f.position0.copy(f.object.position), f.zoom0 = f.object.zoom
        }, this.forceMouseUp = function() {
            ae()
        }, this.reset = (n = new Tn, function() {
            f.targetObj.updateWorldMatrix(!0, !1);
            var e = n.copy(f.target0);
            f.targetObj.worldToLocal(e), f.targetObj.position.add(e), f.object.position.copy(f.position0), f.object.zoom = f.zoom0, f.object.updateProjectionMatrix(), f.dispatchEvent(p), f.update(), g = v.NONE
        }), this.update = (r = new Tn, a = new Tn, o = new An, s = new An, l = new Tn(0, 1, 0), c = new Tn, u = new An, function() {
            var i = f.object.position;
            return f.targetObj.updateWorldMatrix(!0, !1), j.active ? j.update(function(e, t, n) {
                if (i.copy(t), a.copy(n), f.object.lookAt(a), 1 <= e) {
                    for (var r in x.set(0, 0, 0), M.set(0, 0, 0), b = 1, I.set(0, 0), S) S[r] = 0;
                    L.set(0, 0), G.getDelta()
                }
            }) : (a.setFromMatrixPosition(f.targetObj.matrixWorld), r.copy(i).sub(a), o.setFromUnitVectors(f.object.up, l), s.copy(o).invert(), r.applyQuaternion(o), y.setFromVector3(r), f.autoRotate && g === v.NONE && H(2 * Math.PI / 60 / 60 * f.autoRotateSpeed), y.theta += x.theta, y.phi += x.phi, isFinite(f.minAzimuthAngle) && isFinite(f.maxAzimuthAngle) && (y.theta = mn.clampAngle(y.theta, f.minAzimuthAngle, f.maxAzimuthAngle)), y.phi = Math.max(f.minPolarAngle, Math.min(f.maxPolarAngle, y.phi)), y.makeSafe(), f.object.isPerspectiveCamera ? (y.radius *= b, y.radius = Math.max(f.minDistance, Math.min(f.maxDistance, y.radius))) : f.object.isOrthographicCamera && (f.object.zoom /= b, f.object.zoom = Math.max(f.minZoom, Math.min(f.maxZoom, f.object.zoom)), f.object.updateProjectionMatrix()), a.add(M), r.setFromSpherical(y), r.applyQuaternion(s), i.copy(a).add(r), f.object.lookAt(a), x.set(0, 0, 0), M.set(0, 0, 0), function() {
                var e, t, n = G.getDelta();
                for (e in C.copy(L), L.x = f.enableDamping ? mn.expAverageClamp(L.x, 0, n, R, 1) : 0, L.y = f.enableDamping ? mn.expAverageClamp(L.y, 0, n, R, 1) : 0, C.sub(L), function() {
                        var e = f.domElement === document ? f.domElement.body : f.domElement,
                            t = e.clientWidth,
                            e = e.clientHeight;
                        if (!t || !e) return;
                        H(2 * Math.PI * C.x / t * P),
                            function(e) {
                                x.phi -= e
                            }(2 * Math.PI * C.y / e * P)
                    }(), N.copy(I), I.x = f.enableDamping ? mn.expAverageClamp(I.x, 0, n, f.panInertia, .1) : 0, I.y = f.enableDamping ? mn.expAverageClamp(I.y, 0, n, f.panInertia, .1) : 0, N.sub(I), N.multiplyScalar(f.panSpeed), S) t = A.isKeyDown[e] ? S[e] = 1 : (t = S[e], S[e] = mn.expAverageClamp(S[e], 0, n, f.panInertia, .1), t - S[e]), f.enabled && f.enableKeys && f.enablePan && (t *= 60 * n * f.panSpeedKey, e == Qv.A || e == Qv.LEFT_ARROW ? N.x += t : e == Qv.D || e == Qv.RIGHT_ARROW ? N.x -= t : e == Qv.W || e == Qv.UP_ARROW ? N.y += t : e != Qv.S && e != Qv.DOWN_ARROW || (N.y -= t));
                $(N.x, N.y), b = z, z = f.enableDamping ? mn.expAverageClamp(z, 1, n, V, .01) : 1, b /= z
            }()), f.targetObj.position.copy(a), !!(w || c.distanceToSquared(f.object.position) > _ || 8 * (1 - u.dot(f.object.quaternion)) > _) && (f.dispatchEvent(p), c.copy(f.object.position), u.copy(f.object.quaternion), !(w = !1))
        }), this.dispose = function() {
            f.domElement.removeEventListener("contextmenu", ue, !1), f.domElement.removeEventListener("mousedown", re, !1), f.domElement.removeEventListener("wheel", oe, !1), f.domElement.removeEventListener("touchstart", se, !1), f.domElement.removeEventListener("touchend", ce, !1), f.domElement.removeEventListener("touchmove", le, !1), document.removeEventListener("mousemove", ie, !1), document.removeEventListener("mouseup", ae, !1), document.removeEventListener("mouseleave", ae, !1), A.dispose()
        }, this.tween = (d = new Tn, h = new Tn, function(e, t, n, r, i) {
            f.targetObj.updateWorldMatrix(!0, !1), h.setFromMatrixPosition(f.targetObj.matrixWorld), f.object.parent && (e = d.copy(e), f.object.parent.worldToLocal(e));
            e.manhattanDistanceTo(f.object.position) < 1e-5 && t.manhattanDistanceTo(h) < 1e-5 ? void 0 !== r && r() : j.setup({
                posFrom: f.object.position,
                targetFrom: h,
                posTo: e,
                targetTo: t,
                finishCb: r,
                movementType: i
            }).start(n)
        });
        var f = this,
            p = {
                type: "change"
            },
            i = {
                type: "start"
            },
            m = {
                type: "end"
            },
            v = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY_PAN: 4
            },
            g = v.NONE,
            _ = 1e-6,
            y = new zu,
            x = new zu,
            b = 1,
            M = new Tn,
            w = !1,
            S = {};
        S[Qv.W] = S[Qv.S] = S[Qv.A] = S[Qv.D] = S[Qv.UP_ARROW] = S[Qv.DOWN_ARROW] = S[Qv.LEFT_ARROW] = S[Qv.RIGHT_ARROW] = 0;
        var A = new Kv(window);
        A.onKeyDown = function(e) {
            e.keyCode in S && (S[e.keyCode] = 1)
        };
        var T = new vn,
            E = new vn,
            C = new vn,
            L = new vn,
            P = 1,
            R = 1,
            D = new vn,
            O = new vn,
            N = new vn,
            I = new vn,
            F = new vn,
            k = new vn,
            B = new vn,
            z = 1,
            U = 1,
            V = 1,
            G = new Kh,
            j = new Jv;

        function W() {
            return Math.pow(.95, U)
        }

        function H(e) {
            x.theta -= e
        }

        function X(e, t) {
            E.set(e, t), L.add(E).sub(T), T.copy(E)
        }
        var Y, q, Z, Q, K = (Y = new Tn, function(e, t) {
                Y.setFromMatrixColumn(t, 0), Y.multiplyScalar(-e), M.add(Y)
            }),
            J = (q = new Tn, function(e, t) {
                !0 === f.screenSpacePanning ? q.setFromMatrixColumn(t, 1) : (q.setFromMatrixColumn(t, 0), q.crossVectors(f.object.up, q)), q.multiplyScalar(e), M.add(q)
            }),
            $ = (Z = new Tn, Q = new Tn, function(e, t) {
                var n = f.domElement === document ? f.domElement.body : f.domElement,
                    r = n.clientWidth,
                    i = n.clientHeight;
                r && i && (f.object.isPerspectiveCamera ? (f.targetObj.updateWorldMatrix(!0, !1), Q.setFromMatrixPosition(f.targetObj.matrixWorld), n = f.object.position, Z.copy(n).sub(Q), n = Z.length(), n *= Math.tan(f.object.fov / 2 * mn.DEG2RAD), K(2 * e * n / i, f.object.matrix), J(2 * t * n / i, f.object.matrix)) : f.object.isOrthographicCamera ? (K(e * (f.object.right - f.object.left) / f.object.zoom / r, f.object.matrix), J(t * (f.object.top - f.object.bottom) / f.object.zoom / i, f.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), f.enablePan = !1))
            });

        function ee(e) {
            f.object.isPerspectiveCamera ? z /= e : f.object.isOrthographicCamera ? (z /= e, w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), f.enableZoom = !1)
        }

        function te(e) {
            f.object.isPerspectiveCamera ? z *= e : f.object.isOrthographicCamera ? (z *= e, w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), f.enableZoom = !1)
        }

        function ne(e) {
            var t;
            t = e.clientX, e = e.clientY, O.set(t, e), I.add(O).sub(D), D.copy(O)
        }

        function re(e) {
            if (!1 !== f.enabled) {
                switch (e.preventDefault(), e.button) {
                    case f.mouseButtons.ROTATE:
                        if (!1 === f.enableRotate) return;
                        t = e, T.set(t.clientX, t.clientY), g = v.ROTATE;
                        break;
                    case f.mouseButtons.ZOOM:
                    case f.mouseButtons.PAN:
                        if (!1 === f.enablePan) return;
                        t = e, D.set(t.clientX, t.clientY), g = v.PAN
                }
                var t;
                g !== v.NONE && (document.addEventListener("mousemove", ie, !1), document.addEventListener("mouseup", ae, !1), document.addEventListener("mouseleave", ae, !1), f.dispatchEvent(i))
            }
        }

        function ie(e) {
            var t;
            if (!1 !== f.enabled) switch (e.preventDefault(), g) {
                case v.ROTATE:
                    if (!1 === f.enableRotate) return;
                    X((t = e).clientX, t.clientY), P = f.rotateSpeed, R = f.rotateInertia;
                    break;
                case v.DOLLY:
                    if (!1 === f.enableZoom) return;
                    t = e, k.set(t.clientX, t.clientY), B.subVectors(k, F), 0 < B.y ? ee(W()) : B.y < 0 && te(W()), F.copy(k), f.update();
                    break;
                case v.PAN:
                    if (!1 === f.enablePan) return;
                    ne(e)
            }
        }

        function ae(e) {
            !1 !== f.enabled && (document.removeEventListener("mousemove", ie, !1), document.removeEventListener("mouseup", ae, !1), document.removeEventListener("mouseleave", ae, !1), f.dispatchEvent(m), g = v.NONE)
        }

        function oe(e) {
            !1 === f.enabled || !1 === f.enableZoom || g !== v.NONE && g !== v.ROTATE || (e.preventDefault(), e.stopPropagation(), f.dispatchEvent(i), e = e, U = f.zoomSpeed, V = f.zoomInertia, e.deltaY < 0 ? te(W()) : 0 < e.deltaY && ee(W()), f.update(), f.dispatchEvent(m))
        }

        function se(e) {
            if (!1 !== f.enabled) {
                switch (e.touches.length) {
                    case 1:
                        if (!1 === f.enableRotate) return;
                        r = e, T.set(r.touches[0].pageX, r.touches[0].pageY), g = v.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === f.enableZoom && !1 === f.enablePan) return;
                        t = e, f.enableZoom && (U = f.zoomSpeedTouch, V = f.zoomInertiaTouch, r = t.touches[0].pageX - t.touches[1].pageX, n = t.touches[0].pageY - t.touches[1].pageY, n = Math.sqrt(r * r + n * n), F.set(0, n)), f.enablePan && (n = .5 * (t.touches[0].pageX + t.touches[1].pageX), t = .5 * (t.touches[0].pageY + t.touches[1].pageY), D.set(n, t)), f.update(), g = v.TOUCH_DOLLY_PAN;
                        break;
                    default:
                        g = v.NONE
                }
                var t, n, r;
                g !== v.NONE && f.dispatchEvent(i)
            }
        }

        function le(e) {
            var t, n, r;
            if (!1 !== f.enabled) switch (e.preventDefault(), e.touches.length) {
                case 1:
                    if (!1 === f.enableRotate) return;
                    if (g !== v.TOUCH_ROTATE) return;
                    X((r = e).touches[0].pageX, r.touches[0].pageY), P = f.rotateSpeedTouch, R = f.rotateInertiaTouch;
                    break;
                case 2:
                    if (!1 === f.enableZoom && !1 === f.enablePan) return;
                    if (g !== v.TOUCH_DOLLY_PAN) return;
                    n = (t = e).touches[0].pageX - t.touches[1].pageX, r = t.touches[0].pageY - t.touches[1].pageY, r = Math.sqrt(n * n + r * r), k.set(0, r), B.subVectors(k, F), F.copy(k), r = .5 * (t.touches[0].pageX + t.touches[1].pageX), t = .5 * (t.touches[0].pageY + t.touches[1].pageY), O.set(r, t), N.subVectors(O, D), D.copy(O), f.enableZoom && Math.abs(B.length()) > Math.abs(N.length()) && (0 < B.y ? te(W()) : B.y < 0 && ee(W())), f.enablePan && Math.abs(B.length()) < Math.abs(N.length()) && I.add(N), f.update();
                    break;
                default:
                    g = v.NONE
            }
        }

        function ce(e) {
            !1 !== f.enabled && (f.dispatchEvent(m), g = v.NONE)
        }

        function ue(e) {
            !1 !== f.enabled && e.preventDefault()
        }
        f.domElement.addEventListener("contextmenu", ue, !1), f.domElement.addEventListener("mousedown", re, !1), f.domElement.addEventListener("wheel", oe, !1), f.domElement.addEventListener("touchstart", se, !1), f.domElement.addEventListener("touchend", ce, !1), f.domElement.addEventListener("touchmove", le, !1), this.update()
    }

    function ig(e, t, n) {
        this.sourceTexture = e;
        n = Object.assign({
            mapping: e.mapping,
            wrapS: e.wrapS,
            wrapT: e.wrapT,
            magFilter: e.magFilter,
            minFilter: e.minFilter,
            format: e.format,
            type: e.type,
            anisotropy: e.anisotropy,
            encoding: e.encoding,
            generateMipmaps: e.generateMipmaps
        }, n);
        this.renderTarget = new da(t, n), this.renderTarget.texture.name = e.name, this.renderTarget.texture.flipY = e.flipY, this.camera = new ms(-1, 1, 1, -1, 0, 1), this.shader = new oa({
            type: "CubeCopy",
            uniforms: {
                faceIdx: {
                    value: 0
                },
                cubemap: {
                    value: null
                }
            },
            vertexShader: "\n        uniform int faceIdx;\n\n        varying vec3 vCubeDirection;\n\n        vec3 uvToCubeDirection(vec2 uv, int face) {\n            vec3 dir;\n            uv = 2.0 * uv - 1.0;\n\n            if (face == 0) {\n                dir = vec3(1.0, -uv.y, -uv.x);\n            } else if (face == 1) {\n                dir = vec3(-1.0, -uv.y, uv.x);\n            } else if (face == 2) {\n                dir = vec3(uv.x, 1.0, uv.y);\n            } else if (face == 3) {\n                dir = vec3(uv.x, -1.0, -uv.y);\n            } else if (face == 4) {\n                dir = vec3(uv.x, -uv.y, 1.0);\n            } else if (face == 5) {\n                dir = vec3(-uv.x, -uv.y, -1.0);\n            }\n            return dir;\n        }\n\n        void main() {\n            vCubeDirection = uvToCubeDirection(uv, faceIdx);\n            gl_Position = vec4(position, 1.0);\n        }\n        ",
            fragmentShader: "\n        uniform samplerCube cubemap;\n\n        varying vec3 vCubeDirection;\n\n        void main() {\n            gl_FragColor = linearToOutputTexel(mapTexelToLinear(textureCube(\n                    cubemap, vCubeDirection)));\n        }\n        "
        }), this.shader.map = e, this.shader.uniforms.cubemap.value = e, this.planeMesh = new Ki(new ba(2, 2), this.shader), this.scene = new _a, this.scene.add(this.camera), this.scene.add(this.planeMesh)
    }

    function ag(e, t) {
        this.sourceTexture = e, this.resolution = void 0 !== t ? t : 256;
        e = this.resolution, t = {
            format: this.sourceTexture.format,
            magFilter: this.sourceTexture.magFilter,
            minFilter: this.sourceTexture.minFilter,
            type: this.sourceTexture.type,
            generateMipmaps: this.sourceTexture.generateMipmaps,
            anisotropy: this.sourceTexture.anisotropy,
            encoding: this.sourceTexture.encoding
        };
        this.renderTarget = new da(e, e, t), this.renderTarget.texture.name = "EquiCube.cube", this.camera = new ms(-1, 1, 1, -1, 0, 1e3), this.shader = new oa(wa.equicube), this.planeMesh = new Ki(new ba(2, 2), this.shader), this.planeMesh.material.side = oe, this.scene = new _a, this.scene.add(this.planeMesh), this.scene.add(this.camera), this.invertU = !1, this.offsetU = 0, this.shader.uniforms.tEquirect.value = this.sourceTexture
    }

    function og() {
        this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }

    function sg(e) {
        ng = ng || new ba(2, 2), this._mesh = new Ki(ng, e)
    }

    function lg(e, t, n, r, i) {
        og.call(this), this.strength = void 0 !== t ? t : 1, this.radius = n, this.threshold = r, this.resolution = void 0 !== e ? new vn(e.x, e.y) : new vn(256, 256), i = i || {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe
        }, this.clearColor = new Qr(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
        var a = Math.round(this.resolution.x / 2),
            o = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new wn(a, o, i), this.renderTargetBright.texture.name = "BloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
        for (var s = 0; s < this.nMips; s++) {
            var l = new wn(a, o, i);
            l.texture.name = "BloomPass.h" + s, l.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(l), (l = new wn(a, o, i)).texture.name = "BloomPass.v" + s, l.texture.generateMipmaps = !1, this.renderTargetsVertical.push(l), a = Math.round(a / 2), o = Math.round(o / 2)
        }
        e = wa.bloomLumHighPass;
        this.highPassUniforms = ra.clone(e.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new oa({
            type: "BloomHighPass",
            uniforms: this.highPassUniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
            defines: {}
        }), this.separableBlurMaterials = [];
        for (var c = [3, 5, 7, 9, 11], a = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2), s = 0; s < this.nMips; s++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[s])), this.separableBlurMaterials[s].uniforms.texSize.value = new vn(a, o), a = Math.round(a / 2), o = Math.round(o / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0;
        this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new Tn(1, 1, 1), new Tn(1, 1, 1), new Tn(1, 1, 1), new Tn(1, 1, 1), new Tn(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        t = wa.copy;
        this.copyUniforms = ra.clone(t.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new oa({
            type: "BloomCopy",
            defines: t.defines,
            uniforms: this.copyUniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader,
            blending: Z,
            blendEquation: Q,
            blendEquationAlpha: Q,
            blendSrc: ge,
            blendDst: pe,
            blendSrcAlpha: fe,
            blendDstAlpha: pe,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new Qr, this.oldClearAlpha = 1, this.basic = new ei, this.fsQuad = new og.FullScreenQuad(null)
    }

    function cg(e, t, n) {
        og.call(this), this.scene = e, this.camera = t;
        var r = new wn(n.width || window.innerWidth || 1, n.height || window.innerHeight || 1, {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe
        });
        this.renderTargetDepth = r.clone(), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new ds, this.materialDepth.depthPacking = Zt, this.materialDepth.blending = se;
        e = wa.bokeh, r = ra.clone(e.uniforms);
        r.tDepth.value = this.renderTargetDepth.texture, r.focus.value = _i(n.focus) ? n.focus : 1, r.aperture.value = _i(n.aperture) ? n.aperture : 1, r.maxblur.value = _i(n.maxblur) ? n.maxblur : 1, r.depthLeakThreshold.value = _i(n.depthLeakThreshold) ? n.depthLeakThreshold : .2, r.nearClip.value = t.near, r.farClip.value = t.far, r.aspect.value = t.aspect, Object.defineProperties(this, {
            focus: {
                get: function() {
                    return this.uniforms.focus.value
                },
                set: function(e) {
                    this.uniforms.focus.value = e
                }
            },
            aperture: {
                get: function() {
                    return this.uniforms.aperture.value
                },
                set: function(e) {
                    this.uniforms.aperture.value = e
                }
            },
            maxblur: {
                get: function() {
                    return this.uniforms.maxblur.value
                },
                set: function(e) {
                    this.uniforms.maxblur.value = e
                }
            },
            depthLeakThreshold: {
                get: function() {
                    return this.uniforms.depthLeakThreshold.value
                },
                set: function(e) {
                    this.uniforms.depthLeakThreshold.value = e
                }
            }
        }), this.materialBokeh = new oa({
            type: "Bokeh",
            defines: e.defines,
            uniforms: r,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        }), this.uniforms = r, this.camera2 = new ms(-1, 1, 1, -1, 0, 1), this.scene2 = new _a, this.quad2 = new Ki(new ba(2, 2), null), this.quad2.frustumCulled = !1, this.scene2.add(this.quad2), this.oldClearColor = new Qr, this.oldClearAlpha = 1
    }

    function ug(e, t) {
        og.call(this), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof oa ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = ra.clone(e.uniforms), this.material = new oa({
            type: "ShaderPass",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })), this.fsQuad = new og.FullScreenQuad(this.material)
    }

    function dg() {
        ug.call(this, wa.brightness_contrast), this.material.type = "Grayscale", Object.defineProperties(this, {
            brightness: {
                get: function() {
                    return this.uniforms.brightness.value
                },
                set: function(e) {
                    this.uniforms.brightness.value = e
                }
            },
            contrast: {
                get: function() {
                    return this.uniforms.contrast.value
                },
                set: function(e) {
                    this.uniforms.contrast.value = e
                }
            }
        })
    }

    function hg(e, t, n, r) {
        ug.call(this, wa.fxaa), this.material.type = "FXAA", this.width = void 0 !== n ? n : 512, this.height = void 0 !== r ? r : 256, this.needsSwap = !1
    }

    function fg() {
        ug.call(this, wa.grayscale), this.material.type = "Grayscale"
    }

    function pg(e, t) {
        og.call(this), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }

    function mg() {
        og.call(this), this.needsSwap = !1
    }

    function vg() {
        this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this.geometry = new Oi, this.widthCallback = null
    }

    function gg(e, t, n, r, i) {
        var a;
        if (e = e.subarray || e.slice ? e : e.buffer, n = n.subarray || n.slice ? n : n.buffer, e = t ? e.subarray ? e.subarray(t, i && t + i) : e.slice(t, i && t + i) : e, n.set) n.set(e, r);
        else
            for (a = 0; a < e.length; a++) n[a + r] = e[a];
        return n
    }

    function _g(e) {
        this.headEdge = this.tailEdge = e, this.headIndex = e.index0, this.tailIndex = e.index1, this.indexCount = 2
    }

    function yg(e, t) {
        this.index0 = e, this.index1 = t, this.edge0 = null, this.edge1 = null
    }

    function xg() {
        this.geometry = new Oi
    }

    function bg(e, t, n) {
        var r = e.headIndex,
            e = e.tailIndex;
        return t[r][0] || t[e][0] || n[r][0] || n[e][0] || null
    }

    function Mg(e) {
        hu.call(this), this.type = "MeshLineMaterial", this.lineWidth = 1, this.sizeAttenuation = 1, this.color = new Qr(16777215), this.opacity = 1, this.useMap = 0, this.map = null, this.useAlphaMap = 0, this.alphaMap = null, this.visibility = 1, this.alphaTest = 0, this.repeat = new vn(1, 1), this.uniforms = {
            lineWidth: {
                value: 1
            },
            sizeAttenuation: {
                value: 1
            },
            color: {
                value: new Qr(16777215)
            },
            opacity: {
                value: 1
            },
            useMap: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            useAlphaMap: {
                value: 0
            },
            visibility: {
                value: 1
            },
            alphaTest: {
                value: 0
            },
            repeat: {
                value: new vn(1, 1)
            }
        }, this.vertexShader = Ma.raw_meshline_vert, this.fragmentShader = Ma.raw_meshline_frag, this.setValues(e)
    }

    function wg(e, t, n, r) {
        this.renderScene = t, this.renderCamera = n, this.selectedObjects = void 0 !== r ? r : [], this.visibleEdgeColor = new Mn(1, 1, 1, 1), this.hiddenEdgeColor = new Mn(.1, .04, .02, 1), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this.renderToScreen = !1, og.call(this), this.resolution = void 0 !== e ? new vn(e.x, e.y) : new vn(256, 256);
        n = {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe
        }, r = Math.round(this.resolution.x / this.downSampleRatio), e = Math.round(this.resolution.y / this.downSampleRatio);
        this.renderTargetMaskBuffer = new wn(this.resolution.x, this.resolution.y, n), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.renderTargetDepthBuffer = new wn(this.resolution.x, this.resolution.y, n), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new wn(r, e, n), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new wn(r, e, n), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new wn(Math.round(r / 2), Math.round(e / 2), n), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new wn(r, e, n), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new wn(Math.round(r / 2), Math.round(e / 2), n), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1;
        this.separableBlurMaterial1 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value = new vn(r, e), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value = new vn(Math.round(r / 2), Math.round(e / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial();
        e = wa.copy;
        this.copyUniforms = ra.clone(e.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new oa({
            defines: e.defines,
            uniforms: this.copyUniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
            blending: se,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new Qr, this.oldClearAlpha = 1, this.basic = new ei, this.fsQuad = new og.FullScreenQuad(null), this.camera = new ms(-1, 1, 1, -1, 0, 1), this.scene = new _a, this.tempPulseColor1 = new Mn, this.tempPulseColor2 = new Mn, this.textureMatrix = new nr, this.visibilityState = new WeakMap, this._depthMaterial = new ds({
            blending: se,
            depthPacking: Zt,
            side: oe
        }), this._maskMaterial = new bu({
            side: oe
        })
    }

    function Sg(e, t, n, r, i) {
        og.call(this), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== i ? i : 0, this.oldClearColor = new Qr, this.oldClearAlpha = 1, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
    }(rg.prototype = Object.create(n.prototype)).constructor = rg, Object.defineProperties(rg.prototype, {
        center: {
            get: function() {
                return console.warn("v3d.OrbitControls: .center has been deprecated, use .targetObj instead"), new Tn
            }
        },
        target: {
            get: function() {
                return console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead"), new Tn
            },
            set: function() {
                console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead")
            }
        },
        noZoom: {
            get: function() {
                return console.warn("v3d.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
            },
            set: function(e) {
                console.warn("v3d.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
            }
        },
        noRotate: {
            get: function() {
                return console.warn("v3d.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
            },
            set: function(e) {
                console.warn("v3d.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
            }
        },
        noPan: {
            get: function() {
                return console.warn("v3d.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
            },
            set: function(e) {
                console.warn("v3d.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
            }
        },
        noKeys: {
            get: function() {
                return console.warn("v3d.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
            },
            set: function(e) {
                console.warn("v3d.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
            }
        },
        staticMoving: {
            get: function() {
                return console.warn("v3d.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
            },
            set: function(e) {
                console.warn("v3d.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
            }
        }
    }), ig.prototype = {
        constructor: ig,
        update: function(e) {
            var t = e.toneMapping,
                n = e.toneMappingExposure,
                r = e.getRenderTarget();
            e.toneMapping = Oe, e.toneMappingExposure = 1;
            for (var i = 0; i < 6; i++) e.setRenderTarget(this.renderTarget, i), this.shader.uniforms.faceIdx.value = i, e.render(this.scene, this.camera);
            e.toneMapping = t, e.toneMappingExposure = n, e.setRenderTarget(r)
        },
        dispose: function() {
            this.renderTarget.dispose(), this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose()
        }
    }, ag.prototype = {
        constructor: ag,
        update: function(e) {
            var t = e.gammaInput,
                n = e.gammaOutput,
                r = e.toneMapping,
                i = e.toneMappingExposure,
                a = e.getRenderTarget();
            e.toneMapping = Oe, e.toneMappingExposure = 1, e.gammaInput = !1, e.gammaOutput = !1, this.renderToCubeMapTarget(e, this.renderTarget), e.setRenderTarget(a), e.toneMapping = r, e.toneMappingExposure = i, e.gammaInput = t, e.gammaOutput = n
        },
        renderToCubeMapTarget: function(e, t) {
            this.shader.uniforms.invertU.value = this.invertU, this.shader.uniforms.offsetU.value = this.offsetU;
            for (var n = 0; n < 6; n++) this.renderToCubeMapTargetFace(e, t, n)
        },
        renderToCubeMapTargetFace: function(e, t, n) {
            this.shader.uniforms.faceIndex.value = n, e.setRenderTarget(t, n), e.render(this.scene, this.camera)
        },
        dispose: function() {
            this.renderTarget.dispose(), this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose()
        }
    }, og.prototype = Object.assign(Object.create(n.prototype), {
        constructor: og,
        setCamera: function(e) {},
        setSize: function(e, t) {},
        dispose: function() {},
        render: function(e, t, n, r, i) {
            console.error("v3d.Pass: .render() must be implemented in derived pass.")
        }
    }), og.FullScreenQuad = (tg = new ms(-1, 1, 1, -1, 0, 1), ng = null, Object.defineProperty(sg.prototype, "material", {
        get: function() {
            return this._mesh.material
        },
        set: function(e) {
            this._mesh.material = e
        }
    }), Object.assign(sg.prototype, {
        render: function(e) {
            e.render(this._mesh, tg)
        },
        dispose: function() {}
    }), Object.assign(sg, {
        dispose: function() {
            null !== ng && (ng.dispose(), ng = null)
        }
    }), sg), lg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: lg,
        dispose: function() {
            for (var e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
            for (e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
            this.renderTargetBright.dispose()
        },
        setSize: function(e, t) {
            var n = Math.round(e / 2),
                r = Math.round(t / 2);
            this.renderTargetBright.setSize(n, r);
            for (var i = 0; i < this.nMips; i++) this.renderTargetsHorizontal[i].setSize(n, r), this.renderTargetsVertical[i].setSize(n, r), this.separableBlurMaterials[i].uniforms.texSize.value = new vn(n, r), n = Math.round(n / 2), r = Math.round(r / 2)
        },
        render: function(e, t, n, r, i) {
            e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha();
            var a = e.autoClear;
            e.autoClear = !1, e.setClearColor(this.clearColor, 0), i && e.context.disable(e.context.STENCIL_TEST), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
            for (var o = this.renderTargetBright, s = 0; s < this.nMips; s++) this.fsQuad.material = this.separableBlurMaterials[s], this.separableBlurMaterials[s].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[s].uniforms.direction.value = lg.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[s]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[s].uniforms.colorTexture.value = this.renderTargetsHorizontal[s].texture, this.separableBlurMaterials[s].uniforms.direction.value = lg.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[s]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[s];
            this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = a
        },
        getSeperableBlurMaterial: function(e) {
            return new oa({
                type: "BloomSeparableBlur",
                defines: {
                    KERNEL_RADIUS: e,
                    SIGMA: e
                },
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    texSize: {
                        value: new vn(.5, .5)
                    },
                    direction: {
                        value: new vn(.5, .5)
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_bloom_separable_blur_frag
            })
        },
        getCompositeMaterial: function(e) {
            return new oa({
                type: "BloomComposite",
                defines: {
                    NUM_MIPS: e
                },
                uniforms: {
                    blurTexture1: {
                        value: null
                    },
                    blurTexture2: {
                        value: null
                    },
                    blurTexture3: {
                        value: null
                    },
                    blurTexture4: {
                        value: null
                    },
                    blurTexture5: {
                        value: null
                    },
                    dirtTexture: {
                        value: null
                    },
                    bloomStrength: {
                        value: 1
                    },
                    bloomFactors: {
                        value: null
                    },
                    bloomTintColors: {
                        value: null
                    },
                    bloomRadius: {
                        value: 0
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_bloom_composite_frag
            })
        }
    }), lg.BlurDirectionX = new vn(1, 0), lg.BlurDirectionY = new vn(0, 1), cg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: cg,
        render: function(e, t, n, r, i) {
            this.quad2.material = this.materialBokeh, this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha();
            e.autoClear;
            e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = n.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.uniforms.aspect.value = this.camera.aspect, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), e.clear()), e.render(this.scene2, this.camera2), this.scene.overrideMaterial = null, e.setClearColor(this.oldClearColor), e.setClearAlpha(this.oldClearAlpha), e.autoClear = this.oldAutoClear
        },
        setCamera: function(e) {
            this.camera = e
        },
        setSize: function(e, t) {
            this.renderTargetDepth.setSize(e, t)
        },
        dispose: function() {
            this.renderTargetDepth.dispose()
        }
    }), ug.prototype = Object.assign(Object.create(og.prototype), {
        constructor: ug,
        render: function(e, t, n, r, i) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)), this.fsQuad.render(e)
        },
        dispose: function() {
            this.material.dispose()
        }
    }), dg.prototype = Object.assign(Object.create(ug.prototype), {
        constructor: dg
    }), (hg.prototype = Object.create(ug.prototype)).setSize = function(e, t) {
        this.width = e, this.height = t, this.uniforms.resolution.value.set(1 / e, 1 / t)
    }, fg.prototype = Object.assign(Object.create(ug.prototype), {
        constructor: fg
    }), pg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: pg,
        render: function(e, t, n, r, i) {
            var a, o, s = e.context,
                l = e.state;
            l.buffers.color.setMask(!1), l.buffers.depth.setMask(!1), l.buffers.color.setLocked(!0), l.buffers.depth.setLocked(!0), o = this.inverse ? (a = 0, 1) : (a = 1, 0), l.buffers.stencil.setTest(!0), l.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), l.buffers.stencil.setFunc(s.ALWAYS, a, 4294967295), l.buffers.stencil.setClear(o), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), l.buffers.color.setLocked(!1), l.buffers.depth.setLocked(!1), l.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), l.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP)
        },
        setCamera: function(e) {
            this.camera = e
        }
    }), mg.prototype = Object.create(og.prototype), Object.assign(mg.prototype, {
        render: function(e, t, n, r, i) {
            e.state.buffers.stencil.setTest(!1)
        }
    }), vg.prototype.setGeometry = function(e, t) {
        if (this.widthCallback = t, this.positions = [], this.counters = [], e instanceof ql)
            for (var n = 0; n < e.vertices.length; n++) {
                var r = e.vertices[n],
                    t = n / e.vertices.length;
                this.positions.push(r.x, r.y, r.z), this.positions.push(r.x, r.y, r.z), this.counters.push(t), this.counters.push(t)
            }
        if (e instanceof Float32Array || e instanceof Array)
            for (n = 0; n < e.length; n += 3) {
                t = n / e.length;
                this.positions.push(e[n], e[n + 1], e[n + 2]), this.positions.push(e[n], e[n + 1], e[n + 2]), this.counters.push(t), this.counters.push(t)
            }
        this.process()
    }, vg.prototype.compareV3 = function(e, t) {
        e *= 6, t *= 6;
        return this.positions[e] === this.positions[t] && this.positions[1 + e] === this.positions[1 + t] && this.positions[2 + e] === this.positions[2 + t]
    }, vg.prototype.copyV3 = function(e) {
        e *= 6;
        return [this.positions[e], this.positions[1 + e], this.positions[2 + e]]
    }, vg.prototype.process = function() {
        var e = this.positions.length / 6;
        this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];
        for (var t, n = 0; n < e; n++) this.side.push(1), this.side.push(-1);
        for (n = 0; n < e; n++) t = this.widthCallback ? this.widthCallback(n / (e - 1)) : 1, this.width.push(t), this.width.push(t);
        for (var r, n = 0; n < e; n++) this.uvs.push(n / (e - 1), 0), this.uvs.push(n / (e - 1), 1);
        r = this.compareV3(0, e - 1) ? this.copyV3(e - 2) : this.copyV3(0), this.previous.push(r[0], r[1], r[2]), this.previous.push(r[0], r[1], r[2]);
        for (n = 0; n < e - 1; n++) r = this.copyV3(n), this.previous.push(r[0], r[1], r[2]), this.previous.push(r[0], r[1], r[2]);
        for (n = 1; n < e; n++) r = this.copyV3(n), this.next.push(r[0], r[1], r[2]), this.next.push(r[0], r[1], r[2]);
        r = this.compareV3(e - 1, 0) ? this.copyV3(1) : this.copyV3(e - 1), this.next.push(r[0], r[1], r[2]), this.next.push(r[0], r[1], r[2]);
        for (n = 0; n < e - 1; n++) {
            var i = 2 * n;
            this.indices_array.push(i, 1 + i, 2 + i), this.indices_array.push(2 + i, 1 + i, 3 + i)
        }
        this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position.needsUpdate = !0, this.attributes.previous.copyArray(new Float32Array(this.previous)), this.attributes.previous.needsUpdate = !0, this.attributes.next.copyArray(new Float32Array(this.next)), this.attributes.next.needsUpdate = !0, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes.side.needsUpdate = !0, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width.needsUpdate = !0, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = !0, this.attributes.counters.copyArray(new Float32Array(this.counters)), this.attributes.counters.needsUpdate = !0, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = !0) : this.attributes = {
            position: new ri(new Float32Array(this.positions), 3),
            previous: new ri(new Float32Array(this.previous), 3),
            next: new ri(new Float32Array(this.next), 3),
            side: new ri(new Float32Array(this.side), 1),
            width: new ri(new Float32Array(this.width), 1),
            uv: new ri(new Float32Array(this.uvs), 2),
            counters: new ri(new Float32Array(this.counters), 1),
            index: new ri(new Uint16Array(this.indices_array), 1)
        }, this.geometry.setAttribute("position", this.attributes.position), this.geometry.setAttribute("previous", this.attributes.previous), this.geometry.setAttribute("next", this.attributes.next), this.geometry.setAttribute("side", this.attributes.side), this.geometry.setAttribute("width", this.attributes.width), this.geometry.setAttribute("uv", this.attributes.uv), this.geometry.setAttribute("counters", this.attributes.counters), this.geometry.setIndex(this.attributes.index)
    }, vg.prototype.advance = function(e) {
        var t = this.attributes.position.array,
            n = this.attributes.previous.array,
            r = this.attributes.next.array,
            i = t.length;
        gg(t, 0, n, 0, i), gg(t, 6, t, 0, i - 6), t[i - 6] = e.x, t[i - 5] = e.y, t[i - 4] = e.z, t[i - 3] = e.x, t[i - 2] = e.y, t[i - 1] = e.z, gg(t, 6, r, 0, i - 6), r[i - 6] = e.x, r[i - 5] = e.y, r[i - 4] = e.z, r[i - 3] = e.x, r[i - 2] = e.y, r[i - 1] = e.z, this.attributes.position.needsUpdate = !0, this.attributes.previous.needsUpdate = !0, this.attributes.next.needsUpdate = !0
    }, vg.updateAttributes = function(e) {
        var t = e.attributes.position.array,
            n = (e.attributes.previous.array, e.attributes.next.array, new vg);
        n.positions = t, n.process(), e.attributes.previous = n.attributes.previous, e.attributes.previous.needsUpdate = !0, e.attributes.next = n.attributes.next, e.attributes.next.needsUpdate = !0
    }, Object.assign(_g.prototype, {
        mergeStrip: function(e) {
            var t = this.headIndex,
                n = e.headIndex,
                r = this.tailIndex,
                i = e.tailIndex;
            t == n ? (this.headEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.headEdge), this.headEdge = e.tailEdge, this.headIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : t == i ? (this.headEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.headEdge), this.headEdge = e.headEdge, this.headIndex = e.headIndex, this.indexCount += e.indexCount - 1) : r == n ? (this.tailEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.tailEdge), this.tailEdge = e.tailEdge, this.tailIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : r == i && (this.tailEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.tailEdge), this.tailEdge = e.headEdge, this.tailIndex = e.headIndex, this.indexCount += e.indexCount - 1)
        },
        getIndicesFlat: function() {
            for (var e = new Float32Array(this.indexCount), t = 0, n = null, r = this.headEdge, i = e[t++] = this.headIndex; null !== r;) {
                i = r.index0 == i ? r.index1 : r.index0;
                e[t++] = i;
                var a = r.edge0;
                a != n && null !== a || (a = r.edge1), a == n && (a = null), n = r, r = a
            }
            return e
        }
    }), Object.assign(yg.prototype, {
        linkToEdge: function(e) {
            null === this.edge0 ? this.edge0 = e : null === this.edge1 && (this.edge1 = e)
        }
    }), Object.assign(xg.prototype, {
        fromBufferGeometry: function(e) {
            var r, n, i, a, o, s, l, c, u, d, t, h = e.getAttribute("position"),
                e = e.getIndex();
            void 0 !== h && (r = [], null !== e ? function(e) {
                for (var t = e.length % 2 ? e.length - 1 : e.length, n = {}, r = {}, i = 0; i < t; i += 2) {
                    var a = (u = new _g(new yg(e[i], e[i + 1]))).headIndex,
                        o = u.tailIndex;
                    n[a] = n[a] || [], n[o] = n[o] || [], r[a] = r[a] || [], r[o] = r[o] || [], n[a].push(u), r[o].push(u)
                }
                var s, l = new Su.LinkMap;
                for (s in n) n[s].length && l.push(new Su.LinkMapNode(n[s]), s);
                for (var c = [], u = l.first && l.first.value[0]; u;) {
                    n[a = u.headIndex].splice(n[a].indexOf(u), 1), r[o = u.tailIndex].splice(r[o].indexOf(u), 1), 0 == n[a].length && l.removeNodeByKey(a);
                    for (var d = bg(u, n, r); null !== d;) n[a = d.headIndex].splice(n[a].indexOf(d), 1), r[o = d.tailIndex].splice(r[o].indexOf(d), 1), 0 == n[a].length && l.removeNodeByKey(a), u.mergeStrip(d), d = bg(u, n, r);
                    c.push(u), u = l.first && l.first.value[0]
                }
                return c
            }(e.array).forEach(function(e) {
                var t = new vg,
                    n = new Float32Array(3 * e.indexCount);
                e.getIndicesFlat().forEach(function(e, t) {
                    n.set(h.array.subarray(3 * e, 3 * e + 3), 3 * t)
                }), t.setGeometry(n), r.push(t)
            }) : ((t = new vg).setGeometry(h.array), r.push(t)), n = [], i = [], a = [], o = [], s = [], l = [], c = [], u = [], d = 0, r.forEach(function(e) {
                n = n.concat(e.positions), i = i.concat(e.previous), a = a.concat(e.next), o = o.concat(e.side), s = s.concat(e.width), l = l.concat(e.uvs), c = c.concat(e.counters);
                var t = e.indices_array.map(function(e) {
                    return e + d
                });
                u = u.concat(t), d += e.positions.length / 3
            }), this.geometry.setAttribute("position", new ri(new Float32Array(n), 3)), this.geometry.setAttribute("previous", new ri(new Float32Array(i), 3)), this.geometry.setAttribute("next", new ri(new Float32Array(a), 3)), this.geometry.setAttribute("side", new ri(new Float32Array(o), 1)), this.geometry.setAttribute("width", new ri(new Float32Array(s), 1)), this.geometry.setAttribute("uv", new ri(new Float32Array(l), 2)), this.geometry.setAttribute("counters", new ri(new Float32Array(c), 1)), t = 65535 < mi(u) ? Uint32Array : Uint16Array, this.geometry.setIndex(new ri(new t(u), 1)))
        }
    }), Mg.prototype = Object.assign(Object.create(hu.prototype), {
        constructor: Mg,
        isMeshLineMaterial: !0,
        copy: function(e) {
            return hu.prototype.copy.call(this, e), this.lineWidth = e.lineWidth, this.sizeAttenuation = e.sizeAttenuation, this.color.copy(e.color), this.opacity = e.opacity, this.useMap = e.useMap, this.map = e.map, this.useAlphaMap = e.useAlphaMap, this.alphaMap = e.alphaMap, this.visibility = e.visibility, this.alphaTest = e.alphaTest, this.repeat.copy(e.repeat), this
        }
    }), wg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: wg,
        dispose: function() {
            this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose()
        },
        setSize: function(e, t) {
            this.renderTargetMaskBuffer.setSize(e, t);
            e = Math.round(e / this.downSampleRatio), t = Math.round(t / this.downSampleRatio);
            this.renderTargetMaskDownSampleBuffer.setSize(e, t), this.renderTargetBlurBuffer1.setSize(e, t), this.renderTargetEdgeBuffer1.setSize(e, t), this.separableBlurMaterial1.uniforms.texSize.value = new vn(e, t), e = Math.round(e / 2), t = Math.round(t / 2), this.renderTargetBlurBuffer2.setSize(e, t), this.renderTargetEdgeBuffer2.setSize(e, t), this.separableBlurMaterial2.uniforms.texSize.value = new vn(e, t)
        },
        saveVisibilityState: function() {
            var t = this;
            t.renderScene.traverse(function(e) {
                e instanceof Ki && t.visibilityState.set(e, e.visible)
            })
        },
        restoreVisibilityState: function() {
            var t = this;
            t.renderScene.traverse(function(e) {
                e instanceof Ki && (e.visible = t.visibilityState.get(e))
            })
        },
        changeVisibilityOfSelectedObjects: function(t) {
            var n = this;

            function e(e) {
                e instanceof Ki && n.visibilityState.get(e) && (e.visible = t)
            }
            for (var r = 0; r < n.selectedObjects.length; r++) {
                var i = n.selectedObjects[r];
                e(i);
                for (var a = i.children, o = 0; o < a.length; o++) {
                    var s = a[o];
                    s.isMesh && s.isMaterialGeneratedMesh && e(s)
                }
            }
        },
        changeVisibilityOfNonSelectedObjects: function(r) {
            var i = this,
                a = [];

            function e(e) {
                e instanceof Ki && i.visibilityState.get(e) && a.push(e)
            }
            for (var t = 0; t < i.selectedObjects.length; t++) {
                var n = i.selectedObjects[t];
                e(n);
                for (var o = n.children, s = 0; s < o.length; s++) {
                    var l = o[s];
                    l.isMesh && l.isMaterialGeneratedMesh && e(l)
                }
            }
            i.renderScene.traverse(function(e) {
                if (e instanceof Ki && i.visibilityState.get(e)) {
                    for (var t = !1, n = 0; n < a.length; n++)
                        if (a[n].id === e.id) {
                            t = !0;
                            break
                        } t || (e.visible = r)
                }
            })
        },
        updateTextureMatrix: function() {
            this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)
        },
        render: function(e, t, n, r, i) {
            var a, o;
            this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), 0 !== this.selectedObjects.length && (e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha(), a = e.autoClear, e.autoClear = !1, i && e.context.disable(e.context.STENCIL_TEST), e.setClearColor(16777215, 1), o = this.renderScene.background, this.renderScene.background = null, this.saveVisibilityState(), e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(!1), this.changeVisibilityOfNonSelectedObjects(!0), this.renderScene.overrideMaterial = this._depthMaterial, e.render(this.renderScene, this.renderCamera), this.updateTextureMatrix(), e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(!0), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this._maskMaterial, this.renderScene.overrideMaterial.cameraNearFar = new vn(this.renderCamera.near, this.renderCamera.far), this.renderScene.overrideMaterial.depthTexture = this.renderTargetDepthBuffer.texture, this.renderScene.overrideMaterial.textureMatrix = this.textureMatrix, e.render(this.renderScene, this.renderCamera), this.scene.overrideMaterial = null, this.restoreVisibilityState(), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), 0 < this.pulsePeriod && (o = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2, this.tempPulseColor1.multiplyScalar(o), this.tempPulseColor2.multiplyScalar(o)), this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value = new vn(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = wg.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = wg.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = wg.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = wg.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, i && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = a)
        },
        getEdgeDetectionMaterial: function() {
            return new oa({
                type: "OutlineEdgeDetection",
                defines: {
                    HIDDEN_EDGE_ALPHA: 1
                },
                uniforms: {
                    maskTexture: {
                        value: null
                    },
                    texSize: {
                        value: new vn(.5, .5)
                    },
                    visibleEdgeColor: {
                        value: new Mn(1, 1, 1, 1)
                    },
                    hiddenEdgeColor: {
                        value: new Mn(1, 1, 1, 1)
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_outline_edge_frag
            })
        },
        getSeparableBlurMaterial: function(e) {
            return new oa({
                type: "OutlineSeparableBlur",
                defines: {
                    MAX_RADIUS: e
                },
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    texSize: {
                        value: new vn(.5, .5)
                    },
                    direction: {
                        value: new vn(.5, .5)
                    },
                    kernelRadius: {
                        value: 1
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_outline_blur_frag
            })
        },
        getOverlayMaterial: function() {
            return new oa({
                type: "OutlineOverlay",
                uniforms: {
                    maskTexture: {
                        value: null
                    },
                    edgeTexture1: {
                        value: null
                    },
                    edgeTexture2: {
                        value: null
                    },
                    patternTexture: {
                        value: null
                    },
                    edgeStrength: {
                        value: 1
                    },
                    edgeGlow: {
                        value: 1
                    },
                    usePatternTexture: {
                        value: 0
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_outline_overlay_frag,
                blending: Z,
                blendEquation: Q,
                blendEquationAlpha: Q,
                blendSrc: ge,
                blendDst: _e,
                blendSrcAlpha: pe,
                blendDstAlpha: pe,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            })
        },
        setCamera: function(e) {
            this.renderCamera = e
        }
    }), wg.BlurDirectionX = new vn(1, 0), wg.BlurDirectionY = new vn(0, 1), Sg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: Sg,
        render: function(e, t, n, r, i) {
            var a = e.autoClear;
            e.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this.oldClearColor, this.oldClearAlpha), this.scene.overrideMaterial = null, e.autoClear = a
        },
        setCamera: function(e) {
            this.camera = e
        }
    });

    function Ag(e, t, n, r) {
        og.call(this), this.scene = e, this.camera = t, this.sampleLevel = 4, this.unbiased = !0, this.clearColor = void 0 !== n ? n : 0, this.clearAlpha = void 0 !== r ? r : 0, this.oldClearColor = new Qr, this.oldClearAlpha = 1;
        r = wa.copy;
        this.copyUniformsAccum = ra.clone(r.uniforms), this.copyMaterialAccum = new oa({
            type: "SSAACopyAccum",
            defines: r.defines,
            uniforms: this.copyUniformsAccum,
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            premultipliedAlpha: !0,
            transparent: !0,
            blending: X,
            depthTest: !1,
            depthWrite: !1
        }), this.fsQuadAccum = new og.FullScreenQuad(this.copyMaterialAccum), this.copyUniformsFinal = ra.clone(r.uniforms), this.copyMaterialFinal = new oa({
            type: "SSAACopyFinal",
            defines: r.defines,
            uniforms: this.copyUniformsFinal,
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            premultipliedAlpha: !1,
            transparent: !1,
            blending: se,
            depthTest: !1,
            depthWrite: !1
        }), this.fsQuadFinal = new og.FullScreenQuad(this.copyMaterialFinal), this.iterative = !1, this.iterativeFrame = 0
    }

    function Tg(e, t) {
        var n = (this.sourceTexture = e).image.width,
            r = e.image.height,
            t = {
                format: Qe,
                magFilter: Ue,
                minFilter: 1008,
                type: t,
                generateMipmaps: !0,
                anisotropy: e.anisotropy,
                encoding: Vt,
                wrapS: e.wrapS,
                wrapT: e.wrapT
            };
        this.renderTarget = new wn(n, r, t), this.renderTarget.texture.name = e.name, this.renderTarget.texture.flipY = e.flipY, this.camera = new ms(-1, 1, 1, -1, 0, 1), this.shader = new oa({
            type: "RGBEToFloat",
            uniforms: ra.clone(wa.copy.uniforms),
            vertexShader: wa.copy.vertexShader,
            fragmentShader: wa.copy.fragmentShader,
            defines: {
                MAP_TEXELS: 1
            }
        }), this.planeMesh = new Ki(new ba(2, 2), this.shader), this.planeMesh.material.map = e, this.scene = new _a, this.scene.add(this.planeMesh), this.scene.add(this.camera), this.shader.uniforms.tDiffuse.value = e, this.shader.uniforms.opacity.value = 1
    }
    Ag.prototype = Object.assign(Object.create(og.prototype), {
        constructor: Ag,
        _getJitterOffsets: function() {
            return Ag.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))]
        },
        _isLastIterativeFrame: function() {
            var e = this._getJitterOffsets();
            return this.iterativeFrame == e.length - 1
        },
        dispose: function() {
            this.sampleRenderTarget && (this.sampleRenderTarget.dispose(), this.sampleRenderTarget = null, this.accumRenderTarget.dispose(), this.accumRenderTarget = null)
        },
        setSize: function(e, t) {
            this.sampleRenderTarget && (this.sampleRenderTarget.setSize(e, t), this.accumRenderTarget.setSize(e, t))
        },
        render: function(e, t, n) {
            this.sampleRenderTarget || (this.sampleRenderTarget = n.clone(), this.sampleRenderTarget.texture.name = "SSAARenderPass.sample", this.accumRenderTarget = n.clone(), this.accumRenderTarget.texture.name = "SSAARenderPass.accum");
            var r = this._getJitterOffsets(),
                i = e.autoClear;
            e.autoClear = !1, e.getClearColor(this.oldClearColor), this.oldClearAlpha = e.getClearAlpha();
            var a = 1 / r.length;
            this.copyUniformsAccum.tDiffuse.value = this.sampleRenderTarget.texture;
            var o, s, l = n.width,
                c = n.height,
                u = this.camera.view ? this.camera.view.offsetX : 0,
                d = this.camera.view ? this.camera.view.offsetY : 0;
            this.iterative ? (s = this.iterativeFrame, o = performance.now()) : s = 0;
            for (var h = r.length, f = s; f < h; f++) {
                this.dispatchEvent({
                    type: "iteration",
                    frame: f
                });
                var p = r[f];
                this.camera.setViewOffset && this.camera.setViewOffset(l, c, u + .0625 * p[0], d + .0625 * p[1], l, c);
                p = a;
                if (this.unbiased && (p += 1 / 32 * ((f + .5) / r.length - .5)), this.copyUniformsAccum.opacity.value = p, e.setClearColor(this.clearColor, this.clearAlpha), e.setRenderTarget(this.sampleRenderTarget), e.clear(), e.render(this.scene, this.camera), this.iterative ? e.setRenderTarget(this.accumRenderTarget) : e.setRenderTarget(this.renderToScreen ? null : t), 0 === f && (e.setClearColor(0, 0), e.clear()), this.fsQuadAccum.render(e), this.iterativeFrame = f, this.iterative && 4 < performance.now() - o) break
            }
            this.iterative && (this._isLastIterativeFrame() ? (this.copyUniformsFinal.tDiffuse.value = this.accumRenderTarget.texture, e.setRenderTarget(this.renderToScreen ? null : t), this.fsQuadFinal.render(e), this.iterativeFrame = 0) : this.iterativeFrame++), this.camera.setViewOffset && this.camera.setViewOffset(l, c, u, d, l, c), e.autoClear = i, e.setClearColor(this.oldClearColor, this.oldClearAlpha)
        },
        isLastIterativeFrame: function() {
            console.error("isLastIterativeFrame() deprectated, use pass event listener instead")
        },
        setCamera: function(e) {
            this.camera = e
        }
    }), Ag.JitterVectors = [
        [
            [0, 0]
        ],
        [
            [4, 4],
            [-4, -4]
        ],
        [
            [-2, -6],
            [6, -2],
            [-6, 2],
            [2, 6]
        ],
        [
            [1, -3],
            [-1, 3],
            [5, 1],
            [-3, -5],
            [-5, 5],
            [-7, -1],
            [3, 7],
            [7, -7]
        ],
        [
            [1, 1],
            [-1, -3],
            [-3, 2],
            [4, -1],
            [-5, -2],
            [2, 5],
            [5, 3],
            [3, -5],
            [-2, 6],
            [0, -7],
            [-4, -6],
            [-6, 4],
            [-8, 0],
            [7, -4],
            [6, 7],
            [-7, -8]
        ],
        [
            [-4, -7],
            [-7, -5],
            [-3, -5],
            [-5, -4],
            [-1, -4],
            [-2, -2],
            [-6, -1],
            [-4, 0],
            [-7, 1],
            [-1, 2],
            [-6, 3],
            [-3, 3],
            [-7, 6],
            [-3, 6],
            [-5, 7],
            [-1, 7],
            [5, -7],
            [1, -6],
            [6, -5],
            [4, -4],
            [2, -3],
            [7, -2],
            [1, -1],
            [4, -1],
            [2, 1],
            [6, 2],
            [0, 4],
            [4, 4],
            [2, 5],
            [7, 5],
            [5, 6],
            [3, 7]
        ]
    ], Tg.prototype = {
        constructor: Tg,
        update: function(e) {
            var t = e.toneMapping,
                n = e.toneMappingExposure,
                r = e.getRenderTarget();
            e.toneMapping = Oe, e.toneMappingExposure = 1, e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera), e.setRenderTarget(r), e.toneMapping = t, e.toneMappingExposure = n
        },
        dispose: function() {
            this.renderTarget.dispose(), this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose()
        }
    };

    function Eg(e) {
        null == e && (e = Math), this.grad3 = [
            [1, 1, 0],
            [-1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [1, 0, 1],
            [-1, 0, 1],
            [1, 0, -1],
            [-1, 0, -1],
            [0, 1, 1],
            [0, -1, 1],
            [0, 1, -1],
            [0, -1, -1]
        ], this.grad4 = [
            [0, 1, 1, 1],
            [0, 1, 1, -1],
            [0, 1, -1, 1],
            [0, 1, -1, -1],
            [0, -1, 1, 1],
            [0, -1, 1, -1],
            [0, -1, -1, 1],
            [0, -1, -1, -1],
            [1, 0, 1, 1],
            [1, 0, 1, -1],
            [1, 0, -1, 1],
            [1, 0, -1, -1],
            [-1, 0, 1, 1],
            [-1, 0, 1, -1],
            [-1, 0, -1, 1],
            [-1, 0, -1, -1],
            [1, 1, 0, 1],
            [1, 1, 0, -1],
            [1, -1, 0, 1],
            [1, -1, 0, -1],
            [-1, 1, 0, 1],
            [-1, 1, 0, -1],
            [-1, -1, 0, 1],
            [-1, -1, 0, -1],
            [1, 1, 1, 0],
            [1, 1, -1, 0],
            [1, -1, 1, 0],
            [1, -1, -1, 0],
            [-1, 1, 1, 0],
            [-1, 1, -1, 0],
            [-1, -1, 1, 0],
            [-1, -1, -1, 0]
        ], this.p = [];
        for (var t = 0; t < 256; t++) this.p[t] = Math.floor(256 * e.random());
        for (this.perm = [], t = 0; t < 512; t++) this.perm[t] = this.p[255 & t];
        this.simplex = [
            [0, 1, 2, 3],
            [0, 1, 3, 2],
            [0, 0, 0, 0],
            [0, 2, 3, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 2, 3, 0],
            [0, 2, 1, 3],
            [0, 0, 0, 0],
            [0, 3, 1, 2],
            [0, 3, 2, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 3, 2, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 2, 0, 3],
            [0, 0, 0, 0],
            [1, 3, 0, 2],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 3, 0, 1],
            [2, 3, 1, 0],
            [1, 0, 2, 3],
            [1, 0, 3, 2],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 0, 3, 1],
            [0, 0, 0, 0],
            [2, 1, 3, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 0, 1, 3],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [3, 0, 1, 2],
            [3, 0, 2, 1],
            [0, 0, 0, 0],
            [3, 1, 2, 0],
            [2, 1, 0, 3],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [3, 1, 0, 2],
            [0, 0, 0, 0],
            [3, 2, 0, 1],
            [3, 2, 1, 0]
        ]
    }
    var Cg = {
        renderWorldNodeMatToCubemap: function(e, t, n, r) {
            t.isMeshNodeMaterial || console.error("v3d.RenderUtils.renderWorldNodeMatToCubemap(): material is not an instance of MeshNodeMaterial.");
            var i = new _a,
                n = new ca(.1, 10, new da(n, r));
            i.add(n);
            r = !1;
            if (/Firefox/.test(navigator.userAgent) && /Android/.test(navigator.userAgent) && (console.warn("v3d.RenderUtils: Firefox on Android detected, disabling half float rendering"), r = !0), !r && Es.checkHalfFloatTex(e, !0))
                for (var a in n.renderTarget.texture.type = Ye, t.nodeTextures) {
                    var o = t.nodeTextures[a];
                    o.encoding == jt && ((o = new Tg(o, Ye)).update(e), t.nodeTextures[a] = o.renderTarget.texture, t.updateNodeGraph())
                }
            r = t.clone();
            r.defines.WORLD_NODES = 1, r.side = ae;
            var s, l = new Ki(new ea(1, 1, 1), r);
            for (s in i.add(l), n.update(e, i), l.material.dispose(), l.material.nodeTextures) l.material.nodeTextures[s].dispose();
            return l.geometry.dispose(), n.renderTarget
        },
        assignAllLayersMask: function(e) {
            var t = e.layers.mask;
            return e.layers.set(0), e.isArrayCamera && (e.layers.enable(1), e.layers.enable(2)), e.layers.enable(3), e.layers.enable(4), e.layers.enable(5), e.layers.enable(6), t
        }
    };
    Eg.prototype.dot = function(e, t, n) {
        return e[0] * t + e[1] * n
    }, Eg.prototype.dot3 = function(e, t, n, r) {
        return e[0] * t + e[1] * n + e[2] * r
    }, Eg.prototype.dot4 = function(e, t, n, r, i) {
        return e[0] * t + e[1] * n + e[2] * r + e[3] * i
    }, Eg.prototype.noise = function(e, t) {
        var n, r = (e + t) * (.5 * (Math.sqrt(3) - 1)),
            i = Math.floor(e + r),
            a = Math.floor(t + r),
            o = (3 - Math.sqrt(3)) / 6,
            s = (i + a) * o,
            l = e - (i - s),
            c = t - (a - s),
            u = c < l ? (n = 1, 0) : (n = 0, 1),
            r = l - n + o,
            e = c - u + o,
            t = l - 1 + 2 * o,
            s = c - 1 + 2 * o,
            o = 255 & i,
            i = 255 & a,
            a = this.perm[o + this.perm[i]] % 12,
            u = this.perm[o + n + this.perm[i + u]] % 12,
            o = this.perm[1 + o + this.perm[1 + i]] % 12,
            i = .5 - l * l - c * c,
            l = i < 0 ? 0 : (i *= i) * i * this.dot(this.grad3[a], l, c),
            c = .5 - r * r - e * e,
            r = c < 0 ? 0 : (c *= c) * c * this.dot(this.grad3[u], r, e),
            e = .5 - t * t - s * s,
            s = e < 0 ? 0 : (e *= e) * e * this.dot(this.grad3[o], t, s);
        return 70 * (l + r + s)
    }, Eg.prototype.noise3d = function(e, t, n) {
        var r, i, a, o, s = (e + t + n) * (1 / 3),
            l = Math.floor(e + s),
            c = Math.floor(t + s),
            u = Math.floor(n + s),
            d = (l + c + u) * (1 / 6),
            h = e - (l - d),
            f = t - (c - d),
            p = n - (u - d),
            m = f <= h ? p <= f ? (o = a = r = 1, b = i = 0) : a = p <= h ? (o = b = i = 0, r = 1) : (o = i = r = 0, b = 1) : f < p ? (a = i = r = 0, o = b = 1) : h < p ? (a = b = r = 0, o = i = 1) : (o = a = i = 1, b = r = 0),
            v = h - r + 1 / 6,
            g = f - i + 1 / 6,
            _ = p - b + 1 / 6,
            y = h - a + 1 / 6 * 2,
            x = f - o + 1 / 6 * 2,
            s = p - m + 1 / 6 * 2,
            e = h - 1 + .5,
            t = f - 1 + .5,
            n = p - 1 + .5,
            d = 255 & l,
            l = 255 & c,
            c = 255 & u,
            u = this.perm[d + this.perm[l + this.perm[c]]] % 12,
            b = this.perm[d + r + this.perm[l + i + this.perm[c + b]]] % 12,
            m = this.perm[d + a + this.perm[l + o + this.perm[c + m]]] % 12,
            l = this.perm[1 + d + this.perm[1 + l + this.perm[1 + c]]] % 12,
            c = .6 - h * h - f * f - p * p,
            f = c < 0 ? 0 : (c *= c) * c * this.dot3(this.grad3[u], h, f, p),
            p = .6 - v * v - g * g - _ * _,
            g = p < 0 ? 0 : (p *= p) * p * this.dot3(this.grad3[b], v, g, _),
            _ = .6 - y * y - x * x - s * s,
            x = _ < 0 ? 0 : (_ *= _) * _ * this.dot3(this.grad3[m], y, x, s),
            s = .6 - e * e - t * t - n * n,
            n = s < 0 ? 0 : (s *= s) * s * this.dot3(this.grad3[l], e, t, n);
        return 32 * (f + g + x + n)
    }, Eg.prototype.noise4d = function(e, t, n, r) {
        var i = this.grad4,
            a = this.simplex,
            o = this.perm,
            s = (Math.sqrt(5) - 1) / 4,
            l = (5 - Math.sqrt(5)) / 20,
            c = (e + t + n + r) * s,
            u = Math.floor(e + c),
            d = Math.floor(t + c),
            h = Math.floor(n + c),
            f = Math.floor(r + c),
            p = (u + d + h + f) * l,
            m = e - (u - p),
            v = t - (d - p),
            g = n - (h - p),
            _ = r - (f - p),
            y = (v < m ? 32 : 0) + (g < m ? 16 : 0) + (g < v ? 8 : 0) + (_ < m ? 4 : 0) + (_ < v ? 2 : 0) + (_ < g ? 1 : 0),
            x = 3 <= a[y][0] ? 1 : 0,
            b = 3 <= a[y][1] ? 1 : 0,
            M = 3 <= a[y][2] ? 1 : 0,
            w = 3 <= a[y][3] ? 1 : 0,
            S = 2 <= a[y][0] ? 1 : 0,
            A = 2 <= a[y][1] ? 1 : 0,
            T = 2 <= a[y][2] ? 1 : 0,
            E = 2 <= a[y][3] ? 1 : 0,
            C = 1 <= a[y][0] ? 1 : 0,
            L = 1 <= a[y][1] ? 1 : 0,
            P = 1 <= a[y][2] ? 1 : 0,
            R = 1 <= a[y][3] ? 1 : 0,
            D = m - x + l,
            O = v - b + l,
            N = g - M + l,
            I = _ - w + l,
            F = m - S + 2 * l,
            k = v - A + 2 * l,
            B = g - T + 2 * l,
            s = _ - E + 2 * l,
            c = m - C + 3 * l,
            e = v - L + 3 * l,
            t = g - P + 3 * l,
            n = _ - R + 3 * l,
            r = m - 1 + 4 * l,
            p = v - 1 + 4 * l,
            a = g - 1 + 4 * l,
            y = _ - 1 + 4 * l,
            l = 255 & u,
            u = 255 & d,
            d = 255 & h,
            h = 255 & f,
            f = o[l + o[u + o[d + o[h]]]] % 32,
            w = o[l + x + o[u + b + o[d + M + o[h + w]]]] % 32,
            E = o[l + S + o[u + A + o[d + T + o[h + E]]]] % 32,
            R = o[l + C + o[u + L + o[d + P + o[h + R]]]] % 32,
            o = o[1 + l + o[1 + u + o[1 + d + o[1 + h]]]] % 32,
            h = .6 - m * m - v * v - g * g - _ * _,
            g = h < 0 ? 0 : (h *= h) * h * this.dot4(i[f], m, v, g, _),
            _ = .6 - D * D - O * O - N * N - I * I,
            N = _ < 0 ? 0 : (_ *= _) * _ * this.dot4(i[w], D, O, N, I),
            I = .6 - F * F - k * k - B * B - s * s,
            B = I < 0 ? 0 : (I *= I) * I * this.dot4(i[E], F, k, B, s),
            s = .6 - c * c - e * e - t * t - n * n,
            t = s < 0 ? 0 : (s *= s) * s * this.dot4(i[R], c, e, t, n),
            n = .6 - r * r - p * p - a * a - y * y,
            y = n < 0 ? 0 : (n *= n) * n * this.dot4(i[o], r, p, a, y);
        return 27 * (g + N + B + t + y)
    };

    function Lg(e, t, n, r) {
        og.call(this), this.width = void 0 !== n ? n : 512, this.height = void 0 !== r ? r : 512, this.clear = !0, this.camera = t, this.scene = e, this.kernelRadius = 8, this.kernelSize = 32, this.kernel = [], this.noiseTexture = null, this.output = 0, this.minDistance = .005, this.maxDistance = .1, this.generateSampleKernel(), this.generateRandomKernelRotations(), (e = new jl).type = We, e.minFilter = ke, e.maxFilter = ke, this.beautyRenderTarget = new wn(this.width, this.height, {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe,
            depthTexture: e,
            depthBuffer: !0
        }), this.normalRenderTarget = new wn(this.width, this.height, {
            minFilter: ke,
            magFilter: ke,
            format: Qe
        }), this.ssaoRenderTarget = new wn(this.width, this.height, {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe
        }), this.blurRenderTarget = this.ssaoRenderTarget.clone(), this.ssaoMaterial = this.getSSAOMaterial(), this.ssaoMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssaoMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.ssaoMaterial.uniforms.cameraNear.value = this.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = this.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrix).invert(), this.normalMaterial = new gu, this.normalMaterial.blending = se, this.blurMaterial = this.getSSAOBlurMaterial(), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = this.getSSAODepthMaterial(), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, e = wa.copy, this.copyMaterial = new oa({
            type: "SSAOCopy",
            uniforms: ra.clone(e.uniforms),
            defines: Object.assign({}, e.defines),
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1,
            blendSrc: be,
            blendDst: fe,
            blendEquation: Q,
            blendSrcAlpha: ye,
            blendDstAlpha: fe,
            blendEquationAlpha: Q
        }), this.fsQuad = new og.FullScreenQuad(null), this.originalClearColor = new Qr
    }
    Lg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: Lg,
        dispose: function() {
            this.beautyRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose()
        },
        getSSAOMaterial: function() {
            return new oa({
                type: "SSAO",
                defines: {
                    PERSPECTIVE_CAMERA: 1,
                    KERNEL_SIZE: 32
                },
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    tNormal: {
                        value: null
                    },
                    tDepth: {
                        value: null
                    },
                    tNoise: {
                        value: null
                    },
                    kernel: {
                        value: null
                    },
                    cameraNear: {
                        value: null
                    },
                    cameraFar: {
                        value: null
                    },
                    resolution: {
                        value: new vn
                    },
                    cameraProjectionMatrix: {
                        value: new nr
                    },
                    cameraInverseProjectionMatrix: {
                        value: new nr
                    },
                    kernelRadius: {
                        value: 8
                    },
                    minDistance: {
                        value: .005
                    },
                    maxDistance: {
                        value: .05
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_ssao_frag,
                blending: se
            })
        },
        getSSAODepthMaterial: function() {
            return new oa({
                type: "SSAODepth",
                defines: {
                    PERSPECTIVE_CAMERA: 1
                },
                uniforms: {
                    tDepth: {
                        value: null
                    },
                    cameraNear: {
                        value: null
                    },
                    cameraFar: {
                        value: null
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_ssao_depth_frag,
                blending: se
            })
        },
        getSSAOBlurMaterial: function() {
            return new oa({
                type: "SSAOBlur",
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    resolution: {
                        value: new vn
                    }
                },
                vertexShader: Ma.pp_plane_vert,
                fragmentShader: Ma.pp_ssao_blur_frag
            })
        },
        render: function(e, t, n, r, i) {
            var a = Cg.assignAllLayersMask(this.camera);
            switch (e.setRenderTarget(this.beautyRenderTarget), e.clear(), e.render(this.scene, this.camera), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.renderPass(e, this.ssaoMaterial, this.ssaoRenderTarget), this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.output) {
                case Lg.OUTPUT.SSAO:
                    this.copyMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.copyMaterial.blending = se, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Lg.OUTPUT.Blur:
                    this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = se, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Lg.OUTPUT.Beauty:
                    this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = se, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Lg.OUTPUT.Depth:
                    this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : t);
                    break;
                case Lg.OUTPUT.Normal:
                    this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = se, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Lg.OUTPUT.Default:
                    t.disableBlit = !0, this.copyMaterial.uniforms.tDiffuse.value = n.texture, this.copyMaterial.blending = se, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), t.disableBlit = !1, this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = Z, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                default:
                    console.warn("v3d.SSAOPass: Unknown output type.")
            }
            this.camera.layers.mask = a
        },
        renderPass: function(e, t, n, r, i) {
            e.getClearColor(this.originalClearColor);
            var a = e.getClearAlpha(),
                o = e.autoClear;
            e.setRenderTarget(n), e.autoClear = !1, null != r && (e.setClearColor(r), e.setClearAlpha(i || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a)
        },
        renderOverride: function(e, t, n, r, i) {
            e.getClearColor(this.originalClearColor);
            var a = e.getClearAlpha(),
                o = e.autoClear;
            e.setRenderTarget(n), e.autoClear = !1, r = t.clearColor || r, i = t.clearAlpha || i, null != r && (e.setClearColor(r), e.setClearAlpha(i || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a)
        },
        setSize: function(e, t) {
            this.width = e, this.height = t, this.beautyRenderTarget.setSize(e, t), this.ssaoRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.blurRenderTarget.setSize(e, t), this.ssaoMaterial.uniforms.resolution.value.set(e, t), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrix).invert(), this.blurMaterial.uniforms.resolution.value.set(e, t)
        },
        generateSampleKernel: function() {
            for (var e = this.kernelSize, t = this.kernel, n = 0; n < e; n++) {
                var r = new Tn;
                r.x = 2 * Math.random() - 1, r.y = 2 * Math.random() - 1, r.z = Math.random(), r.normalize();
                var i = n / e,
                    i = mn.lerp(.1, 1, i * i);
                r.multiplyScalar(i), t.push(r)
            }
        },
        generateRandomKernelRotations: function() {
            for (var e = new Eg, t = new Float32Array(64), n = 0; n < 16; n++) {
                var r = 4 * n,
                    i = 2 * Math.random() - 1,
                    a = 2 * Math.random() - 1,
                    a = e.noise3d(i, a, 0);
                t[r] = a, t[1 + r] = a, t[2 + r] = a, t[3 + r] = 1
            }
            this.noiseTexture = new ha(t, 4, 4, Qe, Xe), this.noiseTexture.wrapS = U, this.noiseTexture.wrapT = U, this.noiseTexture.needsUpdate = !0
        }
    }), Lg.OUTPUT = {
        Default: 0,
        SSAO: 1,
        Blur: 2,
        Beauty: 3,
        Depth: 4,
        Normal: 5
    };

    function Pg(e, t, n) {
        og.call(this), this.enabled = !0, this.needsSwap = !1, n = n || {}, this.objects = n.objects || [], this.steps = _i(n.steps) || 10, this.stride = _i(n.stride) || 30, this.binarySearchSteps = _i(n.binarySearchSteps) || 4, this.renderTargetScale = _i(n.renderTargetScale) || .5, this.thickness = _i(n.thickness) || .01, this.maxDistance = _i(n.maxDistance) || 100, this.jitter = _i(n.jitter) || 1, this.useRefract = _i(n.useRefract) || !1, this.renderAfter = _i(n.renderAfter) || [], this.simpleRefraction = _i(n.simpleRefraction) || !1, this.scene = e, this.camera = t, this._prevClearColor = new Qr, this._depthBuffer = new wn(256, 256, {
            minFilter: ke,
            magFilter: ke,
            format: Qe,
            type: Ye
        }), this._depthBuffer.texture.name = "SSRPass.Depth", this._depthBuffer.texture.generateMipmaps = !1, this._depthMaterial = new ds, this._depthMaterial.depthPacking = 3202, this._backfaceDepthBuffer = this._depthBuffer.clone(), this._backfaceDepthBuffer.texture.name = "SSRPass.Depth", this._backfaceDepthMaterial = new ds, this._backfaceDepthMaterial.depthPacking = 3202, this._backfaceDepthMaterial.side = ae, this.basic = new ei, this.fsQuad = new og.FullScreenQuad(null)
    }

    function Rg() {
        ug.call(this, wa.tonemap), this.material.type = "ToneMap"
    }
    Pg.prototype = Object.assign(Object.create(og.prototype), {
        constructor: Pg,
        _setLayer: function(e, t) {
            e.layers.set(t), e.isMesh && e.isMaterialGeneratedMesh && e.parent.layers.enable(t)
        },
        dispose: function() {
            this._depthBuffer.dispose(), this._backfaceDepthBuffer.dispose();
            for (var e = 0; e < this.objects.length; e++) {
                var t = (n = this.objects[e]).material;
                t && (this._setLayer(n, 0), delete t.defines.USE_SSR, delete t.defines.USE_SSR_REFRACT, t.needsUpdate = !0)
            }
            this.objects.splice(0);
            for (e = 0; e < this.renderAfter.length; e++) {
                var n = this.renderAfter[e];
                this._setLayer(n, 0)
            }
            this.renderAfter.splice(0)
        },
        setCamera: function(e) {
            this.camera = e
        },
        setSize: function(e, t) {
            e *= this.renderTargetScale, t *= this.renderTargetScale, this._depthBuffer.setSize(e, t), this._backfaceDepthBuffer.setSize(e, t)
        },
        render: function(e, t, n, r, i) {
            var a = this;
            e.getClearColor(this._prevClearColor);
            var o = e.getClearAlpha(),
                s = e.autoClear;
            e.autoClear = !0, e.setClearColor(new Qr(0, 0, 0), 0);
            var l = this.scene.background;
            this.scene.background = null;
            var c = this.camera.layers.mask,
                u = this.scene.overrideMaterial;
            this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(t), e.clear(), this.fsQuad.render(e), this.useRefract || (this._depthMaterial.side = oe), this.camera.layers.enable(this.useRefract ? 3 : 5), this.useRefract && this.simpleRefraction || (this.scene.overrideMaterial = this._depthMaterial, e.setRenderTarget(this._depthBuffer), e.clear(), e.render(this.scene, this.camera)), this.useRefract || (this.scene.overrideMaterial = this._backfaceDepthMaterial, e.setRenderTarget(this._backfaceDepthBuffer), e.clear(), e.render(this.scene, this.camera)), this.scene.overrideMaterial = u, this.scene.traverse(function(e) {
                e.isLight && (e.userData.v3d.oldLayersMask = e.layers.mask, e.layers.enable(a.useRefract ? 5 : 3), a.renderAfter.length && e.layers.enable(a.useRefract ? 6 : 4))
            });
            for (var d = 0; d < this.objects.length; d++) {
                var h = (f = this.objects[d]).material;
                h && h.isMeshNodeMaterial && (this._setLayer(f, this.useRefract ? 5 : 3), h.defines.USE_SSR = "", this.useRefract && (h.defines.USE_SSR_REFRACT = "", this.simpleRefraction && (h.defines.SSR_SIMPLE_REFRACT = "")), h.ssrParams = {
                    invProjectionMatrix: (new nr).copy(this.camera.projectionMatrix).invert(),
                    sourceBuffer: t,
                    depthBuffer: this._depthBuffer,
                    backfaceDepthBuffer: this._backfaceDepthBuffer,
                    stride: this.stride,
                    thickness: this.thickness,
                    maxDistance: this.maxDistance,
                    jitter: this.jitter
                }, h.needsUpdate = !0, h.defines.MAX_STEPS !== this.steps && (h.defines.MAX_STEPS = Math.floor(this.steps), h.needsUpdate = !0), h.defines.BINARY_SEARCH_ITERATIONS !== this.binarySearchSteps && (h.defines.BINARY_SEARCH_ITERATIONS = Math.floor(this.binarySearchSteps), h.needsUpdate = !0))
            }
            for (d = 0; d < this.renderAfter.length; d++) {
                var f = this.renderAfter[d];
                this._setLayer(f, this.useRefract ? 6 : 4)
            }
            this.camera.layers.set(this.useRefract ? 5 : 3), e.autoClear = !1, e.setRenderTarget(n), this.renderAfter.length && (n.disableBlit = !0), e.render(this.scene, this.camera), this.renderAfter.length && (this.camera.layers.set(this.useRefract ? 6 : 4), n.disableBlit = !1, e.render(this.scene, this.camera)), this.scene.background = l, this.camera.layers.mask = c, this.scene.traverse(function(e) {
                e.isLight && "oldLayersMask" in e.userData.v3d && (e.layers.mask = e.userData.v3d.oldLayersMask, delete e.userData.v3d.oldLayersMask)
            }), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), e.setClearColor(this._prevClearColor, o), e.autoClear = s
        }
    }), Rg.prototype = Object.assign(Object.create(ug.prototype), {
        constructor: Rg
    });
    var Dg = {
            Bloom: lg,
            Bokeh: cg,
            "Brightness/Contrast": dg,
            FXAA: hg,
            Grayscale: fg,
            Mask: pg,
            Outline: wg,
            Render: Sg,
            SSAA: Ag,
            SSAO: Lg,
            SSR: Pg,
            ToneMapping: Rg
        },
        Og = {
            getPageParams: function(e) {
                e = e || window;
                var e = decodeURIComponent(e.location.href.toString()),
                    t = {};
                if (-1 == e.indexOf("?")) return t;
                for (var n = e.split("#")[0].split("?")[1].split("&"), r = 0; r < n.length; r++) {
                    var i = n[r].split("="),
                        a = i[0];
                    1 == i.length ? t[a] = "" : t[a] = i[1]
                }
                return t
            },
            updatePageParam: function(e, t, n) {
                var r, i, a = null,
                    o = "",
                    s = e.split("?"),
                    l = s[0],
                    e = s[1],
                    c = "";
                if (e) {
                    i = (r = e.split("#"))[0], (a = r[1]) && (e = i), s = e.split("&");
                    for (var u = 0; u < s.length; u++) s[u].split("=")[0] != t && (o += c + s[u], c = "&")
                } else i = (r = l.split("#"))[0], a = r[1], i && (l = i);
                return a && (n += "#" + a), l + "?" + o + (c + "" + t + "=" + n)
            },
            loadScript: function(e, t, n, r) {
                function i(e) {
                    o.removeEventListener("load", i, !1), o.removeEventListener("error", a, !1), t.removeChild(o), n(e)
                }

                function a(e) {
                    o.removeEventListener("load", i, !1), o.removeEventListener("error", a, !1), t.removeChild(o), r(e)
                }
                var o = document.createElement("script");
                o.addEventListener("load", i, !1), o.addEventListener("error", a, !1), t.appendChild(o), o.src = e
            },
            drawWatermark: function(e) {
                var t, n, r = e.container;
                3483952072 == mn.hashString(sn) && (t = ["color: #fff;", "opacity: 0.5;", "font-size: 18px;", "font-family: sans-serif;", "text-align: center;", "text-decoration: none;", "position: absolute;", "bottom: 1%;", "right: 1%;", "user-select: none;", "z-index: 9999;", "text-shadow: 1px 1px #000;"].join("\n"), (n = document.createElement("div")).innerHTML = '<a href="https://www.soft8soft.com/verge3d-trial/" target="_blank" style="'.concat(t, '">').concat("MADE WITH VERGE3D TRIAL", "</a>"), r.appendChild(n), setTimeout(function() {
                    r.contains(n) && 890310108 == mn.hashString(n.textContent) || e.dispose()
                }, 1e3))
            },
            isXML: function(e) {
                return null !== e.match(/.*\.xml$/)
            },
            isJS: function(e) {
                return null !== e.match(/.*\.js$/)
            },
            createLineObjectHTML: function(c, u, d, e, t, h) {
                console.warn("v3d.AppUtils.createLineObjectHTML has been deprecated. Use v3d.LineHTML instead."), e = e || 2, t = t ? t.convertSRGBToLinear() : new Qr(1, 0, .2), h = h || 5;
                var f = new Tn(1, 0, 0),
                    n = new vg;
                n.setGeometry([0, 0, 0, f.x, f.y, f.z]);
                var e = new Mg({
                        color: t,
                        lineWidth: e,
                        sizeAttenuation: 0
                    }),
                    p = new Ki(n.geometry, e);
                p.name = u.name + "_LINE", u.add(p);
                var m = new Tn,
                    v = new Tn,
                    g = new An;
                c.renderCallbacks.push(function() {
                    c.camera.updateMatrixWorld(), u.traverseAncestors(function(e) {
                        e.updateMatrixWorld()
                    });
                    var e = d.getBoundingClientRect(),
                        t = (e.left + e.right) / 2,
                        n = (e.top + e.bottom) / 2;
                    (o = u.getWorldPosition(m)).project(c.camera);
                    var r = (o.x + 1) / 2 * c.getWidth(),
                        i = (1 - o.y) / 2 * c.getHeight(),
                        a = (n - i) / (t - r),
                        o = (e.height + 2 * h) / (e.width + 2 * h);
                    Math.abs(a) > o ? s = ((l = n < i ? Math.min(e.bottom + h, i) : Math.max(e.top - h, i)) - i) / a + r : l = ((s = r < t ? Math.max(e.left - h, r) : Math.min(e.right + h, r)) - r) * a + i;
                    var s = 2 * s / c.getWidth() - 1,
                        l = 1 - 2 * l / c.getHeight();
                    (s = v.set(s, l, 0)).unproject(c.camera), u.worldToLocal(s), l = s.length(), p.scale.set(l, l, l), s.normalize(), s = g.setFromUnitVectors(f, s), p.setRotationFromQuaternion(s)
                })
            },
            addToAppList: function(e) {
                var t = Mi();
                t.v3d && (t.v3d.apps = t.v3d.apps || [], -1 == t.v3d.apps.indexOf(e) && t.v3d.apps.push(e))
            },
            removeFromAppList: function(e) {
                var t = Mi();
                t.v3d && t.v3d.apps && (-1 < (e = t.v3d.apps.indexOf(e)) && t.v3d.apps.splice(e, 1))
            },
            requestDeviceMotionPermissions: function() {
                var t;
                window.DeviceMotionEvent && window.DeviceMotionEvent.requestPermission && ((t = document.createElement("div")).innerHTML = '<div class="v3d-device-motion-permissions-dialog">Click here to enable iOS VR mode</div>', t.onclick = function() {
                    window.DeviceMotionEvent.requestPermission().then(function(e) {
                        "granted" == e ? console.log("DeviceMotion permissions granted") : console.log("DeviceMotion permissions not granted"), document.querySelector("body").removeChild(t)
                    }).catch(function() {
                        console.error(e)
                    })
                }, document.querySelector("body").appendChild(t))
            },
            printPerformanceInfo: function(g, _) {
                _ = _ || 1;
                var y = g.renderer.info,
                    x = y.autoReset;
                y.autoReset = !1, y.reset();
                for (var b = g.frame, e = 0; e < y.programs.length; e++) y.programs[e].profile.calcRenderTime = !0;
                setTimeout(function() {
                    if (console.log("--- Verge3D Performance Profile (" + _ + "s) ---"), g.scene) {
                        var e = g.frame - b;
                        console.log("Scene Loading Time:", String(Math.round(g._loadingTime)) + "ms"), console.log("FPS:", e / _), console.log("Render Calls:", y.render.calls / e), console.log("Triangles Rendered:", y.render.triangles / e), console.log("Geometry Buffers:", y.memory.geometries), console.log("HDR Rendering:", g.useHDR ? "yes" : "no");
                        var t = g.renderer.getSize(new vn);
                        console.log("Viewport Resolution:", t.x + "x" + t.y), console.log("Pixel Ratio:", g.renderer.getPixelRatio(), "(current) /", window.devicePixelRatio, "(device)");
                        var n = "N/A";
                        switch (g._envIBLMode) {
                            case cn:
                                n = "PMREM";
                                break;
                            case 1:
                                n = "Light Probe + Cubemap";
                                break;
                            case 2:
                                n = "Light Probe"
                        }
                        console.log("Image-Based Lighting:", n, g._pmremMaxTileSize + "px");
                        var r = 0,
                            i = 0,
                            a = "";
                        g.scene.traverse(function(e) {
                            e.isLight && (r++, e.castShadow && e.shadow && (i++, a = e.shadow.mapSize.width + "x" + e.shadow.mapSize.height))
                        }), console.log("Lights:", r);
                        var o = [];
                        g.postprocessing && g.postprocessing.composer.passes.forEach(function(e) {
                            for (var t in Dg)
                                if (e instanceof Dg[t]) return void o.push(t);
                            o.push("Undefined")
                        }), console.log("Post-Processing:", o.length ? o.join(",") : "N/A");
                        var s = "N/A";
                        if (i && g.renderer.shadowMap && g.renderer.shadowMap.enabled) {
                            switch (g.renderer.shadowMap.type) {
                                case K:
                                    s = "Basic";
                                    break;
                                case re:
                                    s = "Bilinear";
                                    break;
                                case J:
                                    s = "PCF";
                                    break;
                                case $:
                                    s = "PCF (Bilinear)";
                                    break;
                                case ne:
                                    s = "PCF (Poisson Disk)";
                                    break;
                                case te:
                                    s = "ESM";
                                    break;
                                case ee:
                                    s = "VSM";
                                    break;
                                default:
                                    s = "Unknown"
                            }
                            s += " " + i + "x " + a
                        }
                        console.log("Shadow Map:", s), console.log("Materials and Shaders:");
                        var l = y.programs.slice(0);
                        l.sort(function(e, t) {
                            return t.profile.renderTime - e.profile.renderTime
                        });
                        for (var c = 0, u = 0; u < l.length; u++) {
                            var d = l[u];
                            d.profile.calcRenderTime = !1;
                            var h = d.profile.materials,
                                f = d.profile.renderTime / e;
                            console.log("   ", 0 == h.length ? "System Material" : h.join(","), "-", d.name, "-", String(Math.round(10 * f) / 10) + "ms"), c += f, d.profile.renderTime = 0
                        }
                        console.log("Total Render Time:", String(Math.round(10 * c) / 10) + "ms"), console.log("Textures & Render Buffers:", y.memory.textures);
                        var p = Array.from(y.memory.textureSpecs.values());
                        p.sort(function(e, t) {
                            return e.type < t.type ? -1 : e.type > t.type ? 1 : e.width != t.width ? t.width - e.width : t.height - e.height
                        });
                        for (var m = 0; m < p.length; m++) {
                            var v = p[m];
                            console.log("   ", v.name || "N/A", "-", v.type, "-", v.width + "x" + v.height)
                        }
                        y.autoReset = x
                    } else console.log("Scene not loaded")
                }, 1e3 * _)
            }
        },
        Ng = {
            prepareRenderer: function(e) {
                Es.checkAndroid() && "ARM" === Es.getGPUVendor(e) && "Mali-T760" === Es.getGPUModel(e) && (e.compatSettings.saturateSpecEnvBlenderApprox = !0)
            }
        };

    function Ig(e, t) {
        var n;
        this.renderer = e, void 0 === t && (n = {
            minFilter: Ue,
            magFilter: Ue,
            format: Qe,
            stencilBuffer: !1
        }, (t = new wn((e = e.getDrawingBufferSize()).width, e.height, n)).texture.name = "EffectComposer.rt1", t.texture.encoding = Gt), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new ug(wa.copy), this._previousFrameTime = Date.now()
    }
    Object.assign(Ig.prototype, {
        swapBuffers: function() {
            var e = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = e
        },
        addPass: function(e) {
            this.passes.push(e);
            var t = this.renderer.getDrawingBufferSize(new vn);
            e.setSize(t.width, t.height)
        },
        insertPass: function(e, t) {
            this.passes.splice(t, 0, e)
        },
        isLastEnabledPass: function(e) {
            for (var t = e + 1; t < this.passes.length; t++)
                if (this.passes[t].enabled) return !1;
            return !0
        },
        render: function(e) {
            void 0 === e && (e = .001 * (Date.now() - this._previousFrameTime)), this._previousFrameTime = Date.now();
            for (var t, n, r = this.renderer.getRenderTarget(), i = !1, a = this.passes.length, o = 0; o < a; o++) !1 !== (n = this.passes[o]).enabled && (n.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o), n.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), n.needsSwap && (i && ((t = this.renderer.context).stencilFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), t.stencilFunc(t.EQUAL, 1, 4294967295)), this.swapBuffers()), n instanceof pg ? i = !0 : n instanceof mg && (i = !1));
            this.renderer.setRenderTarget(r)
        },
        reset: function(e) {
            var t;
            void 0 === e && (t = this.renderer.getDrawingBufferSize(new vn), (e = this.renderTarget1.clone()).setSize(t.width, t.height)), this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        },
        setSize: function(e, t) {
            this.renderTarget1.setSize(e, t), this.renderTarget2.setSize(e, t);
            for (var n = 0; n < this.passes.length; n++) this.passes[n].setSize(e, t)
        },
        dispose: function() {
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
        },
        getActiveSSAAPass: function() {
            return this.passes[0] instanceof Ag ? this.passes[0] : null
        },
        insertPassAfter: function(e, t) {
            for (var n = 0, r = 0; r < this.passes.length; r++) - 1 < t.indexOf(this.passes[r]) && (n = r + 1);
            this.insertPass(e, n)
        },
        enableAllPasses: function() {
            for (var e = 0; e < this.passes.length; e++) this.passes[e].enabled = !0
        },
        disableAllPasses: function() {
            for (var e = 0; e < this.passes.length; e++) this.passes[e].enabled = !1
        }
    });
    var Fg, kg = void 0 !== kg ? kg : {},
        Bg = {};
    for (Fg in kg) kg.hasOwnProperty(Fg) && (Bg[Fg] = kg[Fg]);
    var zg, Ug, Vg, Gg, jg = !1,
        Wg = !1,
        Hg = !1,
        Xg = !1,
        jg = "object" == typeof window,
        Wg = "function" == typeof importScripts,
        Hg = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && !jg && !Wg,
        Xg = !jg && !Hg && !Wg,
        Yg = "";
    Hg ? (Yg = __dirname + "/", zg = function(e, t) {
        var n = C_(e);
        return n ? t ? n : n.toString() : (Vg = Vg || require("fs"), e = (Gg = Gg || require("path")).normalize(e), Vg.readFileSync(e, t ? null : "utf8"))
    }, Ug = function(e) {
        e = zg(e, !0);
        return e.buffer || (e = new Uint8Array(e)), t_(e.buffer), e
    }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), "undefined" != typeof module && (module.exports = kg), process.on("uncaughtException", function(e) {
        if (!(e instanceof
                function(e) {
                    this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                })) throw e
    }), process.on("unhandledRejection", x_), kg.inspect = function() {
        return "[Emscripten Module object]"
    }) : Xg ? ("undefined" != typeof read && (zg = function(e) {
        var t = C_(e);
        return t ? T_(t) : read(e)
    }), Ug = function(e) {
        var t = C_(e);
        return t || ("function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (t_("object" == typeof(t = read(e, "binary"))), t))
    }, "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (jg || Wg) && (Wg ? Yg = self.location.href : document.currentScript && (Yg = document.currentScript.src), Yg = 0 !== Yg.indexOf("blob:") ? Yg.substr(0, Yg.lastIndexOf("/") + 1) : "", zg = function(t) {
        try {
            var e = new XMLHttpRequest;
            return e.open("GET", t, !1), e.send(null), e.responseText
        } catch (e) {
            var n = C_(t);
            if (n) return T_(n);
            throw e
        }
    }, Wg && (Ug = function(t) {
        try {
            var e = new XMLHttpRequest;
            return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response)
        } catch (e) {
            var n = C_(t);
            if (n) return n;
            throw e
        }
    }));
    var qg = kg.print || console.log.bind(console),
        Zg = kg.printErr || console.warn.bind(console);
    for (Fg in Bg) Bg.hasOwnProperty(Fg) && (kg[Fg] = Bg[Fg]);
    Bg = null, kg.arguments && kg.arguments, kg.thisProgram && kg.thisProgram, kg.wasmBinary && (Jg = kg.wasmBinary);
    var Qg, Kg = {
            Memory: function(e) {
                return {
                    buffer: new ArrayBuffer(65536 * e.initial),
                    grow: function(e) {
                        return F_(e)
                    }
                }
            },
            Table: function(e) {
                var n = new Array(e.initial);
                return n.grow = function(e) {
                    1 <= n.length && x_("Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH."), n.push(null)
                }, n.set = function(e, t) {
                    n[e] = t
                }, n.get = function(e) {
                    return n[e]
                }, n
            },
            Module: function(e) {
                return {}
            },
            Instance: function(e, t) {
                var n, r, i, a, o = "function" == typeof o ? o : function(e) {
                    var t, n, r, i, a, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                        s = "",
                        l = 0;
                    for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); t = o.indexOf(e.charAt(l++)) << 2 | (r = o.indexOf(e.charAt(l++))) >> 4, n = (15 & r) << 4 | (i = o.indexOf(e.charAt(l++))) >> 2, r = (3 & i) << 6 | (a = o.indexOf(e.charAt(l++))), s += String.fromCharCode(t), 64 !== i && (s += String.fromCharCode(n)), 64 !== a && (s += String.fromCharCode(r)), l < e.length;);
                    return s
                };
                return {
                    exports: (n = L_, i = (r = Qg).buffer, a = new Uint8Array(i), (i = function(e, t) {
                        var n, r;
                        if ("undefined" == typeof Buffer)
                            for (n = o(t), r = 0; r < n.length; r++) a[e + r] = n.charCodeAt(r);
                        else
                            for (n = Buffer.from(t, "base64"), r = 0; r < n.length; r++) a[e + r] = n[r]
                    })(1024, "/Td6WFo="), i(1041, "BAQECAgIEBAQICAgQEBA"), function(e, t, n) {
                        t.memory;
                        var x = new e.Int8Array(n),
                            g = new e.Int16Array(n),
                            b = new e.Int32Array(n),
                            M = new e.Uint8Array(n),
                            _ = new e.Uint16Array(n),
                            w = new e.Uint32Array(n),
                            y = (new e.Float32Array(n), new e.Float64Array(n), e.Math.imul),
                            r = (e.Math.fround, e.Math.abs, e.Math.clz32, e.Math.min, e.Math.max, e.Math.floor, e.Math.ceil, e.Math.sqrt, t.abort),
                            a = (e.NaN, e.Infinity, t.emscripten_memcpy_big),
                            i = t.emscripten_resize_heap,
                            h = 6296128,
                            S = 0;

                        function A(e, t, n) {
                            var r, i = 0;
                            if (8192 <= n >>> 0) a(0 | e, 0 | t, 0 | n);
                            else {
                                if (r = e + n | 0, 3 & (e ^ t))
                                    if (r >>> 0 < 4) n = e;
                                    else if ((i = r - 4 | 0) >>> 0 < e >>> 0) n = e;
                                else
                                    for (n = e; x[0 | n] = M[0 | t], x[n + 1 | 0] = M[t + 1 | 0], x[n + 2 | 0] = M[t + 2 | 0], x[n + 3 | 0] = M[t + 3 | 0], t = t + 4 | 0, (n = n + 4 | 0) >>> 0 <= i >>> 0;);
                                else {
                                    e: if ((0 | n) < 1) n = e;
                                        else if (3 & e)
                                        for (n = e;;) {
                                            if (x[0 | n] = M[0 | t], t = t + 1 | 0, r >>> 0 <= (n = n + 1 | 0) >>> 0) break e;
                                            if (!(3 & n)) break
                                        } else n = e;
                                    if (e = -4 & r, !(e >>> 0 < 64 || (i = e + -64 | 0) >>> 0 < n >>> 0))
                                        for (; b[n >> 2] = b[t >> 2], b[n + 4 >> 2] = b[t + 4 >> 2], b[n + 8 >> 2] = b[t + 8 >> 2], b[n + 12 >> 2] = b[t + 12 >> 2], b[n + 16 >> 2] = b[t + 16 >> 2], b[n + 20 >> 2] = b[t + 20 >> 2], b[n + 24 >> 2] = b[t + 24 >> 2], b[n + 28 >> 2] = b[t + 28 >> 2], b[n + 32 >> 2] = b[t + 32 >> 2], b[n + 36 >> 2] = b[t + 36 >> 2], b[n + 40 >> 2] = b[t + 40 >> 2], b[n + 44 >> 2] = b[t + 44 >> 2], b[n + 48 >> 2] = b[t + 48 >> 2], b[n + 52 >> 2] = b[t + 52 >> 2], b[n + 56 >> 2] = b[t + 56 >> 2], b[n + 60 >> 2] = b[t + 60 >> 2], t = t - -64 | 0, (n = n - -64 | 0) >>> 0 <= i >>> 0;);
                                    if (!(e >>> 0 <= n >>> 0))
                                        for (; b[n >> 2] = b[t >> 2], t = t + 4 | 0, (n = n + 4 | 0) >>> 0 < e >>> 0;);
                                }
                                if (n >>> 0 < r >>> 0)
                                    for (; x[0 | n] = M[0 | t], t = t + 1 | 0, (0 | r) != (0 | (n = n + 1 | 0)););
                            }
                        }

                        function T(e, t, n) {
                            if (n ^= -1, t)
                                for (; n = b[1056 + ((M[0 | e] ^ 255 & n) << 2) >> 2] ^ n >>> 8, e = e + 1 | 0, t = t + -1 | 0;);
                            return -1 ^ n
                        }

                        function o(e) {
                            var t;
                            e && (t = b[e + 1200 >> 2], b[t + 60 >> 2] && E(b[t + 24 >> 2]), E(t), E(e))
                        }

                        function f(e) {
                            var t = 0;
                            return !((0 | (e = (t = b[263312]) + (e + 3 & -4) | 0)) <= -1) && (e >>> 0 <= (n.byteLength / 65536 | 0) << 16 >>> 0 || i(0 | e)) ? (b[263312] = e, t) : (b[263185] = 48, -1)
                        }

                        function E(e) {
                            var t, n = 0,
                                r = 0,
                                i = 0,
                                a = 0,
                                o = 0,
                                s = 0;
                            e: if (e) {
                                t = (i = e + -8 | 0) + (e = -8 & (r = b[e + -4 >> 2])) | 0;
                                t: if (!(1 & r)) {
                                    if (!(3 & r)) break e;
                                    if ((i = i - (r = b[i >> 2]) | 0) >>> 0 < w[263190]) break e;
                                    if (e = e + r | 0, b[263191] == (0 | i)) {
                                        if (3 == (3 & (r = b[4 + t >> 2]))) return b[263188] = e, b[4 + t >> 2] = -2 & r, b[i + 4 >> 2] = 1 | e, void(b[e + i >> 2] = e)
                                    } else if (r >>> 0 <= 255) a = b[i + 8 >> 2], r = r >>> 3 | 0, (0 | (n = b[i + 12 >> 2])) != (0 | a) ? (b[a + 12 >> 2] = n, b[n + 8 >> 2] = a) : b[263186] = b[263186] & m(r);
                                    else {
                                        if (s = b[i + 24 >> 2], (0 | i) == (0 | (r = b[i + 12 >> 2])))
                                            if (a = i + 20 | 0, n = b[a >> 2], n = n || b[(a = i + 16 | 0) >> 2]) {
                                                for (; o = a, (n = b[(a = (r = n) + 20 | 0) >> 2]) || (a = r + 16 | 0, n = b[r + 16 >> 2]););
                                                b[o >> 2] = 0
                                            } else r = 0;
                                        else n = b[i + 8 >> 2], b[n + 12 >> 2] = r, b[r + 8 >> 2] = n;
                                        if (s) {
                                            a = b[i + 28 >> 2];
                                            n: {
                                                if (b[(n = 1053048 + (a << 2) | 0) >> 2] == (0 | i)) {
                                                    if (b[n >> 2] = r) break n;
                                                    b[263187] = b[263187] & m(a);
                                                    break t
                                                }
                                                if (!(b[s + (b[s + 16 >> 2] == (0 | i) ? 16 : 20) >> 2] = r)) break t
                                            }
                                            b[r + 24 >> 2] = s, (n = b[i + 16 >> 2]) && (b[r + 16 >> 2] = n, b[n + 24 >> 2] = r), (n = b[i + 20 >> 2]) && (b[r + 20 >> 2] = n, b[n + 24 >> 2] = r)
                                        }
                                    }
                                }
                                if (!(t >>> 0 <= i >>> 0) && 1 & (r = b[4 + t >> 2])) {
                                    t: {
                                        if (!(2 & r)) {
                                            if (b[263192] == (0 | t)) {
                                                if (b[263192] = i, e = b[263189] + e | 0, b[263189] = e, b[i + 4 >> 2] = 1 | e, b[263191] != (0 | i)) break e;
                                                return b[263188] = 0, void(b[263191] = 0)
                                            }
                                            if (b[263191] == (0 | t)) return b[263191] = i, e = b[263188] + e | 0, b[263188] = e, b[i + 4 >> 2] = 1 | e, void(b[e + i >> 2] = e);
                                            e = (-8 & r) + e | 0;
                                            n: if (r >>> 0 <= 255) r = r >>> 3 | 0, (0 | (n = b[8 + t >> 2])) != (0 | (a = b[12 + t >> 2])) ? (b[n + 12 >> 2] = a, b[a + 8 >> 2] = n) : b[263186] = b[263186] & m(r);
                                                else {
                                                    if (s = b[24 + t >> 2], (0 | t) == (0 | (r = b[12 + t >> 2])))
                                                        if (a = 20 + t | 0, n = b[a >> 2], n = n || b[(a = 16 + t | 0) >> 2]) {
                                                            for (; o = a, (n = b[(a = (r = n) + 20 | 0) >> 2]) || (a = r + 16 | 0, n = b[r + 16 >> 2]););
                                                            b[o >> 2] = 0
                                                        } else r = 0;
                                                    else n = b[8 + t >> 2], b[n + 12 >> 2] = r, b[r + 8 >> 2] = n;
                                                    if (s) {
                                                        a = b[28 + t >> 2];
                                                        r: {
                                                            if (b[(n = 1053048 + (a << 2) | 0) >> 2] == (0 | t)) {
                                                                if (b[n >> 2] = r) break r;
                                                                b[263187] = b[263187] & m(a);
                                                                break n
                                                            }
                                                            if (!(b[s + (b[s + 16 >> 2] == (0 | t) ? 16 : 20) >> 2] = r)) break n
                                                        }
                                                        b[r + 24 >> 2] = s, (n = b[16 + t >> 2]) && (b[r + 16 >> 2] = n, b[n + 24 >> 2] = r), (n = b[20 + t >> 2]) && (b[r + 20 >> 2] = n, b[n + 24 >> 2] = r)
                                                    }
                                                }
                                            if (b[i + 4 >> 2] = 1 | e, b[e + i >> 2] = e, b[263191] != (0 | i)) break t;
                                            return void(b[263188] = e)
                                        }
                                        b[4 + t >> 2] = -2 & r,
                                        b[i + 4 >> 2] = 1 | e,
                                        b[e + i >> 2] = e
                                    }
                                    if (e >>> 0 <= 255) return r = 1052784 + ((e = e >>> 3 | 0) << 3) | 0,
                                    e = (n = b[263186]) & (e = 1 << e) ? b[r + 8 >> 2] : (b[263186] = e | n, r),
                                    b[r + 8 >> 2] = i,
                                    b[e + 12 >> 2] = i,
                                    b[i + 12 >> 2] = r,
                                    void(b[i + 8 >> 2] = e);b[i + 16 >> 2] = 0,
                                    (a = e >>> 8 | (n = b[i + 20 >> 2] = 0)) && (n = 31, 16777215 < e >>> 0 || (n = a, n <<= a = a + 1048320 >>> 16 & 8, n = 28 + ((n = ((n <<= s = n + 520192 >>> 16 & 4) << (o = n + 245760 >>> 16 & 2) >>> 15 | 0) - (o | a | s) | 0) << 1 | e >>> n + 21 & 1) | 0)),
                                    o = 1053048 + ((b[(r = i) + 28 >> 2] = n) << 2) | 0;t: {
                                        n: {
                                            if ((a = b[263187]) & (r = 1 << n)) {
                                                for (a = e << (31 == (0 | n) ? 0 : 25 - (n >>> 1 | 0) | 0), r = b[o >> 2];;) {
                                                    if ((-8 & b[(n = r) + 4 >> 2]) == (0 | e)) break n;
                                                    if (r = a >>> 29 | 0, a <<= 1, !(r = b[(o = n + (4 & r) | 0) + 16 >> 2])) break
                                                }
                                                b[o + 16 >> 2] = i, b[i + 24 >> 2] = n
                                            } else b[263187] = r | a,
                                            b[o >> 2] = i,
                                            b[i + 24 >> 2] = o;b[i + 12 >> 2] = i,
                                            b[i + 8 >> 2] = i;
                                            break t
                                        }
                                        e = b[n + 8 >> 2],
                                        b[e + 12 >> 2] = i,
                                        b[n + 8 >> 2] = i,
                                        b[i + 24 >> 2] = 0,
                                        b[i + 12 >> 2] = n,
                                        b[i + 8 >> 2] = e
                                    }
                                    if (e = b[263194] + -1 | 0, !(b[263194] = e)) {
                                        for (i = 1053200; i = (e = b[i >> 2]) + 8 | 0, e;);
                                        b[263194] = -1
                                    }
                                }
                            }
                        }

                        function C(e, t) {
                            var n;
                            if (t && (n = e + t | 0, x[n - 1 | 0] = 0, x[0 | e] = 0, !(t >>> 0 < 3 || (x[n - 2 | 0] = 0, x[e + 1 | 0] = 0, x[n - 3 | 0] = 0, x[e + 2 | 0] = 0, t >>> 0 < 7 || (x[n - 4 | 0] = 0, x[e + 3 | 0] = 0, t >>> 0 < 9 || (n = 0 - e & 3, e = n + e | 0, b[e >> 2] = 0, n = t - n & -4, t = n + e | 0, b[t + -4 >> 2] = 0, n >>> 0 < 9 || (b[e + 8 >> 2] = 0, b[e + 4 >> 2] = 0, b[t + -8 >> 2] = 0, b[t + -12 >> 2] = 0, n >>> 0 < 25 || (b[e + 24 >> 2] = 0, b[e + 20 >> 2] = 0, b[e + 16 >> 2] = 0, b[e + 12 >> 2] = 0, b[t + -16 >> 2] = 0, b[t + -20 >> 2] = 0, b[t + -24 >> 2] = 0, b[t + -28 >> 2] = 0, (t = (t = n) - (n = 4 & e | 24) | 0) >>> 0 < 32))))))))
                                for (e = e + n | 0; b[e + 24 >> 2] = 0, b[e + 28 >> 2] = 0, b[e + 16 >> 2] = 0, b[e + 20 >> 2] = 0, b[e + 8 >> 2] = 0, b[e + 12 >> 2] = 0, b[e >> 2] = 0, e = e + 32 | (b[e + 4 >> 2] = 0), 31 < (t = t + -32 | 0) >>> 0;);
                        }

                        function L(e) {
                            var t = 0,
                                n = 0,
                                r = 0,
                                i = 0,
                                a = 0,
                                o = 0,
                                s = 0,
                                l = 0,
                                c = 0,
                                u = 0,
                                d = 0;
                            h = d = h - 16 | 0;
                            e: {
                                t: {
                                    n: {
                                        r: {
                                            i: {
                                                a: {
                                                    o: {
                                                        s: {
                                                            l: {
                                                                c: {
                                                                    u: {
                                                                        if (e >>> 0 <= 244) {
                                                                            if (3 & (t = (a = b[263186]) >>> (e = (o = e >>> 0 < 11 ? 16 : e + 11 & -8) >>> 3 | 0) | 0)) {
                                                                                e = (t = b[(i = (n = e + (1 & (-1 ^ t)) | 0) << 3) + 1052792 >> 2]) + 8 | 0, (0 | (r = b[t + 8 >> 2])) != (0 | (i = i + 1052784 | 0)) ? (b[r + 12 >> 2] = i, b[i + 8 >> 2] = r) : b[263186] = m(n) & a, n <<= 3, b[t + 4 >> 2] = 3 | n, b[(t = t + n | 0) + 4 >> 2] = 1 | b[t + 4 >> 2];
                                                                                break e
                                                                            }
                                                                            if (o >>> 0 <= (l = b[263188]) >>> 0) break u;
                                                                            if (t) {
                                                                                n = t = (e = (0 - (e = (0 - (n = 2 << e) | n) & t << e) & e) - 1 | 0) >>> 12 & 16, n |= t = (e = e >>> t | 0) >>> 5 & 8, n |= t = (e = e >>> t | 0) >>> 2 & 4, t = b[(r = (n = ((n |= t = (e = e >>> t | 0) >>> 1 & 2) | (t = (e = e >>> t | 0) >>> 1 & 1)) + (e >>> t | 0) | 0) << 3) + 1052792 >> 2], (0 | (e = b[t + 8 >> 2])) != (0 | (r = r + 1052784 | 0)) ? (b[e + 12 >> 2] = r, b[r + 8 >> 2] = e) : (a = m(n) & a, b[263186] = a), e = t + 8 | 0, b[t + 4 >> 2] = 3 | o, i = (n <<= 3) - o | 0, b[(s = t + o | 0) + 4 >> 2] = 1 | i, b[t + n >> 2] = i, l && (t = 1052784 + ((n = l >>> 3 | 0) << 3) | 0, r = b[263191], n = (n = 1 << n) & a ? b[t + 8 >> 2] : (b[263186] = n | a, t), b[t + 8 >> 2] = r, b[n + 12 >> 2] = r, b[r + 12 >> 2] = t, b[r + 8 >> 2] = n), b[263191] = s, b[263188] = i;
                                                                                break e
                                                                            }
                                                                            if (!(u = b[263187])) break u;
                                                                            for (n = t = (e = (u & 0 - u) - 1 | 0) >>> 12 & 16, n |= t = (e = e >>> t | 0) >>> 5 & 8, n |= t = (e = e >>> t | 0) >>> 2 & 4, t = b[1053048 + (((n |= t = (e = e >>> t | 0) >>> 1 & 2) | (t = (e = e >>> t | 0) >>> 1 & 1)) + (e >>> t | 0) << 2) >> 2], r = (-8 & b[t + 4 >> 2]) - o | 0, n = t; e = (e = b[n + 16 >> 2]) || b[n + 20 >> 2];) r = (n = (i = (-8 & b[e + 4 >> 2]) - o | 0) >>> 0 < r >>> 0) ? i : r, t = n ? e : t, n = e;
                                                                            if (c = b[t + 24 >> 2], (0 | (i = b[t + 12 >> 2])) != (0 | t)) {
                                                                                e = b[t + 8 >> 2], b[e + 12 >> 2] = i, b[i + 8 >> 2] = e;
                                                                                break t
                                                                            }
                                                                            if (!(e = b[(n = t + 20 | 0) >> 2])) {
                                                                                if (!(e = b[t + 16 >> 2])) break c;
                                                                                n = t + 16 | 0
                                                                            }
                                                                            for (; s = n, (e = b[(n = (i = e) + 20 | 0) >> 2]) || (n = i + 16 | 0, e = b[i + 16 >> 2]););
                                                                            b[s >> 2] = 0;
                                                                            break t
                                                                        }
                                                                        if (o = -1, !(4294967231 < e >>> 0) && (o = -8 & (t = e + 11 | 0), l = b[263187])) {
                                                                            n = 0 - o | 0, (t = t >>> 8 | (a = 0)) && (a = 31, 16777215 < o >>> 0 || (a = 28 + ((e = ((a = (t <<= r = t + 1048320 >>> 16 & 8) << (e = t + 520192 >>> 16 & 4)) << (t = a + 245760 >>> 16 & 2) >>> 15 | 0) - (t | e | r) | 0) << 1 | o >>> e + 21 & 1) | 0));
                                                                            d: {
                                                                                h: {
                                                                                    if (r = b[1053048 + (a << 2) >> 2])
                                                                                        for (t = o << (31 == (0 | a) ? 0 : 25 - (a >>> 1 | 0) | 0), e = 0;;) {
                                                                                            if (s = (-8 & b[r + 4 >> 2]) - o | 0, !(n >>> 0 <= s >>> 0 || (i = r, n = s))) {
                                                                                                n = 0, e = r;
                                                                                                break h
                                                                                            }
                                                                                            if (s = b[r + 20 >> 2], r = b[16 + ((t >>> 29 & 4) + r | 0) >> 2], e = !s || (0 | s) == (0 | r) ? e : s, t <<= 0 != (0 | r), !r) break
                                                                                        } else e = 0;
                                                                                    if (!(e | i)) {
                                                                                        if (!(e = (0 - (e = 2 << a) | e) & l)) break u;
                                                                                        r = t = (e = (e & 0 - e) - 1 | 0) >>> 12 & 16, r |= t = (e = e >>> t | 0) >>> 5 & 8, r |= t = (e = e >>> t | 0) >>> 2 & 4, e = b[1053048 + (((r |= t = (e = e >>> t | 0) >>> 1 & 2) | (t = (e = e >>> t | 0) >>> 1 & 1)) + (e >>> t | 0) << 2) >> 2]
                                                                                    }
                                                                                    if (!e) break d
                                                                                }
                                                                                for (; n = (t = (r = (-8 & b[e + 4 >> 2]) - o | 0) >>> 0 < n >>> 0) ? r : n, i = t ? e : i, e = (t = b[e + 16 >> 2]) || b[e + 20 >> 2];);
                                                                            }
                                                                            if (!(!i | n >>> 0 >= b[263188] - o >>> 0)) {
                                                                                if (s = b[i + 24 >> 2], (0 | i) != (0 | (t = b[i + 12 >> 2]))) {
                                                                                    e = b[i + 8 >> 2], b[e + 12 >> 2] = t, b[t + 8 >> 2] = e;
                                                                                    break n
                                                                                }
                                                                                if (!(e = b[(r = i + 20 | 0) >> 2])) {
                                                                                    if (!(e = b[i + 16 >> 2])) break l;
                                                                                    r = i + 16 | 0
                                                                                }
                                                                                for (; a = r, (e = b[(r = (t = e) + 20 | 0) >> 2]) || (r = t + 16 | 0, e = b[t + 16 >> 2]););
                                                                                b[a >> 2] = 0;
                                                                                break n
                                                                            }
                                                                        }
                                                                    }
                                                                    if (o >>> 0 <= (t = b[263188]) >>> 0) {
                                                                        e = b[263191], 16 <= (n = t - o | 0) >>> 0 ? (b[263188] = n, r = e + o | 0, b[263191] = r, b[r + 4 >> 2] = 1 | n, b[e + t >> 2] = n, b[e + 4 >> 2] = 3 | o) : (b[263191] = 0, b[263188] = 0, b[e + 4 >> 2] = 3 | t, b[(t = e + t | 0) + 4 >> 2] = 1 | b[t + 4 >> 2]), e = e + 8 | 0;
                                                                        break e
                                                                    }
                                                                    if (o >>> 0 < (r = b[263189]) >>> 0) {
                                                                        t = r - o | 0, b[263189] = t, n = (e = b[263192]) + o | 0, b[263192] = n, b[n + 4 >> 2] = 1 | t, b[e + 4 >> 2] = 3 | o, e = e + 8 | 0;
                                                                        break e
                                                                    }
                                                                    if ((n = (a = (n = i = o + 47 | (e = 0)) + (t = b[263304] ? b[263306] : (b[263307] = -1, b[263308] = -1, b[263305] = 4096, b[263306] = 4096, b[263304] = 12 + d & -16 ^ 1431655768, b[263309] = 0, b[263297] = 0, 4096)) | 0) & (s = 0 - t | 0)) >>> 0 <= o >>> 0) break e;
                                                                    if (t = b[263296], t && (c = (l = b[263294]) + n | 0) >>> 0 <= l >>> 0 | t >>> 0 < c >>> 0) break e;
                                                                    if (4 & M[1053188]) break a;u: {
                                                                        d: {
                                                                            if (t = b[263192])
                                                                                for (e = 1053192;;) {
                                                                                    if ((l = b[e >> 2]) + b[e + 4 >> 2] >>> 0 > t >>> 0 && l >>> 0 <= t >>> 0) break d;
                                                                                    if (!(e = b[e + 8 >> 2])) break
                                                                                }
                                                                            if (-1 == (0 | (t = f(0)))) break o;
                                                                            if (a = n, (r = (e = b[263305]) + -1 | 0) & t && (a = (n - t | 0) + (t + r & 0 - e) | 0), a >>> 0 <= o >>> 0 | 2147483646 < a >>> 0) break o;
                                                                            if (e = b[263296], e && (s = (r = b[263294]) + a | 0) >>> 0 <= r >>> 0 | e >>> 0 < s >>> 0) break o;
                                                                            if ((0 | t) != (0 | (e = f(a)))) break u;
                                                                            break i
                                                                        }
                                                                        if (2147483646 < (a = s & a - r) >>> 0) break o;
                                                                        if ((0 | (t = f(a))) == (b[e >> 2] + b[e + 4 >> 2] | 0)) break s;e = t
                                                                    }
                                                                    if (!(o + 48 >>> 0 <= a >>> 0 | 2147483646 < a >>> 0 | -1 == (0 | (t = e)))) {
                                                                        if (2147483646 < (e = (e = b[263306]) + (i - a | 0) & 0 - e) >>> 0) break i;
                                                                        if (-1 != (0 | f(e))) {
                                                                            a = e + a | 0;
                                                                            break i
                                                                        }
                                                                        f(0 - a | 0);
                                                                        break o
                                                                    }
                                                                    if (-1 != (0 | t)) break i;
                                                                    break o
                                                                }
                                                                i = 0;
                                                                break t
                                                            }
                                                            t = 0;
                                                            break n
                                                        }
                                                        if (-1 != (0 | t)) break i
                                                    }
                                                    b[263297] = 4 | b[263297]
                                                }
                                                if (2147483646 < n >>> 0) break r;
                                                if (t = f(n), (e = f(0)) >>> 0 <= t >>> 0 | -1 == (0 | t) | -1 == (0 | e)) break r;
                                                if ((a = e - t | 0) >>> 0 <= o + 40 >>> 0) break r
                                            }
                                            e = b[263294] + a | 0,
                                            (b[263294] = e) >>> 0 > w[263295] && (b[263295] = e);i: {
                                                a: {
                                                    o: {
                                                        if (n = b[263192]) {
                                                            for (e = 1053192;;) {
                                                                if (((r = b[e >> 2]) + (i = b[e + 4 >> 2]) | 0) == (0 | t)) break o;
                                                                if (!(e = b[e + 8 >> 2])) break
                                                            }
                                                            break a
                                                        }
                                                        for ((e = b[263190]) >>> 0 <= t >>> 0 && e || (b[263190] = t), e = 0, b[263299] = a, b[263298] = t, b[263194] = -1, b[263195] = b[263304], b[263301] = 0; r = (n = e << 3) + 1052784 | 0, b[n + 1052792 >> 2] = r, b[n + 1052796 >> 2] = r, 32 != (0 | (e = e + 1 | 0)););r = (e = a + -40 | 0) - (n = t + 8 & 7 ? -8 - t & 7 : 0) | 0,
                                                        b[263189] = r,
                                                        n = t + n | 0,
                                                        b[263192] = n,
                                                        b[n + 4 >> 2] = 1 | r,
                                                        b[4 + (e + t | 0) >> 2] = 40,
                                                        b[263193] = b[263308];
                                                        break i
                                                    }
                                                    if (!(8 & M[e + 12 | 0] | t >>> 0 <= n >>> 0 | n >>> 0 < r >>> 0)) {
                                                        b[e + 4 >> 2] = i + a, t = (e = n + 8 & 7 ? -8 - n & 7 : 0) + n | 0, b[263192] = t, e = (r = b[263189] + a | 0) - e | 0, b[263189] = e, b[t + 4 >> 2] = 1 | e, b[4 + (n + r | 0) >> 2] = 40, b[263193] = b[263308];
                                                        break i
                                                    }
                                                }
                                                t >>> 0 < (i = b[263190]) >>> 0 && (b[263190] = t, i = 0),
                                                r = t + a | 0,
                                                e = 1053192;a: {
                                                    o: {
                                                        s: {
                                                            l: {
                                                                c: {
                                                                    u: {
                                                                        for (;
                                                                            (0 | r) != b[e >> 2];)
                                                                            if (!(e = b[e + 8 >> 2])) break u;
                                                                        if (!(8 & M[e + 12 | 0])) break c
                                                                    }
                                                                    for (e = 1053192;;) {
                                                                        if (r = b[e >> 2], r >>> 0 <= n >>> 0 && n >>> 0 < (i = r + b[e + 4 >> 2] | 0) >>> 0) break l;
                                                                        e = b[e + 8 >> 2]
                                                                    }
                                                                }
                                                                if (b[e >> 2] = t, b[e + 4 >> 2] = b[e + 4 >> 2] + a, b[(c = (t + 8 & 7 ? -8 - t & 7 : 0) + t | 0) + 4 >> 2] = 3 | o, e = ((t = r + (r + 8 & 7 ? -8 - r & 7 : 0) | 0) - c | 0) - o | 0, s = o + c | 0, (0 | t) == (0 | n)) {
                                                                    b[263192] = s, e = b[263189] + e | 0, b[263189] = e, b[s + 4 >> 2] = 1 | e;
                                                                    break o
                                                                }
                                                                if (b[263191] == (0 | t)) {
                                                                    b[263191] = s, e = b[263188] + e | 0, b[263188] = e, b[s + 4 >> 2] = 1 | e, b[e + s >> 2] = e;
                                                                    break o
                                                                }
                                                                if (1 == (3 & (n = b[t + 4 >> 2]))) {
                                                                    u = -8 & n;
                                                                    c: if (n >>> 0 <= 255) i = n >>> 3 | 0, n = b[t + 8 >> 2], (0 | (r = b[t + 12 >> 2])) != (0 | n) ? (b[n + 12 >> 2] = r, b[r + 8 >> 2] = n) : b[263186] = b[263186] & m(i);
                                                                        else {
                                                                            if (l = b[t + 24 >> 2], (0 | (a = b[t + 12 >> 2])) == (0 | t))
                                                                                if (r = t + 20 | 0, o = b[r >> 2], o = o || b[(r = t + 16 | 0) >> 2]) {
                                                                                    for (; n = r, (o = b[(r = (a = o) + 20 | 0) >> 2]) || (r = a + 16 | 0, o = b[a + 16 >> 2]););
                                                                                    b[n >> 2] = 0
                                                                                } else a = 0;
                                                                            else n = b[t + 8 >> 2], b[n + 12 >> 2] = a, b[a + 8 >> 2] = n;
                                                                            if (l) {
                                                                                n = b[t + 28 >> 2];
                                                                                u: {
                                                                                    if (b[(r = 1053048 + (n << 2) | 0) >> 2] == (0 | t)) {
                                                                                        if (b[r >> 2] = a) break u;
                                                                                        b[263187] = b[263187] & m(n);
                                                                                        break c
                                                                                    }
                                                                                    if (!(b[l + (b[l + 16 >> 2] == (0 | t) ? 16 : 20) >> 2] = a)) break c
                                                                                }
                                                                                b[a + 24 >> 2] = l, (n = b[t + 16 >> 2]) && (b[a + 16 >> 2] = n, b[n + 24 >> 2] = a), (n = b[t + 20 >> 2]) && (b[a + 20 >> 2] = n, b[n + 24 >> 2] = a)
                                                                            }
                                                                        } t = t + u | 0, e = e + u | 0
                                                                }
                                                                if (b[t + 4 >> 2] = -2 & b[t + 4 >> 2], b[s + 4 >> 2] = 1 | e, (b[e + s >> 2] = e) >>> 0 <= 255) {
                                                                    e = 1052784 + ((t = e >>> 3 | 0) << 3) | 0, t = (n = b[263186]) & (t = 1 << t) ? b[e + 8 >> 2] : (b[263186] = t | n, e), b[e + 8 >> 2] = s, b[t + 12 >> 2] = s, b[s + 12 >> 2] = e, b[s + 8 >> 2] = t;
                                                                    break o
                                                                }
                                                                if ((r = e >>> 8 | (t = 0)) && (t = 31, 16777215 < e >>> 0 || (t = 28 + ((t = ((o = (r <<= i = r + 1048320 >>> 16 & 8) << (t = r + 520192 >>> 16 & 4)) << (r = o + 245760 >>> 16 & 2) >>> 15 | 0) - (r | t | i) | 0) << 1 | e >>> t + 21 & 1) | 0)), b[(n = s) + 28 >> 2] = t, b[s + 16 >> 2] = 0, n = 1053048 + (t << 2) | (b[s + 20 >> 2] = 0), (r = b[263187]) & (i = 1 << t)) {
                                                                    for (r = e << (31 == (0 | t) ? 0 : 25 - (t >>> 1 | 0) | 0), t = b[n >> 2];;) {
                                                                        if ((-8 & b[(n = t) + 4 >> 2]) == (0 | e)) break s;
                                                                        if (t = r >>> 29 | 0, r <<= 1, !(t = b[(i = (4 & t) + n | 0) + 16 >> 2])) break
                                                                    }
                                                                    b[i + 16 >> 2] = s
                                                                } else b[263187] = r | i,
                                                                b[n >> 2] = s;b[s + 24 >> 2] = n,
                                                                b[s + 12 >> 2] = s,
                                                                b[s + 8 >> 2] = s;
                                                                break o
                                                            }
                                                            for (s = (e = a + -40 | 0) - (r = t + 8 & 7 ? -8 - t & 7 : 0) | 0, b[263189] = s, r = t + r | 0, b[263192] = r, b[r + 4 >> 2] = 1 | s, b[4 + (e + t | 0) >> 2] = 40, b[263193] = b[263308], b[(r = (e = (i + (i + -39 & 7 ? 39 - i & 7 : 0) | 0) - 47 | 0) >>> 0 < n + 16 >>> 0 ? n : e) + 4 >> 2] = 27, e = b[263301], b[r + 16 >> 2] = b[263300], b[r + 20 >> 2] = e, e = b[263299], b[r + 8 >> 2] = b[263298], b[r + 12 >> 2] = e, b[263300] = r + 8, b[263299] = a, b[263298] = t, e = r + 24 | (b[263301] = 0); b[e + 4 >> 2] = 7, t = e + 8 | 0, e = e + 4 | 0, t >>> 0 < i >>> 0;);
                                                            if ((0 | n) == (0 | r)) break i;
                                                            if (b[r + 4 >> 2] = -2 & b[r + 4 >> 2], i = r - n | 0, b[n + 4 >> 2] = 1 | i, (b[r >> 2] = i) >>> 0 <= 255) {
                                                                e = 1052784 + ((t = i >>> 3 | 0) << 3) | 0, t = (r = b[263186]) & (t = 1 << t) ? b[e + 8 >> 2] : (b[263186] = t | r, e), b[e + 8 >> 2] = n, b[t + 12 >> 2] = n, b[n + 12 >> 2] = e, b[n + 8 >> 2] = t;
                                                                break i
                                                            }
                                                            if (b[n + 16 >> 2] = 0, (r = i >>> 8 | (e = b[n + 20 >> 2] = 0)) && (e = 31, 16777215 < i >>> 0 || (e = 28 + ((e = ((s = (r <<= a = r + 1048320 >>> 16 & 8) << (e = r + 520192 >>> 16 & 4)) << (r = s + 245760 >>> 16 & 2) >>> 15 | 0) - (r | e | a) | 0) << 1 | i >>> e + 21 & 1) | 0)), t = 1053048 + ((b[(t = n) + 28 >> 2] = e) << 2) | 0, (r = b[263187]) & (a = 1 << e)) {
                                                                for (e = i << (31 == (0 | e) ? 0 : 25 - (e >>> 1 | 0) | 0), t = b[t >> 2];;) {
                                                                    if ((0 | i) == (-8 & b[(r = t) + 4 >> 2])) break a;
                                                                    if (t = e >>> 29 | 0, e <<= 1, !(t = b[(a = r + (4 & t) | 0) + 16 >> 2])) break
                                                                }
                                                                b[a + 16 >> 2] = n, b[n + 24 >> 2] = r
                                                            } else b[263187] = r | a,
                                                            b[t >> 2] = n,
                                                            b[n + 24 >> 2] = t;b[n + 12 >> 2] = n,
                                                            b[n + 8 >> 2] = n;
                                                            break i
                                                        }
                                                        e = b[n + 8 >> 2],
                                                        b[e + 12 >> 2] = s,
                                                        b[n + 8 >> 2] = s,
                                                        b[s + 24 >> 2] = 0,
                                                        b[s + 12 >> 2] = n,
                                                        b[s + 8 >> 2] = e
                                                    }
                                                    e = c + 8 | 0;
                                                    break e
                                                }
                                                e = b[r + 8 >> 2],
                                                b[e + 12 >> 2] = n,
                                                b[r + 8 >> 2] = n,
                                                b[n + 24 >> 2] = 0,
                                                b[n + 12 >> 2] = r,
                                                b[n + 8 >> 2] = e
                                            }
                                            if (!((e = b[263189]) >>> 0 <= o >>> 0)) {
                                                t = e - o | 0, b[263189] = t, n = (e = b[263192]) + o | 0, b[263192] = n, b[n + 4 >> 2] = 1 | t, b[e + 4 >> 2] = 3 | o, e = e + 8 | 0;
                                                break e
                                            }
                                        }
                                        b[263185] = 48,
                                        e = 0;
                                        break e
                                    }
                                    n: if (s) {
                                        e = b[i + 28 >> 2];
                                        r: {
                                            if (b[(r = 1053048 + (e << 2) | 0) >> 2] == (0 | i)) {
                                                if (b[r >> 2] = t) break r;
                                                l = m(e) & l, b[263187] = l;
                                                break n
                                            }
                                            if (!(b[s + (b[s + 16 >> 2] == (0 | i) ? 16 : 20) >> 2] = t)) break n
                                        }
                                        b[t + 24 >> 2] = s, (e = b[i + 16 >> 2]) && (b[t + 16 >> 2] = e, b[e + 24 >> 2] = t), (e = b[i + 20 >> 2]) && (b[t + 20 >> 2] = e, b[e + 24 >> 2] = t)
                                    }n: if (n >>> 0 <= 15) e = n + o | 0, b[i + 4 >> 2] = 3 | e, b[(e = e + i | 0) + 4 >> 2] = 1 | b[e + 4 >> 2];
                                        else if (b[i + 4 >> 2] = 3 | o, b[(r = i + o | 0) + 4 >> 2] = 1 | n, (b[n + r >> 2] = n) >>> 0 <= 255) e = 1052784 + ((t = n >>> 3 | 0) << 3) | 0,
                                    t = (n = b[263186]) & (t = 1 << t) ? b[e + 8 >> 2] : (b[263186] = t | n, e),
                                    b[e + 8 >> 2] = r,
                                    b[t + 12 >> 2] = r,
                                    b[r + 12 >> 2] = e,
                                    b[r + 8 >> 2] = t;
                                    else {
                                        (o = n >>> 8 | (e = 0)) && (e = 31, 16777215 < n >>> 0 || (e = 28 + ((e = ((s = (o <<= a = o + 1048320 >>> 16 & 8) << (e = o + 520192 >>> 16 & 4)) << (o = s + 245760 >>> 16 & 2) >>> 15 | 0) - (o | e | a) | 0) << 1 | n >>> e + 21 & 1) | 0)), b[(t = r) + 28 >> 2] = e, b[r + 16 >> 2] = 0, t = 1053048 + (e << 2) | (b[r + 20 >> 2] = 0);
                                        r: {
                                            if ((o = 1 << e) & l) {
                                                for (e = n << (31 == (0 | e) ? 0 : 25 - (e >>> 1 | 0) | 0), o = b[t >> 2];;) {
                                                    if ((-8 & b[(t = o) + 4 >> 2]) == (0 | n)) break r;
                                                    if (o = e >>> 29 | 0, e <<= 1, !(o = b[(a = (4 & o) + t | 0) + 16 >> 2])) break
                                                }
                                                b[a + 16 >> 2] = r
                                            } else b[263187] = o | l,
                                            b[t >> 2] = r;b[r + 24 >> 2] = t,
                                            b[r + 12 >> 2] = r,
                                            b[r + 8 >> 2] = r;
                                            break n
                                        }
                                        e = b[t + 8 >> 2], b[e + 12 >> 2] = r, b[t + 8 >> 2] = r, b[r + 24 >> 2] = 0, b[r + 12 >> 2] = t, b[r + 8 >> 2] = e
                                    }
                                    e = i + 8 | 0;
                                    break e
                                }
                                t: if (c) {
                                    e = b[t + 28 >> 2];
                                    n: {
                                        if (b[(n = 1053048 + (e << 2) | 0) >> 2] == (0 | t)) {
                                            if (b[n >> 2] = i) break n;
                                            b[263187] = m(e) & u;
                                            break t
                                        }
                                        if (!(b[c + (b[c + 16 >> 2] == (0 | t) ? 16 : 20) >> 2] = i)) break t
                                    }
                                    b[i + 24 >> 2] = c, (e = b[t + 16 >> 2]) && (b[i + 16 >> 2] = e, b[e + 24 >> 2] = i), (e = b[t + 20 >> 2]) && (b[i + 20 >> 2] = e, b[e + 24 >> 2] = i)
                                }r >>> 0 <= 15 ? (e = r + o | 0, b[t + 4 >> 2] = 3 | e, b[(e = e + t | 0) + 4 >> 2] = 1 | b[e + 4 >> 2]) : (b[t + 4 >> 2] = 3 | o, b[(o = t + o | 0) + 4 >> 2] = 1 | r, b[r + o >> 2] = r, l && (e = 1052784 + ((n = l >>> 3 | 0) << 3) | 0, i = b[263191], n = (n = 1 << n) & a ? b[e + 8 >> 2] : (b[263186] = n | a, e), b[e + 8 >> 2] = i, b[n + 12 >> 2] = i, b[i + 12 >> 2] = e, b[i + 8 >> 2] = n), b[263191] = o, b[263188] = r),
                                e = t + 8 | 0
                            }
                            return h = 16 + d | 0, e
                        }

                        function p(e) {
                            var t, n, r, i, a = 0,
                                o = 0,
                                s = 0,
                                l = 0,
                                c = 0,
                                u = 0,
                                d = 0,
                                h = 0,
                                f = 0,
                                p = 0,
                                m = 0,
                                v = 0,
                                o = b[e + 40 >> 2],
                                f = b[e + 32 >> 2];
                            if (!(o >>> 0 <= f >>> 0) && (a = b[e + 104 >> 2], a && (c = b[e + 84 >> 2], !(w[e + 36 >> 2] <= c >>> 0 | w[e + 48 >> 2] <= c >>> 0)))) {
                                if (u = (o = o - f | 0) >>> 0 < a >>> 0 ? o : a, b[e + 104 >> 2] = a - u, a = (-1 ^ c) + f | 0, a = f >>> 0 <= c >>> 0 ? b[e + 44 >> 2] + a | 0 : a, c = b[e + 24 >> 2], o = M[a + c | 0], b[e + 32 >> 2] = f + 1, x[c + f | 0] = o, s = u + -1 | 0)
                                    for (; a = (0 | (o = a + 1 | 0)) == b[e + 44 >> 2] ? 0 : o, u = b[e + 24 >> 2], c = M[a + u | 0], o = b[e + 32 >> 2], b[e + 32 >> 2] = o + 1, x[o + u | 0] = c, s = s + -1 | 0;);
                                f = b[e + 32 >> 2], w[e + 36 >> 2] >= f >>> 0 || (b[e + 36 >> 2] = f)
                            }
                            e: {
                                t: if (!(f >>> 0 >= w[e + 40 >> 2]))
                                    for (t = e + 1756 | 0, n = e + 2784 | 0, r = e + 84 | 0;;) {
                                        if ((c = b[e + 16 >> 2]) >>> 0 > w[e + 20 >> 2]) break t;
                                        if (u = p = (((m = b[e + 100 >> 2]) << 5) + e | 0) + ((d = b[e + 116 >> 2] & f) << 1) | 0, 16777216 <= (l = b[e >> 2]) >>> 0 ? s = b[e + 4 >> 2] : (l <<= 8, b[e >> 2] = l, o = c + 1 | 0, b[e + 16 >> 2] = o, s = M[b[e + 12 >> 2] + c | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = s, c = o), o = _[u + 120 >> 1], s >>> 0 < (a = y(o, l >>> 11 | 0)) >>> 0) {
                                            b[e >> 2] = a, g[u + 120 >> 1] = o + (2048 - o >>> 5 | 0), l = f + -1 | 0, l = f ? l : b[e + 44 >> 2] + l | 0, d = b[e + 108 >> 2], o = (b[e + 112 >> 2] & f) << d, p = 0, (u = b[e + 36 >> 2]) && (p = M[b[e + 24 >> 2] + l | 0]), v = o + (p >>> 8 - d | 0) | 0, l = 1;
                                            n: {
                                                if (m >>> 0 <= 6)
                                                    for (;;)
                                                        if (u = 3812 + ((l <<= 1) + (y(v, 1536) + e | 0) | 0) | 0, 16777215 < a >>> 0 ? o = a : (o = a << 8, b[e >> 2] = o, a = c + 1 | 0, b[e + 16 >> 2] = a, s = M[b[e + 12 >> 2] + c | 0] | s << 8, b[e + 4 >> 2] = s, c = a), d = _[u >> 1], (a = y(d, o >>> 11 | 0)) >>> 0 <= s >>> 0 ? (s = s - a | 0, b[e + 4 >> 2] = s, a = o - a | 0, b[e >> 2] = a, g[u >> 1] = d - (d >>> 5 | 0), l |= 1) : (b[e >> 2] = a, g[u >> 1] = d + (2048 - d >>> 5 | 0)), !(l >>> 0 < 256)) break n;
                                                for (l = (-1 ^ (o = b[e + 84 >> 2])) + f | 0, l = f >>> 0 <= o >>> 0 ? b[e + 44 >> 2] + l | 0 : l, u = u ? M[b[e + 24 >> 2] + l | 0] : 0, l = 1, h = 256; m = h & (u <<= 1), d = 3812 + ((y(v, 1536) + e | 0) + ((m + h | 0) + l << 1) | 0) | 0, 16777215 < a >>> 0 ? p = a : (p = a << 8, b[e >> 2] = p, o = c + 1 | 0, b[e + 16 >> 2] = o, s = M[b[e + 12 >> 2] + c | 0] | s << 8, b[e + 4 >> 2] = s, c = o), d = _[(i = o = d) >> 1], o = (a = y(d, p >>> 11 | 0)) >>> 0 <= s >>> 0 ? (s = s - a | 0, b[e + 4 >> 2] = s, a = p - a | 0, b[e >> 2] = a, p = 1, d - (d >>> 5 | (h = 0)) | 0) : (b[e >> 2] = a, d + (2048 - d >>> 5 | (p = 0)) | 0), g[i >> 1] = o, h ^= m, (l = l << 1 | p) >>> 0 < 256;);
                                            }(b[e + 32 >> 2] = f + 1, x[b[e + 24 >> 2] + f | 0] = l, f = b[e + 32 >> 2], w[e + 36 >> 2] < f >>> 0 && (b[e + 36 >> 2] = f), (o = b[e + 100 >> 2]) >>> 0 <= 3) ? b[e + 100 >> 2] = 0 : b[e + 100 >> 2] = o >>> 0 <= 9 ? o + -3 : o + -6
                                        } else {
                                            s = s - a | 0, b[e + 4 >> 2] = s, a = l - a | 0, b[e >> 2] = a, g[u + 120 >> 1] = o - (o >>> 5 | 0), u = v = (m << 1) + e | 0, 16777215 < a >>> 0 ? o = c : (a <<= 8, b[e >> 2] = a, o = c + 1 | 0, b[e + 16 >> 2] = o, s = M[b[e + 12 >> 2] + c | 0] | s << 8, b[e + 4 >> 2] = s), m = _[u + 504 >> 1];
                                            n: if ((c = y(m, a >>> 11 | 0)) >>> 0 <= s >>> 0) {
                                                s = s - c | 0, b[e + 4 >> 2] = s, a = a - c | 0, b[e >> 2] = a, g[u + 504 >> 1] = m - (m >>> 5 | 0), 16777215 < a >>> 0 ? u = o : (a <<= 8, b[e >> 2] = a, u = o + 1 | 0, b[e + 16 >> 2] = u, s = M[b[e + 12 >> 2] + o | 0] | s << 8, b[e + 4 >> 2] = s), o = _[v + 528 >> 1];
                                                r: {
                                                    if (s >>> 0 < (l = y(o, a >>> 11 | 0)) >>> 0) {
                                                        if (b[e >> 2] = l, g[v + 528 >> 1] = o + (2048 - o >>> 5 | 0), l >>> 0 <= 16777215 && (l <<= 8, b[e >> 2] = l, b[e + 16 >> 2] = u + 1, s = M[b[e + 12 >> 2] + u | 0] | s << 8, b[e + 4 >> 2] = s), a = _[p + 600 >> 1], (o = y(a, l >>> 11 | 0)) >>> 0 <= s >>> 0) {
                                                            b[e + 4 >> 2] = s - o, b[e >> 2] = l - o, g[p + 600 >> 1] = a - (a >>> 5 | 0);
                                                            break r
                                                        }
                                                        b[e >> 2] = o, g[p + 600 >> 1] = a + (2048 - a >>> 5 | 0), b[e + 104 >> 2] = 1, b[e + 100 >> 2] = w[e + 100 >> 2] < 7 ? 9 : 11;
                                                        break n
                                                    }
                                                    s = s - l | 0,
                                                    b[e + 4 >> 2] = s,
                                                    a = a - l | 0,
                                                    b[e >> 2] = a,
                                                    g[v + 528 >> 1] = o - (o >>> 5 | 0),
                                                    16777215 < a >>> 0 ? o = u : (a <<= 8, b[e >> 2] = a, o = u + 1 | 0, b[e + 16 >> 2] = o, s = M[b[e + 12 >> 2] + u | 0] | s << 8, b[e + 4 >> 2] = s),
                                                    u = _[v + 552 >> 1],
                                                    s >>> 0 < (c = y(u, a >>> 11 | 0)) >>> 0 ? (b[e >> 2] = c, g[v + 552 >> 1] = u + (2048 - u >>> 5 | 0), a = b[e + 88 >> 2]) : (s = s - c | 0, b[e + 4 >> 2] = s, a = a - c | 0, b[e >> 2] = a, g[v + 552 >> 1] = u - (u >>> 5 | 0), a >>> 0 <= 16777215 && (a <<= 8, b[e >> 2] = a, b[e + 16 >> 2] = o + 1, s = M[b[e + 12 >> 2] + o | 0] | s << 8, b[e + 4 >> 2] = s), c = _[v + 576 >> 1], s >>> 0 < (o = y(c, a >>> 11 | 0)) >>> 0 ? (b[e >> 2] = o, g[v + 576 >> 1] = c + (2048 - c >>> 5 | 0), a = b[e + 92 >> 2]) : (b[e + 4 >> 2] = s - o, b[e >> 2] = a - o, g[v + 576 >> 1] = c - (c >>> 5 | 0), a = b[e + 96 >> 2], b[e + 96 >> 2] = b[e + 92 >> 2]), b[e + 92 >> 2] = b[e + 88 >> 2]),
                                                    b[e + 88 >> 2] = b[e + 84 >> 2],
                                                    b[e + 84 >> 2] = a
                                                }
                                                b[e + 100 >> 2] = w[e + 100 >> 2] < 7 ? 8 : 11, R(e, n, d)
                                            } else {
                                                for (b[e >> 2] = c, g[u + 504 >> 1] = m + (2048 - m >>> 5 | 0), b[e + 96 >> 2] = b[e + 92 >> 2], o = b[e + 88 >> 2], b[e + 88 >> 2] = b[e + 84 >> 2], b[e + 92 >> 2] = o, b[e + 100 >> 2] = w[e + 100 >> 2] < 7 ? 7 : 10, R(e, t, d), c = (o = b[e + 104 >> 2]) >>> 0 < 6 ? o + -2 | 0 : 3, a = b[e >> 2], s = 1; u = (s <<= 1) + ((c << 7) + e | 0) | 0, 16777216 <= a >>> 0 ? l = b[e + 4 >> 2] : (a <<= 8, b[e >> 2] = a, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = l), d = _[u + 984 >> 1], (o = y(d, a >>> 11 | 0)) >>> 0 <= l >>> 0 ? (l = l - o | 0, b[e + 4 >> 2] = l, a = a - o | 0, b[e >> 2] = a, g[u + 984 >> 1] = d - (d >>> 5 | 0), s |= 1) : (b[e >> 2] = o, g[u + 984 >> 1] = d + (2048 - d >>> 5 | 0), a = o), s >>> 0 < 64;);
                                                if ((c = s + -64 | 0) >>> 0 <= 3) b[e + 84 >> 2] = c;
                                                else if (h = 1 & c | 2, b[e + 84 >> 2] = h, o = c >>> 1 | 0, c >>> 0 <= 13)
                                                    for (p = h << (u = o + -1 | 0), c = 1538 + ((((b[e + 84 >> 2] = p) << (h = 1)) + r | 0) + (0 - s << 1) | 0) | 0, s = 0; d = c + (h <<= 1) | 0, 16777215 < a >>> 0 ? o = a : (o = a << 8, b[e >> 2] = o, a = b[e + 16 >> 2], b[e + 16 >> 2] = a + 1, l = M[a + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), m = _[d >> 1], l >>> 0 < (a = y(m, o >>> 11 | 0)) >>> 0 ? (b[e >> 2] = a, g[d >> 1] = m + (2048 - m >>> 5 | 0)) : (l = l - a | 0, b[e + 4 >> 2] = l, a = o - a | 0, b[e >> 2] = a, g[d >> 1] = m - (m >>> 5 | 0), p = (1 << s) + p | 0, b[e + 84 >> 2] = p, h |= 1), (s = s + 1 | 0) >>> 0 < u >>> 0;);
                                                else {
                                                    for (c = o + -5 | 0; 16777215 < a >>> 0 ? s = a : (s = a << 8, b[e >> 2] = s, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), a = s >>> 1 | 0, h = (o = (u = l - (b[e >> 2] = a) | 0) >> 31) + (h << 1 | 1) | 0, b[e + 84 >> 2] = h, l = u + (a & o) | 0, b[e + 4 >> 2] = l, c = c + -1 | 0;);
                                                    h <<= 4, b[e + 84 >> 2] = h, s >>> 0 <= 33554431 && (a <<= 8, b[e >> 2] = a, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), c = _[(o = e) + 1726 >> 1], u = 1724 + (o + (c = (a = l >>> 0 < (s = y(c, a >>> 11 | 0)) >>> 0 ? (b[e >> 2] = s, g[e + 1726 >> 1] = c + (2048 - c >>> 5 | 0), 2) : (l = l - s | 0, b[e + 4 >> 2] = l, s = a - s | 0, b[e >> 2] = s, h |= 1, b[e + 84 >> 2] = h, g[e + 1726 >> 1] = c - (c >>> 5 | 0), 3)) << 1) | 0) | 0, s >>> 0 <= 16777215 && (s <<= 8, b[e >> 2] = s, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), o = _[u >> 1], (a = y(o, s >>> 11 | 0)) >>> 0 <= l >>> 0 ? (l = l - a | 0, b[e + 4 >> 2] = l, a = s - a | 0, b[e >> 2] = a, g[u >> 1] = o - (o >>> 5 | 0), h = h + 2 | 0, b[e + 84 >> 2] = h, c |= 1) : (b[e >> 2] = a, g[u >> 1] = o + (2048 - o >>> 5 | 0)), u = 1724 + ((c <<= 1) + e | 0) | 0, a >>> 0 <= 16777215 && (a <<= 8, b[e >> 2] = a, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), o = _[u >> 1], (s = y(o, a >>> 11 | 0)) >>> 0 <= l >>> 0 ? (l = l - s | 0, b[e + 4 >> 2] = l, s = a - s | 0, b[e >> 2] = s, g[u >> 1] = o - (o >>> 5 | 0), h = h + 4 | 0, b[e + 84 >> 2] = h, c |= 1) : (b[e >> 2] = s, g[u >> 1] = o + (2048 - o >>> 5 | 0)), s >>> 0 <= 16777215 && (s <<= 8, b[e >> 2] = s, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, l = M[o + b[e + 12 >> 2] | 0] | l << 8, b[e + 4 >> 2] = l), c = _[(o = 1724 + ((c << 1) + e | 0) | 0) >> 1], (a = y(c, s >>> 11 | 0)) >>> 0 <= l >>> 0 ? (b[e + 4 >> 2] = l - a, b[e >> 2] = s - a, g[o >> 1] = c - (c >>> 5 | 0), b[e + 84 >> 2] = h + 8) : (b[e >> 2] = a, g[o >> 1] = c + (2048 - c >>> 5 | 0))
                                                }
                                            }
                                            if (a = 0, c = b[e + 84 >> 2], w[e + 36 >> 2] <= c >>> 0 | w[e + 48 >> 2] <= c >>> 0) break e;
                                            if (d = b[e + 32 >> 2], u = (o = b[e + 40 >> 2] - d | 0) >>> 0 < (a = b[e + 104 >> 2]) >>> 0 ? o : a, b[e + 104 >> 2] = a - u, a = d + (-1 ^ c) | 0, a = d >>> 0 <= c >>> 0 ? b[e + 44 >> 2] + a | 0 : a, c = b[e + 24 >> 2], o = M[a + c | 0], b[e + 32 >> 2] = d + 1, x[c + d | 0] = o, l = u + -1 | 0)
                                                for (; a = (0 | (o = a + 1 | 0)) == b[e + 44 >> 2] ? 0 : o, u = b[e + 24 >> 2], c = M[a + u | 0], o = b[e + 32 >> 2], b[e + 32 >> 2] = o + 1, x[o + u | 0] = c, l = l + -1 | 0;);
                                            f = b[e + 32 >> 2], w[e + 36 >> 2] >= f >>> 0 || (b[e + 36 >> 2] = f)
                                        }
                                        if (!(f >>> 0 < w[e + 40 >> 2])) break
                                    }
                                a = 1,
                                16777215 < (o = b[e >> 2]) >>> 0 || (b[e >> 2] = o << 8, o = b[e + 16 >> 2], b[e + 16 >> 2] = o + 1, b[e + 4 >> 2] = M[o + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8)
                            }
                            return a
                        }

                        function P(e, t, n) {
                            var r = 0,
                                i = 0,
                                a = 0;
                            e: if (n) {
                                for (;
                                    (0 | (r = M[0 | e])) == (0 | (i = M[0 | t]));)
                                    if (t = t + 1 | 0, e = e + 1 | 0, !(n = n + -1 | 0)) break e;
                                a = r - i | 0
                            }
                            return a
                        }

                        function R(e, t, n) {
                            var r, i = 0,
                                a = 0,
                                o = 0,
                                s = 0,
                                l = 0,
                                c = 0;
                            for (16777216 <= (s = b[e >> 2]) >>> 0 ? o = b[e + 4 >> 2] : (s <<= 8, b[e >> 2] = s, a = b[e + 16 >> 2], b[e + 16 >> 2] = a + 1, o = M[a + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = o), a = _[t >> 1], a = o >>> 0 < (i = y(a, s >>> 11 | 0)) >>> 0 ? (b[e >> 2] = i, g[t >> 1] = a + (2048 - a >>> 5 | 0), c = 4 + ((n << 4) + t | 0) | 0, l = 2, 8) : (o = o - i | 0, b[e + 4 >> 2] = o, s = s - i | 0, b[e >> 2] = s, g[t >> 1] = a - (a >>> 5 | 0), s >>> 0 <= 16777215 && (s <<= 8, b[e >> 2] = s, a = b[e + 16 >> 2], b[e + 16 >> 2] = a + 1, o = M[a + b[e + 12 >> 2] | 0] | o << 8, b[e + 4 >> 2] = o), a = _[t + 2 >> 1], o >>> 0 < (i = y(a, s >>> 11 | 0)) >>> 0 ? (b[e >> 2] = i, g[t + 2 >> 1] = a + (2048 - a >>> 5 | 0), c = 260 + ((n << 4) + t | 0) | 0, l = 10, 8) : (o = o - i | 0, b[e + 4 >> 2] = o, i = s - i | 0, b[e >> 2] = i, g[t + 2 >> 1] = a - (a >>> 5 | 0), c = t + 516 | 0, l = 18, 256)), b[e + 104 >> 2] = l, t = 1; s = c + (t <<= 1) | 0, 16777215 < i >>> 0 ? n = i : (n = i << 8, b[e >> 2] = n, i = b[e + 16 >> 2], b[e + 16 >> 2] = i + 1, o = M[i + b[e + 12 >> 2] | 0] | o << 8, b[e + 4 >> 2] = o), r = _[s >> 1], (i = y(r, n >>> 11 | 0)) >>> 0 <= o >>> 0 ? (o = o - i | 0, b[e + 4 >> 2] = o, i = n - i | 0, b[e >> 2] = i, g[s >> 1] = r - (r >>> 5 | 0), t |= 1) : (b[e >> 2] = i, g[s >> 1] = (2048 - r >>> 5 | 0) + r), t >>> 0 < a >>> 0;);
                            b[e + 104 >> 2] = (t - a | 0) + l
                        }

                        function D(e) {
                            for (var t, n, r, i = 0, a = 0, o = 0, s = 0, l = 0, c = 0, u = e + 28392 | 0, d = e + 28388 | 0;;) {
                                i = b[e + 64 >> 2];
                                e: {
                                    t: {
                                        n: {
                                            r: {
                                                i: {
                                                    a: {
                                                        o: {
                                                            s: {
                                                                l: {
                                                                    c: {
                                                                        u: {
                                                                            d: {
                                                                                h: {
                                                                                    f: {
                                                                                        p: {
                                                                                            if (a = b[132105], (o = b[132106]) >>> 0 <= a >>> 0) {
                                                                                                if (7 == (0 | i)) break p;
                                                                                                return 0
                                                                                            }
                                                                                            if (8 < i >>> 0) continue;
                                                                                            switch (i - 1 | 0) {
                                                                                                case 4:
                                                                                                    break l;
                                                                                                case 3:
                                                                                                    break c;
                                                                                                case 2:
                                                                                                    break u;
                                                                                                case 1:
                                                                                                    break d;
                                                                                                case 0:
                                                                                                    break h;
                                                                                                case 6:
                                                                                                    break p;
                                                                                                case 7:
                                                                                                    break a;
                                                                                                case 5:
                                                                                                    break s;
                                                                                                default:
                                                                                                    break f
                                                                                            }
                                                                                        }
                                                                                        i = b[e + 76 >> 2];
                                                                                        break o
                                                                                    }
                                                                                    if (l = 1, b[132105] = a + 1, !(i = M[b[132104] + a | 0])) break i;
                                                                                    if (!(1 != (0 | i) && i >>> 0 <= 223)) {
                                                                                        g[e + 80 >> 1] = 256, b[e + 60 >> 2] || (o = b[132108], b[e + 24 >> 2] = o + b[132107], b[e + 44 >> 2] = b[132109] - o), b[e + 28 >> 2] = 0, b[e + 32 >> 2] = 0, b[e + 36 >> 2] = 0, b[e + 40 >> 2] = 0;
                                                                                        break n
                                                                                    }
                                                                                    if (!M[e + 80 | 0]) break n;
                                                                                    return 7
                                                                                }
                                                                                b[132105] = a + 1,
                                                                                i = M[b[132104] + a | 0],
                                                                                b[e + 64 >> 2] = 2,
                                                                                b[e + 72 >> 2] = b[e + 72 >> 2] + (i << 8);
                                                                                continue
                                                                            }
                                                                            b[132105] = a + 1,
                                                                            i = M[b[132104] + a | 0],
                                                                            b[e + 64 >> 2] = 3,
                                                                            b[e + 72 >> 2] = 1 + (i + b[e + 72 >> 2] | 0);
                                                                            continue
                                                                        }
                                                                        b[132105] = a + 1,
                                                                        i = M[b[132104] + a | 0],
                                                                        b[e + 64 >> 2] = 4,
                                                                        b[e + 76 >> 2] = i << 8;
                                                                        continue
                                                                    }
                                                                    b[132105] = a + 1,
                                                                    i = M[b[132104] + a | 0],
                                                                    b[e + 64 >> 2] = b[e + 68 >> 2],
                                                                    b[e + 76 >> 2] = 1 + (i + b[e + 76 >> 2] | 0);
                                                                    continue
                                                                }
                                                                if (b[132105] = a + 1, l = 7, 224 < (i = M[b[132104] + a | 0]) >>> 0) break i;
                                                                if (o = e, s = i >>> (a = 0) < 45 ? 0 : (i = (i = i + -45 | 0) - y(s = ((255 & i) >>> 0) / 45 | 0, 45) | 0, s + 1 | 0), b[o + 116 >> 2] = -1 << s ^ -1, 9 <= (255 & i) >>> 0 && (a = (o = ((255 & (i = i + -9 | 0)) >>> 0) / 9 | 0) + 1 | 0, i = i - y(o, 9) | 0), b[e + 112 >> 2] = a, i &= 255, 4 < (b[e + 108 >> 2] = i) + a >>> 0) break i;
                                                                for (b[e + 112 >> 2] = -1 << a ^ -1, i = 0, b[e + 100 >> 2] = 0, b[e + 92 >> 2] = 0, b[e + 96 >> 2] = 0, b[e + 84 >> 2] = 0, b[e + 88 >> 2] = 0; g[120 + ((i << 1) + e | 0) >> 1] = 1024, 14134 != (0 | (i = i + 1 | 0)););b[e + 64 >> 2] = 6,
                                                                b[e + 8 >> 2] = 5,
                                                                b[e >> 2] = -1,
                                                                b[e + 4 >> 2] = 0
                                                            }
                                                            if ((l = b[e + 76 >> 2]) >>> 0 < 5) return 7;
                                                            if (a = b[e + 8 >> 2])
                                                                for (i = b[132105], s = b[132106];;) {
                                                                    if ((0 | i) == (0 | s)) return 0;
                                                                    if (c = b[e + 4 >> 2], o = i + 1 | 0, b[132105] = o, i = M[b[132104] + i | 0], a = a + -1 | 0, b[e + 8 >> 2] = a, b[e + 4 >> 2] = i | c << 8, i = o, !a) break
                                                                }
                                                            b[e + 64 >> 2] = 7,
                                                            i = l + -5 | 0,
                                                            b[e + 76 >> 2] = i
                                                        }
                                                        o = b[e + 32 >> 2],
                                                        a = (a = b[132109] - b[132108] | 0) >>> 0 < (l = b[e + 72 >> 2]) >>> 0 ? a : l,
                                                        l = b[e + 44 >> 2],
                                                        b[e + 40 >> 2] = a >>> 0 < l - o >>> 0 ? o + a | 0 : l,
                                                        a = (s = b[132106]) - (o = b[132105]) | 0,
                                                        l = b[e + 28388 >> 2];o: {
                                                            if (!i || l) {
                                                                if (A(4 + (l + d | 0) | 0, s = b[132104] + o | 0, i = a >>> 0 < (i = (i = i - l | 0) >>> 0 < (o = 42 - l | 0) >>> 0 ? i : o) >>> 0 ? a : i), (0 | (o = (a = b[e + 28388 >> 2]) + i | 0)) != b[e + 76 >> 2]) {
                                                                    if (o >>> 0 <= 20) {
                                                                        b[e + 28388 >> 2] = o, b[132105] = i + b[132105];
                                                                        break o
                                                                    }
                                                                    o = o + -21 | 0
                                                                } else C(4 + (i + (a + d | 0) | 0) | 0, 63 - o | 0), o = i + b[e + 28388 >> 2] | 0;
                                                                if (b[e + 16 >> 2] = 0, b[e + 12 >> 2] = u, b[e + 20 >> 2] = o, l = 7, !p(e)) break i;
                                                                if (o = b[e + 16 >> 2], (a = b[e + 28388 >> 2]) + i >>> 0 < o >>> 0) break i;
                                                                if (i = b[e + 76 >> 2] - o | 0, b[e + 76 >> 2] = i, o >>> 0 < a >>> 0) {
                                                                    i = a - o | 0,
                                                                        function(e, t, n) {
                                                                            var r = 0,
                                                                                i = 0;
                                                                            s: if ((0 | e) != (0 | t)) {
                                                                                if (!(e >>> 0 < t + n >>> 0 && t >>> 0 < (i = e + n | 0) >>> 0)) return A(e, t, n);
                                                                                if (r = 3 & (e ^ t), e >>> 0 < t >>> 0) {
                                                                                    if (!r) {
                                                                                        if (3 & e)
                                                                                            for (;;) {
                                                                                                if (!n) break s;
                                                                                                if (x[0 | e] = M[0 | t], t = t + 1 | 0, n = n + -1 | 0, !(3 & (e = e + 1 | 0))) break
                                                                                            }
                                                                                        if (!(n >>> 0 <= 3)) {
                                                                                            for (r = n; b[e >> 2] = b[t >> 2], t = t + 4 | 0, e = e + 4 | 0, 3 < (r = r + -4 | 0) >>> 0;);
                                                                                            n &= 3
                                                                                        }
                                                                                    }
                                                                                    if (n)
                                                                                        for (; x[0 | e] = M[0 | t], e = e + 1 | 0, t = t + 1 | 0, n = n + -1 | 0;);
                                                                                } else {
                                                                                    if (!r) {
                                                                                        if (3 & i)
                                                                                            for (;;) {
                                                                                                if (!n) break s;
                                                                                                if (x[0 | (r = (n = n + -1 | 0) + e | 0)] = M[t + n | 0], !(3 & r)) break
                                                                                            }
                                                                                        if (!(n >>> 0 <= 3))
                                                                                            for (; b[(n = n + -4 | 0) + e >> 2] = b[t + n >> 2], 3 < n >>> 0;);
                                                                                    }
                                                                                    if (n)
                                                                                        for (; x[(n = n + -1 | 0) + e | 0] = M[t + n | 0], n;);
                                                                                }
                                                                            }
                                                                        }(u, 4 + (o + d | 0) | 0, b[e + 28388 >> 2] = i);
                                                                    break o
                                                                }
                                                                o = b[132105] + (o - a | 0) | 0, b[132105] = o, b[e + 28388 >> 2] = 0, a = (s = b[132106]) - o | 0
                                                            }
                                                            if (21 <= a >>> 0) {
                                                                if (l = b[132104], b[e + 16 >> 2] = o, b[e + 12 >> 2] = l, b[e + 20 >> 2] = a >>> 0 < i + 21 >>> 0 ? s + -21 | 0 : i + o | 0, l = 7, !p(e)) break i;
                                                                if ((i = b[e + 76 >> 2]) >>> 0 < (a = (o = b[e + 16 >> 2]) - b[132105] | 0) >>> 0) break i;
                                                                if (i = i - a | 0, b[e + 76 >> 2] = i, b[132105] = o, 20 < (a = b[132106] - o | 0) >>> 0) break o
                                                            }
                                                            i = i >>> 0 < a >>> 0 ? i : a,
                                                            A(u, b[132104] + o | 0, i),
                                                            b[e + 28388 >> 2] = i,
                                                            b[132105] = i + b[132105]
                                                        }
                                                        if (a = (i = b[e + 32 >> 2]) - (l = b[e + 28 >> 2]) | 0, b[(o = e) + 60 >> 2] && ((0 | i) == b[e + 44 >> 2] && (b[e + 32 >> 2] = 0), A(b[132107] + b[132108] | 0, l + b[e + 24 >> 2] | 0, a), i = b[e + 32 >> 2]), b[o + 28 >> 2] = i, i = a + b[132108] | 0, b[132108] = i, o = b[e + 72 >> 2] - a | 0, !(b[e + 72 >> 2] = o)) {
                                                            if (l = 7, b[e + 4 >> 2] | (b[e + 76 >> 2] | b[e + 104 >> 2])) break i;
                                                            b[e + 64 >> 2] = 0;
                                                            break t
                                                        }
                                                        if (((l = 0) | i) == b[132109]) break i;
                                                        if (b[132105] != b[132106] | w[e + 28388 >> 2] >= w[e + 76 >> 2]) continue;
                                                        break i
                                                    }
                                                    if (!(s = b[e + 76 >> 2])) break r;
                                                    if (!(o >>> (l = 0) <= a >>> 0))
                                                        for (;;) {
                                                            if ((i = b[132109]) >>> 0 <= (c = b[132108]) >>> 0) break i;
                                                            if (r = s, t = b[e + 32 >> 2], s = s >>> 0 < (i = (n = b[e + 44 >> 2] - t | 0) >>> 0 < (i = (o = o - a | 0) >>> 0 < (i = i - c | 0) >>> 0 ? o : i) >>> 0 ? n : i) >>> 0 ? s : i, b[e + 76 >> 2] = r - s, A(b[e + 24 >> 2] + t | 0, b[132104] + a | 0, s), i = s + b[e + 32 >> 2] | 0, b[e + 32 >> 2] = i, w[e + 36 >> 2] < i >>> 0 && (b[e + 36 >> 2] = i), b[(o = e) + 60 >> 2] && ((0 | i) == b[e + 44 >> 2] && (b[e + 32 >> 2] = 0), A(b[132107] + b[132108] | 0, b[132104] + b[132105] | 0, s), i = b[e + 32 >> 2]), b[o + 28 >> 2] = i, b[132108] = s + b[132108], a = s + b[132105] | 0, b[132105] = a, !(s = b[e + 76 >> 2])) break r;
                                                            if (!(a >>> 0 < (o = b[132106]) >>> 0)) break
                                                        }
                                                }
                                                return l
                                            }
                                            b[e + 64 >> 2] = 0;
                                            continue
                                        }
                                        if (-1 < i << 24 >> 24) break e;
                                        if (b[e + 64 >> 2] = 1, b[e + 72 >> 2] = i << 16 & 2031616, 192 <= i >>> 0) {
                                            b[e + 68 >> 2] = 5, x[e + 81 | 0] = 0;
                                            continue
                                        }
                                        if (M[e + 81 | 0]) return 7;
                                        if (b[e + 68 >> 2] = 6, i >>> 0 < 160) continue;
                                        for (b[e + 84 >> 2] = 0, i = b[e + 88 >> 2] = 0, b[e + 100 >> 2] = 0, b[e + 92 >> 2] = 0, b[e + 96 >> 2] = 0; g[120 + ((i << 1) + e | 0) >> 1] = 1024, 14134 != (0 | (i = i + 1 | 0)););
                                    }
                                    b[e + 8 >> 2] = 5,
                                    b[e >> 2] = -1,
                                    b[e + 4 >> 2] = 0;
                                    continue
                                }
                                if (!(i >>> 0 <= 2)) break;
                                b[e + 64 >> 2] = 3, b[e + 68 >> 2] = 8
                            }
                            return 7
                        }

                        function s() {
                            var e, t = 0,
                                n = 0;
                            if (t = L(1208)) {
                                if (b[t + 36 >> 2] = 2, e = 0, n = (e = L(28456)) ? (b[e + 52 >> 2] = 8388608, b[e + 60 >> 2] = 2, b[e + 56 >> 2] = 0, b[e + 24 >> 2] = 0, e) : 0, b[t + 1200 >> 2] = n) return x[t + 40 | 0] = 0, b[t >> 2] = 0, b[t + 4 >> 2] = 0, b[t + 24 >> 2] = 0, C(t + 72 | (b[t + 28 >> 2] = 0), 100), b[t + 172 >> 2] = 12, t;
                                E(t)
                            }
                            return 0
                        }

                        function l(e) {
                            var t, n, r, i, a = 0,
                                o = 0,
                                s = 0,
                                l = 0,
                                c = 0,
                                u = 0,
                                d = 0,
                                h = 0,
                                f = 0,
                                p = 0,
                                m = 0,
                                v = 0,
                                g = 0,
                                o = b[e + 36 >> 2] ? b[e >> 2] : (x[e + 40 | 0] = 0, b[e >> 2] = 0, b[e + 4 >> 2] = 0, b[e + 24 >> 2] = 0, C(e + 72 | (b[e + 28 >> 2] = 0), 100), b[e + 172 >> 2] = 12, 0),
                                _ = b[132108],
                                y = b[132105];
                            b[e + 16 >> 2] = y, n = e + 96 | 0, v = (a = e) + 182 | 0, r = a + 176 | 0, d = a + 168 | 0;
                            e: {
                                t: {
                                    n: {
                                        r: {
                                            i: {
                                                for (;;)
                                                    if (!(9 < o >>> 0)) {
                                                        e = d;
                                                        a: {
                                                            o: {
                                                                s: {
                                                                    l: {
                                                                        c: {
                                                                            u: switch (o - 1 | 0) {
                                                                                case 1:
                                                                                    u = b[132106], o = b[132104], l = b[a + 172 >> 2], s = b[a + 168 >> 2];
                                                                                    break c;
                                                                                default:
                                                                                    if (s = b[132105], o = b[132106] - s | 0, c = b[a + 168 >> 2], o = o >>> 0 < (u = b[a + 172 >> 2] - c | 0) >>> 0 ? o : u, A(8 + (c + d | 0) | 0, s + b[132104] | 0, o), b[132105] = o + b[132105], l = 0, o = o + b[a + 168 >> 2] | 0, s = b[a + 172 >> 2], b[a + 168 >> 2] = (0 | s) == (0 | o) ? 0 : o, (0 | o) != (0 | s)) break e;
                                                                                    if (b[a >> 2] = 1, P(r, 1024, 6)) {
                                                                                        l = 5;
                                                                                        break e
                                                                                    }
                                                                                    if ((0 | T(v, 2, 0)) != (M[a + 184 | 0] | M[a + 185 | 0] << 8 | (M[a + 186 | 0] << 16 | M[a + 187 | 0] << 24))) {
                                                                                        l = 7;
                                                                                        break e
                                                                                    }
                                                                                    if (l = 6, M[0 | v]) break e;
                                                                                    if (o = M[a + 183 | 0], 15 < (b[a + 32 >> 2] = o) >>> 0) break e;
                                                                                    if (l = 2, !(1 << o & 19) | 4 < o >>> 0) break e;
                                                                                    break;
                                                                                case 4:
                                                                                    break o;
                                                                                case 3:
                                                                                    break s;
                                                                                case 2:
                                                                                    break l;
                                                                                case 0:
                                                                                    break u;
                                                                                case 8:
                                                                                    break n;
                                                                                case 7:
                                                                                    break r;
                                                                                case 6:
                                                                                    break i;
                                                                                case 5:
                                                                                    break a
                                                                            }
                                                                            if ((0 | (u = b[132106])) == (0 | (s = b[132105]))) {
                                                                                l = 0;
                                                                                break e
                                                                            }
                                                                            if (o = b[132104], !(c = M[s + o | 0])) {
                                                                                b[132105] = s + 1, b[a + 16 >> 2] = s, o = 6, b[a >> 2] = 6;
                                                                                continue
                                                                            }
                                                                            b[a + 168 >> 2] = 0,
                                                                            l = 4 + (c << (b[a >> 2] = 2)) | 0,
                                                                            b[a + 172 >> 2] = l,
                                                                            b[a + 64 >> 2] = l,
                                                                            s = 0
                                                                        }
                                                                        if (c = u, A(8 + (e + s | 0) | 0, o + (u = b[132105]) | 0, c = (c = c - u | 0) >>> 0 < (l = l - s | 0) >>> 0 ? c : l), b[132105] = c + b[132105], l = 0, e = c + b[a + 168 >> 2] | 0, o = b[a + 172 >> 2], b[a + 168 >> 2] = (0 | o) == (0 | e) ? 0 : e, (0 | e) != (0 | o)) break e;
                                                                        if (e = e + -4 | 0, o = T(r, b[a + 172 >> 2] = e, 0), f = b[a + 172 >> 2], (0 | o) != (M[(e = f + a | 0) + 176 | 0] | M[e + 177 | 0] << 8 | (M[e + 178 | 0] << 16 | M[e + 179 | 0] << 24))) {
                                                                            l = 7;
                                                                            break e
                                                                        }
                                                                        if (b[a + 168 >> 2] = 2, 63 & (t = x[a + 177 | 0])) {
                                                                            l = 6;
                                                                            break e
                                                                        }
                                                                        if (o = 2, c = s = g = h = -1, 64 & t) {
                                                                            for ((u = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0);;) {
                                                                                if (f >>> 0 <= o >>> 0) {
                                                                                    l = 7;
                                                                                    break e
                                                                                }
                                                                                p = M[8 + (o + d | 0) | 0], o = o + 1 | 0, b[a + 168 >> 2] = o, i = b[(e = a) + 12 >> 2], m = 127 & p, l = 31 & (s = u), s = 32 <= (63 & s) >>> 0 ? (c = m << l, 0) : (c = (1 << l) - 1 & m >>> 32 - l, m << l), s |= b[a + 8 >> 2], c = l = c | i, b[e + 8 >> 2] = s, b[e + 12 >> 2] = c;
                                                                                c: {
                                                                                    if (!(128 & p)) {
                                                                                        if (p | !u) break c;
                                                                                        l = 7;
                                                                                        break e
                                                                                    }
                                                                                    if (u = u + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = u))) continue;
                                                                                    break e
                                                                                }
                                                                                break
                                                                            }
                                                                            b[a + 4 >> 2] = 0
                                                                        }
                                                                        if (b[a + 48 >> 2] = s, b[a + 52 >> 2] = c, (0 | t) <= -1) {
                                                                            for ((u = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0);;) {
                                                                                if (f >>> 0 <= o >>> 0) {
                                                                                    l = 7;
                                                                                    break e
                                                                                }
                                                                                p = M[8 + (o + d | 0) | 0], o = o + 1 | 0, b[a + 168 >> 2] = o, m = b[(e = a) + 12 >> 2], h = 127 & p, l = 31 & (s = u), h = (s = 32 <= (63 & s) >>> 0 ? (c = h << l, 0) : (c = (1 << l) - 1 & h >>> 32 - l, h << l)) | b[a + 8 >> 2], g = s = c | m, b[e + 8 >> 2] = h, b[e + 12 >> 2] = s;
                                                                                c: {
                                                                                    if (!(128 & p)) {
                                                                                        if (p | !u) break c;
                                                                                        l = 7;
                                                                                        break e
                                                                                    }
                                                                                    if (u = u + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = u))) continue;
                                                                                    break e
                                                                                }
                                                                                break
                                                                            }
                                                                            b[a + 4 >> 2] = 0
                                                                        }
                                                                        if (b[a + 56 >> 2] = h, b[a + 60 >> 2] = g, f - o >>> 0 < 2) {
                                                                            l = 7;
                                                                            break e
                                                                        }
                                                                        if (s = o + 1 | 0, b[a + 168 >> 2] = s, 33 != M[8 + (o + d | 0) | 0]) {
                                                                            l = 6;
                                                                            break e
                                                                        }
                                                                        if (e = o + 2 | 0, b[a + 168 >> 2] = e, 1 != M[8 + (s + d | 0) | 0]) {
                                                                            l = 6;
                                                                            break e
                                                                        }
                                                                        if (l = 7, (0 | e) == (0 | f)) break e;
                                                                        if (b[a + 168 >> 2] = o + 3, l = function(e, t) {
                                                                                var n = 0,
                                                                                    r = 0;
                                                                                n = 6;
                                                                                c: if (!(39 < t >>> 0)) {
                                                                                    if (t = (1 & t | 2) << 11 + (t >>> 1 | 0), b[e + 48 >> 2] = t, r = b[e + 60 >> 2]) {
                                                                                        if (n = 4, t >>> 0 > w[e + 52 >> 2]) break c;
                                                                                        if (b[e + 44 >> 2] = t, !(2 != (0 | r) | w[e + 56 >> 2] >= t >>> 0 || (E(b[e + 24 >> 2]), t = L(b[e + 48 >> 2]), b[e + 24 >> 2] = t))) return b[e + 56 >> 2] = 0, 3
                                                                                    }
                                                                                    b[e + 28388 >> 2] = 0, b[e + 64 >> 2] = 0, x[e + 80 | 0] = 1, b[e + 104 >> 2] = 0, n = 0
                                                                                }
                                                                                return n
                                                                            }(b[a + 1200 >> 2], M[8 + (e + d | 0) | 0])) break e;o = b[a + 168 >> 2],
                                                                        s = b[a + 172 >> 2];c: {
                                                                            for (;;) {
                                                                                if (s >>> 0 <= o >>> 0) break c;
                                                                                if (e = o + 1 | 0, c = o + d | 0, o = b[a + 168 >> 2] = e, M[c + 8 | 0]) break
                                                                            }
                                                                            l = 6;
                                                                            break e
                                                                        }
                                                                        b[a + 168 >> 2] = 0,
                                                                        b[a + 80 >> 2] = 0,
                                                                        b[a + 84 >> 2] = 0,
                                                                        b[a + 72 >> 2] = 0,
                                                                        b[a + 76 >> 2] = 0,
                                                                        b[a >> 2] = 3
                                                                    }
                                                                    if (b[a + 16 >> 2] = b[132105], b[a + 20 >> 2] = b[132108], l = D(b[a + 1200 >> 2]), e = b[(o = a) + 76 >> 2], (c = (s = b[132105] - b[a + 16 >> 2] | 0) + b[a + 72 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0), u = c, s = e, b[o + 72 >> 2] = c, b[o + 76 >> 2] = e, e = b[a + 84 >> 2], f = b[a + 20 >> 2], (p = (c = h = b[132108] - f | 0) + b[a + 80 >> 2] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0), c = e, b[o + 80 >> 2] = p, b[o + 84 >> 2] = e, (0 | (e = b[a + 52 >> 2])) == (0 | s) & u >>> 0 > w[a + 48 >> 2] | e >>> 0 < s >>> 0) {
                                                                        l = 7;
                                                                        break e
                                                                    }
                                                                    if ((0 | (e = b[a + 60 >> 2])) == (0 | c) & p >>> 0 > w[a + 56 >> 2] | e >>> 0 < c >>> 0) {
                                                                        l = 7;
                                                                        break e
                                                                    }
                                                                    l: if (!(3 < (o = b[a + 32 >> 2] + -1 | 0) >>> 0)) {
                                                                        e = a;
                                                                        c: {
                                                                            u: switch (o - 1 | 0) {
                                                                                default:
                                                                                    o = T(f + b[132107] | 0, h, b[a + 24 >> 2]), s = 0;
                                                                                    break c;
                                                                                case 0:
                                                                                case 1:
                                                                                    break l;
                                                                                case 2:
                                                                                    break u
                                                                            }
                                                                            o = function(e, t, n, r) {
                                                                                var i = 0;
                                                                                if (n ^= -1, r ^= -1, t)
                                                                                    for (; i = 2080 + ((M[0 | e] ^ 255 & n) << 3) | 0, n = b[i >> 2] ^ ((255 & r) << 24 | n >>> 8), r = b[4 + i >> 2] ^ r >>> 8, e = e + 1 | 0, t = t + -1 | 0;);
                                                                                return S = -1 ^ r, -1 ^ n
                                                                            }(f + b[132107] | 0, h, b[a + 24 >> 2], b[a + 28 >> 2]),
                                                                            s = S
                                                                        }
                                                                        b[e + 24 >> 2] = o, b[e + 28 >> 2] = s
                                                                    }if (1 != (0 | l)) break e;
                                                                    if (o = e = b[a + 52 >> 2], !(-1 == (0 | (s = b[a + 48 >> 2])) & -1 == (0 | o) | b[a + 72 >> 2] == (0 | s) & b[a + 76 >> 2] == (0 | o))) {
                                                                        l = 7;
                                                                        break e
                                                                    }
                                                                    if (e = b[a + 80 >> 2], o = b[a + 84 >> 2], c = u = b[a + 60 >> 2], -1 == (0 | (s = b[a + 56 >> 2])) & -1 == (0 | c)) s = e,
                                                                    c = o;
                                                                    else if (l = 7, (0 | e) != (0 | s) | (0 | o) != (0 | c)) break e;c = c + b[a + 108 >> 2] | 0,
                                                                    (o = s + b[a + 104 >> 2] | 0) >>> 0 < s >>> 0 && (c = c + 1 | 0),
                                                                    b[a + 104 >> 2] = o,
                                                                    b[a + 108 >> 2] = c,
                                                                    c = b[a + 100 >> 2],
                                                                    e = b[a + 76 >> 2],
                                                                    (u = (s = b[a + 64 >> 2]) + b[a + 72 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0),
                                                                    e = e + c | 0,
                                                                    e = (s = u + b[a + 96 >> 2] | 0) >>> 0 < u >>> 0 ? e + 1 | 0 : e,
                                                                    (s = (c = s) + M[b[a + 32 >> 2] + 1040 | 0] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0),
                                                                    b[a + 96 >> 2] = s,
                                                                    b[a + 100 >> 2] = e,
                                                                    b[a + 112 >> 2] = T(n, 24, b[a + 112 >> 2]),
                                                                    b[a >> 2] = 4,
                                                                    o = b[a + 92 >> 2],
                                                                    (s = b[a + 88 >> 2] + 1 | 0) >>> 0 < 1 && (o = o + 1 | 0),
                                                                    b[a + 88 >> 2] = s,
                                                                    b[a + 92 >> 2] = o
                                                                }
                                                                if (c = b[a + 76 >> 2], 3 & (s = b[a + 72 >> 2]))
                                                                    for (o = b[132105], u = b[132106];;) {
                                                                        if ((0 | o) == (0 | u)) {
                                                                            l = 0;
                                                                            break e
                                                                        }
                                                                        if (e = o + 1 | 0, b[132105] = e, M[b[132104] + o | 0]) {
                                                                            l = 7;
                                                                            break e
                                                                        }
                                                                        if ((s = s + 1 | 0) >>> 0 < 1 && (c = c + 1 | 0), b[a + 72 >> 2] = s, b[a + 76 >> 2] = c, o = e, !(3 & s)) break
                                                                    }
                                                                b[a >> 2] = 5
                                                            }
                                                            o: {
                                                                s: if (!(3 < (o = (e = b[a + 32 >> 2]) + -1 | 0) >>> 0)) {
                                                                    l: switch (o - 1 | 0) {
                                                                        default:
                                                                            for (o = b[132105], l = b[132106];;) {
                                                                                if ((0 | o) == (0 | l)) {
                                                                                    l = 0;
                                                                                    break e
                                                                                }
                                                                                if (u = b[a + 24 >> 2], s = b[a + 28 >> 2], e = b[a + 4 >> 2], c = o + 1 | 0, b[132105] = c, h = M[b[132104] + o | 0], f = u, o = s, u = 31 & e, (0 | h) != (255 & (32 <= (63 & e) >>> 0 ? o >>> u | 0 : ((1 << u) - 1 & o) << 32 - u | f >>> u))) {
                                                                                    l = 7;
                                                                                    break e
                                                                                }
                                                                                if (e = e + 8 | 0, o = c, !((b[a + 4 >> 2] = e) >>> 0 < 32)) break
                                                                            }
                                                                            b[a + 24 >> 2] = 0, b[a + 28 >> 2] = 0;
                                                                            break o;
                                                                        case 0:
                                                                        case 1:
                                                                            break s;
                                                                        case 2:
                                                                            break l
                                                                    }
                                                                    for (o = b[132105], l = b[132106];;) {
                                                                        if ((0 | o) == (0 | l)) {
                                                                            l = 0;
                                                                            break e
                                                                        }
                                                                        if (u = b[a + 24 >> 2], s = b[a + 28 >> 2], e = b[a + 4 >> 2], c = o + 1 | 0, b[132105] = c, h = M[b[132104] + o | 0], f = u, o = s, u = 31 & e, (0 | h) != (255 & (32 <= (63 & e) >>> 0 ? o >>> u | 0 : ((1 << u) - 1 & o) << 32 - u | f >>> u))) {
                                                                            l = 7;
                                                                            break e
                                                                        }
                                                                        if (e = e + 8 | 0, o = c, !((b[a + 4 >> 2] = e) >>> 0 < 64)) break
                                                                    }
                                                                    b[a + 24 >> 2] = 0,
                                                                    b[a + 28 >> 2] = 0;
                                                                    break o
                                                                }if (o = b[a + 4 >> 2], !((e = M[e + 1040 | 0]) >>> 0 <= o >>> 0))
                                                                    for (l = b[132105], s = b[132106];;) {
                                                                        if ((0 | l) == (0 | s)) {
                                                                            l = 0;
                                                                            break e
                                                                        }
                                                                        if (l = l + 1 | 0, b[132105] = l, o = o + 1 | 0, (0 | e) == (0 | (b[a + 4 >> 2] = o))) break
                                                                    }
                                                            }
                                                            b[a + 4 >> 2] = 0,
                                                            o = 1,
                                                            b[a >> 2] = 1;
                                                            continue
                                                        }
                                                        break
                                                    } for (p = a + 144 | 0;;) {
                                                    m = b[132106], h = b[132104], (e = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0), o = b[132105];
                                                    a: {
                                                        for (;;) {
                                                            if (m >>> 0 <= o >>> 0) l = 0;
                                                            else if (d = M[o + h | 0], o = o + 1 | 0, b[132105] = o, v = b[(u = a) + 12 >> 2], f = 127 & d, l = 31 & e, s = 32 <= (63 & e) >>> 0 ? (c = f << l, 0) : (c = (1 << l) - 1 & f >>> 32 - l, f << l), s |= b[a + 8 >> 2], c = l = c | v, b[u + 8 >> 2] = s, b[u + 12 >> 2] = c, 128 & d) {
                                                                if (e = e + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = e))) continue
                                                            } else {
                                                                if (d | !e) break a;
                                                                l = 7
                                                            }
                                                            break
                                                        }
                                                        e = b[a + 132 >> 2],
                                                        (d = (c = (s = o) - (o = b[a + 16 >> 2]) | 0) + b[a + 128 >> 2] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0),
                                                        b[a + 128 >> 2] = d,
                                                        b[a + 132 >> 2] = e,
                                                        b[a + 24 >> 2] = T(o + h | 0, c, b[a + 24 >> 2]),
                                                        b[a + 28 >> 2] = 0;
                                                        break e
                                                    }
                                                    b[a + 4 >> 2] = 0;
                                                    a: {
                                                        if ((e = b[a + 120 >> 2]) >>> 0 <= 2) {
                                                            o: switch (e - 1 | 0) {
                                                                default:
                                                                    if (b[a + 136 >> 2] = s, b[a + 140 >> 2] = c, (0 | s) != b[a + 88 >> 2] | (0 | c) != b[a + 92 >> 2]) {
                                                                        l = 7;
                                                                        break e
                                                                    }
                                                                    b[a + 120 >> 2] = 1;
                                                                    break a;
                                                                case 1:
                                                                    e = c + b[a + 156 >> 2] | 0, (c = s + b[a + 152 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0), b[a + 152 >> 2] = c, b[a + 156 >> 2] = e, b[a + 160 >> 2] = T(p, 24, b[a + 160 >> 2]), b[a + 120 >> 2] = 1, c = b[a + 140 >> 2] + -1 | 0, (o = b[a + 136 >> 2] + -1 | 0) >>> 0 < 4294967295 && (c = c + 1 | 0), s = o, b[a + 136 >> 2] = o, b[a + 140 >> 2] = c;
                                                                    break a;
                                                                case 0:
                                                                    break o
                                                            }
                                                            b[a + 120 >> 2] = 2,
                                                            e = c + b[a + 148 >> 2] | 0,
                                                            (c = s + b[a + 144 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0),
                                                            b[a + 144 >> 2] = c,
                                                            b[a + 148 >> 2] = e
                                                        }
                                                        s = b[a + 136 >> 2],
                                                        c = b[a + 140 >> 2]
                                                    }
                                                    if (!(s | c)) break
                                                }
                                                b[a >> 2] = 7
                                            }
                                            s = b[a + 132 >> 2],
                                            f = ((o = b[132105]) + (((c = b[a + 16 >> 2]) - o | 0) - (d = b[a + 128 >> 2]) & 3) | 0) - c | 0;i: {
                                                for (;;) {
                                                    if (e = s, (l = (u = h = o - c | 0) + d | 0) >>> 0 < u >>> 0 && (e = e + 1 | 0), !(3 & (u = l))) break i;
                                                    if (l = b[132104], b[132106] == (0 | o)) {
                                                        b[a + 128 >> 2] = u, b[a + 132 >> 2] = e, b[a + 24 >> 2] = T(l + c | 0, h, b[a + 24 >> 2]), l = b[a + 28 >> 2] = 0;
                                                        break e
                                                    }
                                                    if (e = o + 1 | 0, u = o + l | 0, o = b[132105] = e, M[0 | u]) break
                                                }
                                                l = 7;
                                                break e
                                            }
                                            if (o = b[132104], b[a + 128 >> 2] = u, b[a + 132 >> 2] = e, b[a + 24 >> 2] = T(o + c | 0, f, b[a + 24 >> 2]), l = 7, P(n, a + 144 | (b[a + 28 >> 2] = 0), 24)) break e;b[a >> 2] = 8
                                        }
                                        for (o = b[132105], l = b[132106];;) {
                                            if ((0 | o) == (0 | l)) {
                                                l = 0;
                                                break e
                                            }
                                            if (d = b[a + 24 >> 2], c = b[a + 28 >> 2], s = b[a + 4 >> 2], e = o + 1 | 0, b[132105] = e, u = b[132104], h = M[u + o | 0], f = d, o = c, d = 31 & s, (0 | h) != (255 & (32 <= (63 & s) >>> 0 ? o >>> d | 0 : ((1 << d) - 1 & o) << 32 - d | f >>> d))) {
                                                l = 7;
                                                break e
                                            }
                                            if (s = s + 8 | 0, o = e, !((b[a + 4 >> 2] = s) >>> 0 < 32)) break
                                        }
                                        b[a + 172 >> 2] = 12,
                                        b[a + 24 >> 2] = 0,
                                        b[a + 28 >> 2] = 0,
                                        b[a >> 2] = 9,
                                        b[a + 4 >> 2] = 0,
                                        o = 12;
                                        break t
                                    }
                                    e = b[132105],
                                    u = b[132104],
                                    l = b[132106],
                                    o = b[a + 172 >> 2]
                                }
                                s = l - e | 0,
                                A(176 + (a + (c = b[a + 168 >> 2]) | 0) | 0, e + u | 0, o = s >>> 0 < (o = o - c | 0) >>> 0 ? s : o),
                                b[132105] = o + b[132105],
                                l = 0,
                                e = o + b[a + 168 >> 2] | 0,
                                o = b[a + 172 >> 2],
                                b[a + 168 >> 2] = (0 | o) == (0 | e) ? 0 : e,
                                (0 | e) == (0 | o) && (l = 7, 23129 == (M[a + 186 | 0] | M[a + 187 | 0] << 8) && (0 | T(a + 180 | 0, 6, 0)) == (M[a + 176 | 0] | M[a + 177 | 0] << 8 | (M[a + 178 | 0] << 16 | M[a + 179 | 0] << 24)) && (e = (o = b[a + 132 >> 2]) >>> 2 | 0, M[a + 184 | 0] | (M[a + 180 | 0] | M[a + 181 | 0] << 8 | (M[a + 182 | 0] << 16 | M[a + 183 | 0] << 24)) != ((3 & o) << 30 | b[a + 128 >> 2] >>> 2) | e || (l = b[a + 32 >> 2] == M[a + 185 | 0] ? 1 : 7)))
                            }
                            e: {
                                if (!b[a + 36 >> 2]) {
                                    if (l) {
                                        if (a = 1 == (0 | l), e = l, l = 1, a) break e
                                    } else e = b[132105] == b[132106] ? 7 : 8;
                                    return b[132108] = _, b[132105] = y, e
                                }
                                if (!(b[132105] != (0 | y) | l | b[132108] != (0 | _))) return e = M[a + 40 | 0],
                                x[a + 40 | 0] = 1,
                                e << 3;x[a + 40 | 0] = 0
                            }
                            return l
                        }

                        function m(e) {
                            var t = 0;
                            return (-1 >>> (t = 31 & e) & -2) << t | (-1 << (e = 0 - e & 31) & -2) >>> e
                        }
                        return {
                            __wasm_call_ctors: function() {},
                            init_decompressor: function() {
                                var e = 0;
                                return b[132108] = 0, b[132109] = 524288, b[132107] = 528448, b[132105] = 0, b[132106] = 0, b[132104] = 4128,
                                    function() {
                                        for (var e = 0, t = 0, n = 0; e = ((t = (0 - (1 & (e = (0 - (1 & (e = ((t = n >>> 1 | 0) ^ 0 - (1 & n) & -306674912) >>> 1 | 0)) & -306674912 ^ (t = (e ^ 0 - (1 & t) & -306674912) >>> 1 | 0)) >>> 1 | 0)) & -306674912 ^ (e = (e ^ 0 - (1 & t) & -306674912) >>> 1 | 0)) >>> 1 | 0) ^ 0 - (1 & e) & -306674912) >>> 1 | 0, b[1056 + (n << 2) >> 2] = 0 - (1 & e) & -306674912 ^ (e ^ 0 - (1 & t) & -306674912) >>> 1, 256 != (0 | (n = n + 1 | 0)););
                                    }(),
                                    function() {
                                        for (var e, t, n = 0, r = 0, i = 0, a = 0, o = 0, s = 0; r = (n = a) >>> 1 | 0, i = 1 & (n = (1 & n) << 31 | o >>> 1), r ^= 0 - (0 < (t = 1 & o) >>> 0) & -915646571, t = n ^ 0 - t & -679014590, n = r >>> 1 | 0, n ^= 0 - (0 < i >>> 0) & -915646571, i = (r = (1 & r) << 31 | t >>> 1) ^ 0 - i & -679014590, e = n >>> 1 | 0, i = 1 & (n = (1 & n) << 31 | i >>> 1), t = 0 - (r &= 1) & -679014590, r = e ^ 0 - (0 < r >>> 0) & -915646571, e = n ^ t, n = r >>> 1 | 0, e = 0 - i & -679014590 ^ (r = (1 & r) << 31 | e >>> 1), n = (i = n ^ 0 - (0 < i >>> 0) & -915646571) >>> 1 | 0, r = (1 & (n ^= 0 - (0 < (r &= 1) >>> 0) & -915646571)) << 31 | (r = (i = (1 & i) << 31 | e >>> 1) ^ 0 - r & -679014590) >>> 1, n = (i = 0 - (0 < (e = 1 & i) >>> 0) & -915646571 ^ n >>> 1) >>> 1 | 0, e = 1 & (i = (1 & i) << 31 | (r ^ 0 - e & -679014590) >>> 1), i ^= 0 - (r &= 1) & -679014590, r = (n ^= 0 - (0 < r >>> 0) & -915646571) >>> 1 | 0, b[(t = 2080 + (s << 3) | 0) >> 2] = 0 - e & -679014590 ^ ((1 & n) << 31 | i >>> 1), b[4 + t >> 2] = r ^ 0 - (0 < e >>> 0) & -915646571, s = s + 1 | 0, n = a, (a = o + 1 | 0) >>> 0 < 1 && (n = n + 1 | 0), 256 != (0 | (o = a)) | (a = n););
                                    }(), e = s(), 0 | (e = (b[263184] = e) ? 0 : (o(0), 1))
                            },
                            decompress: function() {
                                var e = 0,
                                    t = 0;
                                e: {
                                    if ((e = l(b[263184])) >>> 0 <= 8) {
                                        t: switch (e - 1 | 0) {
                                            case 0:
                                                return o(b[263184]), 0;
                                            case 2:
                                                return o(b[263184]), 1;
                                            case 3:
                                                return o(b[263184]), 2;
                                            case 4:
                                                return o(b[263184]), 4;
                                            case 5:
                                                return o(b[263184]), 5;
                                            case 6:
                                            case 7:
                                                break t;
                                            default:
                                                break e
                                        }
                                        return o(b[263184]),
                                        6
                                    }
                                    o(b[263184]),
                                    t = 7
                                }
                                return 0 | t
                            },
                            get_in_buffer_ptr: function() {
                                return b[132104]
                            },
                            get_out_buffer_ptr: function() {
                                return b[132107]
                            },
                            in_buffer_set_pos: function(e) {
                                e |= 0, b[132105] = e
                            },
                            in_buffer_set_size: function(e) {
                                e |= 0, b[132106] = e >>> 0 < 524288 ? e : 524288
                            },
                            out_buffer_set_pos: function(e) {
                                e |= 0, b[132108] = e
                            },
                            out_buffer_set_size: function(e) {
                                e |= 0, b[132109] = e >>> 0 < 524288 ? e : 524288
                            },
                            get_curr_output_length: function() {
                                return b[132108]
                            },
                            is_input_end_reached: function() {
                                return b[132105] == b[132106] | 0
                            },
                            stackSave: function() {
                                return 0 | h
                            },
                            stackAlloc: function(e) {
                                return 0 | (h = e = h - (e |= 0) & -16)
                            },
                            stackRestore: function(e) {
                                h = e |= 0
                            },
                            __growWasmMemory: function(e) {
                                return 0 | r()
                            }
                        }
                    }({
                        Int8Array: Int8Array,
                        Int16Array: Int16Array,
                        Int32Array: Int32Array,
                        Uint8Array: Uint8Array,
                        Uint16Array: Uint16Array,
                        Uint32Array: Uint32Array,
                        Float32Array: Float32Array,
                        Float64Array: Float64Array,
                        NaN: NaN,
                        Infinity: 1 / 0,
                        Math: Math
                    }, n, r.buffer))
                }
            },
            instantiate: function(t, n) {
                return {
                    then: function(e) {
                        e({
                            instance: new Kg.Instance(new Kg.Module(t, n))
                        })
                    }
                }
            },
            RuntimeError: Error
        },
        Jg = [];
    "object" != typeof Kg && Zg("no native wasm support detected");
    var $g = new Kg.Table({
            initial: 1,
            maximum: 1,
            element: "anyfunc"
        }),
        e_ = !1;

    function t_(e, t) {
        e || x_("Assertion failed: " + t)
    }

    function n_(e) {
        var t = kg["_" + e];
        return t_(t, "Cannot call unknown function " + e + ", make sure it is exported"), t
    }

    function r_(e, t, n, r) {
        var i = {
            string: function(e) {
                var t, n = 0;
                return null != e && 0 !== e && (t = 1 + (e.length << 2), n = N_(t), function(e, t, n, r) {
                    if (0 < r) {
                        for (var i = n + r - 1, a = 0; a < e.length; ++a) {
                            var o, s = e.charCodeAt(a);
                            if (55296 <= s && s <= 57343 && (o = e.charCodeAt(++a), s = 65536 + ((1023 & s) << 10) | 1023 & o), s <= 127) {
                                if (i <= n) break;
                                t[n++] = s
                            } else if (s <= 2047) {
                                if (i <= n + 1) break;
                                t[n++] = 192 | s >> 6, t[n++] = 128 | 63 & s
                            } else if (s <= 65535) {
                                if (i <= n + 2) break;
                                t[n++] = 224 | s >> 12, t[n++] = 128 | s >> 6 & 63, t[n++] = 128 | 63 & s
                            } else {
                                if (i <= n + 3) break;
                                t[n++] = 240 | s >> 18, t[n++] = 128 | s >> 12 & 63, t[n++] = 128 | s >> 6 & 63, t[n++] = 128 | 63 & s
                            }
                        }
                        t[n] = 0
                    }
                }(e, s_, n, t)), n
            },
            array: function(e) {
                var t, n = N_(e.length);
                return t = e, e = n, o_.set(t, e), n
            }
        };
        var e = n_(e),
            a = [],
            o = 0;
        if (r)
            for (var s = 0; s < r.length; s++) {
                var l = i[n[s]];
                l ? (0 === o && (o = O_()), a[s] = l(r[s])) : a[s] = r[s]
            }
        var c, u, d, e = e.apply(null, a);
        return c = e, e = "string" === t ? (u = c) ? function(e, t, n) {
            var r = t + n,
                i = t;
            for (; e[i] && !(r <= i);) ++i; {
                if (16 < i - t && e.subarray && i_) return i_.decode(e.subarray(t, i));
                for (var a = ""; t < i;) {
                    var o, s, l = e[t++];
                    128 & l ? (o = 63 & e[t++], 192 != (224 & l) ? (s = 63 & e[t++], (l = 224 == (240 & l) ? (15 & l) << 12 | o << 6 | s : (7 & l) << 18 | o << 12 | s << 6 | 63 & e[t++]) < 65536 ? a += String.fromCharCode(l) : (s = l - 65536, a += String.fromCharCode(55296 | s >> 10, 56320 | 1023 & s))) : a += String.fromCharCode((31 & l) << 6 | o)) : a += String.fromCharCode(l)
                }
            }
            return a
        }(s_, u, d) : "" : "boolean" === t ? Boolean(c) : c, 0 !== o && I_(o), e
    }
    var i_ = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
    "undefined" != typeof TextDecoder && new TextDecoder("utf-16le");
    var a_, o_, s_, l_;
    var c_, u_ = kg.TOTAL_MEMORY || 16777216;

    function d_(e) {
        for (; 0 < e.length;) {
            var t, n = e.shift();
            "function" != typeof n ? "number" == typeof(t = n.func) ? void 0 === n.arg ? kg.dynCall_v(t) : kg.dynCall_vi(t, n.arg) : t(void 0 === n.arg ? null : n.arg) : n()
        }
    }(Qg = kg.wasmMemory || new Kg.Memory({
        initial: u_ / 65536,
        maximum: u_ / 65536
    })) && (a_ = Qg.buffer), u_ = a_.byteLength, a_ = c_ = a_, kg.HEAP8 = o_ = new Int8Array(c_), kg.HEAP16 = new Int16Array(c_), kg.HEAP32 = l_ = new Int32Array(c_), kg.HEAPU8 = s_ = new Uint8Array(c_), kg.HEAPU16 = new Uint16Array(c_), kg.HEAPU32 = new Uint32Array(c_), kg.HEAPF32 = new Float32Array(c_), kg.HEAPF64 = new Float64Array(c_), l_[263312] = 6296288;
    var h_ = [],
        f_ = [],
        p_ = [],
        m_ = [];

    function v_() {
        if (kg.preRun)
            for ("function" == typeof kg.preRun && (kg.preRun = [kg.preRun]); kg.preRun.length;) e = kg.preRun.shift(), h_.unshift(e);
        var e;
        d_(h_)
    }

    function g_() {
        if (kg.postRun)
            for ("function" == typeof kg.postRun && (kg.postRun = [kg.postRun]); kg.postRun.length;) e = kg.postRun.shift(), m_.unshift(e);
        var e;
        d_(m_)
    }
    var __ = 0,
        y_ = null;

    function x_(e) {
        throw kg.onAbort && kg.onAbort(e), qg(e += ""), Zg(e), e_ = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new Kg.RuntimeError(e)
    }
    kg.preloadedImages = {}, kg.preloadedAudios = {};
    var b_ = "data:application/octet-stream;base64,";

    function M_(e) {
        return String.prototype.startsWith ? e.startsWith(b_) : 0 === e.indexOf(b_)
    }
    var w_, S_ = "xz.wasm";

    function A_() {
        try {
            if (Jg) return new Uint8Array(Jg);
            var e = C_(S_);
            if (e) return e;
            if (Ug) return Ug(S_);
            throw "both async and sync fetching of the wasm failed"
        } catch (e) {
            x_(e)
        }
    }

    function T_(e) {
        for (var t = [], n = 0; n < e.length; n++) {
            var r = e[n];
            255 < r && (r &= 255), t.push(String.fromCharCode(r))
        }
        return t.join("")
    }
    M_(S_) || (w_ = S_, S_ = kg.locateFile ? kg.locateFile(w_, Yg) : Yg + w_), f_.push({
        func: function() {
            D_()
        }
    });
    var E_ = "function" == typeof atob ? atob : function(e) {
        var t, n, r, i, a, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            s = "",
            l = 0;
        for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); t = o.indexOf(e.charAt(l++)) << 2 | (r = o.indexOf(e.charAt(l++))) >> 4, n = (15 & r) << 4 | (i = o.indexOf(e.charAt(l++))) >> 2, r = (3 & i) << 6 | (a = o.indexOf(e.charAt(l++))), s += String.fromCharCode(t), 64 !== i && (s += String.fromCharCode(n)), 64 !== a && (s += String.fromCharCode(r)), l < e.length;);
        return s
    };

    function C_(e) {
        if (M_(e)) return function(t) {
            if ("boolean" == typeof Hg && Hg) {
                var n;
                try {
                    n = Buffer.from(t, "base64")
                } catch (e) {
                    n = new Buffer(t, "base64")
                }
                return new Uint8Array(n.buffer, n.byteOffset, n.byteLength)
            }
            try {
                for (var e = E_(t), r = new Uint8Array(e.length), i = 0; i < e.length; ++i) r[i] = e.charCodeAt(i);
                return r
            } catch (e) {
                throw new Error("Converting base64 string to bytes failed.")
            }
        }(e.slice(b_.length))
    }
    var L_ = {
            emscripten_memcpy_big: function(e, t, n) {
                s_.set(s_.subarray(t, t + n), e)
            },
            emscripten_resize_heap: function(e) {
                x_("OOM")
            },
            memory: Qg,
            table: $g
        },
        P_ = function() {
            var t = {
                env: L_,
                wasi_snapshot_preview1: L_
            };

            function n(e, t) {
                e = e.exports;
                kg.asm = e, __--, kg.monitorRunDependencies && kg.monitorRunDependencies(__), 0 == __ && y_ && (e = y_, y_ = null, e())
            }

            function r(e) {
                n(e.instance)
            }

            function i(e) {
                return (Jg || !jg && !Wg || "function" != typeof fetch ? new Promise(function(e, t) {
                    e(A_())
                }) : fetch(S_, {
                    credentials: "same-origin"
                }).then(function(e) {
                    if (!e.ok) throw "failed to load wasm binary file at '" + S_ + "'";
                    return e.arrayBuffer()
                }).catch(A_)).then(function(e) {
                    return Kg.instantiate(e, t)
                }).then(e, function(e) {
                    Zg("failed to asynchronously prepare wasm: " + e), x_(e)
                })
            }
            if (__++, kg.monitorRunDependencies && kg.monitorRunDependencies(__), kg.instantiateWasm) try {
                return kg.instantiateWasm(t, n)
            } catch (e) {
                return Zg("Module.instantiateWasm callback failed with error: " + e), !1
            }
            return Jg || "function" != typeof Kg.instantiateStreaming || M_(S_) || "function" != typeof fetch ? i(r) : fetch(S_, {
                credentials: "same-origin"
            }).then(function(e) {
                return Kg.instantiateStreaming(e, t).then(r, function(e) {
                    Zg("wasm streaming compile failed: " + e), Zg("falling back to ArrayBuffer instantiation"), i(r)
                })
            }), {}
        }();
    kg.asm = P_;
    var R_, D_ = kg.___wasm_call_ctors = function() {
            return (D_ = kg.___wasm_call_ctors = kg.asm.__wasm_call_ctors).apply(null, arguments)
        },
        O_ = (kg._init_decompressor = function() {
            return (kg._init_decompressor = kg.asm.init_decompressor).apply(null, arguments)
        }, kg._decompress = function() {
            return (kg._decompress = kg.asm.decompress).apply(null, arguments)
        }, kg._get_in_buffer_ptr = function() {
            return (kg._get_in_buffer_ptr = kg.asm.get_in_buffer_ptr).apply(null, arguments)
        }, kg._get_out_buffer_ptr = function() {
            return (kg._get_out_buffer_ptr = kg.asm.get_out_buffer_ptr).apply(null, arguments)
        }, kg._in_buffer_set_pos = function() {
            return (kg._in_buffer_set_pos = kg.asm.in_buffer_set_pos).apply(null, arguments)
        }, kg._in_buffer_set_size = function() {
            return (kg._in_buffer_set_size = kg.asm.in_buffer_set_size).apply(null, arguments)
        }, kg._out_buffer_set_pos = function() {
            return (kg._out_buffer_set_pos = kg.asm.out_buffer_set_pos).apply(null, arguments)
        }, kg._out_buffer_set_size = function() {
            return (kg._out_buffer_set_size = kg.asm.out_buffer_set_size).apply(null, arguments)
        }, kg._get_curr_output_length = function() {
            return (kg._get_curr_output_length = kg.asm.get_curr_output_length).apply(null, arguments)
        }, kg._is_input_end_reached = function() {
            return (kg._is_input_end_reached = kg.asm.is_input_end_reached).apply(null, arguments)
        }, kg.stackSave = function() {
            return (O_ = kg.stackSave = kg.asm.stackSave).apply(null, arguments)
        }),
        N_ = kg.stackAlloc = function() {
            return (N_ = kg.stackAlloc = kg.asm.stackAlloc).apply(null, arguments)
        },
        I_ = kg.stackRestore = function() {
            return (I_ = kg.stackRestore = kg.asm.stackRestore).apply(null, arguments)
        },
        F_ = kg.__growWasmMemory = function() {
            return (F_ = kg.__growWasmMemory = kg.asm.__growWasmMemory).apply(null, arguments)
        };

    function k_(e) {
        function t() {
            R_ || (R_ = !0, e_ || (d_(f_), d_(p_), kg.onRuntimeInitialized && kg.onRuntimeInitialized(), g_()))
        }
        0 < __ || (v_(), 0 < __ || (kg.setStatus ? (kg.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
                kg.setStatus("")
            }, 1), t()
        }, 1)) : t()))
    }
    if (kg.asm = P_, kg.cwrap = function(e, t, n, r) {
            var i = (n = n || []).every(function(e) {
                return "number" === e
            });
            return "string" !== t && i && !r ? n_(e) : function() {
                return r_(e, t, n, arguments)
            }
        }, y_ = function e() {
            R_ || k_(), R_ || (y_ = e)
        }, kg.run = k_, kg.preInit)
        for ("function" == typeof kg.preInit && (kg.preInit = [kg.preInit]); 0 < kg.preInit.length;) kg.preInit.pop()();
    k_(), kg._lock = !1;
    var B_ = ["", "Memory allocation failed", "Memory usage limit reached", "Unsupported check; not verifying file integrity", "Not an .xz file", "Unsupported options in the .xz headers", "File is corrupt", "Unknown decompression bug"];

    function z_(e) {
        this.manager = void 0 !== e ? e : Fd
    }
    Object.assign(z_.prototype, {
        crossOrigin: "Anonymous",
        load: function(r, i, a, o) {
            void 0 === r && (r = ""), void 0 !== this.path && (r = this.path + r);
            var s = this,
                e = Nd.get(r);
            if (void 0 !== e) return s.manager.itemStart(r), setTimeout(function() {
                i && i(e), s.manager.itemEnd(r)
            }, 0), e;
            var t = new XMLHttpRequest;
            return t.open("GET", r, !0), t.addEventListener("load", function(e) {
                var t, n = e.target.response;
                200 === this.status || 0 === this.status ? (0 === this.status && console.warn("v3d.XZLoader: HTTP Status 0 received."), t = function() {
                    kg._lock ? setTimeout(t, 1) : s.decompressArrayBuffer(n, function(e) {
                        setTimeout(function() {
                            i && i(e), s.manager.itemEnd(r), Nd.add(r, e)
                        }, 1)
                    }, function(e) {
                        a && a((+e + 2) / 3)
                    }, function(e) {
                        o && o(e), s.manager.itemEnd(r), s.manager.itemError(r)
                    })
                }, setTimeout(t, 1)) : (o && o(e), s.manager.itemEnd(r), s.manager.itemError(r))
            }, !1), a && t.addEventListener("progress", function(e) {
                e = e.lengthComputable ? e.loaded / e.total : 1, a(2 * e / 3)
            }, !1), t.addEventListener("error", function(e) {
                o && o(e), s.manager.itemEnd(r), s.manager.itemError(r)
            }, !1), t.responseType = "arraybuffer", t.send(null), s.manager.itemStart(r), t
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        },
        decompressArrayBuffer: function(e, a, o, s) {
            var l = this;

            function c(e) {
                var t = l._emGetInBufferPtr();
                kg.HEAPU8.set(e, t), l._emInBufferSetPos(0), l._emInBufferSetSize(e.length), u()
            }

            function u() {
                l._emOutBufferSetPos(0)
            }
            kg._lock = !0;
            var t = l._emInitDecompressor();
            if (0 != t) return console.error("XZLoader._emInitDecompressor: error code " + t + " (" + B_[t] + ")"), void(s && s(t));
            var d = new Uint8Array(e),
                h = d.length,
                f = [],
                p = 0,
                m = Math.min(524288, h),
                v = 0;
            c(d.subarray(p, m)),
                function e() {
                    var t, n, r, i = l._emDecompress();
                    i ? (console.error("XZLoader._emDecompress: error code " + i + " (" + B_[i] + ")"), kg._lock = !1, s && s(i)) : (r = l._emGetCurrOutputLength(), f.push((i = r, r = l._emGetOutBufferPtr(), new Uint8Array(kg.HEAPU8.subarray(r, r + i)))), u(), l._emIsInputEndReached() && (p = m, m = Math.min(m + 524288, h), c(d.subarray(p, m))), o && o(p / h), p == m ? (i = f.reduce(function(e, t, n, r) {
                        return e + t.length
                    }, 0), t = new Uint8Array(i), n = 0, f.forEach(function(e) {
                        t.set(e, n), n += e.length
                    }), kg._lock = !1, a && a(t.buffer)) : ++v % 2 == 0 ? setTimeout(e, 1) : e())
                }()
        },
        _emInitDecompressor: kg.cwrap("init_decompressor", "number"),
        _emDecompress: kg.cwrap("decompress", "number"),
        _emGetInBufferPtr: kg.cwrap("get_in_buffer_ptr", "number"),
        _emGetOutBufferPtr: kg.cwrap("get_out_buffer_ptr", "number"),
        _emInBufferSetPos: kg.cwrap("in_buffer_set_pos", null, ["number"]),
        _emInBufferSetSize: kg.cwrap("in_buffer_set_size", null, ["number"]),
        _emOutBufferSetPos: kg.cwrap("out_buffer_set_pos", null, ["number"]),
        _emOutBufferSetSize: kg.cwrap("out_buffer_set_size", null, ["number"]),
        _emGetCurrOutputLength: kg.cwrap("get_curr_output_length", "number"),
        _emIsInputEndReached: kg.cwrap("is_input_end_reached", "number")
    });

    function U_(e) {
        kd.call(this, e), this.reversed = !1
    }
    U_.prototype = Object.assign(Object.create(kd.prototype), {
        constructor: U_,
        load: function(e, t, n, r) {
            var i = this,
                a = new zd(this.manager);
            a.setPath(this.path), a.setResponseType("arraybuffer"), a.load(e, function(e) {
                t(i.parse(e))
            }, n, r)
        },
        parse: function(e) {
            return "undefined" == typeof opentype ? (console.warn("v3d.TTFLoader: The loader requires opentype.js. Make sure it's included before using the loader."), null) : function(e, t) {
                for (var n = Math.round, r = {}, i = 1e3 / (e.unitsPerEm || 2048), a = e.encoding.cmap.glyphIndexMap, o = Object.keys(a), s = 0; s < o.length; s++) {
                    var l, c = o[s],
                        u = e.glyphs.glyphs[a[c]];
                    void 0 !== c && (l = {
                        ha: n(u.advanceWidth * i),
                        x_min: n(u.xMin * i),
                        x_max: n(u.xMax * i),
                        o: ""
                    }, t && (u.path.commands = function(e) {
                        var t, n = [];
                        e.forEach(function(e) {
                            "m" === e.type.toLowerCase() ? (t = [e], n.push(t)) : "z" !== e.type.toLowerCase() && t.push(e)
                        });
                        var i = [];
                        return n.forEach(function(e) {
                            var t = {
                                type: "m",
                                x: e[e.length - 1].x,
                                y: e[e.length - 1].y
                            };
                            i.push(t);
                            for (var n = e.length - 1; 0 < n; n--) {
                                var r = e[n],
                                    t = {
                                        type: r.type
                                    };
                                void 0 !== r.x2 && void 0 !== r.y2 ? (t.x1 = r.x2, t.y1 = r.y2, t.x2 = r.x1, t.y2 = r.y1) : void 0 !== r.x1 && void 0 !== r.y1 && (t.x1 = r.x1, t.y1 = r.y1), t.x = e[n - 1].x, t.y = e[n - 1].y, i.push(t)
                            }
                        }), i
                    }(u.path.commands)), u.path.commands.forEach(function(e) {
                        "c" === e.type.toLowerCase() && (e.type = "b"), l.o += e.type.toLowerCase() + " ", void 0 !== e.x && void 0 !== e.y && (l.o += n(e.x * i) + " " + n(e.y * i) + " "), void 0 !== e.x1 && void 0 !== e.y1 && (l.o += n(e.x1 * i) + " " + n(e.y1 * i) + " "), void 0 !== e.x2 && void 0 !== e.y2 && (l.o += n(e.x2 * i) + " " + n(e.y2 * i) + " ")
                    }), r[String.fromCodePoint(u.unicode)] = l)
                }
                return {
                    glyphs: r,
                    familyName: e.getEnglishName("fullName"),
                    ascender: n(e.tables.os2.sTypoAscender * i),
                    descender: n(e.tables.os2.sTypoDescender * i),
                    lineGap: e.tables.os2.sTypoLineGap * i,
                    underlinePosition: e.tables.post.underlinePosition,
                    underlineThickness: e.tables.post.underlineThickness,
                    boundingBox: {
                        xMin: e.tables.head.xMin * i,
                        xMax: e.tables.head.xMax * i,
                        yMin: e.tables.head.yMin * i,
                        yMax: e.tables.head.yMax * i
                    },
                    resolution: 1e3,
                    original_font_information: e.tables.name
                }
            }(opentype.parse(e), this.reversed)
        }
    });

    function V_(e) {
        Wd.call(this, e), this.type = je
    }
    V_.prototype = Object.assign(Object.create(Wd.prototype), {
        constructor: V_,
        parse: function(e) {
            function _(e, t) {
                switch (e) {
                    case 1:
                        console.error("RGBELoader Read Error: " + (t || ""));
                        break;
                    case 2:
                        console.error("RGBELoader Write Error: " + (t || ""));
                        break;
                    case 3:
                        console.error("RGBELoader Bad File Format: " + (t || ""));
                        break;
                    default:
                        console.error("RGBELoader: Error: " + (t || ""))
                }
                return -1
            }

            function l(e, t, n) {
                t = t || 1024;
                for (var r = e.pos, i = -1, a = 0, o = "", s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                    (i = s.indexOf("\n")) < 0 && a < t && r < e.byteLength;) o += s, a += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                return -1 < i && (!1 !== n && (e.pos += a + i + 1), o + s.slice(0, i))
            }
            var i, a, t = (i = new Float32Array(1), a = new Int32Array(i.buffer), function(e, t, n, r) {
                var i = e[t + 3],
                    i = Math.pow(2, i - 128) / 255;
                n[r + 0] = o(e[t + 0] * i), n[r + 1] = o(e[t + 1] * i), n[r + 2] = o(e[t + 2] * i)
            });

            function o(e) {
                i[0] = e;
                var t = a[0],
                    n = t >> 16 & 32768,
                    r = t >> 12 & 2047,
                    e = t >> 23 & 255;
                return e < 103 ? n : 142 < e ? (n |= 31744, n |= (255 == e ? 0 : 1) && 8388607 & t) : e < 113 ? n |= ((r |= 2048) >> 114 - e) + (r >> 113 - e & 1) : (n |= e - 112 << 10 | r >> 1, n += 1 & r)
            }
            var n = new Uint8Array(e);
            n.pos = 0;
            var r, s, c, u, d, h = function(e) {
                var t, n, r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    a = /^\s*FORMAT=(\S+)\s*$/,
                    o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    s = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                if (e.pos >= e.byteLength || !(t = l(e))) return _(1, "no header found");
                if (!(n = t.match(/^#\?(\S+)$/))) return _(3, "bad initial token");
                for (s.valid |= 1, s.programtype = n[1], s.string += t + "\n"; !1 !== (t = l(e));)
                    if (s.string += t + "\n", "#" !== t.charAt(0)) {
                        if ((n = t.match(r)) && (s.gamma = parseFloat(n[1], 10)), (n = t.match(i)) && (s.exposure = parseFloat(n[1], 10)), (n = t.match(a)) && (s.valid |= 2, s.format = n[1]), (n = t.match(o)) && (s.valid |= 4, s.height = parseInt(n[1], 10), s.width = parseInt(n[2], 10)), 2 & s.valid && 4 & s.valid) break
                    } else s.comments += t + "\n";
                return 2 & s.valid ? 4 & s.valid ? s : _(3, "missing image size specifier") : _(3, "missing format specifier")
            }(n);
            if (-1 !== h) {
                var f = h.width,
                    e = h.height,
                    p = function(e, t, n) {
                        var r, i, a, o, s, l, c, u, d, h, f, p, m, v = t,
                            g = n;
                        if (v < 8 || 32767 < v || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                        if (v !== (e[2] << 8 | e[3])) return _(3, "wrong scanline width");
                        if (!(r = new Uint8Array(4 * t * n)) || !r.length) return _(4, "unable to allocate buffer space");
                        for (a = i = 0, u = 4 * v, m = new Uint8Array(4), l = new Uint8Array(u); 0 < g && a < e.byteLength;) {
                            if (a + 4 > e.byteLength) return _(1);
                            if (m[0] = e[a++], m[1] = e[a++], m[2] = e[a++], m[3] = e[a++], 2 != m[0] || 2 != m[1] || (m[2] << 8 | m[3]) != v) return _(3, "bad rgbe scanline format");
                            for (c = 0; c < u && a < e.byteLength;) {
                                if ((p = 128 < (o = e[a++])) && (o -= 128), 0 === o || u < c + o) return _(3, "bad scanline data");
                                if (p)
                                    for (s = e[a++], d = 0; d < o; d++) l[c++] = s;
                                else l.set(e.subarray(a, a + o), c), c += o, a += o
                            }
                            for (h = v, d = 0; d < h; d++) f = 0, r[i] = l[d + 0], f += v, r[i + 1] = l[d + f], f += v, r[i + 2] = l[d + f], f += v, r[i + 3] = l[d + f], i += 4;
                            g--
                        }
                        return r
                    }(n.subarray(n.pos), f, e);
                if (-1 !== p) {
                    switch (this.type) {
                        case je:
                            var m = p,
                                v = w,
                                g = je;
                            break;
                        case Xe:
                            for (var y = p.length / 4 * 3, x = new Float32Array(y), b = 0; b < y; b++) c = x, u = 3 * b, d = d = void 0, d = (r = p)[(s = 4 * b) + 3], d = Math.pow(2, d - 128) / 255, c[u + 0] = r[s + 0] * d, c[u + 1] = r[s + 1] * d, c[u + 2] = r[s + 2] * d;
                            m = x, v = Ze, g = Xe;
                            break;
                        case Ye:
                            for (var y = p.length / 4 * 3, M = new Uint16Array(y), b = 0; b < y; b++) t(p, 4 * b, M, 3 * b);
                            m = M, v = Ze, g = Ye;
                            break;
                        default:
                            console.error("v3d.RGBELoader: unsupported type: ", this.type)
                    }
                    return {
                        width: f,
                        height: e,
                        data: m,
                        header: h.string,
                        gamma: h.gamma,
                        exposure: h.exposure,
                        format: v,
                        type: g
                    }
                }
            }
            return null
        },
        setDataType: function(e) {
            return this.type = e, this
        },
        load: function(e, n, t, r) {
            return Wd.prototype.load.call(this, e, function(e, t) {
                switch (e.type) {
                    case je:
                        e.encoding = jt, e.minFilter = ke, e.magFilter = ke, e.generateMipmaps = !1, e.flipY = !0;
                        break;
                    case Xe:
                    case Ye:
                        e.encoding = Vt, e.minFilter = Ue, e.magFilter = Ue, e.generateMipmaps = !1, e.flipY = !0
                }
                n && n(e, t)
            }, t, r)
        }
    });
    var G_ = {
            init: function(e, t) {
                void 0 !== e && void 0 !== t || console.error("RectAreaLightUniformsLib: Missing LTC data (required in Verge3D)");
                var n = new Float32Array(e),
                    r = new Float32Array(t);
                va.LTC_FLOAT_1 = new ha(n, 64, 64, Qe, Xe, o, V, V, Ue, ke, 1), va.LTC_FLOAT_2 = new ha(r, 64, 64, Qe, Xe, o, V, V, Ue, ke, 1);
                var i = new Uint16Array(e.length);
                e.forEach(function(e, t) {
                    i[t] = mp.toHalfFloat(e)
                });
                var a = new Uint16Array(t.length);
                t.forEach(function(e, t) {
                    a[t] = mp.toHalfFloat(e)
                }), va.LTC_HALF_1 = new ha(i, 64, 64, Qe, Ye, o, V, V, Ue, ke, 1), va.LTC_HALF_2 = new ha(a, 64, 64, Qe, Ye, o, V, V, Ue, ke, 1)
            }
        },
        j_ = ["TEXTURE_BL", "TEX_IMAGE_BL", "TEX_ENVIRONMENT_BL", "TEX_ENVIRONMENT_MX", "BITMAP_MX", "BITMAP_ENV_MX", "REFLECT_REFRACT_MX", "AI_SKYDOME_LIGHT_MY", "FILE_MY", "TEXTURE", "TEX_IMAGE", "TEX_ENVIRONMENT", "TEX_ENVIRONMENT_MAX", "BITMAP_MAX", "BITMAP_ENV_MAX", "REFLECT_REFRACT_MAX", "OSL_NODE"];

    function W_(e) {
        this.manager = void 0 !== e ? e : Fd, this.crossOrigin = "Anonymous", this.onProgress = null
    }

    function H_() {
        var n = {};
        return {
            get: function(e) {
                return n[e]
            },
            add: function(e, t) {
                n[e] = t
            },
            remove: function(e) {
                delete n[e]
            },
            removeAll: function() {
                n = {}
            }
        }
    }
    Object.assign(W_.prototype, {
        load: function(e, t, n, r) {
            var i = this;
            i.onProgress = n || function() {};
            var a, o = this.path && "string" == typeof this.path ? this.path : Ph.extractUrlBase(e),
                s = -1 != e.indexOf(".xz", e.length - 3);
            s ? a = new z_(i.manager) : (a = new zd(i.manager)).setResponseType("arraybuffer");

            function l(e) {
                i.onProgress && i.onProgress(.3 * e * 100)
            }
            n = a instanceof zd ? function(e) {
                e = e.lengthComputable ? e.loaded / e.total : 1;
                l(e)
            } : l;
            a.load(e, function(e) {
                i.parse(e, o, t, r, s)
            }, n, r)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        setPath: function(e) {
            this.path = e
        },
        parse: function(e, t, o, n, r) {
            var i, s = this,
                a = {},
                e = _y(new Uint8Array(e, 0, 4)) === Z_ ? (a[X_.KHR_BINARY_GLTF] = new J_(e), a[X_.KHR_BINARY_GLTF].content) : _y(new Uint8Array(e)),
                e = JSON.parse(e);
            void 0 === e.asset || e.asset.version[0] < 2 ? n(new Error("v3d.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")) : (-1 < (i = e.asset.generator || "").indexOf("Verge3D") && "ALL" != on && [
                ["Blender", "BLENDER"],
                ["3ds Max", "MAX"],
                ["Maya", "MAYA"]
            ].forEach(function(e) {
                var t = e[0],
                    e = e[1]; - 1 < i.indexOf(t) && on != e && console.warn("The glTF asset was exported from " + t + ". It may not be fully compatible with Verge3D " + xi() + ".")
            }), new My(e, a, {
                path: t || this.path,
                crossOrigin: this.crossOrigin,
                loadBinXZ: r,
                manager: this.manager,
                onProgress: function(e) {
                    s.onProgress && s.onProgress(e)
                }
            }).parse(function(e, t, n, r, i, a) {
                a = {
                    scene: e,
                    scenes: t,
                    world: n,
                    cameras: r,
                    animations: i,
                    renderer: a
                };
                s.onProgress && s.onProgress(100), o(a)
            }, n))
        }
    });
    var X_ = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        S8S_V3D_ANIMATION_DATA: "S8S_v3d_animation_data",
        S8S_V3D_DATA: "S8S_v3d_data",
        S8S_V3D_CAMERA_DATA: "S8S_v3d_camera_data",
        S8S_V3D_MATERIAL_DATA: "S8S_v3d_material_data",
        S8S_V3D_MESH_DATA: "S8S_v3d_mesh_data",
        S8S_V3D_NODE_DATA: "S8S_v3d_node_data",
        S8S_V3D_SCENE_DATA: "S8S_v3d_scene_data",
        S8S_V3D_TEXTURE_DATA: "S8S_v3d_texture_data"
    };

    function Y_(e) {
        this.parser = e, this.name = X_.S8S_V3D_DATA;
        var t = e.json,
            t = e.getExt(t, X_.S8S_V3D_DATA) || {};
        this.lights = {};
        var n, r = t.lights || {};
        for (n in r) {
            var i, a = r[n],
                o = (new Qr).fromArray(a.color),
                s = a.intensity;
            switch (a.type) {
                case "point":
                    i = new bh(o, s);
                    break;
                case "directional":
                    i = new Sh(o, s), _i(a.shadow) && _i(a.shadow.csm) && (i.shadow = new wh);
                    break;
                case "spot":
                    i = new yh(o, s);
                    break;
                case "area":
                    i = new Th(o, s, a.width, a.height);
                    break;
                case "hemisphere":
                    i = new _h(o, new Qr(0, 0, 0), s);
                    break;
                case "ambient":
                    i = new Ah(o, s)
            }
            i && (_i(a.distance) && (i.distance = a.distance), _i(a.decay) && (i.decay = a.decay, "blender" == a.profile && 2 <= a.decay && ("area" == a.type ? i.intensity /= 2 * Math.PI : i.intensity /= 4 * Math.PI)), _i(a.angle) && (i.angle = a.angle), _i(a.penumbra) && (i.penumbra = a.penumbra), i.isRectAreaLight && G_.init(a.ltcMat1, a.ltcMat2), _i(a.shadow) && "area" != a.type ? (_i(a.shadow.enabled) || (a.shadow.enabled = !0), i.castShadow = a.shadow.enabled, i.shadow.bias = a.shadow.bias, _i(a.shadow.expBias) && (i.shadow.expBias = a.shadow.expBias), _i(a.shadow.slopeScaledBias) && (i.shadow.slopeScaledBias = a.shadow.slopeScaledBias), i.shadow.radius = a.shadow.radius, i.shadow.mapSize.width = a.shadow.mapSize, i.shadow.mapSize.height = a.shadow.mapSize, i.shadow.camera.near = a.shadow.cameraNear, i.shadow.camera.far = a.shadow.cameraFar, i.isSpotLight ? (i.shadow.camera.fov = mn.radToDeg(a.shadow.cameraFov), i.shadow.useMinFov90 = "blender" === a.profile) : i.isDirectionalLight && (_i(a.shadow.cameraOrthoLeft) && _i(a.shadow.cameraOrthoRight) && _i(a.shadow.cameraOrthoBottom) && _i(a.shadow.cameraOrthoTop) && (i.shadow.camera.left = a.shadow.cameraOrthoLeft, i.shadow.camera.right = a.shadow.cameraOrthoRight, i.shadow.camera.bottom = a.shadow.cameraOrthoBottom, i.shadow.camera.top = a.shadow.cameraOrthoTop), i.shadow.isDirectionalLightShadowCSM && (i.shadow.maxDistance = a.shadow.csm.maxDistance)), i.shadow.camera.updateProjectionMatrix()) : i.castShadow = !1, i.name = a.name || "light_" + n, this.lights[n] = i)
        }
        this.nodeGraphs = {};
        var l, c = t.nodeGraphs || [];
        for (l in c) {
            var u = c[l];
            this.nodeGraphs[l] = u
        }
    }

    function q_(e) {
        this.name = X_.S8S_V3D_MATERIAL_DATA
    }
    Y_.prototype.loadCurve = function(a, o) {
        var t, s, i = this.parser,
            e = i.json,
            e = i.getExt(e, X_.S8S_V3D_DATA),
            l = e.curves[a],
            c = !1,
            u = !1;
        return "number" == typeof l.font ? (t = e.fonts[l.font], s = t.uri, void 0 !== t.bufferView && (s = i.getDependency("bufferView", t.bufferView).then(function(e) {
            u = !0;
            e = new Blob([e], {
                type: t.mimeType
            });
            return s = URL.createObjectURL(e)
        }))) : (c = !0, s = l.font), Promise.resolve(s).then(function(n) {
            if (c) return new Vh(n);
            if ("undefined" == typeof opentype) return null;
            var r = new U_;
            return r.setCrossOrigin(i.options.crossOrigin), new Promise(function(e, t) {
                r.load(gy(n, i.options.path), e, void 0, t)
            }).then(function(e) {
                return new Vh(e)
            }, function(e) {
                return null
            })
        }).then(function(e) {
            !0 === u && URL.revokeObjectURL(s);
            var t = l.type;
            switch (null === e && (t = "empty"), t) {
                case "font":
                    var n = 0 < l.bevelSize || 0 < l.bevelThickness,
                        r = new Kc(l.text, {
                            font: e,
                            size: l.size,
                            height: l.height,
                            curveSegments: l.curveSegments,
                            bevelEnabled: n,
                            bevelThickness: l.bevelThickness,
                            bevelSize: l.bevelSize,
                            bevelSegments: l.bevelSegments,
                            alignX: l.alignX,
                            alignY: l.alignY,
                            lineHeight: l.lineHeight,
                            scaledEmSize: l.scaledEmSize
                        }),
                        n = o && o[l.material] ? o[l.material] : new fu({
                            color: new Qr(.8, .8, .8)
                        }),
                        i = new Ki(r, n);
                    break;
                case "curve":
                case "surface":
                case "empty":
                default:
                    i = new Er
            }
            return i.name = l.name || "curve_" + a, i
        })
    }, q_.prototype.extendParams = function(e, t, n) {
        var t = t.extensions[this.name],
            r = [];
        if (_i(t.nodeGraph)) {
            var i = t.nodeGraph;
            e.nodeGraph = _d.nodeGraphFromExtGraph(i);
            for (var a = 0; a < i.nodes.length; a++) {
                var o = i.nodes[a]; - 1 < j_.indexOf(o.type) && _i(o.texture) && (c = _d.nodeTexUniName(o.type, o.texture), r.push(n.assignTextureNode(e, c, o.texture)))
            }
            var s = n.extensions[X_.S8S_V3D_DATA];
            if (s)
                for (var l in e.additionalNodeGraphs = {}, s.nodeGraphs) {
                    i = s.nodeGraphs[l];
                    e.additionalNodeGraphs[l] = _d.nodeGraphFromExtGraph(i);
                    for (a = 0; a < i.nodes.length; a++) {
                        var c, o = i.nodes[a]; - 1 < j_.indexOf(o.type) && (c = _d.nodeTexUniName(o.type, o.texture), r.push(n.assignTextureNode(e, c, o.texture)))
                    }
                }
        }
        return _i(t.profile) && (e.profile = t.profile), _i(t.renderSide) && (e.side = my[t.renderSide]), _i(t.useShadows) && (e.receiveShadow = t.useShadows), _i(t.useCastShadows) && (e.castShadow = t.useCastShadows), _i(t.depthWrite) && (e.depthWrite = t.depthWrite), _i(t.depthTest) && (e.depthTest = t.depthTest), _i(t.dithering) && (e.dithering = t.dithering), Promise.all(r)
    };
    var Z_ = "glTF",
        Q_ = 12,
        K_ = {
            JSON: 1313821514,
            BIN: 5130562
        };

    function J_(e) {
        this.name = X_.KHR_BINARY_GLTF, this.content = null, this.body = null;
        var t = new DataView(e, 0, Q_);
        if (this.header = {
                magic: _y(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== Z_) throw new Error("v3d.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("v3d.GLTFLoader: Legacy binary file detected. Use GLTFLoader instead.");
        for (var n = new DataView(e, Q_), r = 0; r < n.byteLength;) {
            var i = n.getUint32(r, !0);
            r += 4;
            var a, o = n.getUint32(r, !0);
            r += 4, o === K_.JSON ? (a = new Uint8Array(e, Q_ + r, i), this.content = _y(a)) : o === K_.BIN && (o = Q_ + r, this.body = e.slice(o, o + i)), r += i
        }
        if (null === this.content) throw new Error("v3d.GLTFLoader: JSON content not found.")
    }
    var $_ = 0,
        ey = 1,
        ty = 2,
        ny = 3,
        ry = 4,
        iy = 5,
        ay = 6,
        oy = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        sy = {
            9728: ke,
            9729: Ue,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008
        },
        ly = {
            33071: V,
            33648: Fe,
            10497: U
        },
        cy = {
            32774: Q,
            32778: le,
            32779: ce
        },
        uy = {
            0: fe,
            1: pe,
            768: me,
            769: ve,
            770: ge,
            771: _e,
            772: ye,
            773: xe,
            774: be,
            775: Me,
            776: we
        },
        dy = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        hy = {
            CATMULLROMSPLINE: kt,
            CUBICSPLINE: kt,
            LINEAR: Ft,
            STEP: It
        },
        fy = "OPAQUE",
        py = "MASK",
        my = {
            FRONT: ie,
            BACK: ae,
            DOUBLE: oe
        };

    function vy(e, t, n) {
        if (!e) return Promise.resolve();
        var r, i = [];
        if ("[object Array]" === Object.prototype.toString.call(e)) {
            r = [];
            for (var a, o = e.length, s = 0; s < o; s++)(a = t.call(n || this, e[s], s)) && (i.push(a), a instanceof Promise ? a.then(function(e, t) {
                r[e] = t
            }.bind(this, s)) : r[s] = a)
        } else
            for (var l in r = {}, e) e.hasOwnProperty(l) && (a = t.call(n || this, e[l], l)) && (i.push(a), a instanceof Promise ? a.then(function(e, t) {
                r[e] = t
            }.bind(this, l)) : r[l] = a);
        return Promise.all(i).then(function() {
            return r
        })
    }

    function gy(e, t) {
        return "string" != typeof e || "" === e ? "" : /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : (t || "") + e
    }

    function _y(e) {
        if (void 0 !== window.TextDecoder) return (new TextDecoder).decode(e);
        for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
        return t
    }

    function yy(e, t) {
        return _i(e.attributes.color) && !t.isMeshNodeMaterial
    }

    function xy(e) {
        return void 0 === e.attributes.normal
    }

    function by(e, t, n, r) {
        var i = yy(e, t),
            a = xy(e),
            o = t.isMeshNodeMaterial && (t.nodeValue.length || t.nodeRGB.length),
            s = t.morphTargets,
            e = t.isMeshNodeMaterial && t.hasNode("TEX_COORD_BL"),
            n = t.isMeshNodeMaterial && 0 < Object.getOwnPropertyNames(n).length && t.hasNode("UVMAP_BL"),
            t = t.isMeshNodeMaterial && 0 < Object.getOwnPropertyNames(r).length && (t.hasNode("ATTRIBUTE_BL") || t.hasNode("VERTEX_COLOR_BL"));
        return i || a || o || s || e || n || t
    }

    function My(e, t, n) {
        this.json = e || {}, this.extensions = t || {}, this.options = n || {}, this.onProgress = n.onProgress || function() {}, this.cache = new H_, this.clonedResources = {
            materials: []
        }, e.extensionsUsed && (0 <= e.extensionsUsed.indexOf(X_.S8S_V3D_DATA) && (t[X_.S8S_V3D_DATA] = new Y_(this)), 0 <= e.extensionsUsed.indexOf(X_.S8S_V3D_MATERIAL_DATA) && (t[X_.S8S_V3D_MATERIAL_DATA] = new q_))
    }
    My.prototype._withDependencies = function(e) {
        for (var t = this, n = {}, r = 0; r < e.length; r++) {
            var i = e[r],
                a = "load" + i.charAt(0).toUpperCase() + i.slice(1),
                o = t.cache.get(i);
            void 0 !== o ? n[i] = o : t[a] && (o = new Promise(function(e) {
                e(a)
            }).then(function(e) {
                return t[e]()
            }), t.cache.add(i, o), n[i] = o)
        }
        return vy(n, function(e) {
            return e
        })
    }, My.prototype.parse = function(p, e) {
        var m = this,
            v = this.json;
        this.cache.removeAll(), this._withDependencies(["scenes", "nodes", "materials", "cameras", "animations", "clonedMaterials"]).then(function(r) {
            var e = [];
            r.scenes = r.scenes || [];
            for (var t = 0; t < r.scenes.length; t++) e.push(r.scenes[t]);
            var n = _i(v.scene) ? v.scenes[v.scene] : v.scenes[0],
                i = _i(v.scene) ? r.scenes[v.scene] : e[0],
                a = {};
            n && (d = m.getExt(n, X_.S8S_V3D_SCENE_DATA)) && _i(d.worldMaterial) && (a.material = r.materials[d.worldMaterial]), r.materials = r.materials || [], [].concat(r.materials, r.clonedMaterials).forEach(function(n) {
                n.isMeshNodeMaterial && n.traverseNodes(function(e) {
                    var t;
                    "TEX_COORD_BL" !== e.originData.type || (t = r.nodes[e.originData.object]) && (e = n.nodeTexCoordObjectMap[e.originData.name], n.nodeTexCoordObject[e] = t)
                })
            });
            var o = [];
            r.cameras = r.cameras || [];
            for (t = 0; t < r.cameras.length; t++) {
                var s = r.cameras[t],
                    l = !1;
                s.traverseAncestors(function(e) {
                    e == i && (l = !0)
                }), l && o.push(s)
            }
            var c = [];
            r.animations = r.animations || [];
            for (t = 0; t < r.animations.length; t++) {
                var u = r.animations[t];
                u.clip && void 0 !== u.clip.name && (u.clip.name = u.clip.name), c.push(u)
            }
            var d, h, f = {};
            if (n && (d = m.getExt(n, X_.S8S_V3D_SCENE_DATA))) {
                if (_i(d.shadowMap)) {
                    switch (f.shadowMap = {
                            enabled: !0
                        }, d.shadowMap.type) {
                        case "BASIC":
                            f.shadowMap.type = K;
                            break;
                        case "BILINEAR":
                            f.shadowMap.type = re;
                            break;
                        case "PCF":
                            f.shadowMap.type = J;
                            break;
                        case "PCFSOFT":
                            f.shadowMap.type = $;
                            break;
                        case "PCFPOISSON":
                            f.shadowMap.type = ne;
                            break;
                        case "ESM":
                            f.shadowMap.type = te
                    }
                    h = d.shadowMap.renderSingleSided ? d.shadowMap.renderReverseSided ? ae : ie : oe, i.traverse(function(e) {
                        e = e.material;
                        e && (e.shadowSide = h)
                    }), f.esmDistanceScale = d.shadowMap.esmDistanceScale
                }
                if (_i(d.physicallyCorrectLights) && (f.physicallyCorrectLights = d.physicallyCorrectLights), _i(d.aaMethod) && (f.aaMethod = d.aaMethod), _i(d.useHDR) && (f.useHDR = d.useHDR), _i(d.unitsScaleFactor) ? f.unitsScaleFactor = d.unitsScaleFactor : f.unitsScaleFactor = 1, _i(d.toneMapping)) switch (d.toneMapping.type) {
                    case "logarithmicMax":
                        f.toneMapping = Ne, f.toneMappingBrightness = d.toneMapping.brightness, f.toneMappingContrast = d.toneMapping.contrast, f.toneMappingMidTones = d.toneMapping.midTones, f.toneMappingPhysicalScale = d.toneMapping.physicalScale, f.toneMappingChromaticAdaptation = d.toneMapping.chromaticAdaptation, f.toneMappingWhiteColor = (new Qr).fromArray(d.toneMapping.whiteColor), f.toneMappingColorDifferentiation = d.toneMapping.colorDifferentiation, f.toneMappingExteriorDaylight = d.toneMapping.exteriorDaylight;
                        break;
                    case "physicalMax":
                        f.toneMapping = Ie, f.toneMappingWhiteBalance = (new Qr).fromArray(d.toneMapping.whiteBalance), f.toneMappingHighlights = d.toneMapping.highlights, f.toneMappingMidTones = d.toneMapping.midTones, f.toneMappingShadows = d.toneMapping.shadows, f.toneMappingSaturation = d.toneMapping.saturation, f.toneMappingPhysicalScale = d.toneMapping.physicalScale, f.toneMappingAperture = d.toneMapping.aperture, f.toneMappingShutter = d.toneMapping.shutter, f.toneMappingISO = d.toneMapping.iso, f.toneMappingVignetting = d.toneMapping.vignetting;
                        break;
                    case "filmicBlender":
                        f.toneMapping = O
                }
                if (_i(d.pmremMaxTileSize) && (f.pmremMaxTileSize = d.pmremMaxTileSize), _i(d.iblEnvironmentMode)) switch (d.iblEnvironmentMode) {
                    case "PMREM":
                        f.iblEnvironmentMode = cn;
                        break;
                    case "PROBE_CUBEMAP":
                        f.iblEnvironmentMode = 1;
                        break;
                    case "PROBE":
                        f.iblEnvironmentMode = 2;
                        break;
                    default:
                        f.iblEnvironmentMode = cn
                }
            }
            p(i, e, a, o, c, f)
        }).catch(e)
    }, My.prototype.getDependency = function(e, t) {
        var n, r = this,
            i = e + ":" + t,
            a = r.cache.get(i);
        return a || (n = "load" + e.charAt(0).toUpperCase() + e.slice(1), a = new Promise(function(e) {
            e()
        }).then(function() {
            return r[n](t)
        }), r.cache.add(i, a)), a
    }, My.prototype.loadBuffer = function(e) {
        var a = this,
            o = this.json.buffers[e];
        if (o.type && "arraybuffer" !== o.type) throw new Error("v3d.GLTFLoader: %s buffer type is not supported.", o.type);
        if (void 0 === o.uri && 0 === e) return Promise.resolve(this.extensions[X_.KHR_BINARY_GLTF].body);
        var s = this.options;
        return new Promise(function(e) {
            var t, n;
            s.loadBinXZ ? (t = gy(o.uri, s.path) + ".xz", n = new z_) : (t = gy(o.uri, s.path), (n = new zd).setResponseType("arraybuffer"));

            function r(e) {
                a.onProgress && (e = 100 * (.3 + .7 * e), a.onProgress(e))
            }
            var i = n instanceof zd ? function(e) {
                e = e.lengthComputable ? e.loaded / e.total : 1;
                r(e)
            } : r;
            n.load(t, e, i)
        })
    }, My.prototype.loadBufferView = function(e) {
        var r = this.json.bufferViews[e];
        return this.getDependency("buffer", r.buffer).then(function(e) {
            var t = r.byteLength || 0,
                n = r.byteOffset || 0;
            return e.slice(n, n + t)
        })
    }, My.prototype.loadAccessors = function() {
        var e = this,
            s = this.json;
        return vy(s.accessors, function(o) {
            return e.getDependency("bufferView", o.bufferView).then(function(e) {
                var t = dy[o.type],
                    n = oy[o.componentType],
                    r = n.BYTES_PER_ELEMENT,
                    i = r * t,
                    a = s.bufferViews[o.bufferView].byteStride;
                return a && a !== i ? new Gs(new zs(new n(e), a / r), t, o.byteOffset / r) : new ri(new n(e, o.byteOffset, o.count * t), t)
            })
        })
    }, My.prototype.loadTexture = function(e) {
        var n, t = this,
            r = this.json,
            a = this.options,
            i = (this.extensions, window.URL || window.webkitURL),
            o = r.textures[e],
            s = r.images[o.source],
            l = s.uri,
            c = !1,
            u = t.getExt(o, X_.S8S_V3D_TEXTURE_DATA);
        n = u && ("linear" == u.colorSpace || "non-color" == u.colorSpace) ? Vt : Gt;
        var d = !0;
        return "image/jpeg" === s.mimeType && (d = !1), void 0 !== s.bufferView && (l = this.getDependency("bufferView", s.bufferView).then(function(e) {
            "image/png" === s.mimeType && (d = 6 === new DataView(e, 25, 1).getUint8(0, !1)), c = !0;
            e = new Blob([e], {
                type: s.mimeType
            });
            return l = i.createObjectURL(e)
        })), Promise.resolve(l).then(function(r) {
            "hdr" != r.split(".").pop() && "image/vnd.radiance" != s.mimeType || (n = jt);
            var i = t.options.manager.getHandler(r);
            return (i = i || new(n == jt ? V_ : Hd)).setCrossOrigin(a.crossOrigin), new Promise(function(e, t) {
                var n = i.load(gy(r, a.path), e, void 0, function(e) {
                    t(n)
                })
            }).then(function(e) {
                return e
            }, function(e) {
                return e
            })
        }).then(function(e) {
            !0 === c && i.revokeObjectURL(l), e.flipY = !1, void 0 !== o.name && (e.name = o.name), d || (e.format = Ze);
            var t = (r.samplers || {})[o.sampler] || {};
            return e.magFilter = sy[t.magFilter] || Ue, e.minFilter = sy[t.minFilter] || 1008, e.wrapS = ly[t.wrapS] || U, e.wrapT = ly[t.wrapT] || U, (e.encoding = n) == jt && (e.minFilter = Ue, e.magFilter = Ue), u && (_i(u.anisotropy) && (e.anisotropy = u.anisotropy), _i(u.uvTransform) && (e.matrix = (new gn).fromArray(u.uvTransform), e.matrixAutoUpdate = !1)), e
        })
    }, My.prototype.assignTexture = function(t, n, e) {
        return this.getDependency("texture", e).then(function(e) {
            t[n] = e
        })
    }, My.prototype.assignTextureNode = function(t, n, e) {
        return this.getDependency("texture", e).then(function(e) {
            t.nodeTextures = t.nodeTextures || {}, t.nodeTextures[n] = e
        })
    }, My.prototype.loadMaterials = function() {
        var c = this,
            e = this.json,
            u = this.extensions;
        return vy(e.materials, function(t) {
            var n, e, r, i = {},
                a = [],
                o = c.getExt(t, X_.S8S_V3D_MATERIAL_DATA);
            _i(t.pbrMetallicRoughness) ? (n = fu, e = t.pbrMetallicRoughness, i.color = new Qr(1, 1, 1), i.opacity = 1, Array.isArray(e.baseColorFactor) && (r = e.baseColorFactor, i.color.fromArray(r), i.opacity = r[3]), _i(e.baseColorTexture) && a.push(c.assignTexture(i, "map", e.baseColorTexture.index)), i.metalness = _i(e.metallicFactor) ? e.metallicFactor : 1, i.roughness = _i(e.roughnessFactor) ? e.roughnessFactor : 1, _i(e.metallicRoughnessTexture) && (s = e.metallicRoughnessTexture.index, a.push(c.assignTexture(i, "metalnessMap", s)), a.push(c.assignTexture(i, "roughnessMap", s))), _i(t.normalTexture) && (a.push(c.assignTexture(i, "normalMap", t.normalTexture.index)), i.normalScale = new vn(1, 1), _i(t.normalTexture.scale) && i.normalScale.set(t.normalTexture.scale, t.normalTexture.scale)), _i(t.occlusionTexture) && (a.push(c.assignTexture(i, "aoMap", t.occlusionTexture.index)), _i(t.occlusionTexture.strength) && (i.aoMapIntensity = t.occlusionTexture.strength)), _i(t.emissiveFactor) && (i.emissive = (new Qr).fromArray(t.emissiveFactor)), _i(t.emissiveTexture) && a.push(c.assignTexture(i, "emissiveMap", t.emissiveTexture.index))) : n = o ? _d : fu, o && (l = u[X_.S8S_V3D_MATERIAL_DATA], a.push(l.extendParams(i, t, c))), !0 === t.doubleSided && (i.side = oe);
            var s = t.alphaMode || fy,
                l = s !== fy,
                s = s === py;
            return i.premultipliedAlpha = l, i.transparent = l, i.alphaTest = s ? _i(t.alphaCutoff) ? t.alphaCutoff : .5 : 0, l && (o && _i(o.blendMode) ? (l = o.blendMode, i.blending = Z, _i(l.blendEquation) && (i.blendEquation = cy[l.blendEquation]), _i(l.blendEquationAlpha) && (i.blendEquationAlpha = cy[l.blendEquationAlpha]), _i(l.srcRGB) && (i.blendSrc = uy[l.srcRGB]), _i(l.dstRGB) && (i.blendDst = uy[l.dstRGB]), _i(l.srcAlpha) && (i.blendSrcAlpha = uy[l.srcAlpha]), _i(l.dstAlpha) && (i.blendDstAlpha = uy[l.dstAlpha])) : c.assignDefaultBlending(i)), Promise.all(a).then(function() {
                var e = new n(i);
                return void 0 !== t.name && (e.name = t.name), t.extras && (e.userData.v3d = t.extras), (t.pbrMetallicRoughness || e.isMeshNodeMaterial) && e.envMap && (e.envMap.mapping = F, e.envMap.flipY = !0), e.isMeshStandardMaterial && (e.map && (e.map.encoding = Gt), e.emissiveMap && (e.emissiveMap.encoding = Gt), e.normalScale && o && _i(o.profile) && "max" == o.profile && (e.normalScale.y = -e.normalScale.y)), e
            })
        })
    }, My.prototype.loadClonedMaterials = function() {
        var e = this;
        return this._withDependencies(["meshes", "nodes"]).then(function() {
            return Promise.resolve(e.clonedResources.materials)
        })
    }, My.prototype.loadGeometries = function(e) {
        var s = this;
        return this._withDependencies(["accessors"]).then(function(o) {
            return vy(e, function(e) {
                var t, n = new Oi,
                    r = e.attributes;
                for (t in r) {
                    var i = r[t];
                    if (void 0 === i) return;
                    var a = o.accessors[i];
                    switch (t) {
                        case "POSITION":
                            n.setAttribute("position", a);
                            break;
                        case "NORMAL":
                            n.setAttribute("normal", a);
                            break;
                        case "TEXCOORD_0":
                        case "TEXCOORD0":
                        case "TEXCOORD":
                            n.setAttribute("uv", a);
                            break;
                        case "COLOR_0":
                        case "COLOR0":
                        case "COLOR":
                            n.setAttribute("color", a);
                            break;
                        case "WEIGHTS_0":
                        case "WEIGHT":
                            n.setAttribute("skinWeight", a);
                            break;
                        case "JOINTS_0":
                        case "JOINT":
                            n.setAttribute("skinIndex", a);
                            break;
                        case "TANGENT":
                            n.setAttribute("tangent", a);
                            break;
                        default:
                            -1 < t.indexOf("TEXCOORD_") && n.setAttribute(s.texcoordToAttrName(t), a), -1 < t.indexOf("COLOR_") && n.setAttribute(s.colorToAttrName(t), a)
                    }
                }
                return void 0 !== e.indices && n.setIndex(o.accessors[e.indices]), n
            })
        })
    }, My.prototype.loadMeshes = function() {
        var v = this,
            e = this.json;
        return this._withDependencies(["accessors", "materials"]).then(function(m) {
            return vy(e.meshes, function(u, d) {
                var h = new As,
                    f = u.primitives || [],
                    p = v.getExt(u, X_.S8S_V3D_MESH_DATA);
                return v.loadGeometries(f).then(function(e) {
                    for (var t = 0; t < f.length; t++) {
                        var n, r, i, g = f[t],
                            a = e[t],
                            o = void 0 === g.material ? new fu({
                                color: 16777215,
                                emissive: 0,
                                metalness: 1,
                                roughness: 1,
                                transparent: !1,
                                depthTest: !0,
                                side: ie,
                                receiveShadow: !0,
                                castShadow: !0
                            }) : m.materials[g.material];
                        if (o.aoMap && void 0 === a.attributes.uv2 && void 0 !== a.attributes.uv && a.setAttribute("uv2", new ri(a.attributes.uv.array, 2)), g.mode === ry || void 0 === g.mode) i = new Ki(a, o);
                        else if (g.mode === iy)(i = new Ki(a, o)).drawMode = 1;
                        else if (g.mode === ay)(i = new Ki(a, o)).drawMode = 2;
                        else if (g.mode === ey) p ? ((n = new xg).fromBufferGeometry(a), r = new Mg({
                            color: _i(p.lineColor) ? (new Qr).fromArray(p.lineColor) : new Qr(1, 1, 1),
                            lineWidth: _i(p.lineWidth) ? p.lineWidth : 1,
                            sizeAttenuation: 0
                        }), (i = new Ki(n.geometry, r)).userData.originalLineGeom = a) : i = new Rl(a, o);
                        else if (g.mode === ny) i = new Cl(a, o);
                        else if (g.mode === ty) i = new Dl(a, o);
                        else {
                            if (g.mode !== $_) throw new Error("v3d.GLTFLoader: Primitive mode unsupported: ", g.mode);
                            i = new Bl(a, o)
                        }
                        i.name = u.name || "mesh_" + d, void 0 !== g.targets && function(e, t, n) {
                            var r = e.geometry,
                                i = e.material,
                                a = g.targets,
                                o = r.morphAttributes;
                            o.position = [], o.normal = [], i.morphTargets = !0;
                            for (var s = 0, l = a.length; s < l; s++) {
                                var c, u, d = a[s],
                                    h = _i(t.extras) && _i(t.extras.targetNames) ? t.extras.targetNames[s] : "morphTarget" + s;
                                if (void 0 !== d.POSITION) {
                                    c = n.accessors[d.POSITION].clone();
                                    for (var f = r.attributes.position, p = 0, m = c.count; p < m; p++) c.setXYZ(p, c.getX(p) + f.getX(p), c.getY(p) + f.getY(p), c.getZ(p) + f.getZ(p))
                                } else c = r.attributes.position.clone();
                                if (void 0 !== d.NORMAL) {
                                    i.morphNormals = !0, u = n.accessors[d.NORMAL].clone();
                                    for (var v = r.attributes.normal, p = 0, m = u.count; p < m; p++) u.setXYZ(p, u.getX(p) + v.getX(p), u.getY(p) + v.getY(p), u.getZ(p) + v.getZ(p))
                                } else u = r.attributes.normal.clone();
                                d.TANGENT, c.name = h, u.name = h, o.position.push(c), o.normal.push(u)
                            }
                            if (e.updateMorphTargets(), void 0 !== t.weights)
                                for (s = 0, l = t.weights.length; s < l; s++) e.morphTargetInfluences[s] = t.weights[s]
                        }(i, u, m);
                        var s = {},
                            l = {};
                        if (i.material.isMeshNodeMaterial && p) {
                            if (p.uvLayers)
                                for (var c in p.uvLayers) s[c] = v.texcoordToAttrName(p.uvLayers[c]);
                            if (p.colorLayers)
                                for (var c in p.colorLayers) l[c] = v.colorToAttrName(p.colorLayers[c])
                        }
                        if (by(i.geometry, i.material, s, l) && (i.material = i.material.clone(), v.clonedResources.materials.push(i.material)), i.material.isMeshNodeMaterial && (Object.assign(i.material.nodeUVAliases, s), Object.assign(i.material.nodeVCAliases, l), i.material.updateNodeGraph()), yy(a, i.material) && (i.material.vertexColors = !0, i.material.needsUpdate = !0), xy(a) && (i.material.flatShading = !0), !(1 < f.length)) return i;
                        i.name += "_" + t, i.isMaterialGeneratedMesh = !0, h.add(i)
                    }
                    return h
                })
            })
        })
    }, My.prototype.loadCameras = function() {
        var e = this.json,
            o = this;
        return vy(e.cameras, function(e) {
            var t, n, r, i = e[e.type];
            if (i) {
                "perspective" === e.type ? (t = i.aspectRatio || 1, n = i.yfov, r = new la(mn.radToDeg(n), t, i.znear || 1, i.zfar || 2e6)) : "orthographic" === e.type && (r = new ms(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), _i(e.name) && (r.name = e.name);
                var a = o.getExt(e, X_.S8S_V3D_CAMERA_DATA);
                if (a) {
                    if (r.controls = {}, r.controls.type = a.controls, r.viewportFit.type = 3, _i(a.viewportFitType)) switch (a.viewportFitType) {
                        case "VERTICAL":
                            r.viewportFit.type = 1;
                            break;
                        case "HORIZONTAL":
                            r.viewportFit.type = 2;
                            break;
                        case "AUTO":
                            r.viewportFit.type = 3
                    }
                    _i(a.viewportFitInitialAspect) && (r.viewportFit.initialAspect = a.viewportFitInitialAspect), _i(a.enablePan) ? r.controls.enablePan = a.enablePan : r.controls.enablePan = !0, _i(a.rotateSpeed) ? r.controls.rotateSpeed = a.rotateSpeed : r.controls.rotateSpeed = 1, _i(a.moveSpeed) ? r.controls.moveSpeed = a.moveSpeed : r.controls.moveSpeed = 1, _i(a.orbitMinDistance) && (r.controls.orbitMinDistance = a.orbitMinDistance), _i(a.orbitMaxDistance) && (r.controls.orbitMaxDistance = a.orbitMaxDistance), _i(a.orbitMinZoom) ? r.controls.orbitMinZoom = a.orbitMinZoom : r.controls.orbitMinZoom = 0, _i(a.orbitMaxZoom) ? r.controls.orbitMaxZoom = a.orbitMaxZoom : r.controls.orbitMaxZoom = 1 / 0, _i(a.orbitMinPolarAngle) && (r.controls.orbitMinPolarAngle = a.orbitMinPolarAngle), _i(a.orbitMaxPolarAngle) && (r.controls.orbitMaxPolarAngle = a.orbitMaxPolarAngle), _i(a.orbitMinAzimuthAngle) ? r.controls.orbitMinAzimuthAngle = a.orbitMinAzimuthAngle : r.controls.orbitMinAzimuthAngle = -1 / 0, _i(a.orbitMaxAzimuthAngle) ? r.controls.orbitMaxAzimuthAngle = a.orbitMaxAzimuthAngle : r.controls.orbitMaxAzimuthAngle = 1 / 0, _i(a.orbitTarget) && (a.orbitTarget instanceof Array ? (r.controls.orbitTarget = new Er, r.controls.orbitTarget.position.fromArray(a.orbitTarget)) : o._withDependencies(["nodes"]).then(function(e) {
                        r.controls.orbitTarget = e.nodes[a.orbitTarget]
                    })), _i(a.fpsCollisionMaterial) ? r.controls.collisionMaterial = a.fpsCollisionMaterial : r.controls.collisionMaterial = null, _i(a.fpsGazeLevel) ? r.controls.gazeLevel = a.fpsGazeLevel : r.controls.gazeLevel = 1.8, _i(a.fpsStoryHeight) ? r.controls.storyHeight = a.fpsStoryHeight : r.controls.storyHeight = 3
                }
                return e.extras && (r.userData.v3d = e.extras), r
            }
            console.warn("v3d.GLTFLoader: Missing camera parameters.")
        })
    }, My.prototype.loadSkins = function() {
        var e = this.json;
        return this._withDependencies(["accessors"]).then(function(t) {
            return vy(e.skins, function(e) {
                return {
                    joints: e.joints,
                    inverseBindMatrices: t.accessors[e.inverseBindMatrices]
                }
            })
        })
    }, My.prototype.loadAnimations = function() {
        var E = this,
            e = this.json;
        return this._withDependencies(["accessors", "materials", "nodes"]).then(function(T) {
            return vy(e.animations, function(e, t) {
                for (var n = [], r = -1, i = 0; i < e.channels.length; i++) {
                    var a = e.channels[i],
                        o = e.samplers[a.sampler];
                    if (o && -1 < o.input && -1 < o.output) {
                        var s = a.target,
                            l = void 0 !== s.node ? s.node : s.id,
                            c = void 0 !== e.parameters ? e.parameters[o.input] : o.input,
                            a = void 0 !== e.parameters ? e.parameters[o.output] : o.output,
                            u = T.accessors[c];
                        if (!(u.count <= 1)) {
                            var d = T.accessors[a],
                                c = T.nodes[l];
                            if (c) {
                                r = c.id;
                                c.updateMatrix(), c.matrixAutoUpdate = !0;
                                var h = "";
                                switch (s.path) {
                                    case "weights":
                                        f = Ed, h = "morphTargetInfluences";
                                        break;
                                    case "rotation":
                                        f = Ld, h = "quaternion";
                                        break;
                                    case "translation":
                                        f = Rd, h = "position";
                                        break;
                                    case "scale":
                                        f = Rd, h = "scale";
                                        break;
                                    case "intensity":
                                        f = Ed, h = "intensity";
                                        break;
                                    default:
                                        var f = Rd; - 1 < s.path.indexOf("nodeValue") ? h = "material.nodeValue[" + s.path.match(/".*"/g)[0] + "]" : -1 < s.path.indexOf("nodeRGB") && (h = "material.nodeRGB[" + s.path.match(/".*"/g)[0] + "]")
                                }
                                a = c.name || c.uuid;
                                "CATMULLROMSPLINE" == o.interpolation && console.warn("v3d.GLTFLoader: CATMULLROMSPLINE interpolation is not supported. Using CUBICSPLINE instead.");
                                var p = _i(o.interpolation) ? hy[o.interpolation] : Ft,
                                    m = [];
                                "weights" == s.path ? c.traverse(function(e) {
                                    e.isMesh && e.material.morphTargets && m.push(e.name || e.uuid)
                                }) : -1 < s.path.indexOf("material") ? c.traverse(function(e) {
                                    var t, n;
                                    e.isMesh && e.material.isMeshNodeMaterial && (n = !1, (n = !s.extras || (n = T.materials[s.extras.material].name === e.material.name, t = s.path.match(/\["(.*)"\]/), n && null !== t && null !== e.material.findNodeByName(t[1]))) && m.push(e.name || e.uuid))
                                }) : m.push(a);
                                for (var v = 0, g = m.length; v < g; v++) {
                                    var _ = Md.arraySlice(u.array, 0),
                                        y = Md.arraySlice(d.array, 0);
                                    if (p == kt) {
                                        for (var x = new y.constructor(y.length / 3), b = x.length / _.length, M = 0; M < x.length / b; M++)
                                            for (var w = 0; w < b; w++) x[b * M + w] = y[3 * b * M + b + w];
                                        p = Ft, y = x
                                    }
                                    n.push(new f(m[v] + "." + h, _, y, p))
                                }
                            }
                        }
                    }
                }
                var S = {
                        clip: new Dd(l = _i(e.name) ? e.name : "animation_" + t, void 0, n),
                        nodeId: r,
                        auto: !0,
                        loop: Nt,
                        repetitions: 1 / 0,
                        startAt: 0
                    },
                    t = E.getExt(e, X_.S8S_V3D_ANIMATION_DATA);
                if (t) {
                    S.auto = t.auto;
                    var A = t.repeatInfinite ? 1 / 0 : t.repeatCount;
                    switch (t.loop) {
                        case "ONCE":
                            S.loop = 2200;
                            break;
                        case "REPEAT":
                            S.loop = Nt, S.repetitions = A;
                            break;
                        case "PING_PONG":
                            S.loop = 2202, S.repetitions = A
                    }
                    S.startAt = t.offset
                }
                return S
            })
        })
    }, My.prototype.loadNodes = function() {
        var e, _ = this.json,
            y = this,
            t = _.nodes || [],
            n = _.skins || [],
            r = {},
            i = {};
        for (e in n.forEach(function(e) {
                e.joints.forEach(function(e) {
                    t[e].isBone = !0
                })
            }), t) {
            var a = t[e];
            _i(a.mesh) && (_i(r[a.mesh]) || (r[a.mesh] = i[a.mesh] = 0), r[a.mesh]++)
        }
        var o, n = y.getExt(_, X_.S8S_V3D_DATA);
        return n && n.curves && n.curves.length && (o = n.curves), y._withDependencies(["materials", "meshes", "skins", "cameras"]).then(function(t) {
            return _i(o) ? new Promise(function(e) {
                Si("opentype.js", function() {
                    e(t)
                }, function() {
                    console.error("GLTFLoader: opentype.js module not found, please copy it to your app directory"), e(t)
                })
            }) : Promise.resolve(t)
        }).then(function(n) {
            return vy(o, function(e, t) {
                return y.getExt(y, X_.S8S_V3D_DATA).loadCurve(t, n.materials)
            }).then(function(e) {
                return n.curves = e, n
            })
        }).then(function(g) {
            return vy(_.nodes, function(e) {
                var t = y.getExt(e, X_.S8S_V3D_NODE_DATA);
                if (!0 === e.isBone) return new fl;
                if (void 0 === e.mesh) return void 0 !== e.camera ? g.cameras[e.camera] : t && _i(t.curve) ? g.curves[t.curve] : t && _i(t.light) ? y.getExt(y, X_.S8S_V3D_DATA).lights[t.light].clone() : new Er;
                t = g.meshes[e.mesh];
                return 0 < i[e.mesh] && ((t = t.clone()).name += "_instance_" + i[e.mesh], void 0 !== t.geometry && void 0 !== t.material && by(t.geometry, t.material, t.material.nodeUVAliases, t.material.nodeVCAliases) && (t.material = t.material.clone(), y.clonedResources.materials.push(t.material))), i[e.mesh]++, t
            }).then(function(v) {
                return vy(v, function(d, e) {
                    var h = _.nodes[e];
                    if (_i(h.skin)) {
                        for (var t = [], n = 0 < d.children.length ? d.children : [d], r = 0; r < n.length; r++) {
                            var i = n[r];
                            if (i.isMesh) {
                                var a = g.skins[h.skin],
                                    o = i.geometry,
                                    s = i.material.clone();
                                y.clonedResources.materials.push(s), s.skinning = !0;
                                s = new hl(o, s);
                                s.morphTargetInfluences = i.morphTargetInfluences, s.name = i.name, s.isMaterialGeneratedMesh = i.isMaterialGeneratedMesh;
                                for (var l = [], c = [], u = 0, f = a.joints.length; u < f; u++) {
                                    var p = a.joints[u],
                                        m = v[p];
                                    m ? (l.push(m), m = new nr, _i(a.inverseBindMatrices) && m.fromArray(a.inverseBindMatrices.array, 16 * u), c.push(m)) : console.warn('v3d.GLTFLoader: Joint "%s" could not be found.', p)
                                }
                                s.bind(new vl(l, c), s.matrixWorld), t.push(s)
                            }
                        }
                        t.length && (0 < d.children.length ? (d.remove.apply(d, d.children), d.add.apply(d, t)) : d = t[0])
                    }
                    return d.traverse(function(e) {
                        var t, n = d == e,
                            r = y.getExt(h, X_.S8S_V3D_NODE_DATA);
                        if (n) {
                            void 0 !== h.name && (e.name = h.name), void 0 !== h.matrix ? ((t = new nr).fromArray(h.matrix), e.applyMatrix4(t)) : (void 0 !== h.translation && e.position.fromArray(h.translation), void 0 !== h.rotation && e.quaternion.fromArray(h.rotation), void 0 !== h.scale && e.scale.fromArray(h.scale));
                            var i = r && r.target ? v[r.target] : null;
                            if ((e.isDirectionalLight || e.isSpotLight) && (i ? (e.target = i, e.isFreeLight = !1) : e.isFreeLight = !0), e.isCamera && e.controls && "FIRST_PERSON" == e.controls.type && (e.controls.collisionMaterial = g.materials[e.controls.collisionMaterial]), r && r.hidden && (e.visible = !1), r && _i(r.constraints))
                                for (var a = 0; a < r.constraints.length; a++) {
                                    var o, s, l, c = r.constraints[a];
                                    "lockedTrack" == c.type ? (c.trackAxis = c.trackAxis.toUpperCase(), c.lockAxis = c.lockAxis || "Y") : "trackTo" == c.type ? (c.trackAxis = c.trackAxis.toUpperCase(), c.upAxis = c.upAxis || "Y") : "floor" == c.type ? c.floorLocation = c.floorLocation.toUpperCase() : "copyTransforms" == c.type && (o = new Bv(i = v[c.target]), s = new zv(i), l = new Uv(i), o.name = s.name = l.name = c.name, o.mute = s.mute = l.mute = c.mute, e.constraints.push(o), e.constraints.push(s), e.constraints.push(l));
                                    var u = null;
                                    switch (c.type) {
                                        case "copyLocation":
                                            u = new Bv(v[c.target]);
                                            break;
                                        case "copyRotation":
                                            u = new zv(v[c.target]);
                                            break;
                                        case "copyScale":
                                            u = new Uv(v[c.target]);
                                            break;
                                        case "limitLocation":
                                            (u = new Gv).min.set(Number(c.minX), Number(c.minY), Number(c.minZ)), u.max.set(Number(c.maxX), Number(c.maxY), Number(c.maxZ));
                                            break;
                                        case "limitRotation":
                                            (u = new jv).axis = c.axis, u.min = c.min, u.max = c.max;
                                            break;
                                        case "limitScale":
                                            (u = new Wv).min.set(Number(c.minX), Number(c.minY), Number(c.minZ)), u.max.set(Number(c.maxX), Number(c.maxY), Number(c.maxZ));
                                            break;
                                        case "lockedTrack":
                                            (u = new Hv(v[c.target])).trackAxis = c.trackAxis, u.lockAxis = c.lockAxis;
                                            break;
                                        case "trackTo":
                                            (u = new Xv(v[c.target])).trackAxis = c.trackAxis, u.upAxis = c.upAxis;
                                            break;
                                        case "childOf":
                                            (u = new kv(v[c.target])).offsetMatrix = (new nr).fromArray(c.offsetMatrix);
                                            break;
                                        case "floor":
                                            (u = new Vv(v[c.target])).floorLocation = c.floorLocation, u.offset = c.offset
                                    }
                                    u && (u.name = c.name, u.mute = c.mute, e.constraints.push(u))
                                }
                        }
                        e.isMesh && (r && _i(r.useCastShadows) ? e.castShadow = r.useCastShadows : _i(e.material.castShadow) && (e.castShadow = e.material.castShadow), r && _i(r.useShadows) ? e.receiveShadow = r.useShadows : _i(e.material.receiveShadow) && (e.receiveShadow = e.material.receiveShadow)), h.extras && (e.userData.v3d = h.extras), r && (e.renderOrder = r.renderOrder, e.frustumCulled = r.frustumCulling, _i(r.groupNames) ? e.groupNames = r.groupNames : e.groupNames = []), e.isMesh && e.material.isMeshNodeMaterial && (((t = e.material).hasNode("MATTE_SHADOW_MX") || t.hasNode("AI_SHADOW_MATTE_MY")) && (t.transparent = !1, t.premultipliedAlpha = !0, y.assignDefaultBlending(t), e.renderOrder -= 1e3, e.castShadow = !1, e.receiveShadow = !0))
                    }), d
                })
            })
        })
    }, My.prototype.loadScenes = function() {
        var l = this.json,
            s = this,
            c = this.extensions;
        return this._withDependencies(["nodes"]).then(function(o) {
            return vy(l.scenes, function(e) {
                var t = new _a;
                _i(e.name) && (t.name = e.name), e.extras && (t.userData.v3d = e.extras);
                for (var n = e.nodes || [], r = 0, i = n.length; r < i; r++) ! function e(t, n, r) {
                    var i = r[t];
                    n.add(i), (i.isDirectionalLight || i.isSpotLight) && i.isFreeLight && n.add(i.target);
                    t = l.nodes[t];
                    if (t.children)
                        for (var a = t.children, o = 0, s = a.length; o < s; o++) e(a[o], i, r)
                }(n[r], t, o.nodes);
                var a = s.getExt(e, X_.S8S_V3D_SCENE_DATA);
                return a && (_i(a.light) && (e = c[X_.S8S_V3D_DATA].lights, t.add(e[a.light])), _i(a.postprocessing) && (t.postprocessing = a.postprocessing)), t
            })
        })
    }, My.prototype.getExt = function(e, t) {
        return e.extensions && e.extensions[t] ? e.extensions[t] : null
    }, My.prototype.texcoordToAttrName = function(e) {
        return "TEXCOORD_0" == e ? "uv" : "uv" + String(Number(e.split("TEXCOORD_")[1]) + 1)
    }, My.prototype.colorToAttrName = function(e) {
        return "COLOR_0" == e ? "color" : "color" + String(Number(e.split("COLOR_")[1]) + 1)
    }, My.prototype.assignDefaultBlending = function(e) {
        e.blending = Z, e.blendEquation = Q, e.blendSrc = pe, e.blendDst = _e
    };
    var wy, Sy = {
            fromCubeTexture: function(e) {
                for (var t, n, r = 0, i = new Tn, a = new Tn, o = new Mn, s = [0, 0, 0, 0, 0, 0, 0, 0, 0], l = new Eh, c = l.coefficients, u = 0; u < 6; u++) {
                    var d = e.image[u],
                        h = d.width,
                        f = d.height,
                        p = document.createElement("canvas");
                    p.width = h, p.height = f;
                    p = p.getContext("2d");
                    p.drawImage(d, 0, 0, h, f);
                    for (var f = p.getImageData(0, 0, h, f), m = f.data, v = f.width, g = 2 / v, _ = 0, y = m.length; _ < y; _ += 4) {
                        o.set(m[_] / 255, m[_ + 1] / 255, m[_ + 2] / 255, m[_ + 3] / 255), Ay(o, e.encoding);
                        var x = _ / 4,
                            b = (x % v + .5) * g - 1,
                            M = 1 - (Math.floor(x / v) + .5) * g;
                        switch (u) {
                            case 0:
                                i.set(-1, M, -b);
                                break;
                            case 1:
                                i.set(1, M, b);
                                break;
                            case 2:
                                i.set(-b, 1, -M);
                                break;
                            case 3:
                                i.set(-b, -1, M);
                                break;
                            case 4:
                                i.set(-b, M, 1);
                                break;
                            case 5:
                                i.set(b, M, -1)
                        }
                        x = i.lengthSq(), r += n = 4 / (Math.sqrt(x) * x), a.copy(i).normalize(), Eh.getBasisAt(a, s);
                        for (var w = 0; w < 9; w++) c[w].x += s[w] * o.x * n, c[w].y += s[w] * o.y * n, c[w].z += s[w] * o.z * n
                    }
                }
                t = 4 * Math.PI / r;
                for (w = 0; w < 9; w++) c[w].x *= t, c[w].y *= t, c[w].z *= t;
                return new Ch(l)
            },
            fromCubeRenderTarget: function(e, t) {
                for (var n, r, i = 0, a = new Tn, o = new Tn, s = new Mn, l = [0, 0, 0, 0, 0, 0, 0, 0, 0], c = new Eh, u = c.coefficients, d = 0; d < 6; d++) {
                    var h = t.width,
                        f = new Uint8Array(h * h * 4);
                    e.readRenderTargetPixels(t, 0, 0, h, h, f, d);
                    for (var p = 2 / h, m = 0, v = f.length; m < v; m += 4) {
                        s.set(f[m] / 255, f[m + 1] / 255, f[m + 2] / 255, f[m + 3] / 255), Ay(s, t.texture.encoding);
                        var g = m / 4,
                            _ = (g % h + .5) * p - 1,
                            y = 1 - (Math.floor(g / h) + .5) * p;
                        switch (d) {
                            case 0:
                                a.set(1, y, -_);
                                break;
                            case 1:
                                a.set(-1, y, _);
                                break;
                            case 2:
                                a.set(_, 1, -y);
                                break;
                            case 3:
                                a.set(_, -1, y);
                                break;
                            case 4:
                                a.set(_, y, 1);
                                break;
                            case 5:
                                a.set(-_, y, -1)
                        }
                        g = a.lengthSq(), i += r = 4 / (Math.sqrt(g) * g), o.copy(a).normalize(), Eh.getBasisAt(o, l);
                        for (var x = 0; x < 9; x++) u[x].x += l[x] * s.x * r, u[x].y += l[x] * s.y * r, u[x].z += l[x] * s.z * r
                    }
                }
                n = 4 * Math.PI / i;
                for (x = 0; x < 9; x++) u[x].x *= n, u[x].y *= n, u[x].z *= n;
                return new Ch(c)
            }
        },
        Ay = (wy = new Qr, function(e, t) {
            switch (t) {
                case Gt:
                    Ty(e, wy), wy.convertSRGBToLinear(), Ey(wy, e);
                    break;
                case jt:
                    Ty(e, wy), wy.convertRGBEToLinear(e.w), Ey(wy, e), e.w = 1;
                    break;
                case Vt:
                    break;
                default:
                    console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.")
            }
            return e
        });

    function Ty(e, t) {
        t.setRGB(e.x, e.y, e.z)
    }

    function Ey(e, t) {
        t.setX(e.r).setY(e.g).setZ(e.b)
    }
    var Cy = 256,
        Ly = [{
            relSize: 1,
            sigma: 0,
            origin: [0, 0]
        }, {
            relSize: .5,
            sigma: .025,
            origin: [0, 2 / 3]
        }, {
            relSize: .25,
            sigma: .07,
            origin: [.5, 2 / 3]
        }, {
            relSize: 1 / 8,
            sigma: .18,
            origin: [.75, 2 / 3]
        }, {
            relSize: 1 / 16,
            sigma: .24,
            origin: [.875, 2 / 3]
        }, {
            relSize: 1 / 16,
            sigma: .3,
            origin: [.875, 17 / 24]
        }, {
            relSize: 1 / 16,
            sigma: .36,
            origin: [.875, .75]
        }, {
            relSize: 1 / 16,
            sigma: .42,
            origin: [.875, 19 / 24]
        }, {
            relSize: 1 / 16,
            sigma: .48,
            origin: [.875, 20 / 24]
        }, {
            relSize: 1 / 16,
            sigma: .54,
            origin: [.875, .875]
        }, {
            relSize: 1 / 16,
            sigma: .6,
            origin: [.875, 22 / 24]
        }];

    function Py(e) {
        return Ly[e].relSize * Cy
    }
    var Ry = !1,
        Dy = 20,
        Oy = (_defineProperty(ff = {}, Vt, 0), _defineProperty(ff, Gt, 1), _defineProperty(ff, jt, 2), _defineProperty(ff, Ht, 3), _defineProperty(ff, Xt, 4), _defineProperty(ff, Yt, 5), _defineProperty(ff, r, 6), ff),
        Ny = new ms,
        Iy = null,
        Fy = null,
        ky = null,
        By = Ly.map(function(e, t) {
            for (var n = 1 / (Py(t) - 1), t = -n / 2, n = 1 + n / 2, r = [t, t, n, t, n, n, t, t, n, n, t, n], i = new Float32Array(108), a = new Float32Array(72), o = new Float32Array(36), s = 0; s < 6; s++) {
                var l = s % 3 * 2 / 3 - 1,
                    c = 2 < s ? 0 : -1,
                    c = [l, c, 0, l + 2 / 3, c, 0, l + 2 / 3, 1 + c, 0, l, c, 0, l + 2 / 3, 1 + c, 0, l, 1 + c, 0];
                i.set(c, 18 * s), a.set(r, 12 * s);
                c = [s, s, s, s, s, s];
                o.set(c, 6 * s)
            }
            n = new Oi;
            return n.setAttribute("position", new ri(i, 3)), n.setAttribute("uv", new ri(a, 2)), n.setAttribute("faceIndex", new ri(o, 1)), n
        }),
        zy = null,
        Uy = null,
        Vy = null,
        vf = (1 + Math.sqrt(5)) / 2,
        mf = 1 / vf,
        Gy = [new Tn(1, 1, 1), new Tn(-1, 1, 1), new Tn(1, 1, -1), new Tn(-1, 1, -1), new Tn(0, vf, mf), new Tn(0, vf, -mf), new Tn(mf, 0, vf), new Tn(-mf, 0, vf), new Tn(vf, mf, 0), new Tn(-vf, mf, 0)];

    function jy(e, t, n) {
        var r, i;
        this.flipCubemapX = !0, Uy = e, Object.defineProperties(this, {
            maxTileSize: {
                get: function() {
                    return Cy
                },
                set: function(e) {
                    Cy = e
                }
            },
            blurLinEncodingOptimization: {
                get: function() {
                    return Ry
                },
                set: function(e) {
                    Ry = e
                }
            }
        }), void 0 !== t && (this.maxTileSize = t), void 0 !== n && (this.blurLinEncodingOptimization = n), r = Dy, i = this.maxTileSize, e = this.blurLinEncodingOptimization, t = new Float32Array(r), n = new Tn(0, 1, 0), (n = new hu({
            defines: {
                n: r,
                cubeUV_maxTileSize: bi(i),
                linEncodingOptimization: e ? 1 : 0
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: t
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                lodIdx: {
                    value: 0
                },
                poleAxis: {
                    value: n
                },
                inputEncoding: {
                    value: Oy[Vt]
                },
                outputEncoding: {
                    value: Oy[Vt]
                }
            },
            vertexShader: ex(),
            fragmentShader: "\nprecision highp float;\nprecision highp int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float lodIdx;\nuniform vec3 poleAxis;\n\n".concat(tx(), "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n    float cosTheta = cos(theta);\n    // Rodrigues' axis-angle rotation\n    vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross(axis, vOutputDirection) * sin(theta)\n            + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n    return bilinearCubeUV(envMap, sampleDirection, lodIdx);\n}\n\nvoid main() {\n    vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n    if (all(equal(axis, vec3(0.0))))\n        axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n    axis = normalize(axis);\n    gl_FragColor = vec4(0.0);\n    gl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n    for (int i = 1; i < n; i++) {\n        if (i >= samples)\n            break;\n        float theta = dTheta * float(i);\n        gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n        gl_FragColor.rgb += weights[i] * getSample(theta, axis);\n    }\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: se,
            depthTest: !1,
            depthWrite: !1
        })).type = "SphericalGaussianBlur", Xy(Iy = n)
    }

    function Wy(e, t) {
        var n = {
            magFilter: Ue,
            minFilter: Ue,
            generateMipmaps: !1,
            type: e ? e.type : je,
            format: e ? e.format : w,
            encoding: e ? e.encoding : jt,
            depthBuffer: !1,
            stencilBuffer: !1
        };
        Object.assign(n, t);
        t = Yy(n);
        return t.depthBuffer = !e, zy = Yy(n), t
    }

    function Hy(e) {
        zy.dispose(), Uy.setRenderTarget(Vy), e.scissorTest = !1, e.setSize(e.width, e.height)
    }

    function Xy(e) {
        var t = new _a;
        t.add(new Ki(By[0], e)), Uy.compile(t, Ny)
    }

    function Yy(e) {
        var t = Py(0),
            e = new wn(3 * t, 3 * t, e);
        return e.texture.mapping = B, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
    }

    function qy(e, t, n, r, i) {
        e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
    }

    function Zy(e) {
        var t = Uy.autoClear;
        Uy.autoClear = !1;
        for (var n = 1; n < Ly.length; n++) {
            var r = Ly[n].sigma,
                i = Ly[n - 1].sigma;
            Qy(e, n - 1, n, Math.sqrt(r * r - i * i), Gy[(n - 1) % Gy.length])
        }
        Uy.autoClear = t
    }

    function Qy(e, t, n, r, i) {
        Ky(e, zy, t, n, r, "latitudinal", i), Ky(zy, e, n, n, r, "longitudinal", i)
    }

    function Ky(e, t, n, r, i, a, o) {
        "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
        var s = new _a;
        s.add(new Ki(By[r], Iy));
        var l = Iy.uniforms,
            c = Py(n) - 1,
            c = isFinite(i) ? Math.PI / (2 * c) : 2 * Math.PI / (2 * Dy - 1),
            u = i / c,
            d = isFinite(i) ? 1 + Math.floor(3 * u) : Dy;
        Dy < d && (c = i / (u = ((d = Dy) - 1) / 3));
        for (var h = [], f = 0, p = 0; p < Dy; ++p) {
            var m = p / u,
                m = Math.exp(-m * m / 2);
            h.push(m), 0 == p ? f += m : p < d && (f += 2 * m)
        }
        for (var v = 0; v < h.length; v++) h[v] = h[v] / f;
        l.envMap.value = e.texture, l.samples.value = d, l.weights.value = h, l.latitudinal.value = "latitudinal" === a, o && (l.poleAxis.value = o), l.dTheta.value = c, l.lodIdx.value = n, l.inputEncoding.value = Oy[e.texture.encoding], l.outputEncoding.value = Oy[e.texture.encoding];
        l = Iy.defines;
        l.cubeUV_maxTileSize = bi(Py(0)), l.linEncodingOptimization = Ry ? 1 : 0;
        e = _slicedToArray(Ly[r].origin.map(function(e) {
            return e * Cy * 3
        }), 2), l = e[0], e = e[1], r = Py(r);
        qy(t, l, e, 3 * r, 2 * r), Uy.setRenderTarget(t), Uy.render(s, Ny)
    }

    function Jy() {
        var e = new hu({
            defines: {
                linEncodingOptimization: 0
            },
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: new vn(1, 1)
                },
                inputEncoding: {
                    value: Oy[Vt]
                },
                outputEncoding: {
                    value: Oy[Vt]
                }
            },
            vertexShader: ex(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n".concat(tx(), "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n    gl_FragColor = vec4(0.0);\n    vec3 outputDirection = normalize(vOutputDirection);\n    vec2 uv;\n    uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n    uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n    vec2 f = fract(uv / texelSize - 0.5);\n    uv -= f * texelSize;\n    vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.x += texelSize.x;\n    vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.y += texelSize.y;\n    vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.x -= texelSize.x;\n    vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    vec3 tm = mix(tl, tr, f.x);\n    vec3 bm = mix(bl, br, f.x);\n    gl_FragColor.rgb = mix(tm, bm, f.y);\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: se,
            depthTest: !1,
            depthWrite: !1
        });
        return e.type = "EquirectangularToCubeUV", e
    }

    function $y() {
        var e = new hu({
            defines: {
                linEncodingOptimization: 0
            },
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Oy[Vt]
                },
                outputEncoding: {
                    value: Oy[Vt]
                },
                flipCubemapX: {
                    value: !0
                }
            },
            vertexShader: ex(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\nuniform bool flipCubemapX;\n\n".concat(tx(), "\n\nvoid main() {\n    gl_FragColor = vec4(0.0);\n    gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3(vOutputDirection.x * (flipCubemapX ? -1.0 : 1.0), vOutputDirection.yz))).rgb;\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: se,
            depthTest: !1,
            depthWrite: !1
        });
        return e.type = "CubemapToCubeUV", e
    }

    function ex() {
        return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n    uv = 2.0 * uv - 1.0;\n    vec3 direction = vec3(uv, 1.0);\n    if (face == 0.0) {\n        direction = direction.zyx;\n        direction.z *= -1.0;\n    } else if (face == 1.0) {\n        direction = direction.xzy;\n        direction.z *= -1.0;\n    } else if (face == 3.0) {\n        direction = direction.zyx;\n        direction.x *= -1.0;\n    } else if (face == 4.0) {\n        direction = direction.xzy;\n        direction.y *= -1.0;\n    } else if (face == 5.0) {\n        direction.xz *= -1.0;\n    }\n    return direction;\n}\nvoid main() {\n    vOutputDirection = getDirection(uv, faceIndex);\n    gl_Position = vec4(position, 1.0);\n}\n    "
    }

    function tx() {
        return "\n\n#if linEncodingOptimization\n\n    vec4 linearToOutputTexel(vec4 value) {\n        return value;\n    }\n\n    vec4 envMapTexelToLinear(vec4 color) {\n        return color;\n    }\n\n#else\n\n    uniform int inputEncoding;\n    uniform int outputEncoding;\n\n    #include <encodings_pars_fragment>\n\n    vec4 inputTexelToLinear(vec4 value){\n        if(inputEncoding == 0){\n            return value;\n        }else if(inputEncoding == 1){\n            return sRGBToLinear(value);\n        }else if(inputEncoding == 2){\n            return RGBEToLinear(value);\n        }else if(inputEncoding == 3){\n            return RGBMToLinear(value, 7.0);\n        }else if(inputEncoding == 4){\n            return RGBMToLinear(value, 16.0);\n        }else if(inputEncoding == 5){\n            return RGBDToLinear(value, 256.0);\n        }else{\n            return GammaToLinear(value, 2.2);\n        }\n    }\n\n    vec4 linearToOutputTexel(vec4 value){\n        if(outputEncoding == 0){\n            return value;\n        }else if(outputEncoding == 1){\n            return LinearTosRGB(value);\n        }else if(outputEncoding == 2){\n            return LinearToRGBE(value);\n        }else if(outputEncoding == 3){\n            return LinearToRGBM(value, 7.0);\n        }else if(outputEncoding == 4){\n            return LinearToRGBM(value, 16.0);\n        }else if(outputEncoding == 5){\n            return LinearToRGBD(value, 256.0);\n        }else{\n            return LinearToGamma(value, 2.2);\n        }\n    }\n\n    vec4 envMapTexelToLinear(vec4 color) {\n        return inputTexelToLinear(color);\n    }\n\n#endif\n    "
    }

    function nx(e, t, n, r, i) {
        this._domElement = e, this._keyCode = t, this._callback = n, this._repeats = r, this._period = i, this._timer = 0, this._counter = 0, this._keydownCb = function(e) {
            e.keyCode == this._keyCode && (this._timer || (this._timer = window.setTimeout(function() {
                this._counter = 0, this._timer = null
            }.bind(this), 1e3 * i)), ++this._counter >= r && (this._timer && (window.clearTimeout(this._timer), this._timer = null), this._counter = 0, this._callback()))
        }.bind(this), this._domElement.addEventListener("keydown", this._keydownCb, !1)
    }

    function rx(e) {
        this.data = void 0 !== e ? e : null, this.useHDR = !1
    }
    jy.prototype = {
        constructor: jy,
        fromScene: function(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : .1,
                r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 100;
            Vy = Uy.getRenderTarget();
            var i = Wy();
            return function(e, t, n, r) {
                var i = new la(90, 1, t, n),
                    a = [1, 1, 1, 1, -1, 1],
                    o = [1, 1, -1, -1, -1, 1],
                    s = Uy.outputEncoding,
                    l = Uy.toneMapping,
                    c = Uy.toneMappingExposure,
                    u = Uy.getClearColor(),
                    d = Uy.getClearAlpha();
                Uy.toneMapping = Oe, Uy.toneMappingExposure = 1, Uy.outputEncoding = Vt, e.scale.z *= -1, (t = e.background) && t.isColor && (t.convertSRGBToLinear(), n = Math.max(t.r, t.g, t.b), n = Math.min(Math.max(Math.ceil(Math.log2(n)), -128), 127), t = t.multiplyScalar(Math.pow(2, -n)), n = (n + 128) / 255, Uy.setClearColor(t, n), e.background = null);
                for (var h = 0; h < 6; h++) {
                    var f = h % 3;
                    0 == f ? (i.up.set(0, a[h], 0), i.lookAt(o[h], 0, 0)) : 1 == f ? (i.up.set(0, 0, a[h]), i.lookAt(0, o[h], 0)) : (i.up.set(0, a[h], 0), i.lookAt(0, 0, o[h]));
                    var p = Py(0);
                    qy(r, f * p, 2 < h ? p : 0, p, p), Uy.setRenderTarget(r), Uy.render(e, i)
                }
                Uy.toneMapping = l, Uy.toneMappingExposure = c, Uy.outputEncoding = s, Uy.setClearColor(u, d), e.scale.z *= -1
            }(e, n, r, i), 0 < t && Qy(i, 0, 0, t), Zy(i), Hy(i), i
        },
        fromEquirectangular: function(e) {
            return e.magFilter = Ue, e.minFilter = Ue, e.generateMipmaps = !1, this.fromCubemap(e)
        },
        fromCubemap: function(e) {
            Vy = Uy.getRenderTarget();
            var t = Wy(e);
            return function(e, t, n) {
                var r = new _a;
                e.isCubeTexture ? null == ky && (ky = $y()) : null == Fy && (Fy = Jy());
                var i = e.isCubeTexture ? ky : Fy;
                r.add(new Ki(By[0], i)), ((i = i.uniforms).envMap.value = e).isCubeTexture ? i.flipCubemapX.value = n || !1 : i.texelSize.value.set(1 / e.image.width, 1 / e.image.height), i.inputEncoding.value = Oy[e.encoding], i.outputEncoding.value = Oy[e.encoding], e = Py(0), qy(t, 0, 0, 3 * e, 2 * e), Uy.setRenderTarget(t), Uy.render(r, Ny)
            }(e, t, this.flipCubemapX), Zy(t), Hy(t), t
        },
        fromCubeRenderTarget: function(e, t) {
            t = Wy(e.texture, t);
            return function(e, t, n) {
                var r = new _a;
                null == ky && (ky = $y());
                var i = ky;
                r.add(new Ki(By[0], i)), (i = i.uniforms).envMap.value = e.texture, i.flipCubemapX.value = n || !1, i.inputEncoding.value = Oy[e.texture.encoding], i.outputEncoding.value = Oy[t.texture.encoding], i = Py(0), qy(t, 0, 0, 3 * i, 2 * i), Uy.setRenderTarget(t), Uy.render(r, Ny)
            }(e, t, this.flipCubemapX), Zy(t), Hy(t), t
        },
        compileCubemapShader: function() {
            null == ky && Xy(ky = $y())
        },
        compileEquirectangularShader: function() {
            null == Fy && Xy(Fy = Jy())
        },
        dispose: function() {
            Iy.dispose(), null != ky && ky.dispose(), null != Fy && Fy.dispose();
            for (var e = 0; e < By.length; e++) By[e].dispose()
        }
    }, Object.assign(nx.prototype, {
        dispose: function() {
            this._domElement.removeEventListener("keydown", this._keydownCb, !1), this._timer && window.clearTimeout(this._timer)
        }
    }), Object.assign(rx.prototype, {
        isSceneBackground: !0,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            null === e.data ? this.data = null : e.data.isColor ? this.data = e.data.clone() : e.data.isCubeTexture || e.data.isTexture ? (this.data = e.data.clone(), this.data.needsUpdate = !0) : e.data.isWebGLCubeRenderTarget ? (this.data = e.data.clone(), this.data.texture.needsUpdate = !0) : this.data = e.data, this.useHDR = e.useHDR
        },
        toJSON: function(e) {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "SceneBackground",
                    generator: "SceneBackground.toJSON"
                }
            };
            return null !== this.data && (t.data = this.data.toJSON(e)), t
        }
    });
    var ix = {
            createMultiMaterialObject: function(e, t) {
                for (var n = new As, r = 0, i = t.length; r < i; r++) n.add(new Ki(e, t[r]));
                return n
            },
            detach: function(e, t, n) {
                e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
            },
            attach: function(e, t, n) {
                e.applyMatrix((new nr).copy(n.matrixWorld).invert()), t.remove(e), n.add(e)
            },
            getMaterialByName: function(e, t) {
                t = this.getMaterialsByName(e, t);
                return t.length ? t[0] : null
            },
            getMaterialsByName: function(e, t) {
                var n = [];
                null !== e.scene && e.scene.traverse(function(e) {
                    e.material && e.material.name === t && -1 === n.indexOf(e.material) && n.push(e.material)
                });
                e = e.worldMaterial;
                return e && e.name === t && -1 === n.indexOf(e) && n.push(e), n
            },
            getAnimationActionByName: function(e, t) {
                for (var n = 0; n < e.actions.length; n++) {
                    var r = e.actions[n];
                    if (r.getClip().name == t) return r
                }
                return null
            },
            checkActionIsUsed: function(t, e) {
                return Boolean(e._propertyBindings.find(function(e) {
                    e = e.binding.node;
                    return e && e.findRoot() === t
                }))
            },
            createEnvironmentMaterial: function(e, t, n) {
                var r = new Su.DiGraph(6),
                    i = {};
                return r.node(0).originData = {
                    name: "Light Path",
                    type: "LIGHT_PATH_BL",
                    inputs: [],
                    outputs: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    is_active_output: !1
                }, r.node(1).originData = {
                    name: "Lighting Texture",
                    type: "TEX_ENVIRONMENT_BL",
                    projection: "EQUIRECTANGULAR",
                    inputs: [
                        [0, 0, 0]
                    ],
                    outputs: [
                        [0, 0, 0, 0]
                    ],
                    texture: 0,
                    is_active_output: !1
                }, i[_d.nodeTexUniName("TEX_ENVIRONMENT_BL", 0)] = t, n instanceof Qr ? ((t = [0, 0, 0, 0])[0] = n.r, t[1] = n.g, t[2] = n.b, t[3] = 1, r.node(2).originData = {
                    name: "Background Color",
                    type: "RGB_BL",
                    inputs: [],
                    outputs: [t],
                    is_active_output: !1
                }) : (r.node(2).originData = {
                    name: "Background Texture",
                    type: "TEX_ENVIRONMENT_BL",
                    projection: "EQUIRECTANGULAR",
                    inputs: [
                        [0, 0, 0]
                    ],
                    outputs: [
                        [0, 0, 0, 0]
                    ],
                    texture: 1,
                    is_active_output: !1
                }, i[_d.nodeTexUniName("TEX_ENVIRONMENT_BL", 1)] = n), r.node(3).originData = {
                    name: "Mix",
                    type: "MIX_RGB_BL",
                    blendType: "MIX",
                    inputs: [0, [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    outputs: [
                        [0, 0, 0, 0]
                    ],
                    is_active_output: !1
                }, r.node(4).originData = {
                    name: "Background",
                    type: "BACKGROUND_BL",
                    inputs: [
                        [0, 0, 0, 0], 1
                    ],
                    outputs: [
                        [0, 0, 0, 0]
                    ],
                    is_active_output: !1
                }, r.node(5).originData = {
                    name: "Output",
                    type: "OUTPUT_WORLD_BL",
                    inputs: [
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    outputs: [],
                    is_active_output: !0
                }, yd(r, 0, 0, 3, 0), yd(r, 1, 0, 3, 1), yd(r, 2, 0, 3, 2), yd(r, 3, 0, 4, 0), yd(r, 4, 0, 5, 0), new _d({
                    name: e,
                    nodeGraph: r,
                    nodeTextures: i
                })
            },
            calcSceneBox: function(e) {
                var t = new Ln;
                return t.expandByObject(e), t
            },
            createDefaultCamera: function(e, t) {
                var n = new Tn,
                    r = 2 * e.getSize(n).length(),
                    r = new la(45, t, r / 1e4, r);
                return r.position.copy(e.max).multiplyScalar(2), r.lookAt(e.getCenter(n)), r
            },
            assignDefaultControls: function(e, t) {
                var n = new Er;
                t.getCenter(n.position), e.controls = {
                    type: "ORBIT",
                    enablePan: !0,
                    rotateSpeed: 1,
                    moveSpeed: 1,
                    orbitMinDistance: e.near,
                    orbitMaxDistance: e.far,
                    orbitMinPolarAngle: 0,
                    orbitMaxPolarAngle: Math.PI,
                    orbitMinAzimuthAngle: -1 / 0,
                    orbitMaxAzimuthAngle: 1 / 0,
                    orbitTarget: n
                }
            }
        },
        ax = function() {
            var n = 0,
                r = document.createElement("div");

            function e(e) {
                return r.appendChild(e.dom), e
            }

            function t(e) {
                for (var t = 0; t < r.children.length; t++) r.children[t].style.display = t === e ? "block" : "none";
                n = e
            }
            r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(e) {
                e.preventDefault(), t(++n % r.children.length)
            }, !1);
            var i, a = (performance || Date).now(),
                o = a,
                s = 0,
                l = e(new ax.Panel("FPS", "#0ff", "#002")),
                c = e(new ax.Panel("MS", "#0f0", "#020"));
            return self.performance && self.performance.memory && (i = e(new ax.Panel("MB", "#f08", "#201"))), t(0), {
                REVISION: 16,
                dom: r,
                addPanel: e,
                showPanel: t,
                begin: function() {
                    a = (performance || Date).now()
                },
                end: function() {
                    s++;
                    var e, t = (performance || Date).now();
                    return c.update(t - a, 200), o + 1e3 <= t && (l.update(1e3 * s / (t - o), 100), o = t, s = 0, i && (e = performance.memory, i.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576))), t
                },
                update: function() {
                    a = this.end()
                },
                domElement: r,
                setMode: t
            }
        };
    ax.Panel = function(n, r, i) {
        var a = 1 / 0,
            o = 0,
            s = Math.round,
            l = s(window.devicePixelRatio || 1),
            c = 80 * l,
            e = 48 * l,
            u = 3 * l,
            d = 2 * l,
            h = 3 * l,
            f = 15 * l,
            p = 74 * l,
            m = 30 * l,
            v = document.createElement("canvas");
        v.width = c, v.height = e, v.style.cssText = "width:80px;height:48px";
        var g = v.getContext("2d");
        return g.font = "bold " + 9 * l + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = i, g.fillRect(0, 0, c, e), g.fillStyle = r, g.fillText(n, u, d), g.fillRect(h, f, p, m), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(h, f, p, m), {
            dom: v,
            update: function(e, t) {
                a = Math.min(a, e), o = Math.max(o, e), g.fillStyle = i, g.globalAlpha = 1, g.fillRect(0, 0, c, f), g.fillStyle = r, g.fillText(s(e) + " " + n + " (" + s(a) + "-" + s(o) + ")", u, d), g.drawImage(v, h + l, f, p - l, m, h, f, p - l, m), g.fillRect(h + p - l, f, l, m), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(h + p - l, f, l, s((1 - e / t) * m))
            }
        }
    };
    var ox = ["toneMapping", "toneMappingMidTones", "toneMappingPhysicalScale", "toneMappingBrightness", "toneMappingContrast", "toneMappingChromaticAdaptation", "toneMappingWhiteColor", "toneMappingColorDifferentiation", "toneMappingExteriorDaylight", "toneMappingWhiteBalance", "toneMappingHighlights", "toneMappingShadows", "toneMappingSaturation", "toneMappingAperture", "toneMappingShutter", "toneMappingISO", "toneMappingVignetting"];

    function sx(e, t, n) {
        return 2 * mn.RAD2DEG * Math.atan(Math.tan(mn.DEG2RAD * e / 2) * t / n)
    }
    var lx, cx, ux, dx, hx, fx, gf = function() {
            _inherits(a, n);
            var i = _createSuper(a);

            function a(e, t, n) {
                var r;
                return _classCallCheck(this, a), (r = i.call(this)).container = e instanceof HTMLElement ? e : document.getElementById(e), Es.checkWebGL() ? (r.scene = null, r.camera = null, r.clock = new Kh, r.mixer = null, r.renderCallbacks = [], r.compileCallbacks = [], r.elapsed = 0, r.frame = 0, r.preloader = n, r.worldMaterial = null, r.worldCubemapRes = 1024, r._pmremMaxTileSize = 256, r._lightProbeCubemapRes = 64, r.xrSession = null, r.xrControllers = [], void 0 === (t = t || {}).alpha && (t.alpha = !1), void 0 === t.depth && (t.depth = !0), void 0 === t.stencil && (t.stencil = !0), void 0 === t.antialias && (t.antialias = !0), void 0 === t.premultipliedAlpha && (t.premultipliedAlpha = !0), void 0 === t.preserveDrawingBuffer && (t.preserveDrawingBuffer = !1), r.renderer = new Is(t), Ng.prepareRenderer(r.renderer), r.clearBkgOnLoad = !1, r.frameRateDivider = 1, r.enableRender = !0, r.disableRenderTrigger = 0, r.ssaaOnPause = !1, r.renderer.setSize(r.container.offsetWidth, r.container.offsetHeight), r.renderer.outputEncoding = Gt, r.container.appendChild(r.renderer.domElement), r.container.classList.add("v3d-container"), r.renderer.domElement.classList.add("v3d-canvas"), r.loader = new W_, Oi.prototype.computeBoundsTree = tv, Oi.prototype.disposeBoundsTree = nv, Ki.prototype.raycast = ev, r.actions = [], r.materials = {
                    push: function() {}
                }, r.updateMaterials = function() {}, r._envIBLMode = cn, r._envRTargetIBL = null, r._envLightProbe = null, r._resizeCb = null, r._loadingTime = 0, r._postprocessingSave = null, r.stats = null, Og.drawWatermark(_assertThisInitialized(r)), Og.addToAppList(_assertThisInitialized(r)), Es.checkIOS() && "polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill && Og.requestDeviceMotionPermissions(), r) : (Es.showWebGLErrorMessage(r.container), _possibleConstructorReturn(r))
            }
            return _createClass(a, [{
                key: "_updateRendererFromGLTF",
                value: function(e) {
                    var t = Es.checkHalfFloatTex(this.renderer, !0);
                    if (e.renderer.shadowMap ? (this.renderer.shadowMap.enabled = e.renderer.shadowMap.enabled, this.renderer.shadowMap.type = e.renderer.shadowMap.type, t || this.renderer.shadowMap.type !== te || (this.renderer.shadowMap.type = $, e.scene.traverse(function(e) {
                            e.isLight && e.castShadow && e.shadow && (e.shadow.bias /= 100, e.shadow.isDirectionalLightShadowCSM && (e.shadow.radius *= 100 / e.shadow.mapSize.x / 2, e.shadow = (new Mh).copy(e.shadow), e.shadow.camera.updateProjectionMatrix()))
                        }))) : (this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = $), e.scene.traverse(function(e) {
                            e.isRectAreaLight
                        }), e.renderer.physicallyCorrectLights && (this.renderer.physicallyCorrectLights = !0), this.aaMethod = e.renderer.aaMethod || "AUTO", this.useHDR = Boolean(e.renderer.useHDR && t), this.renderer.unitsScaleFactor = e.renderer.unitsScaleFactor, e.renderer.toneMapping)
                        for (var n = 0; n < ox.length; n++) {
                            var r = ox[n];
                            _i(e.renderer[r]) && (this.renderer[r] = e.renderer[r])
                        }
                    void 0 !== e.renderer.pmremMaxTileSize && (this._pmremMaxTileSize = e.renderer.pmremMaxTileSize), void 0 !== e.renderer.iblEnvironmentMode && (this._envIBLMode = e.renderer.iblEnvironmentMode), void 0 !== e.renderer.esmDistanceScale && (this.renderer.shadowMap.esmDistanceScale = e.renderer.esmDistanceScale)
                }
            }, {
                key: "_updateMeshesRaycastFromGLTF",
                value: function(e) {
                    e.scene && e.scene.traverse(function(e) {
                        var t = e.geometry;
                        e.isMesh && (!t.computeBoundsTree || 0 !== Object.keys(t.morphAttributes).length || t.attributes.position.isInterleavedBufferAttribute || t.index && t.index.isInterleavedBufferAttribute || t.computeBoundsTree({
                            verbose: !1
                        }))
                    })
                }
            }, {
                key: "_updateMaterialsFromGLTF",
                value: function(e) {
                    var t = this;
                    e.scene && e.scene.traverse(function(e) {
                        e = e.material;
                        e && t.useHDR && (e.useHDR = !0, e.useFloatTex = Es.checkFloatTex(t.renderer, !0), e.isMeshNodeMaterial && e.updateNodeGraph())
                    })
                }
            }, {
                key: "_updateAnimationsFromGLTF",
                value: function(e, n) {
                    var r = this;
                    !r.mixer && e.animations && e.animations.length && (r.mixer = new Tf(r.scene)), (e.animations || []).forEach(function(e) {
                        var t = n.getObjectById(e.nodeId);
                        t && ((t = t.id == n.id || "" !== t.name && "root" !== t.name && "." !== t.name && t.name !== n.name && t.name !== n.uuid ? r.mixer.clipAction(e.clip, n) : r.mixer.clipAction(e.clip, t)).setLoop(e.loop, e.repetitions), t.startAt(e.startAt + r.mixer.time), t.clampWhenFinished = !0, e.auto ? t.play() : (t.stop(), t.paused = !0), r.actions.push(t))
                    })
                }
            }, {
                key: "_updateSceneEnvIBL",
                value: function(e, t) {
                    null !== t && this._traverseSceneForEnvUpdates(e, function(e) {
                        e.material.envMap = t.texture, e.material.needsUpdate = !0
                    })
                }
            }, {
                key: "_traverseSceneForEnvUpdates",
                value: function(e, t) {
                    e.traverse(function(e) {
                        e.isMesh && e.material && (e.material.isMeshStandardMaterial || e.material.isMeshPhysicalMaterial || e.material.isMeshNodeMaterial) && t(e)
                    })
                }
            }, {
                key: "_traverseSceneForTexUniforms",
                value: function(e, n) {
                    e.traverse(function(t) {
                        t.material && (Array.isArray(t.material) ? t.material : [t.material]).forEach(function(e) {
                            void 0 !== e.program && n(t, e, e.program.getTexUniformCount())
                        })
                    })
                }
            }, {
                key: "_checkMSAA",
                value: function(e, t) {
                    return Math.min(t, e.capabilities.maxSamples)
                }
            }, {
                key: "_precompileSceneAsync",
                value: function(e, t, n, r) {
                    for (var i = this, a = i.compileCallbacks, o = 0; o < a.length; o++) a[o](i);
                    var s = i.renderer.getRenderTarget();
                    i.renderer.setRenderTarget(n), i.renderer.compileAsync(e, t, function(e) {
                        1 <= e && i.renderer.setRenderTarget(s), r && r(100 * e)
                    })
                }
            }, {
                key: "load",
                value: function(e, t, n, r) {
                    console.warn("v3d.App.load has been deprecated. Use v3d.App.loadScene instead.");
                    var i = this;
                    i.loadScene(e, function(e) {
                        t(e), r && i.run()
                    }, null, n)
                }
            }, {
                key: "loadScene",
                value: function(e, r, i, t) {
                    var a = this;
                    a.renderer ? (a._loadingTime = performance.now(), a.preloader && a.preloader.onUpdate(0), this.loader.load(e, function(t) {
                        a.scene = t.scene || new _a;
                        var e = null;
                        t.cameras && t.cameras.length ? a.camera = t.cameras[0] : (e = ix.calcSceneBox(a.scene), a.camera = ix.createDefaultCamera(e, a.container.offsetWidth / a.container.offsetHeight), a.scene.add(a.camera)), a.camera.controls || (e = e || ix.calcSceneBox(a.scene), ix.assignDefaultControls(a.camera, ix.calcSceneBox(a.scene)), a.camera.viewportFit.type = 1), a._updateRendererFromGLTF(t), a._updateMaterialsFromGLTF(t), a._updateAnimationsFromGLTF(t, a.scene);
                        e = t.world.material;
                        e && (a.scene.background = new rx, a.updateEnvironment(e), a.worldMaterial = e), a.initPostprocessing(), a.onResize && a.onResize(), a.scene.updateMatrixWorld(), a.scene.visible = !1, a.scene.disableChildRendering = !0;
                        var n = function() {
                                a.scene && a._traverseSceneForTexUniforms(a.scene, function(e, t, n) {
                                    8 < n && console.warn('v3d.App: Material "'.concat(t.name, '" on object ') + '"'.concat(e.name, '" exceeds iOS limit of ') + "".concat(8, " textures ") + "(has ".concat(n, ")."))
                                }), a.removeEventListener("firstFrameRendered", n)
                            },
                            e = a.postprocessing ? a.postprocessing.composer.renderTarget1 : null;
                        a._precompileSceneAsync(a.scene, a.camera, e, function(e) {
                            e = 60 + .4 * e;
                            i && i(e), a.preloader && a.preloader.onUpdate(e), 100 <= e && (a._updateMeshesRaycastFromGLTF(t), a.addEventListener("firstFrameRendered", n), r && setTimeout(function() {
                                a.scene.visible = !0, a.scene.disableChildRendering = !1, a._loadingTime = performance.now() - a._loadingTime, a.dispatchEvent({
                                    type: "loadSceneEnd"
                                }), r(a.scene)
                            }, 16))
                        }), a.clearBkgOnLoad && (a.scene.background = null), a._tripleP = new nx(window, Qv.P, function() {
                            Og.printPerformanceInfo(a, 1)
                        }, 3, 1), a._tripleF = new nx(window, Qv.F, function() {
                            a.stats ? a.hideFPS() : a.showFPS()
                        }, 3, 1)
                    }, function(e) {
                        e *= .6;
                        i && i(e), a.preloader && a.preloader.onUpdate(e)
                    }, function(e) {
                        console.error(e), t && t(e)
                    }), window.removeEventListener("resize", this._resizeCb, !1), this._resizeCb = function() {
                        a.onResize && a.onResize()
                    }, window.addEventListener("resize", this._resizeCb, !1)) : t && t("WebGL not found")
                }
            }, {
                key: "appendScene",
                value: function(e, a, o, t, s, l) {
                    var c = this;
                    c.renderer ? (void 0 === s && (s = !0), void 0 === l && (l = !0), c.preloader && c.preloader.onUpdate(0), this.loader.load(e, function(t) {
                        var n = t.scene || new _a,
                            r = [];
                        n.traverse(function(e) {
                            (e.isCamera && !s || e.isLight && !l) && r.push(e)
                        }), r.forEach(function(e) {
                            c.unload(e)
                        }), c.scene && (c.scene.add(n), c._updateMaterialsFromGLTF(t), c._updateAnimationsFromGLTF(t, n), c._updateSceneEnvIBL(n, c._envRTargetIBL), c.scene.updateMatrixWorld());
                        var e = c.postprocessing ? c.postprocessing.composer.renderTarget1 : null,
                            i = c.scene || n;
                        n.visible = !1, n.disableChildRendering = !0, c._precompileSceneAsync(i, c.camera || new sa, e, function(e) {
                            e = 60 + .4 * e;
                            o && o(e), c.preloader && c.preloader.onUpdate(e), 100 <= e && (c._updateMeshesRaycastFromGLTF(t), c._traverseSceneForTexUniforms(n, function(e, t, n) {
                                8 < n && console.warn('v3d.App: Material "'.concat(t.name, '" on object ') + '"'.concat(e.name, '" exceeds iOS limit of ') + "".concat(8, " textures ") + "(has ".concat(n, ")."))
                            }), a && setTimeout(function() {
                                n.visible = !0, n.disableChildRendering = !1, a(n)
                            }, 16))
                        })
                    }, function(e) {
                        e *= .6;
                        o && o(e), c.preloader && c.preloader.onUpdate(e)
                    }, function(e) {
                        console.error(e), t && t(e)
                    })) : t && t("WebGL not found")
                }
            }, {
                key: "unload",
                value: function(e) {
                    var t = this;

                    function n(e) {
                        e.isAnnotation ? e.dispose() : e.isLight && e.shadow && e.shadow.isLightShadow ? e.shadow.dispose() : e.isCamera && e.controls && e.controls.orbitTarget ? n(e.controls.orbitTarget) : e.isMesh && (e.geometry.dispose(), e.geometry.disposeBoundsTree && e.geometry.disposeBoundsTree(), e = e.material, Nv.disposeTextures(e), e.dispose())
                    }
                    if ((e = e || t.scene) === t.scene) {
                        if (t.scene && (t.scene.traverse(n), t.disposeEnvironment()), t.scene = null, t.controls && t.controls.dispose && t.controls.dispose(), t.controls = null, t.camera = null, t.mixer && (t.mixer.stopAllAction(), t.actions.forEach(function(e) {
                                t.mixer.uncacheAction(e.getClip(), e.getRoot())
                            })), t.mixer = null, t.actions = [], t.postprocessing) {
                            if (t.postprocessing.composer)
                                for (var r in t.postprocessing) {
                                    var i = t.postprocessing[r];
                                    (i instanceof og || i instanceof Ig) && i.dispose()
                                }
                            t.disablePostprocessing()
                        }
                        t.postprocessing = null, og.FullScreenQuad.dispose(), t.renderer && t.renderer.disposeInternalCaches(), t._tripleP && t._tripleP.dispose(), t._tripleF && t._tripleF.dispose()
                    } else if (t.scene && (e.traverse(n), e.parent && e.parent.remove(e)), t.mixer)
                        for (var a = t.actions.length - 1; 0 <= a; a--) {
                            var o = t.actions[a];
                            ix.checkActionIsUsed(t.scene, o) || (o.stop(), t.mixer.uncacheAction(o.getClip(), o.getRoot()), t.actions.splice(a, 1))
                        }
                }
            }, {
                key: "dispose",
                value: function() {
                    this.scene && this.unload(), this.renderer && (this.renderer.forceContextLoss(), this.renderer.dispose(), this.renderer.domElement.parentElement === this.container && this.container.removeChild(this.renderer.domElement)), this.renderer = null, window.removeEventListener("resize", this._resizeCb, !1), Og.removeFromAppList(this), Nd.clear(), this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, {
                key: "getWidth",
                value: function() {
                    return this.container.offsetWidth
                }
            }, {
                key: "getHeight",
                value: function() {
                    return this.container.offsetHeight
                }
            }, {
                key: "onResize",
                value: function() {
                    this.enableRender && !this.ssaaOnPause || (this.enableRendering(), this.disableRendering(1));
                    var e, t = this.getWidth(),
                        n = this.getHeight();
                    if (this.renderer.setSize(t, n), this.postprocessing && (e = this.renderer.getPixelRatio(), this.postprocessing.composer.setSize(t * e, n * e)), this.scene) {
                        var r = t / n,
                            i = this.camera;
                        if (i.isPerspectiveCamera) switch (i.viewportFit.type) {
                            case 1:
                                i.aspect = r;
                                break;
                            case 2:
                                i.fov = sx(i.fov, i.aspect, r), i.aspect = r;
                                break;
                            case 3:
                                var a = i.aspect < i.viewportFit.initialAspect,
                                    o = r < i.viewportFit.initialAspect;
                                a && o ? i.fov = sx(i.fov, i.aspect, r) : a && !o ? i.fov = sx(i.fov, i.aspect, i.viewportFit.initialAspect) : !a && o && (i.fov = sx(i.fov, i.viewportFit.initialAspect, r)), i.aspect = r
                        } else if (i.isOrthographicCamera) switch (i.viewportFit.type) {
                            case 1:
                                c = i.top * r, i.left = -c, i.right = c;
                                break;
                            case 2:
                                var s = i.right / r;
                                i.bottom = -s, i.top = s;
                                break;
                            case 3:
                                var l = (i.right - i.left) / (i.top - i.bottom) < i.viewportFit.initialAspect,
                                    s = r < i.viewportFit.initialAspect,
                                    c = l && s ? i.right : l && !s ? i.right * r / i.viewportFit.initialAspect : !l && s ? i.top * i.viewportFit.initialAspect : i.top * r;
                                i.left = -c, i.right = c, i.bottom = -c / r, i.top = c / r
                        }
                        i.updateProjectionMatrix()
                    }
                }
            }, {
                key: "run",
                value: function() {
                    this.preloader && (this.preloader.onFinish(), this.preloader = null), this.animate()
                }
            }, {
                key: "animate",
                value: function() {
                    var r = this;
                    r.renderer.setAnimationLoop(function() {
                        r.stats && r.stats.begin();
                        var e = r.clock.getDelta();
                        r.elapsed = e, r.mixer && r.mixer.update(e), r.controls && !r.xrSession && r.controls.update(e);
                        for (var t = r.renderCallbacks, n = 0; n < t.length; n++) t[n](e, r.clock.elapsedTime);
                        r.frame % r.frameRateDivider == 0 && r.enableRender && (r.render(), 0 === r.frame && r.dispatchEvent({
                            type: "firstFrameRendered"
                        })), r.frame++, r.disableRenderTrigger && 0 == --r.disableRenderTrigger && (r.enableRender = !1), r.stats && r.stats.end()
                    })
                }
            }, {
                key: "enableRendering",
                value: function() {
                    this.disableRenderTrigger = 0, this.enableRender = !0, this.ssaaOnPause && this.enableSSAA(0, !0)
                }
            }, {
                key: "disableRendering",
                value: function(e) {
                    ((e = e || 0) || this.ssaaOnPause) && this.enableRender && 0 == this.disableRenderTrigger ? (this.disableRenderTrigger = this.ssaaOnPause ? 32 : e, this.ssaaOnPause && this.enableSSAA(4, !0)) : 0 == e && (this.enableRender = !1)
                }
            }, {
                key: "setFrameRateDivider",
                value: function(e) {
                    this.frameRateDivider = e
                }
            }, {
                key: "render",
                value: function() {
                    this.dispatchEvent({
                        type: "onBeforeRender"
                    }), this.postprocessing ? this.postprocessing.composer.render(this.elapsed) : this.scene && this.camera && this.renderer.render(this.scene, this.camera), this.dispatchEvent({
                        type: "onAfterRender"
                    })
                }
            }, {
                key: "enableControls",
                value: function(e) {
                    var n = this.camera;
                    if (n.controls) {
                        switch (n.controls.type) {
                            case "ORBIT":
                                this.controls = new rg(n, e || this.renderer.domElement), this.controls.targetObj = n.controls.orbitTarget, this.controls.minDistance = n.controls.orbitMinDistance, this.controls.maxDistance = n.controls.orbitMaxDistance, this.controls.minZoom = n.controls.orbitMinZoom, this.controls.maxZoom = n.controls.orbitMaxZoom, this.controls.minPolarAngle = n.controls.orbitMinPolarAngle, this.controls.maxPolarAngle = n.controls.orbitMaxPolarAngle, this.controls.minAzimuthAngle = n.controls.orbitMinAzimuthAngle, this.controls.maxAzimuthAngle = n.controls.orbitMaxAzimuthAngle;
                                break;
                            case "FLYING":
                                this.controls = new eg(n, this.renderer.domElement), this.controls.panSpeedTouch *= n.controls.moveSpeed, this.controls.zoomSpeedKey *= n.controls.moveSpeed;
                                break;
                            case "FIRST_PERSON":
                                this.controls = new $v(n, this.renderer.domElement), this.controls.collisionMeshes = [];
                                var r = this;
                                this.scene.traverse(function(e) {
                                    var t = e.material;
                                    t && n.controls.collisionMaterial && t.name == n.controls.collisionMaterial.name && r.controls.collisionMeshes.push(e)
                                }), r.controls.gazeLevel = n.controls.gazeLevel, r.controls.storyHeight = n.controls.storyHeight, this.controls.zoomSpeedKey *= n.controls.moveSpeed;
                                break;
                            default:
                                this.controls = null
                        }
                        this.controls && (this.controls.enablePan = n.controls.enablePan, this.controls.rotateSpeed *= n.controls.rotateSpeed, this.controls.rotateSpeedTouch *= n.controls.rotateSpeed, this.controls.panSpeed *= n.controls.moveSpeed, this.controls.panSpeedKey *= n.controls.moveSpeed, this.controls.zoomSpeed *= n.controls.moveSpeed, this.controls.zoomSpeedTouch *= n.controls.moveSpeed, this.controls.update())
                    }
                }
            }, {
                key: "setCamera",
                value: function(e) {
                    if (this.camera = e, this.postprocessing) {
                        for (var t = this.postprocessing.composer.passes, n = 0; n < t.length; n++) t[n].setCamera(e);
                        this.postprocessing.renderPass && this.postprocessing.renderPass.setCamera(e), this.postprocessing.ssaaRenderPass && this.postprocessing.ssaaRenderPass.setCamera(e)
                    }
                    this.controls && this.controls.dispose(), this.enableControls(), this.onResize()
                }
            }, {
                key: "getCamera",
                value: function() {
                    return this.camera
                }
            }, {
                key: "cleanup",
                value: function() {
                    if (console.warn("v3d.App.cleanup has been deprecated. Use v3d.App.unload or v3d.App.dispose instead."), this.container)
                        for (; this.container.firstChild;) this.container.removeChild(this.container.firstChild);
                    this.loader && this.mixer && this.mixer.stopAllAction()
                }
            }, {
                key: "initPostprocessing",
                value: function() {
                    (this.scene.postprocessing && this.scene.postprocessing.length || this.useHDR || "AUTO" != this.aaMethod) && this.enablePostprocessing(this.scene.postprocessing || [])
                }
            }, {
                key: "enablePostprocessing",
                value: function(e) {
                    var t, n = {
                        format: Qe,
                        stencilBuffer: !1
                    };
                    if (this.useHDR ? (n.type = Ye, n.encoding = Vt) : (n.type = je, n.encoding = Gt), this.postprocessing) t = this.postprocessing.composer;
                    else {
                        this.postprocessing = {};
                        var r = new Sg(this.scene, this.camera);
                        this.postprocessing.renderPass = r;
                        var i, a = 0;
                        switch (this.aaMethod) {
                            case "AUTO":
                            case "MSAA4":
                                a = this._checkMSAA(this.renderer, 4);
                                break;
                            case "MSAA8":
                                a = this._checkMSAA(this.renderer, 8);
                                break;
                            case "MSAA16":
                                a = this._checkMSAA(this.renderer, 16)
                        }
                        Es.checkSwiftShader(this.renderer) && (a = 0, console.warn("v3d.App: disabling buggy multisampling on SwiftShader renderer")), a ? (i = new Sn(this.getWidth(), this.getHeight(), n)).samples = a : i = new wn(this.getWidth(), this.getHeight(), n), i.texture.name = "EffectComposer.rt1", (t = new Ig(this.renderer, i)).addPass(r), this.postprocessing.composer = t, this.useHDR && (r = new Rg, t.addPass(r), this.postprocessing.toneMapPass = r), 0 == a && "NONE" != this.aaMethod && (o = new hg(this.scene, this.camera), t.addPass(o), this.postprocessing.fxaaPass = o)
                    }
                    e.length && this.postprocessing.copyPass && (t.passes.splice(t.passes.indexOf(this.postprocessing.copyPass), 1), this.postprocessing.copyPass = null);
                    for (var o, s = 0; s < e.length; s++) {
                        var l = e[s],
                            c = t.passes.length - 1;
                        switch (t.passes[c] instanceof hg || c++, this.useHDR && c--, l.type) {
                            case "bloom":
                                var u = l.strength,
                                    d = l.radius,
                                    h = l.threshold,
                                    f = void 0;
                                this.postprocessing.bloomPass ? ((f = this.postprocessing.bloomPass).strength = u, f.radius = d, f.threshold = h) : (f = new lg(new vn(this.getWidth(), this.getHeight()), u, d, h, n), t.insertPass(f, c), this.postprocessing.bloomPass = f);
                                break;
                            case "brightnessContrast":
                                var p = void 0;
                                this.postprocessing.brightnessContrastPass ? p = this.postprocessing.brightnessContrastPass : (p = new dg, t.insertPass(p, c), this.postprocessing.brightnessContrastPass = p), p.brightness = l.brightness, p.contrast = l.contrast;
                                break;
                            case "dof":
                                p = void 0;
                                this.postprocessing.bokehPass ? p = this.postprocessing.bokehPass : (p = new cg(this.scene, this.camera, {
                                    width: this.getWidth(),
                                    height: this.getHeight()
                                }), t.insertPass(p, c), this.postprocessing.bokehPass = p), p.focus = l.focus, p.aperture = l.aperture, p.maxblur = l.maxblur, p.depthLeakThreshold = l.depthLeakThreshold;
                                break;
                            case "grayscale":
                                this.postprocessing.grayscalePass || (m = new fg, t.insertPass(m, c), this.postprocessing.grayscalePass = m);
                                break;
                            case "outline":
                                var m, v = void 0;
                                this.postprocessing.outlinePass ? v = this.postprocessing.outlinePass : (v = new wg(new vn(this.getWidth(), this.getHeight()), this.scene, this.camera), t.insertPass(v, c), this.postprocessing.outlinePass = v), v.edgeStrength = l.edgeStrength, v.edgeGlow = l.edgeGlow, v.edgeThickness = l.edgeThickness, v.pulsePeriod = l.pulsePeriod, v.visibleEdgeColor.fromArray(l.visibleEdgeColor), v.hiddenEdgeColor.fromArray(l.hiddenEdgeColor), void 0 === l.renderHiddenEdge ? (m = 0 === l.hiddenEdgeColor[0] && 0 === l.hiddenEdgeColor[1] && 0 === l.hiddenEdgeColor[2], v.hiddenEdgeColor.setW(Number(!m))) : v.hiddenEdgeColor.setW(Number(l.renderHiddenEdge));
                                break;
                            case "ssao":
                                if (!Es.checkDepthTex(this.renderer)) {
                                    console.warn("v3d.App: disabling SSAO since your hardware does not support depth textures");
                                    break
                                }
                                if (!Es.checkFloatTex(this.renderer, !1)) {
                                    console.warn("v3d.App: disabling SSAO since your hardware does not support float textures");
                                    break
                                }
                                var g = void 0;
                                this.postprocessing.ssaoPass ? g = this.postprocessing.ssaoPass : (g = new Lg(this.scene, this.camera, this.getWidth(), this.getHeight()), t.insertPass(g, c), this.postprocessing.ssaoPass = g), g.kernelRadius = l.radius, g.minDistance = l.minDistance || .005, g.maxDistance = l.maxDistance || .1;
                                break;
                            case "ssr":
                                if (!Es.checkHalfFloatTex(this.renderer, !1)) {
                                    console.warn("v3d.App: disabling SSR since your hardware does not support half float textures");
                                    break
                                }
                                v = !1;
                                _i(l.useRefract) && (v = l.useRefract);
                                g = void 0;
                                (v ? this.postprocessing.ssrPassRefract : this.postprocessing.ssrPassReflect) ? g = v ? this.postprocessing.ssrPassRefract : this.postprocessing.ssrPassReflect: (g = new Pg(this.scene, this.camera), t.insertPassAfter(g, [this.postprocessing.renderPass, this.postprocessing.ssrPassRefract, this.postprocessing.ssrPassReflect]), v ? this.postprocessing.ssrPassRefract = g : this.postprocessing.ssrPassReflect = g), g.useRefract = v, _i(l.objects) && (g.objects = l.objects), _i(l.intensity) && (g.intensity = l.intensity), _i(l.steps) && (g.steps = l.steps), _i(l.stride) && (g.stride = l.stride), _i(l.binarySearchSteps) && (g.binarySearchSteps = l.binarySearchSteps), _i(l.renderTargetScale) && (g.renderTargetScale = l.renderTargetScale), _i(l.thickness) && (g.thickness = l.thickness), _i(l.maxDistance) && (g.maxDistance = l.maxDistance), _i(l.jitter) && (g.jitter = l.jitter), _i(l.renderAfter) && (g.renderAfter = l.renderAfter), _i(l.simpleRefraction) && (g.simpleRefraction = l.simpleRefraction), this.onResize && this.onResize();
                                break;
                            default:
                                console.error("v3d.App: wrong postprocessing effect")
                        }
                    }
                    1 == t.passes.length && (o = new ug(wa.copy), t.passes.push(o), this.postprocessing.copyPass = o)
                }
            }, {
                key: "disablePostprocessing",
                value: function(e) {
                    if (this.postprocessing) {
                        var t = ["bloomPass", "brightnessContrastPass", "bokehPass", "grayscalePass", "ssaoPass", "ssrPassReflect", "ssrPassRefract"];
                        e || t.push("outlinePass");
                        for (var n = this.postprocessing.composer, r = 0; r < t.length; r++) {
                            var i = t[r];
                            this.postprocessing[i] && (n.passes.splice(n.passes.indexOf(this.postprocessing[i]), 1), this.postprocessing[i].dispose(), this.postprocessing[i] = null)
                        }!this.useHDR && "AUTO" == this.aaMethod && n.passes.length <= 2 && (this.postprocessing.renderPass.dispose(), this.postprocessing.fxaaPass && this.postprocessing.fxaaPass.dispose(), this.postprocessing.composer.dispose(), this.postprocessing = null)
                    }
                }
            }, {
                key: "enableSSAA",
                value: function(t, e) {
                    var n, r, i;
                    this.postprocessing || this.enablePostprocessing([]), 0 < t && (this.postprocessing.ssrPassRefract || this.postprocessing.ssrPassReflect) || ((n = this).scene.traverse(function(e) {
                        e.isAnnotationControl && (e.update(n.camera), e.doUpdate = !Boolean(t))
                    }), r = this.postprocessing.composer, 0 < t && r.passes[0] instanceof Sg ? (this.postprocessing.ssaaRenderPass ? i = this.postprocessing.ssaaRenderPass : (i = new Ag(this.scene, this.camera), this.postprocessing.ssaaRenderPass = i, e && i.addEventListener("iteration", function(e) {
                        e.frame == t * t - 1 && (r.enableAllPasses(), r.renderToScreen = !0, n.disableRenderTrigger = 1)
                    })), i.sampleLevel = t || 4, r.passes[0] = i, this.postprocessing.fxaaPass && r.passes.splice(r.passes.length - 1, 1), e && (i.iterative = !0, i.iterativeFrame = 0, r.disableAllPasses(), r.renderToScreen = !1, i.enabled = !0)) : 0 < t ? (r.passes[0].sampleLevel = t || 4, e && (ssaaRenderPass.iterative = !0, ssaaRenderPass.iterativeFrame = 0, r.disableAllPasses(), r.renderToScreen = !1, ssaaRenderPass.enabled = !0)) : 0 == t && r.passes[0] instanceof Ag && (r.passes[0] = this.postprocessing.renderPass, this.postprocessing.fxaaPass && r.passes.push(this.postprocessing.fxaaPass), r.enableAllPasses(), r.renderToScreen = !0))
                }
            }, {
                key: "updateEnvironment",
                value: function(e) {
                    var t = this.renderer.xr.enabled;
                    this.renderer.xr.enabled = !1, this.disposeEnvironment(), e.useHDR = !0;
                    var n = {
                        encoding: Gt,
                        format: Qe,
                        generateMipmaps: !0,
                        minFilter: Ge
                    };
                    this._envIBLMode === cn && new jy(this.renderer, this._pmremMaxTileSize, !0).compileCubemapShader();
                    var r, i = Cg.renderWorldNodeMatToCubemap(this.renderer, e, this.worldCubemapRes, n),
                        a = i;
                    switch (e.needsLightPathDir() && (r = e.defines.LIGHT_PATH_IS_CAM_RAY, e.defines.LIGHT_PATH_IS_CAM_RAY = 0, a = Cg.renderWorldNodeMatToCubemap(this.renderer, e, this.worldCubemapRes, n), e.defines.LIGHT_PATH_IS_CAM_RAY = r), this._envIBLMode) {
                        case cn:
                            this._envRTargetIBL = this.generateRTargetPMREM(a), a !== i && a.dispose(), this._updateSceneEnvIBL(this.scene, this._envRTargetIBL), this.renderer.compatSettings.useSpecEnvBlenderApprox = !0;
                            break;
                        case 1:
                            var o = new ig(a.texture, this._pmremMaxTileSize, {
                                mapping: N
                            });
                            o.update(this.renderer), this._envRTargetIBL = o.renderTarget, this._updateSceneEnvIBL(this.scene, this._envRTargetIBL);
                            o = new ig(a.texture, this._lightProbeCubemapRes, {
                                type: je,
                                format: Qe,
                                encoding: jt
                            });
                            o.update(this.renderer), this._envLightProbe = (new Ch).copy(Sy.fromCubeRenderTarget(this.renderer, o.renderTarget)), this.scene.add(this._envLightProbe), o.dispose(), a !== i && a.dispose(), this.renderer.compatSettings.useSpecEnvBlenderApprox = !1;
                            break;
                        case 2:
                            o = new ig(a.texture, this._lightProbeCubemapRes, {
                                type: je,
                                format: Qe,
                                encoding: jt
                            });
                            o.update(this.renderer), a !== i && a.dispose(), this._envLightProbe = (new Ch).copy(Sy.fromCubeRenderTarget(this.renderer, o.renderTarget)), this.scene.add(this._envLightProbe), o.dispose(), this.renderer.compatSettings.useSpecEnvBlenderApprox = !1
                    }
                    null !== this.scene.background && this.scene.background.isSceneBackground && (this.scene.background.data = i, this.scene.background.useHDR = this.useHDR), this.renderer.xr.enabled = t
                }
            }, {
                key: "disposeEnvironment",
                value: function() {
                    null !== this._envRTargetIBL && (this._envRTargetIBL.dispose(), this._traverseSceneForEnvUpdates(this.scene, function(e) {
                        e.material.envMap && e.material.envMap.dispose()
                    })), (this._envRTargetIBL = null) !== this._envLightProbe && (this.scene.remove(this._envLightProbe), void 0 !== this._envLightProbe.dispose && this._envLightProbe.dispose(), this._envLightProbe = null);
                    var e = this.scene.background;
                    e && (e.isSceneBackground && (e = e.data), e && (e.isTexture || e.isWebGLRenderTarget) && e.dispose())
                }
            }, {
                key: "updateObjectMaterialEnv",
                value: function(e) {
                    this._envRTargetIBL && (e.material.envMap = this._envRTargetIBL.texture, e.material.needsUpdate = !0)
                }
            }, {
                key: "generateRTargetPMREM",
                value: function(e) {
                    if (!e.isWebGLCubeRenderTarget) return null;
                    var t = new jy(this.renderer, this._pmremMaxTileSize, !0);
                    t.flipCubemapX = !1;
                    e = t.fromCubeRenderTarget(e, {
                        encoding: Vt
                    });
                    return t.dispose(), e
                }
            }, {
                key: "initWebXR",
                value: function(i, a, o, e, r, t) {
                    o = o || function() {}, e = e || function() {}, r = r || function() {}, t = t || {};
                    var s = this;

                    function l(e) {
                        s.xrSession.removeEventListener("end", l), s.renderer.xr.setSession(null), r();
                        for (var t = 0; t < s.xrControllers.length; t++) {
                            var n = s.xrControllers[t];
                            s.scene.remove(n)
                        }
                        s.xrControllers = [], s.xrSession = null, s.postprocessing = s._postprocessingSave, s._postprocessingSave = null, s.onResize()
                    }

                    function c(e) {
                        var t, n = e.data,
                            e = e.target;
                        "tracked-pointer" == n.targetRayMode ? ((t = new Cl((new Oi).setFromPoints([new Tn(0, 0, 0), new Tn(0, 0, -1)]))).name = e.name + "_RAY", t.scale.z = 5, e.add(t)) : "gaze" == n.targetRayMode && ((t = new nl(new js({
                            map: (new Hd).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIQXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja7ZhZltw2DEX/uYosQSQ4LofjOdlBlp8LSqquHt12nD+X3JIKYpEg3sMDZDP/+XuZv/iIOGd8SDmWGA8+vvjiKjf5OD91n+3h93l//PWI76/s5vHAYRKucn7N8bJP7I7x7rL3a56KPTxNVOb1oL1+UK+JXL4WuOz3QmLPBY5rYlOvicRdK18utnNbRyw5PW+hX+PX9XyHgT+jJy/JxRBt8py9O1KKhfvsDp+I21BHV3dFfxfaNdGb7+Ye6vDJTbFycM7qoeC+FKmi93rGaSzCvUjY53J6ClrOHIn7csf1689Xnpvb9QvyV5A+7uwn9iekzQ7o/UDeIBQf1w/tNrzYzTOkG7enlWN8rPzKnufRXu35Rk3/1hp5rXnurvrIluO1qXsr+45xTaO1fxU5En/hyBpsPQpHJiU6PBqQrHF0W6wDxmW9HbbaZee+dttx0bvpElfnuhPbDcYMGMX1DbfXwy6XAH5IBvgOHQSre/hi97JlL9dtZuFhs4E9lsksP/lPh/nOoLU0oaw98iNW+OU00/BCkbPWHJZhIGLXFdSwA3wfbz+Kq4Bg2GHObLAeTWcA/hbsC7lkAy0MDFzPBLZpXBMQIjwIOGMFBI5oJdhoj4SwJWsJZAagiutOvGvAYkNwAyedF4mAQxawNr9Jdg91wZ1mhBAggkQjCWxITcDyPsCf5DMcqkGCDyHEkEIOJdQoUTMsxhRVUWuS5FNIMaWUU0nVZMk+hxxzyjmXXIsrguKGQj6WXEqplUUrM1d+XRlQa3NNmm+hxZZabqXV7kyX7nvosaeee+l1uCGDPB5xpJFHGXXaCZWmn2HGmWaeZdYF1ZYsv8KKK628iln1gdoF67vjJ1CzF2puI6UD0wM1rCndU1iVk6CYgZjzFsCTImDFOKeYHdl67xQ5xewoTkXQ4WRQcIZVxEDQT+vCsg/sXpALRuLvwc0AhPsdyBmF7hvIvcftI9RG3YVONkKahhrUQ8i+VdbM1eWqlfLLq/nRgO9e/0z0Z6LfNtEKlJIcBGEJdi4Y3YtQv/vMn9hbb2uO2qngQp1HkExeIqtF6sbqOjSLnimwjeScNfUo89iTZO/b7GHNot9iXc1v+ypRmpg4x9DZbZ/owSyht5CoP3X52YZQTUprFa0ItmIdx22xPvAvogdcVPyXdoNjrZpJ4+lZTtdDaj62hxnWigOhXduzQx+mQvaPZrNbk99ZfVDsDIMlgtBQLro75kMVI3Xb63P8HRXr6s2O0hI7YuI8TZLWlq8z1NZmxkfWRLdoCMcQIVAj5kCbeFkOhcg11PO8o7M6r+Z4Y/iJq4KdFVJt3w261qI9nXagWtvw6cKp96g4ZMIw/NZERidb2NYSDUzpabXiF3EzpaKqdZNqZSuTXqnN0CtBntdNmZYJStprx7kgxZCka/XWsc9qwzRVdkRnFEWjy8mRQDknXhkExoYgj6QNm96PWsKsM8EoejmdKOblTRMIQOt3ucsgJUigEUldCH5vJRCMcd1I1wWdMmKMNfyqcepalKOCefgzY9iGzOJ/Jd3Mhw9aLbrhTCyntQ44IOYBgdocpAPBbbGP1siF1bRxHYNyFKjJcD0EaAQs0EU0zcCEBBDNiuQn3CFPANTv3epZWd+CRs2zU7Og7coEZKcArFQGA8BOU5faUL/I3J0OuVAw2xqHzAHbywZiudFiNEM9XIMa3edcw7USP5WUzT5RLsA6JZ9SD/K07JoZAFUiPmdQak0CPlGYa/MptVDJT20yYguxkIT0DXQKexSrkjpz8QhlimYmdYF13enoS7Lj9CkCxcXzCa7Esl8AQBq6rDabFASNxDfMWcgaRzTRgIFeBRmje5n4GAJmnGIHE2qUtOBqhOpzOhnrHtCJiJnTPoAA9FmVwgzCETw7yqmHPwbBfIbCOxC6jSogCHVjYzWhLEk1KTQonoYhUIEbIQd4p42Wliu5ngJtT8Le6LXS6CdV5xIA+p3l6GY+dKCrHMp8mK0bSBPGK/WJ/d4U1PdiM3WhDiU9dQCRH6o4sxerpKcUyJGASZrjLVvTQ/XiJ0sAAj9ayPYW+8IbpLzW/3KkLUIvEnQKEG6FLW3OF3aksFMFtoZp+I0+giNUtd4xUutm3LTnZxLXmFQ5el3WkFEIPtPMorRGG2sfslIJ8NIaqxnbBKp7ckpOgDThLLn1kBGbnmRkvcgIlH+WkbLIoOC1LCAksc5RuviYqfE0yZeFd/2vomk+DSfceh1PLZ5k35uI3vXUvC+oKlTrUVBJ56eSyhJ5flhTzS8U1Q+v5ptF9aXK7ZuWNaXDJshY1S4xofutu27qtutxVSPSrffPqhGj39Ujan+5K9IXxXq+FPp3UhsAdw3TwQG5G3aWmEBohrt4qthpkCbBz4ntlcQXXreum5R1sbAXHs2QldBo9LOroE+gIaj52mBwabjzC2+lX17NjwbodeuhtFsPof1Q0UMOyTI0EO45g2lqG8k2i809EsB4quEkUrK1cKgW8mZb+UkcIAdcUXKyI9scHR1MY6I3jzUIZ2ODum6EgoaiEIrp9/YJmYP0QbMBnHLaCW2meqzsfm6AyYtX7S+id3W/vKle3e/OPRojdI/oDyOdRFVlrAORRx/igFKtQDte/oV654VGuvIKzMM2eCFuVB4SbD3CppXcXFE7i8guPY8i0l5XcpVqGsNjp1bjzGyCNLRgySyT5TY9R2fu2joo2cRhR6bsdCYa8P8MEJnzEqJpHiH6KEA6wXcCRHzMrwRovzykVEY/b/U/r81981+vfyb6M9H/MBF5RKaafwEjmLcIrlR0mgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCAwojJyJFeN4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAd0lEQVR42u3YUQqAIBAFwLUDdf9zdCH7lwwEI2VnPkWQfWCvigAAAAAAgDTK1wecNWq7dpX+uaP7lw7gaZi3oUb3z3BkvwICEIAW+KcFRte3DWBGO7gCAhCAAHZ9FY6IpC3QG963gGeAAASgBRb6IwQAAAAAQCY34QUtIL9dJTwAAAAASUVORK5CYII="),
                            sizeAttenuation: !1
                        }))).name = e.name + "_RETICLE", t.scale.multiplyScalar(.1), t.position.z = -5, e.add(t)), e.userData.v3d.inputSource = n
                    }

                    function u(e) {
                        for (var t = e.target, n = t.children.length - 1; 0 <= n; n--) {
                            var r = t.children[n]; - 1 < r.name.indexOf(t.name) && (r.geometry.dispose(), r.material.dispose(), t.remove(r))
                        }
                    }
                    var n = {
                        optionalFeatures: [a]
                    };
                    "immersive-ar" == i && (n.optionalFeatures.push("hit-test"), t.domOverlay && (n.optionalFeatures.push("dom-overlay"), n.domOverlay = {
                        root: s.container
                    })), navigator.xr.requestSession(i, n).then(function(e) {
                        s._postprocessingSave = s.postprocessing, s.postprocessing = null, s.renderer.xr.setReferenceSpaceType(a), (s.xrSession = e).addEventListener("end", l);
                        for (var t = "immersive-vr" == i ? 2 : 1, n = 0; n < t; n++) {
                            var r = s.renderer.xr.getController(n);
                            s.scene.add(r), s.xrControllers.push(r), r.addEventListener("connected", c), r.addEventListener("disconnected", u)
                        }
                        "immersive-vr" == i ? 2 <= window.devicePixelRatio && s.renderer.xr.setFramebufferScaleFactor(.5) : s.scene.background = null, s.renderer.xr.enabled = !0, s.renderer.xr.setSession(e), o()
                    }).catch(e)
                }
            }, {
                key: "endWebXR",
                value: function() {
                    this.xrSession && this.xrSession.end()
                }
            }, {
                key: "printPerformanceInfo",
                value: function(e) {
                    Og.printPerformanceInfo(this, e)
                }
            }, {
                key: "showFPS",
                value: function() {
                    var e;
                    this.container && (this.hideFPS(), (e = new ax).showPanel(0), this.container.appendChild(e.dom), this.stats = e)
                }
            }, {
                key: "hideFPS",
                value: function() {
                    this.container && this.stats && (this.container.removeChild(this.stats.dom), this.stats = null)
                }
            }]), a
        }(),
        _f = {
            computeTangents: function(e) {
                var t = e.index,
                    n = e.attributes;
                if (null !== t && void 0 !== n.position && void 0 !== n.normal && void 0 !== n.uv) {
                    var r = t.array,
                        i = n.position.array,
                        a = n.normal.array,
                        o = n.uv.array,
                        s = i.length / 3;
                    void 0 === n.tangent && e.setAttribute("tangent", new ri(new Float32Array(4 * s), 4));
                    for (var l = n.tangent.array, c = [], u = [], d = 0; d < s; d++) c[d] = new Tn, u[d] = new Tn;
                    var h = new Tn,
                        f = new Tn,
                        p = new Tn,
                        m = new vn,
                        v = new vn,
                        g = new vn,
                        _ = new Tn,
                        y = new Tn,
                        x = e.groups;
                    0 === x.length && (x = [{
                        start: 0,
                        count: r.length
                    }]);
                    for (var d = 0, b = x.length; d < b; ++d)
                        for (var M = P = (L = x[d]).start, w = P + L.count; M < w; M += 3) ! function(e, t, n) {
                            h.fromArray(i, 3 * e), f.fromArray(i, 3 * t), p.fromArray(i, 3 * n), m.fromArray(o, 2 * e), v.fromArray(o, 2 * t), g.fromArray(o, 2 * n), f.sub(h), p.sub(h), v.sub(m), g.sub(m);
                            var r = 1 / (v.x * g.y - g.x * v.y);
                            isFinite(r) && (_.copy(f).multiplyScalar(g.y).addScaledVector(p, -v.y).multiplyScalar(r), y.copy(p).multiplyScalar(v.x).addScaledVector(f, -g.x).multiplyScalar(r), c[e].add(_), c[t].add(_), c[n].add(_), u[e].add(y), u[t].add(y), u[n].add(y))
                        }(r[M + 0], r[M + 1], r[M + 2]);
                    for (var S, A = new Tn, T = new Tn, E = new Tn, C = new Tn, d = 0, b = x.length; d < b; ++d)
                        for (var L, P, M = P = (L = x[d]).start, w = P + L.count; M < w; M += 3) R(r[M + 0]), R(r[M + 1]), R(r[M + 2])
                } else console.warn("v3d.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");

                function R(e) {
                    E.fromArray(a, 3 * e), C.copy(E), S = c[e], A.copy(S), A.sub(E.multiplyScalar(E.dot(S))).normalize(), T.crossVectors(C, S), S = T.dot(u[e]), S = S < 0 ? -1 : 1, l[4 * e] = A.x, l[4 * e + 1] = A.y, l[4 * e + 2] = A.z, l[4 * e + 3] = S
                }
            },
            mergeBufferGeometries: function(e, t) {
                for (var n = null !== e[0].index, r = new Set(Object.keys(e[0].attributes)), i = new Set(Object.keys(e[0].morphAttributes)), a = {}, o = {}, s = e[0].morphTargetsRelative, l = new Oi, c = 0, u = 0; u < e.length; ++u) {
                    var d, h, f = e[u];
                    if (n != (null !== f.index)) return null;
                    for (d in f.attributes) {
                        if (!r.has(d)) return null;
                        void 0 === a[d] && (a[d] = []), a[d].push(f.attributes[d])
                    }
                    if (s !== f.morphTargetsRelative) return null;
                    for (d in f.morphAttributes) {
                        if (!i.has(d)) return null;
                        void 0 === o[d] && (o[d] = []), o[d].push(f.morphAttributes[d])
                    }
                    if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(f.userData), t) {
                        if (n) h = f.index.count;
                        else {
                            if (void 0 === f.attributes.position) return null;
                            h = f.attributes.position.count
                        }
                        l.addGroup(c, h, u), c += h
                    }
                }
                if (n) {
                    for (var p = 0, m = [], u = 0; u < e.length; ++u) {
                        for (var v = e[u].index, g = 0; g < v.count; ++g) m.push(v.getX(g) + p);
                        p += e[u].attributes.position.count
                    }
                    l.setIndex(m)
                }
                for (d in a) {
                    var _ = this.mergeBufferAttributes(a[d]);
                    if (!_) return null;
                    l.setAttribute(d, _)
                }
                for (d in o) {
                    var y = o[d][0].length;
                    if (0 === y) break;
                    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[d] = [];
                    for (u = 0; u < y; ++u) {
                        for (var x = [], g = 0; g < o[d].length; ++g) x.push(o[d][g][u]);
                        var b = this.mergeBufferAttributes(x);
                        if (!b) return null;
                        l.morphAttributes[d].push(b)
                    }
                }
                return l
            },
            mergeBufferAttributes: function(e) {
                for (var t, n, r, i = 0, a = 0; a < e.length; ++a) {
                    var o = e[a];
                    if (o.isInterleavedBufferAttribute) return null;
                    if (void 0 === t && (t = o.array.constructor), t !== o.array.constructor) return null;
                    if (void 0 === n && (n = o.itemSize), n !== o.itemSize) return null;
                    if (void 0 === r && (r = o.normalized), r !== o.normalized) return null;
                    i += o.array.length
                }
                for (var s = new t(i), l = 0, a = 0; a < e.length; ++a) s.set(e[a].array, l), l += e[a].array.length;
                return new ri(s, n, r)
            },
            interleaveAttributes: function(e) {
                for (var t, n = 0, r = 0, i = 0, a = e.length; i < a; ++i) {
                    var o = e[i];
                    if (void 0 === t && (t = o.array.constructor), t !== o.array.constructor) return console.warn("AttributeBuffers of different types cannot be interleaved"), null;
                    n += o.array.length, r += o.itemSize
                }
                for (var s = new zs(new t(n), r), l = 0, c = [], u = ["getX", "getY", "getZ", "getW"], d = ["setX", "setY", "setZ", "setW"], h = 0, a = e.length; h < a; h++) {
                    var f = (o = e[h]).itemSize,
                        p = o.count,
                        m = new Gs(s, f, l, o.normalized);
                    c.push(m), l += f;
                    for (var v = 0; v < p; v++)
                        for (var g = 0; g < f; g++) m[d[g]](v, o[u[g]](v))
                }
                return c
            },
            estimateBytesUsed: function(e) {
                var t, n = 0;
                for (t in e.attributes) {
                    var r = e.getAttribute(t);
                    n += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT
                }
                var i = e.getIndex();
                return n += i ? i.count * i.itemSize * i.array.BYTES_PER_ELEMENT : 0
            },
            mergeVertices: function(e) {
                for (var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1e-4, t = Math.max(t, Number.EPSILON), n = {}, r = e.getIndex(), i = e.getAttribute("position"), a = (r || i).count, o = 0, s = Object.keys(e.attributes), l = {}, c = {}, u = [], d = ["getX", "getY", "getZ", "getW"], h = 0, f = s.length; h < f; h++) l[_ = s[h]] = [], (M = e.morphAttributes[_]) && (c[_] = new Array(M.length).fill().map(function() {
                    return []
                }));
                for (var t = Math.log10(1 / t), p = Math.pow(10, t), h = 0; h < a; h++) {
                    for (var m = r ? r.getX(h) : h, v = "", g = 0, f = s.length; g < f; g++)
                        for (var _ = s[g], y = (b = e.getAttribute(_)).itemSize, x = 0; x < y; x++) v += "".concat(~~(b[d[x]](m) * p), ",");
                    if (v in n) u.push(n[v]);
                    else {
                        for (g = 0, f = s.length; g < f; g++)
                            for (var _ = s[g], b = e.getAttribute(_), M = e.morphAttributes[_], y = b.itemSize, w = l[_], S = c[_], x = 0; x < y; x++) {
                                var A = d[x];
                                if (w.push(b[A](m)), M)
                                    for (var T = 0, E = M.length; T < E; T++) S[T].push(M[T][A](m))
                            }
                        n[v] = o, u.push(o), o++
                    }
                }
                for (var C = e.clone(), h = 0, f = s.length; h < f; h++) {
                    var _ = s[h],
                        L = e.getAttribute(_),
                        b = new ri(new L.array.constructor(l[_]), L.itemSize, L.normalized);
                    if (C.setAttribute(_, b), _ in c)
                        for (g = 0; g < c[_].length; g++) {
                            var P = e.morphAttributes[_][g],
                                P = new ri(new P.array.constructor(c[_][g]), P.itemSize, P.normalized);
                            C.morphAttributes[_][g] = P
                        }
                }
                return C.setIndex(u), C
            },
            toTrianglesDrawMode: function(e, t) {
                if (0 === t) return console.warn("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
                if (2 !== t && 1 !== t) return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e;
                var n = e.getIndex();
                if (null === n) {
                    var r = [],
                        i = e.getAttribute("position");
                    if (void 0 === i) return console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (var a = 0; a < i.count; a++) r.push(a);
                    e.setIndex(r), n = e.getIndex()
                }
                var o = n.count - 2,
                    s = [];
                if (2 === t)
                    for (a = 1; a <= o; a++) s.push(n.getX(0)), s.push(n.getX(a)), s.push(n.getX(a + 1));
                else
                    for (a = 0; a < o; a++) a % 2 == 0 ? (s.push(n.getX(a)), s.push(n.getX(a + 1)), s.push(n.getX(a + 2))) : (s.push(n.getX(a + 2)), s.push(n.getX(a + 1)), s.push(n.getX(a)));
                s.length / 3 != o && console.error("v3d.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                e = e.clone();
                return e.setIndex(s), e.clearGroups(), e
            }
        },
        px = {
            calcCameraZoomToObjectsParams: (cx = new Ln, ux = new Yn, function(e, t, n, r) {
                var i = cx.makeEmpty();
                t.forEach(function(e) {
                    i.expandByObject(e)
                });
                t = i.getBoundingSphere(ux);
                px.calcCameraZoomToSphereParams(e, t, n, r)
            }),
            calcCameraZoomToSphereParams: (lx = new Tn, function(e, t, n, r) {
                var i = mn.degToRad(e.fov / 2);
                e.aspect < 1 && (i = Math.atan(e.aspect * Math.tan(i)));
                i = t.radius / Math.sin(i), e = e.getWorldDirection(lx);
                n.copy(t.center).addScaledVector(e, -i), r.copy(t.center)
            })
        },
        mx = {
            normalizeDialectOptions: function(e) {
                var t, n = {
                    delimiter: ",",
                    doublequote: !0,
                    lineterminator: "\n",
                    quotechar: '"',
                    skipinitialspace: !0,
                    skipinitialrows: 0
                };
                for (t in e) n[t.toLowerCase()] = e[t];
                return n
            },
            parse: function(e, t) {
                t && (!t || t.lineterminator) || (e = mx.normalizeLineTerminator(e, t));
                var n = mx.normalizeDialectOptions(t);
                e = mx.chomp(e, n.lineterminator);
                for (var r, i = !1, a = !1, o = "", s = [], l = [], c = function(e) {
                        var t = String.prototype.trim ? function(e) {
                            return e.trim()
                        } : function(e) {
                            return e.replace(/^\s*/, "").replace(/\s*$/, "")
                        };
                        return !0 !== a && ("" === e ? e = null : !0 === n.skipinitialspace && (e = t(e)), /^\d+$/.test(e) ? e = parseInt(e, 10) : /^\d*\.\d+$|^\d+\.\d*$/.test(e) && (e = parseFloat(e, 10))), e
                    }, u = 0; u < e.length; u += 1) r = e.charAt(u), !1 !== i || r !== n.delimiter && r !== n.lineterminator ? r !== n.quotechar ? o += r : i ? e.charAt(u + 1) === n.quotechar ? (o += n.quotechar, u += 1) : i = !1 : a = i = !0 : (o = c(o), s.push(o), r === n.lineterminator && (l.push(s), s = []), o = "", a = !1);
                return o = c(o), s.push(o), l.push(s), n.skipinitialrows && (l = l.slice(n.skipinitialrows)), l
            },
            normalizeLineTerminator: function(e, t) {
                return (t = t || {}).lineterminator ? e : e.replace(/(\r\n|\n|\r)/gm, "\n")
            },
            chomp: function(e, t) {
                return e.charAt(e.length - t.length) !== t ? e : e.substring(0, e.length - t.length)
            }
        },
        vx = new Tn(1, 0, 0);

    function gx(e, t) {
        e = void 0 !== e ? e : new Qr(1, 0, 0), t = void 0 !== t ? t : 2;
        var n = new vg;
        n.setGeometry([0, 0, 0, vx.x, vx.y, vx.z]);
        t = new Mg({
            color: e,
            lineWidth: t,
            sizeAttenuation: 0
        });
        Ki.call(this, n.geometry, t), this.elemHTML = null, this.offset = 5
    }

    function _x() {}

    function yx(e) {
        for (var t in _x.call(this), e) {
            var n = e[t];
            "container" === t && (void 0 === n ? this.container = document.body : n instanceof HTMLElement ? this.container = n : this.container = document.getElementById(n))
        }
        this.bar = document.createElement("div"), this.bar.setAttribute("class", "v3d-simple-preloader-bar"), this.logo = document.createElement("div"), this.logo.setAttribute("class", "v3d-simple-preloader-logo"), this.logoCont = document.createElement("div"), this.logoCont.setAttribute("id", "v3d_preloader_container"), this.logoCont.setAttribute("class", "v3d-simple-preloader-container"), this.background = document.createElement("div"), this.background.setAttribute("class", "v3d-simple-preloader-background"), this.background.appendChild(this.logoCont), this.logoCont.appendChild(this.logo), this.logoCont.appendChild(this.bar), this.container.appendChild(this.background), "none" == getComputedStyle(this.logo).backgroundImage && this.logo.setAttribute("style", 'background-image: url("./assets/images/logo/logo1-light.svg");'), this.clock = new Kh
    }
    gx.prototype = Object.assign(Object.create(Ki.prototype), {
        constructor: gx,
        isLineHTML: !0,
        onBeforeRender: (dx = new Tn, hx = new Tn, fx = new An, function(e, t, n, r, i, a) {
            var o, s, l, c, u, d, h, f, p, m;
            Ki.prototype.onBeforeRender.call(this), this.elemHTML && (m = e.domElement.offsetHeight, p = e.domElement.offsetWidth, s = ((o = this.elemHTML.getBoundingClientRect()).left + o.right) / 2, l = (o.top + o.bottom) / 2, c = ((d = this.getWorldPosition(dx).project(n)).x + 1) / 2 * p, e = (l - (u = (1 - d.y) / 2 * m)) / (s - c), d = (o.height + 2 * this.offset) / (o.width + 2 * this.offset), Math.abs(e) > d ? h = ((f = l < u ? Math.min(o.bottom + this.offset, u) : Math.max(o.top - this.offset, u)) - u) / e + c : f = ((h = c < s ? Math.max(o.left - this.offset, c) : Math.min(o.right + this.offset, c)) - c) * e + u, p = 2 * h / p - 1, m = 1 - 2 * f / m, (m = hx.set(p, m, -1)).unproject(n), this.parent && this.parent.worldToLocal(m), n = m.length(), this.scale.setScalar(n), m.normalize(), m = fx.setFromUnitVectors(vx, m), this.setRotationFromQuaternion(m), this.updateMatrixWorld())
        })
    }), Object.assign(_x.prototype, {
        onUpdate: function(e) {},
        onFinish: function() {}
    }), yx.prototype = Object.assign(Object.create(_x.prototype), {
        constructor: yx,
        onUpdate: function(e) {
            e = Math.round(e), this.bar.style.width = e + "%"
        },
        onFinish: function() {
            this.container.removeChild(this.background)
        }
    });
    var xx, bx, Mx, wx;

    function Sx() {}

    function Ax(e) {
        Ki.call(this), this.type = "CubeTextureHelper", this.geometry = new Zl(2, 2, 2, 1, 1, 1), this.geometry.computeBoundingSphere(), this.material = new ei, this.material.envMap = e
    }

    function Tx(e) {
        Er.call(this), this.doUpdate = !0, this.projected = new Tn, this.container = e, this.updatedCallback = null
    }

    function Ex(e, t, n) {
        Tx.call(this, e), this.type = "Annotation", this.character = t, this.dialogContents = n, this.annotation = document.createElement("div"), this.annotation.innerHTML = t, this.annotation.className = "v3d-annotation", this.container.appendChild(this.annotation), this.annotationDialogVisible = !1, this.annotationDialog = document.createElement("div"), this.annotationDialog.innerHTML = n, this.annotationDialog.className = "v3d-annotation-dialog", this.annotation.appendChild(this.annotationDialog), this.fadeObscured = !0, this.obscured = !1, this.text = this.dialogContents, this.annotationText = this.annotationDialog;
        var r = !1,
            i = this;

        function a(e) {
            e.target == i.annotation ? 0 == i.annotationDialog.innerHTML.length || i.obscured || (i.annotationDialogVisible = !i.annotationDialogVisible, i.annotationDialog.style.visibility = i.annotationDialogVisible ? "visible" : "hidden", i.annotationDialogVisible ? i.annotation.style.zIndex = "1" : i.annotation.style.zIndex = "auto") : -1 < e.target.className.indexOf("v3d-annotation") && (i.annotationDialogVisible = !1, i.annotationDialog.style.visibility = "hidden", i.annotation.style.zIndex = "auto")
        }
        this._touchstartCb = function(e) {
            a(e), r = !0
        }, document.body.addEventListener("touchstart", this._touchstartCb, !1), this._mousedownCb = function(e) {
            r || a(e), r = !1
        }, document.body.addEventListener("mousedown", this._mousedownCb, !1)
    }
    Object.assign(Sx.prototype, {
        _logicFileLoadError: function(e) {
            e = new Error(e);
            return e.name = "LogicFileLoadError", e
        },
        _editorLoadError: function(e) {
            e = new Error(e);
            return e.name = "EditorLoadError", e
        },
        _getLogicPromise: function(n) {
            var r = this;
            return new Promise(function(e, t) {
                Og.loadScript(n, document.body, function() {
                    e()
                }, function() {
                    t(r._logicFileLoadError("Unable to load the logic file: '" + n + "'."))
                })
            })
        },
        _getEditorPromise: function(n, e) {
            var r = this;
            return new Promise(function(e, t) {
                Og.loadScript(n, document.body, function() {
                    e()
                }, function() {
                    t(r._editorLoadError("Unable to load the Puzzles Editor: '" + n + "'."))
                })
            })
        },
        _getLogicViaEditorPromise: function(a, o) {
            var s = this;
            return new Promise(function(t, n) {
                var e, r, i = Mi();
                i.v3d && i.v3d.PE ? ((e = o.split("."))[e.length - 1] = "xml", r = e.join("."), i.v3d.PE.init(a, r, function(e) {
                    e ? t() : n(s._logicFileLoadError("Unable to load the Puzzles Editor's XML logic file: '" + r + "'."))
                })) : n(s._editorLoadError("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded."))
            })
        },
        _getAmmoJSPromise: function() {
            return "function" == typeof window.Ammo ? new Promise(function(e, t) {
                window.Ammo().then(function() {
                    window.Ammo = Ammo, e()
                })
            }) : Promise.resolve()
        },
        loadLogic: function(e, t, n) {
            var r = this;
            this._getLogicPromise(e).then(function() {
                return r._getAmmoJSPromise()
            }).then(function() {
                t && t()
            }, function(e) {
                console.error(e), n && n(e)
            })
        },
        loadEditorWithLogic: function(e, t, n, r) {
            var i = this;
            i._getEditorPromise(e + "puzzles.min.js").then(function() {
                return i._getLogicViaEditorPromise(e, t)
            }).catch(function(e) {
                return "LogicFileLoadError" === e.name ? Promise.resolve() : Promise.reject(e)
            }).then(function() {
                return i._getAmmoJSPromise()
            }).then(function() {
                n && n()
            }).catch(function(e) {
                console.error(e), r && r(e)
            })
        }
    }), (Ax.prototype = Object.create(Ki.prototype)).constructor = Ax, Tx.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Tx,
        isAnnotationControl: !0,
        clone: function() {
            return new this.constructor(this.container).copy(this)
        },
        update: function(e) {
            var t, n, r, i;
            this.doUpdate && (t = this.projected, this.getWorldPosition(t).project(e), n = this.container.offsetWidth, i = this.container.offsetHeight, r = (.5 + t.x / 2) * n, e = (.5 - t.y / 2) * i, t.x = r, t.y = e, i = t.z <= 1 && 0 <= r && r <= n && 0 <= e && e <= i, this.visible = i, this.updatedCallback && this.updatedCallback(t.x, t.y, i))
        }
    }), Ex.prototype = Object.assign(Object.create(Tx.prototype), {
        constructor: Ex,
        isAnnotation: !0,
        raycast: function() {},
        clone: function() {
            return new this.constructor(this.container, this.character, this.dialogContents).copy(this)
        },
        update: (xx = new Cs, bx = new Tn, Mx = new Tn, wx = new Tn, function(e) {
            Tx.prototype.update.call(this, e);
            var t = this.projected,
                n = this.annotation;
            n.style.transform = "translate(" + t.x + "px, " + t.y + "px)", n.style.visibility = this.visible ? "visible" : "hidden", this.annotationDialog.style.visibility = this.visible && this.annotationDialogVisible ? "visible" : "hidden", this.fadeObscured && (e.getWorldPositionNU(bx), this.getWorldPositionNU(Mx), wx.copy(Mx).sub(bx).normalize(), xx.set(bx, wx), xx.far = bx.distanceTo(Mx), 1 < (e = xx.intersectObject(this.findRoot(), !0)).length || 1 == e.length && e[0].object != this.parent ? (n.classList.add("v3d-annotation-transparent"), this.obscured = !0, this.annotationDialog.style.visibility = "hidden") : (n.classList.remove("v3d-annotation-transparent"), this.obscured = !1))
        }),
        setDialogVisibility: function(e) {
            e ? (this.annotationDialogVisible = !0, this.annotationDialog.style.visibility = "visible", this.annotation.style.zIndex = "1") : (this.annotationDialogVisible = !1, this.annotationDialog.style.visibility = "hidden", this.annotation.style.zIndex = "auto")
        },
        dispose: function() {
            var e = this.annotation.parentElement;
            e && e.removeChild(this.annotation), document.body.removeEventListener("touchstart", this._touchstartCb, !1), document.body.removeEventListener("mousedown", this._mousedownCb, !1)
        }
    });
    var Cx, Lx, yf = {
            translateVRCamera: function() {
                var i = new Tn;
                new nr;
                return function(e, t, n) {
                    var r = e.parent;
                    r && !r.isScene && (i.copy(t).applyQuaternion(e.quaternion).applyQuaternion(r.quaternion), r.position.add(i.multiplyScalar(n)))
                }
            }(),
            rotateVRCamera: (Cx = new An, Lx = new An, function(e, t, n) {
                var r = e.parent;
                r && !r.isScene && (Cx.setFromAxisAngle(t, n), Cx.premultiply(e.quaternion), Cx.premultiply(r.quaternion), r.quaternion.multiplyQuaternions(Cx, Lx.copy(e.quaternion).invert()))
            })
        },
        Px = 0,
        Rx = 1,
        Dx = 2,
        Ox = 3,
        Nx = 4,
        Ix = 5121,
        Fx = 5123,
        kx = 5126,
        Bx = 5125,
        zx = 34962,
        Ux = 34963,
        om = 9728,
        ym = 9729,
        Xg = 9984,
        u_ = 9985,
        $g = 9986,
        P_ = 9987,
        ff = 33071,
        vf = 33648,
        mf = 10497,
        Vx = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        Gx = {};
    Gx[ke] = om, Gx[Be] = Xg, Gx[ze] = $g, Gx[Ue] = ym, Gx[Ve] = u_, Gx[Ge] = P_, Gx[V] = ff, Gx[U] = mf, Gx[Fe] = vf;

    function jx() {}
    var Wx = {
        scale: "scale",
        position: "translation",
        quaternion: "rotation",
        morphTargetInfluences: "weights"
    };
    jx.prototype = {
        constructor: jx,
        parse: function(e, c, h) {
            var t = {
                binary: !1,
                trs: !1,
                onlyVisible: !0,
                truncateDrawRange: !0,
                embedImages: !0,
                maxTextureSize: 1 / 0,
                animations: [],
                forcePowerOfTwoTextures: !1,
                includeCustomExtensions: !1
            };
            0 < (h = Object.assign({}, t, h)).animations.length && (h.trs = !0);
            var f, O = {
                    asset: {
                        version: "2.0",
                        generator: "Verge3D Runtime Exporter"
                    }
                },
                p = 0,
                n = [],
                m = [],
                d = new Map,
                v = [],
                N = {},
                I = {
                    meshes: new Map,
                    attributes: new Map,
                    attributesNormalized: new Map,
                    materials: new Map,
                    textures: new Map,
                    images: new Map
                },
                r = new Map,
                i = 0;

            function F(e) {
                return r.has(e) || r.set(e, i++), r.get(e)
            }

            function k(e, n) {
                return e.length === n.length && e.every(function(e, t) {
                    return e === n[t]
                })
            }

            function g(e) {
                return 4 * Math.ceil(e / 4)
            }

            function _(e, t) {
                t = t || 0;
                var n = g(e.byteLength);
                if (n === e.byteLength) return e;
                var r = new Uint8Array(n);
                if (r.set(new Uint8Array(e)), 0 !== t)
                    for (var i = e.byteLength; i < n; i++) r[i] = t;
                return r.buffer
            }

            function B(t, e) {
                if (0 !== Object.keys(t.userData).length) try {
                    var n = JSON.parse(JSON.stringify(t.userData));
                    if (h.includeCustomExtensions && n.gltfExtensions) {
                        for (var r in void 0 === e.extensions && (e.extensions = {}), n.gltfExtensions) e.extensions[r] = n.gltfExtensions[r], N[r] = !0;
                        delete n.gltfExtensions
                    }
                    0 < Object.keys(n).length && (e.extras = n)
                } catch (e) {
                    console.warn("v3d.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + e.message)
                }
            }

            function z(e, t) {
                var n = !1,
                    r = {};
                0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, N.KHR_texture_transform = !0)
            }

            function y(e) {
                return O.buffers || (O.buffers = [{
                    byteLength: 0
                }]), n.push(e), 0
            }

            function U(e, t, n, r) {
                var i, a;
                if (e.array.constructor === Float32Array) i = kx;
                else if (e.array.constructor === Uint32Array) i = Bx;
                else if (e.array.constructor === Uint16Array) i = Fx;
                else {
                    if (e.array.constructor !== Uint8Array) throw new Error("v3d.GLTFExporter: Unsupported bufferAttribute component type.");
                    i = Ix
                }
                if (void 0 === n && (n = 0), void 0 === r && (r = e.count), h.truncateDrawRange && void 0 !== t && null === t.index && (a = n + r, o = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count, n = Math.max(n, t.drawRange.start), (r = Math.min(a, o) - n) < 0 && (r = 0)), 0 === r) return null;
                var o = function(e, t, n) {
                    for (var r = {
                            min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
                            max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
                        }, i = t; i < t + n; i++)
                        for (var a, o = 0; o < e.itemSize; o++) 4 < e.itemSize ? a = e.array[i * e.itemSize + o] : 0 === o ? a = e.getX(i) : 1 === o ? a = e.getY(i) : 2 === o ? a = e.getZ(i) : 3 === o && (a = e.getW(i)), r.min[o] = Math.min(r.min[o], a), r.max[o] = Math.max(r.max[o], a);
                    return r
                }(e, n, r);
                void 0 !== t && (s = e === t.index ? Ux : zx);
                var s = function(e, t, n, r, i) {
                        var a;
                        O.bufferViews || (O.bufferViews = []), a = t === Ix ? 1 : t === Fx ? 2 : 4;
                        for (var o = g(r * e.itemSize * a), s = new DataView(new ArrayBuffer(o)), l = 0, c = n; c < n + r; c++)
                            for (var u, d = 0; d < e.itemSize; d++) 4 < e.itemSize ? u = e.array[c * e.itemSize + d] : 0 === d ? u = e.getX(c) : 1 === d ? u = e.getY(c) : 2 === d ? u = e.getZ(c) : 3 === d && (u = e.getW(c)), t === kx ? s.setFloat32(l, u, !0) : t === Bx ? s.setUint32(l, u, !0) : t === Fx ? s.setUint16(l, u, !0) : t === Ix && s.setUint8(l, u), l += a;
                        var h = {
                            buffer: y(s.buffer),
                            byteOffset: p,
                            byteLength: o
                        };
                        return void 0 !== i && (h.target = i), i === zx && (h.byteStride = e.itemSize * a), p += o, O.bufferViews.push(h), {
                            id: O.bufferViews.length - 1,
                            byteLength: 0
                        }
                    }(e, i, n, r, s),
                    o = {
                        bufferView: s.id,
                        byteOffset: s.byteOffset,
                        componentType: i,
                        count: r,
                        max: o.max,
                        min: o.min,
                        type: {
                            1: "SCALAR",
                            2: "VEC2",
                            3: "VEC3",
                            4: "VEC4",
                            16: "MAT4"
                        } [e.itemSize]
                    };
                return !0 === e.normalized && (o.normalized = !0), O.accessors || (O.accessors = []), O.accessors.push(o), O.accessors.length - 1
            }

            function a(e, t, n) {
                I.images.has(e) || I.images.set(e, {});
                var r = I.images.get(e),
                    i = t === Qe ? "image/png" : "image/jpeg",
                    a = i + ":flipY/" + n.toString();
                if (void 0 !== r[a]) return r[a];
                O.images || (O.images = []);
                var o = {
                    mimeType: i
                };
                if (h.embedImages) {
                    var s = f = f || document.createElement("canvas");
                    s.width = Math.min(e.width, h.maxTextureSize), s.height = Math.min(e.height, h.maxTextureSize);
                    var l = s.getContext("2d");
                    if (!0 === n && (l.translate(0, s.height), l.scale(1, -1)), "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) l.drawImage(e, 0, 0, s.width, s.height);
                    else {
                        t !== Qe && t !== RGBFormat && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (e.width > h.maxTextureSize || e.height > h.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                        var c = e.data;
                        if (t === RGBFormat) {
                            c = new Uint8ClampedArray(e.height * e.width * 4);
                            for (var u = 0, d = 0; u < c.length; u += 4, d += 3) c[u + 0] = e.data[d + 0], c[u + 1] = e.data[d + 1], c[u + 2] = e.data[d + 2], c[u + 3] = 255
                        }
                        l.putImageData(new ImageData(c, e.width, e.height), 0, 0)
                    }!0 === h.binary ? m.push(new Promise(function(n) {
                        s.toBlob(function(e) {
                            var t;
                            t = e, O.bufferViews || (O.bufferViews = []), new Promise(function(n) {
                                var r = new window.FileReader;
                                r.readAsArrayBuffer(t), r.onloadend = function() {
                                    var e = _(r.result),
                                        t = {
                                            buffer: y(e),
                                            byteOffset: p,
                                            byteLength: e.byteLength
                                        };
                                    p += e.byteLength, O.bufferViews.push(t), n(O.bufferViews.length - 1)
                                }
                            }).then(function(e) {
                                o.bufferView = e, n()
                            })
                        }, i)
                    })) : o.uri = s.toDataURL(i)
                } else o.uri = e.src;
                O.images.push(o);
                l = O.images.length - 1;
                return r[a] = l
            }

            function V(e) {
                if (I.textures.has(e)) return I.textures.get(e);
                O.textures || (O.textures = []);
                t = {
                    sampler: (t = e, O.samplers || (O.samplers = []), t = {
                        magFilter: Gx[t.magFilter],
                        minFilter: Gx[t.minFilter],
                        wrapS: Gx[t.wrapS],
                        wrapT: Gx[t.wrapT]
                    }, O.samplers.push(t), O.samplers.length - 1),
                    source: a(e.image, e.format, e.flipY)
                };
                e.name && (t.name = e.name), O.textures.push(t);
                var t = O.textures.length - 1;
                return I.textures.set(e, t), t
            }

            function x(e) {
                var t = [e.geometry.uuid];
                if (Array.isArray(e.material))
                    for (var n = 0, r = e.material.length; n < r; n++) t.push(e.material[n].uuid);
                else t.push(e.material.uuid);
                var i = t.join(":");
                if (I.meshes.has(i)) return I.meshes.get(i);
                var a = e.geometry,
                    o = e.isLineSegments ? Rx : e.isLineLoop ? Dx : e.isLine ? Ox : e.isPoints ? Px : e.material.wireframe ? Rx : Nx;
                a.isBufferGeometry || (console.warn("GLTFExporter: Exporting v3d.Geometry will increase file size. Use BufferGeometry instead."), a = (new Oi).setFromObject(e));
                var s = {},
                    l = {},
                    c = [],
                    u = [],
                    d = {
                        uv: "TEXCOORD_0",
                        uv2: "TEXCOORD_1",
                        color: "COLOR_0",
                        skinWeight: "WEIGHTS_0",
                        skinIndex: "JOINTS_0"
                    },
                    h = a.getAttribute("normal");
                void 0 === h || function(e) {
                    if (!I.attributesNormalized.has(e)) {
                        for (var t = new Tn, n = 0, r = e.count; n < r; n++)
                            if (5e-4 < Math.abs(t.fromBufferAttribute(e, n).length() - 1)) return;
                        return 1
                    }
                }(h) || (console.warn("v3d.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), a.setAttribute("normal", function(e) {
                    if (I.attributesNormalized.has(e)) return I.attributesNormalized.get(e);
                    for (var t = e.clone(), n = new Tn, r = 0, i = t.count; r < i; r++) n.fromBufferAttribute(t, r), 0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(), t.setXYZ(r, n.x, n.y, n.z);
                    return I.attributesNormalized.set(e, t), t
                }(h)));
                var f, p = null;
                for (y in a.attributes) "morph" !== y.substr(0, 5) && (M = a.attributes[y], y = d[y] || y.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y) || (y = "_" + y), I.attributes.has(F(M)) ? l[y] = I.attributes.get(F(M)) : (p = null, f = M.array, "JOINTS_0" !== y || f instanceof Uint16Array || f instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p = new ri(new Uint16Array(f), M.itemSize, M.normalized)), null !== (f = U(p || M, a)) && (l[y] = f, I.attributes.set(F(M), f))));
                if (void 0 !== h && a.setAttribute("normal", h), 0 === Object.keys(l).length) return null;
                if (void 0 !== e.morphTargetInfluences && 0 < e.morphTargetInfluences.length) {
                    var m = [],
                        v = [],
                        g = {};
                    if (void 0 !== e.morphTargetDictionary)
                        for (var _ in e.morphTargetDictionary) g[e.morphTargetDictionary[_]] = _;
                    for (n = 0; n < e.morphTargetInfluences.length; ++n) {
                        var y, x = {},
                            b = !1;
                        for (y in a.morphAttributes)
                            if ("position" === y || "normal" === y) {
                                var M = a.morphAttributes[y][n],
                                    w = y.toUpperCase(),
                                    S = a.attributes[y];
                                if (I.attributes.has(F(M))) x[w] = I.attributes.get(F(M));
                                else {
                                    var A = M.clone();
                                    if (!a.morphTargetsRelative)
                                        for (var T = 0, E = M.count; T < E; T++) A.setXYZ(T, M.getX(T) - S.getX(T), M.getY(T) - S.getY(T), M.getZ(T) - S.getZ(T));
                                    x[w] = U(A, a), I.attributes.set(F(S), x[w])
                                }
                            } else b || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), b = !0);
                        u.push(x), m.push(e.morphTargetInfluences[n]), void 0 !== e.morphTargetDictionary && v.push(g[n])
                    }
                    s.weights = m, 0 < v.length && (s.extras = {}, s.extras.targetNames = v)
                }
                h = Array.isArray(e.material);
                if (h && 0 === a.groups.length) return null;
                for (var C = h ? e.material : [e.material], L = h ? a.groups : [{
                        materialIndex: 0,
                        start: void 0,
                        count: void 0
                    }], n = 0, P = L.length; n < P; n++) {
                    var R = {
                        mode: o,
                        attributes: l
                    };
                    B(a, R), 0 < u.length && (R.targets = u), null !== a.index && (D = F(a.index), void 0 === L[n].start && void 0 === L[n].count || (D += ":" + L[n].start + ":" + L[n].count), I.attributes.has(D) ? R.indices = I.attributes.get(D) : (R.indices = U(a.index, a, L[n].start, L[n].count), I.attributes.set(D, R.indices)), null === R.indices && delete R.indices);
                    var D = function(e) {
                        if (I.materials.has(e)) return I.materials.get(e);
                        if (e.isShaderMaterial) return console.warn("GLTFExporter: v3d.ShaderMaterial not supported."), null;
                        O.materials || (O.materials = []);
                        var t = {
                            pbrMetallicRoughness: {}
                        };
                        e.isMeshBasicMaterial ? (t.extensions = {
                            KHR_materials_unlit: {}
                        }, N.KHR_materials_unlit = !0) : e.isGLTFSpecularGlossinessMaterial ? (t.extensions = {
                            KHR_materials_pbrSpecularGlossiness: {}
                        }, N.KHR_materials_pbrSpecularGlossiness = !0) : e.isMeshStandardMaterial || console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                        var n, r, i, a = e.color.toArray().concat([e.opacity]);
                        return k(a, [1, 1, 1, 1]) || (t.pbrMetallicRoughness.baseColorFactor = a), e.isMeshStandardMaterial ? (t.pbrMetallicRoughness.metallicFactor = e.metalness, t.pbrMetallicRoughness.roughnessFactor = e.roughness) : e.isMeshBasicMaterial ? (t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9) : (t.pbrMetallicRoughness.metallicFactor = .5, t.pbrMetallicRoughness.roughnessFactor = .5), e.isGLTFSpecularGlossinessMaterial && (t.pbrMetallicRoughness.baseColorFactor && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor), a = [1, 1, 1], e.specular.toArray(a, 0), t.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = a, t.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = e.glossiness), (e.metalnessMap || e.roughnessMap) && (e.metalnessMap === e.roughnessMap ? (z(n = {
                            index: V(e.metalnessMap)
                        }, e.metalnessMap), t.pbrMetallicRoughness.metallicRoughnessTexture = n) : console.warn("v3d.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.")), e.map && (z(n = {
                            index: V(e.map)
                        }, e.map), e.isGLTFSpecularGlossinessMaterial && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = n), t.pbrMetallicRoughness.baseColorTexture = n), e.isGLTFSpecularGlossinessMaterial && e.specularMap && (z(r = {
                            index: V(e.specularMap)
                        }, e.specularMap), t.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = r), e.emissive && (k(r = e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray(), [0, 0, 0]) || (t.emissiveFactor = r), e.emissiveMap && (z(r = {
                            index: V(e.emissiveMap)
                        }, e.emissiveMap), t.emissiveTexture = r)), e.normalMap && (i = {
                            index: V(e.normalMap)
                        }, e.normalScale && -1 !== e.normalScale.x && (e.normalScale.x !== e.normalScale.y && console.warn("v3d.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), i.scale = e.normalScale.x), z(i, e.normalMap), t.normalTexture = i), e.aoMap && (i = {
                            index: V(e.aoMap),
                            texCoord: 1
                        }, 1 !== e.aoMapIntensity && (i.strength = e.aoMapIntensity), z(i, e.aoMap), t.occlusionTexture = i), e.transparent ? t.alphaMode = "BLEND" : 0 < e.alphaTest && (t.alphaMode = "MASK", t.alphaCutoff = e.alphaTest), e.side === oe && (t.doubleSided = !0), "" !== e.name && (t.name = e.name), B(e, t), O.materials.push(t), t = O.materials.length - 1, I.materials.set(e, t), t
                    }(C[L[n].materialIndex]);
                    null !== D && (R.material = D), c.push(R)
                }
                s.primitives = c, O.meshes || (O.meshes = []), O.meshes.push(s);
                s = O.meshes.length - 1;
                return I.meshes.set(i, s), s
            }

            function b(e) {
                var t = !1;
                if (h.onlyVisible && !e.visible && (e.traverse(function(e) {
                        e.visible && (t = !0)
                    }), !t)) return null;
                O.nodes || (O.nodes = []);
                var n, r, i, a = {};
                if (h.trs ? (n = e.quaternion.toArray(), r = e.position.toArray(), i = e.scale.toArray(), k(n, [0, 0, 0, 1]) || (a.rotation = n), k(r, [0, 0, 0]) || (a.translation = r), k(i, [1, 1, 1]) || (a.scale = i)) : (e.matrixAutoUpdate && e.updateMatrix(), !1 === k(e.matrix.elements, Vx) && (a.matrix = e.matrix.elements)), "" !== e.name && (a.name = String(e.name)), B(e, a), (e.isMesh || e.isLine || e.isPoints) && !t) {
                    var o = x(e);
                    null !== o && (a.mesh = o)
                } else if (e.isCamera && !t) a.camera = function(e) {
                    O.cameras || (O.cameras = []);
                    var t = e.isOrthographicCamera,
                        n = {
                            type: t ? "orthographic" : "perspective"
                        };
                    return t ? n.orthographic = {
                        xmag: 2 * e.right,
                        ymag: 2 * e.top,
                        zfar: e.far <= 0 ? .001 : e.far,
                        znear: e.near < 0 ? 0 : e.near
                    } : n.perspective = {
                        aspectRatio: e.aspect,
                        yfov: mn.degToRad(e.fov),
                        zfar: e.far <= 0 ? .001 : e.far,
                        znear: e.near < 0 ? 0 : e.near
                    }, "" !== e.name && (n.name = e.type), O.cameras.push(n), O.cameras.length - 1
                }(e);
                else if ((e.isDirectionalLight || e.isPointLight || e.isSpotLight) && !t) N.KHR_lights_punctual || (O.extensions = O.extensions || {}, O.extensions.KHR_lights_punctual = {
                    lights: []
                }, N.KHR_lights_punctual = !0), a.extensions = a.extensions || {}, a.extensions.KHR_lights_punctual = {
                    light: (i = {}, (o = e).name && (i.name = o.name), i.color = o.color.toArray(), i.intensity = o.intensity, o.isDirectionalLight ? i.type = "directional" : o.isPointLight ? (i.type = "point", 0 < o.distance && (i.range = o.distance)) : o.isSpotLight && (i.type = "spot", 0 < o.distance && (i.range = o.distance), i.spot = {}, i.spot.innerConeAngle = (o.penumbra - 1) * o.angle * -1, i.spot.outerConeAngle = o.angle), void 0 !== o.decay && 2 !== o.decay && console.warn("v3d.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !o.target || o.target.parent === o && 0 === o.target.position.x && 0 === o.target.position.y && -1 === o.target.position.z || console.warn("v3d.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), (o = O.extensions.KHR_lights_punctual.lights).push(i), o.length - 1)
                };
                else if (e.isLight && !t) return console.warn("v3d.GLTFExporter: Only directional, point, and spot lights are supported.", e), null;
                if (e.isSkinnedMesh && !t && v.push(e), 0 < e.children.length) {
                    for (var s = [], l = 0, c = e.children.length; l < c; l++) {
                        var u = b(e.children[l]);
                        null !== u && s.push(u)
                    }
                    0 < s.length && (a.children = s)
                }
                O.nodes.push(a);
                a = O.nodes.length - 1;
                return d.set(e, a), a
            }

            function o(e) {
                O.scenes || (O.scenes = [], O.scene = 0);
                var t = {};
                "" !== e.name && (t.name = e.name), O.scenes.push(t);
                for (var n = [], r = 0, i = e.children.length; r < i; r++) {
                    var a = b(e.children[r]);
                    null !== a && n.push(a)
                }
                0 < n.length && (t.nodes = n), B(e, t)
            }! function(e) {
                e = e instanceof Array ? e : [e];
                for (var t = [], n = 0; n < e.length; n++) e[n] instanceof _a ? o(e[n]) : t.push(e[n]);
                for (0 < t.length && function(e) {
                        var t = new _a;
                        t.name = "AuxScene";
                        for (var n = 0; n < e.length; n++) t.children.push(e[n]);
                        o(t)
                    }(t), n = 0; n < v.length; ++n) ! function(e) {
                    var t = O.nodes[d.get(e)],
                        n = e.skeleton;
                    if (void 0 !== n) {
                        var r = e.skeleton.bones[0];
                        if (void 0 !== r) {
                            for (var i = [], a = new Float32Array(16 * n.bones.length), o = new Matrix4, s = 0; s < n.bones.length; ++s) i.push(d.get(n.bones[s])), o.copy(n.boneInverses[s]), o.multiply(e.bindMatrix).toArray(a, 16 * s);
                            void 0 === O.skins && (O.skins = []), O.skins.push({
                                inverseBindMatrices: U(new ri(a, 16)),
                                joints: i,
                                skeleton: d.get(r)
                            }), t.skin = O.skins.length - 1
                        }
                    }
                }(v[n]);
                for (n = 0; n < h.animations.length; ++n) ! function(e, t) {
                    O.animations || (O.animations = []);
                    for (var n = (e = jx.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, r = [], i = [], a = 0; a < n.length; ++a) {
                        var o = n[a],
                            s = wf.parseTrackName(o.name),
                            l = wf.findNode(t, s.nodeName),
                            c = Wx[s.propertyName];
                        if ("bones" === s.objectName && (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(s.objectIndex) : void 0), !l || !c) return console.warn('v3d.GLTFExporter: Could not export animation track "%s".', o.name);
                        var u, s = o.values.length / o.times.length;
                        c === Wx.morphTargetInfluences && (s /= l.morphTargetInfluences.length), !0 === o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (u = "CUBICSPLINE", s /= 3) : u = o.getInterpolation() === It ? "STEP" : "LINEAR", i.push({
                            input: U(new ri(o.times, 1)),
                            output: U(new ri(o.values, s)),
                            interpolation: u
                        }), r.push({
                            sampler: i.length - 1,
                            target: {
                                node: d.get(l),
                                path: c
                            }
                        })
                    }
                    O.animations.push({
                        name: e.name || "clip_" + O.animations.length,
                        samplers: i,
                        channels: r
                    }), O.animations.length
                }(h.animations[n], e[0])
            }(e), Promise.all(m).then(function() {
                var l, e = new Blob(n, {
                        type: "application/octet-stream"
                    }),
                    t = Object.keys(N);
                0 < t.length && (O.extensionsUsed = t), O.buffers && 0 < O.buffers.length && (O.buffers[0].byteLength = e.size), !0 === h.binary ? ((l = new window.FileReader).readAsArrayBuffer(e), l.onloadend = function() {
                    var e = _(l.result),
                        t = new DataView(new ArrayBuffer(8));
                    t.setUint32(0, e.byteLength, !0), t.setUint32(4, 5130562, !0);
                    var n = _(function(e) {
                            if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(e).buffer;
                            for (var t = new Uint8Array(new ArrayBuffer(e.length)), n = 0, r = e.length; n < r; n++) {
                                var i = e.charCodeAt(n);
                                t[n] = 255 < i ? 32 : i
                            }
                            return t.buffer
                        }(JSON.stringify(O)), 32),
                        r = new DataView(new ArrayBuffer(8));
                    r.setUint32(0, n.byteLength, !0), r.setUint32(4, 1313821514, !0);
                    var i = new ArrayBuffer(12),
                        a = new DataView(i);
                    a.setUint32(0, 1179937895, !0), a.setUint32(4, 2, !0);
                    var o = 12 + r.byteLength + n.byteLength + t.byteLength + e.byteLength;
                    a.setUint32(8, o, !0);
                    var e = new Blob([i, r, n, t, e], {
                            type: "application/octet-stream"
                        }),
                        s = new window.FileReader;
                    s.readAsArrayBuffer(e), s.onloadend = function() {
                        c(s.result)
                    }
                }) : O.buffers && 0 < O.buffers.length ? ((l = new window.FileReader).readAsDataURL(e), l.onloadend = function() {
                    var e = l.result;
                    O.buffers[0].uri = e, c(O)
                }) : c(O)
            })
        }
    }, jx.Utils = {
        insertKeyframe: function(e, t) {
            var n, r = e.getValueSize(),
                i = new e.TimeBufferType(e.times.length + 1),
                a = new e.ValueBufferType(e.values.length + r),
                o = e.createInterpolant(new e.ValueBufferType(r));
            if (0 === e.times.length) {
                i[0] = t;
                for (var s = 0; s < r; s++) a[s] = 0;
                n = 0
            } else if (t < e.times[0]) {
                if (Math.abs(e.times[0] - t) < .001) return 0;
                i[0] = t, i.set(e.times, 1), a.set(o.evaluate(t), 0), a.set(e.values, r), n = 0
            } else if (t > e.times[e.times.length - 1]) {
                if (Math.abs(e.times[e.times.length - 1] - t) < .001) return e.times.length - 1;
                i[i.length - 1] = t, i.set(e.times, 0), a.set(e.values, 0), a.set(o.evaluate(t), e.values.length), n = i.length - 1
            } else
                for (s = 0; s < e.times.length; s++) {
                    if (Math.abs(e.times[s] - t) < .001) return s;
                    if (e.times[s] < t && e.times[s + 1] > t) {
                        i.set(e.times.slice(0, s + 1), 0), i[s + 1] = t, i.set(e.times.slice(s + 1), s + 2), a.set(e.values.slice(0, (s + 1) * r), 0), a.set(o.evaluate(t), (s + 1) * r), a.set(e.values.slice((s + 1) * r), (s + 2) * r), n = s + 1;
                        break
                    }
                }
            return e.times = i, e.values = a, n
        },
        mergeMorphTargetTracks: function(e, t) {
            for (var n = [], r = {}, i = e.tracks, a = 0; a < i.length; ++a) {
                var o = i[a],
                    s = wf.parseTrackName(o.name),
                    l = wf.findNode(t, s.nodeName);
                if ("morphTargetInfluences" === s.propertyName && void 0 !== s.propertyIndex) {
                    if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("v3d.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                        console.warn("v3d.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (o = o.clone()).setInterpolation(Ft)
                    }
                    var c = l.morphTargetInfluences.length,
                        u = l.morphTargetDictionary[s.propertyIndex];
                    if (void 0 === u) throw new Error("v3d.GLTFExporter: Morph target name not found: " + s.propertyIndex);
                    if (void 0 !== r[l.uuid]) {
                        for (var d = o.createInterpolant(new o.ValueBufferType(1)), h = r[l.uuid], f = 0; f < h.times.length; f++) h.values[f * c + u] = d.evaluate(h.times[f]);
                        for (f = 0; f < o.times.length; f++) {
                            var p = this.insertKeyframe(h, o.times[f]);
                            h.values[p * c + u] = o.values[f]
                        }
                    } else {
                        for (var m = new(h = o.clone()).ValueBufferType(c * h.times.length), f = 0; f < h.times.length; f++) m[f * c + u] = h.values[f];
                        h.name = (s.nodeName || "") + ".morphTargetInfluences", h.values = m, r[l.uuid] = h, n.push(h)
                    }
                } else n.push(o)
            }
            return e.tracks = n, e
        }
    };
    "undefined" != typeof __V3D_DEVTOOLS__ && __V3D_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: REVISION
        }
    }));
    vf = Mi();
    vf.v3d && (vf.THREE = vf.v3d), "undefined" != typeof document && ((vf = document.createElement("style")).appendChild(document.createTextNode(".v3d-container {\n    \n    overflow: hidden;\n    z-index: 0;\n}\n.v3d-canvas {\n    \n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    \n    z-index: -1;\n}\n.v3d-simple-preloader-background {\n    background-color: #fff;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 1;\n    height: 100%;\n    width: 100%;\n}\n.v3d-simple-preloader-container {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -90px;\n    margin-left: -90px;\n    width: 180px;\n    height: 180px;\n}\n.v3d-simple-preloader-bar {\n    background: linear-gradient(90deg, #1458ae, #4388e0);\n    width: 0%;\n    height: 3px;\n    margin: 15px -1px;\n    border: 1px solid;\n    border-radius: 5px;\n    border-color: #2b70c7;\n}\n.v3d-simple-preloader-logo {\n    width: 110px;\n    height: 120px;\n    background-repeat: no-repeat;\n    margin: 20px auto;\n}\n.v3d-annotation {\n    position: absolute;\n    top: -16px;\n    left: -16px;\n    width: auto;\n    min-width: 14px;\n    height: 26px;\n    padding: 2px 8px;\n    border: 1px solid #fff;\n    border-radius: 18px;\n    font-size: 16px;\n    font-family: sans-serif;\n    line-height: 26px;\n    color: #fff;\n    text-align: center;\n    user-select: none;\n    background: rgba(0, 0, 0, 0.8);\n}\n.v3d-annotation-transparent {\n    opacity: 0.5;\n}\n.v3d-annotation-dialog {\n    position: absolute;\n    top: 0;\n    left: 0;\n    margin-left: 15px;\n    margin-top: 31px;\n    font-family: sans-serif;\n    user-select: none;\n    padding: 1em;\n    min-width: 200px;\n    color: #fff;\n    background: rgba(0, 0, 0, 0.8);\n    border-radius: .5em;\n    font-size: 12px;\n    line-height: 1.2;\n    transition: opacity .5s;\n    visibility: hidden;\n}\n.v3d-webgl-error {\n    color: #015fb1;\n    background-color: white;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -44px;\n    margin-left: -256px;\n    text-align: center;\n    border-style: solid;\n    border-width: 3px;\n    border-radius: 8px;\n    border-color: #015fb1;\n    font-size: 20px;\n    font-family: sans-serif;\n    padding: 10px;\n    line-height: 30px;\n    z-index: 10;\n}\n@media only screen and (max-width: 540px) {\n    .v3d-webgl-error {\n        top: 50%;\n        left: 10px;\n        right: 10px;\n        margin-top: -58px;\n        margin-left: 0px;\n    }\n}\n.v3d-webgl-error-link {\n    color: #015fb1;\n}\n.v3d-device-motion-permissions-dialog {\n    z-index: 1;\n    position: absolute;\n    width: 100%;\n    background-color: #f00;\n    color: #000;\n    text-align: center;\n    padding: 10px;\n}\n")), document.head.insertBefore(vf, document.head.firstChild)), t.ACESFilmicToneMapping = D, t.AVERAGE = 1, t.AddEquation = Q, t.AddOperation = C, t.AdditiveAnimationBlendMode = 2501, t.AdditiveBlending = X, t.AlphaFormat = d, t.AlwaysDepth = Ae, t.AlwaysStencilFunc = tn, t.AmbientLight = Ah, t.AmbientLightProbe = Yh, t.AnimationClip = Dd, t.AnimationLoader = Ud, t.AnimationMixer = Tf, t.AnimationObjectGroup = Sf, t.AnimationUtils = Md, t.Annotation = Ex, t.AnnotationControl = Tx, t.App = gf, t.AppUtils = Og, t.ArcCurve = qd, t.ArrayCamera = Ss, t.ArrowHelper = dp, t.Audio = af, t.AudioAnalyser = df, t.AudioContext = Wh, t.AudioListener = rf, t.AudioLoader = Hh, t.AxesHelper = hp, t.AxisHelper = function(e) {
        return console.warn("v3d.AxisHelper has been renamed to v3d.AxesHelper."), new hp(e)
    }, t.BackSide = ae, t.BasicDepthPacking = qt, t.BasicShadowMap = K, t.BilinearShadowMap = re, t.BinaryTextureLoader = function(e) {
        return console.warn("v3d.BinaryTextureLoader has been renamed to v3d.DataTextureLoader."), new Wd(e)
    }, t.BlenderTextBufferGeometry = cu, t.BlenderTextGeometry = lu, t.BloomPass = lg, t.BokehPass = cg, t.Bone = fl, t.BooleanKeyframeTrack = Ad, t.BoundingBoxHelper = function(e, t) {
        return console.warn("v3d.BoundingBoxHelper has been deprecated. Creating a v3d.BoxHelper instead."), new sp(e, t)
    }, t.Box2 = Df, t.Box3 = Ln, t.Box3Helper = lp, t.BoxBufferGeometry = ea, t.BoxGeometry = Zl, t.BoxHelper = sp, t.BrightnessContrastPass = dg, t.BufferAttribute = ri, t.BufferGeometry = Oi, t.BufferGeometryLoader = Oh, t.BufferGeometryUtils = _f, t.ByteType = i, t.CENTER = Um, t.CSVParser = mx, t.Cache = Nd, t.Camera = sa, t.CameraHelper = np, t.CameraUtils = px, t.CanvasRenderer = function() {
        console.error("v3d.CanvasRenderer has been removed")
    }, t.CanvasTexture = Gl, t.CatmullRomCurve3 = eh, t.ChildOfConstraint = kv, t.CineonToneMapping = R, t.CircleBufferGeometry = Ql, t.CircleGeometry = Kl, t.ClampToEdgeWrapping = V, t.ClearMaskPass = mg, t.Clock = Kh, t.ClosedSplineCurve3 = vp, t.Color = Qr, t.ColorKeyframeTrack = Td, t.Compat = Ng, t.CompressedTexture = Vl, t.CompressedTextureLoader = Vd, t.ConeBufferGeometry = tc, t.ConeGeometry = ec, t.Constraint = Iv, t.CopyLocationConstraint = Bv, t.CopyRotationConstraint = zv, t.CopyScaleConstraint = Uv, t.CubeCamera = ca, t.CubeCopy = ig, t.CubeGeometry = Zl, t.CubeReflectionMapping = N, t.CubeRefractionMapping = I, t.CubeTexture = ua, t.CubeTextureHelper = Ax, t.CubeTextureLoader = jd, t.CubeUVReflectionMapping = B, t.CubeUVRefractionMapping = z, t.CubicBezierCurve = ih, t.CubicBezierCurve3 = ah, t.CubicInterpolant = wd, t.CullFaceBack = j, t.CullFaceFront = W, t.CullFaceFrontBack = 3, t.CullFaceNone = G, t.Curve = Xd, t.CurvePath = ph, t.CustomBlending = Z, t.CustomToneMapping = 5, t.CylinderBufferGeometry = Jl, t.CylinderGeometry = $l, t.Cylindrical = Pf, t.DataTexture = ha, t.DataTexture2DArray = ka, t.DataTexture3D = Ba, t.DataTextureLoader = Wd, t.DataUtils = mp, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = Fd, t.DepthFormat = Ke, t.DepthStencilFormat = Je, t.DepthTexture = jl, t.Detector = Es, t.DirectionalLight = Sh, t.DirectionalLightHelper = $f, t.DiscreteInterpolant = wu, t.DodecahedronBufferGeometry = rc, t.DodecahedronGeometry = ic, t.DoubleSide = oe, t.DstAlphaFactor = ye, t.DstColorFactor = be, t.DynamicBufferAttribute = function(e, t) {
        return console.warn("v3d.DynamicBufferAttribute has been removed. Use new v3d.BufferAttribute().setUsage(v3d.DynamicDrawUsage) instead."), new ri(e, t).setUsage(rn)
    }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = rn, t.DynamicReadUsage = 35049, t.ESMDistancePacking = Kt, t.ESMShadowMap = te, t.EdgesGeometry = cc, t.EdgesHelper = function(e, t) {
        return console.warn("v3d.EdgesHelper has been removed. Use v3d.EdgesGeometry instead."), new Rl(new cc(e.geometry), new Ml({
            color: void 0 !== t ? t : 16777215
        }))
    }, t.EffectComposer = Ig, t.EllipseCurve = Yd, t.EqualDepth = Ce, t.EqualStencilFunc = 514, t.EquiCube = ag, t.EquirectangularReflectionMapping = F, t.EquirectangularRefractionMapping = k, t.Euler = ur, t.EventDispatcher = n, t.ExtrudeBufferGeometry = Pc, t.ExtrudeGeometry = Dc, t.FXAAPass = hg, t.Face3 = Kr, t.Face4 = function(e, t, n, r, i, a, o) {
        return console.warn("v3d.Face4 has been removed. A v3d.Face3 will be created instead."), new Kr(e, t, n, i, a, o)
    }, t.FaceColors = 1, t.FileLoader = zd, t.FilmicBlenderToneMapping = O, t.FirstPersonControls = $v, t.FlatShading = 1, t.Float16BufferAttribute = di, t.Float32Attribute = function(e, t) {
        return console.warn("v3d.Float32Attribute has been removed. Use new v3d.Float32BufferAttribute() instead."), new hi(e, t)
    }, t.Float32BufferAttribute = hi, t.Float64Attribute = function(e, t) {
        return console.warn("v3d.Float64Attribute has been removed. Use new v3d.Float64BufferAttribute() instead."), new fi(e, t)
    }, t.Float64BufferAttribute = fi, t.FloatType = Xe, t.FloorConstraint = Vv, t.FlyingControls = eg, t.Fog = Bs, t.FogExp2 = ks, t.Font = Vh, t.FontLoader = jh, t.FrontSide = ie, t.Frustum = ma, t.GLBufferAttribute = Lf, t.GLSL1 = "100", t.GLSL3 = an, t.GLTFExporter = jx, t.GLTFLoader = W_, t.GammaEncoding = r, t.Geometry = ql, t.GeometryUtils = yp, t.GraphUtils = Su, t.GrayscalePass = fg, t.GreaterDepth = Re, t.GreaterEqualDepth = Le, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = qf, t.Group = As, t.HalfFloatType = Ye, t.HemisphereLight = _h, t.HemisphereLightHelper = Yf, t.HemisphereLightProbe = Xh, t.IBLEnvironmentPMREM = cn, t.IBLEnvironmentProbe = 2, t.IBLEnvironmentProbeCubemap = 1, t.IcosahedronBufferGeometry = Oc, t.IcosahedronGeometry = Nc, t.ImageBitmapLoader = zh, t.ImageLoader = Gd, t.ImageUtils = _n, t.ImmediateRenderObject = Ff, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Dh, t.InstancedBufferGeometry = Rh, t.InstancedInterleavedBuffer = Cf, t.InstancedMesh = bl, t.Int16Attribute = function(e, t) {
        return console.warn("v3d.Int16Attribute has been removed. Use new v3d.Int16BufferAttribute() instead."), new si(e, t)
    }, t.Int16BufferAttribute = si, t.Int32Attribute = function(e, t) {
        return console.warn("v3d.Int32Attribute has been removed. Use new v3d.Int32BufferAttribute() instead."), new ci(e, t)
    }, t.Int32BufferAttribute = ci, t.Int8Attribute = function(e, t) {
        return console.warn("v3d.Int8Attribute has been removed. Use new v3d.Int8BufferAttribute() instead."), new ii(e, t)
    }, t.Int8BufferAttribute = ii, t.IntType = s, t.InterleavedBuffer = zs, t.InterleavedBufferAttribute = Gs, t.Interpolant = Mu, t.InterpolateDiscrete = It, t.InterpolateLinear = Ft, t.InterpolateSmooth = kt, t.InvertStencilOp = 5386, t.JSONLoader = function() {
        console.error("v3d.JSONLoader has been removed.")
    }, t.KeepStencilOp = en, t.KeyframeTrack = Sd, t.Keys = Qv, t.LOD = ol, t.LatheBufferGeometry = Ic, t.LatheGeometry = Fc, t.Layers = fr, t.LensFlare = function() {
        console.error("v3d.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
    }, t.LessDepth = Te, t.LessEqualDepth = Ee, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = gh, t.LightProbe = Ch, t.LightProbeGenerator = Sy, t.LimitLocationConstraint = Gv, t.LimitRotationConstraint = jv, t.LimitScaleConstraint = Wv, t.Line = Cl, t.Line3 = If, t.LineBasicMaterial = Ml, t.LineCurve = oh, t.LineCurve3 = sh, t.LineDashedMaterial = xu, t.LineHTML = gx, t.LineLoop = Dl, t.LinePieces = 1, t.LineSegments = Rl, t.LineStrip = 0, t.LinearDepthPacking = 3202, t.LinearEncoding = Vt, t.LinearFilter = Ue, t.LinearInterpolant = Du, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = Ge, t.LinearMipmapNearestFilter = Ve, t.LinearToneMapping = Oe, t.Loader = kd, t.LoaderUtils = Ph, t.LoadingManager = Id, t.LockedTrackConstraint = Hv, t.LogLuvEncoding = Wt, t.LogarithmicMaxToneMapping = Ne, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = Nt, t.LuminanceAlphaFormat = f, t.LuminanceFormat = h, t.MOD_SUITE = on, t.MOUSE = de, t.MaskPass = pg, t.Material = $r, t.MaterialLoader = Lh, t.MaterialUtils = Nv, t.Math = mn, t.MathUtils = mn, t.Matrix3 = gn, t.Matrix4 = nr, t.MaxEquation = he, t.Mesh = Ki, t.MeshBVH = Hm, t.MeshBasicMaterial = ei, t.MeshDepthMaterial = ds, t.MeshDistanceMaterial = hs, t.MeshFaceMaterial = function(e) {
        return console.warn("v3d.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, t.MeshLambertMaterial = _u, t.MeshLine = vg, t.MeshLineIndexed = xg, t.MeshLineMaterial = Mg, t.MeshMaskMaterial = bu, t.MeshMatcapMaterial = yu, t.MeshNodeMaterial = _d, t.MeshNormalMaterial = gu, t.MeshPhongMaterial = mu, t.MeshPhysicalMaterial = pu, t.MeshStandardMaterial = fu, t.MeshToonMaterial = vu, t.MinEquation = ue, t.MirroredRepeatWrapping = Fe, t.MixOperation = E, t.MultiMaterial = function() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [];
        return console.warn("v3d.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function() {
            return e.slice()
        }, e
    }, t.MultiplyBlending = q, t.MultiplyOperation = T, t.NearestFilter = ke, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = ze, t.NearestMipmapNearestFilter = Be, t.NeverDepth = Se, t.NeverStencilFunc = 512, t.NoBlending = se, t.NoColors = 0, t.NoToneMapping = L, t.NormalAnimationBlendMode = 2500, t.NormalBlending = H, t.NotEqualDepth = De, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = Ed, t.Object3D = Er, t.ObjectLoader = Ih, t.ObjectSpaceNormalMap = $t, t.OctahedronBufferGeometry = kc, t.OctahedronGeometry = Bc, t.OneFactor = pe, t.OneMinusDstAlphaFactor = xe, t.OneMinusDstColorFactor = Me, t.OneMinusSrcAlphaFactor = _e, t.OneMinusSrcColorFactor = ve, t.OrbitControls = rg, t.OrthographicCamera = ms, t.OutlinePass = wg, t.PCFShadowMap = J, t.PCFShadowMapPoissonDisk = ne, t.PCFSoftShadowMap = $, t.PMREMGenerator = jy, t.ParametricBufferGeometry = zc, t.ParametricGeometry = Uc, t.Particle = function(e) {
        return console.warn("v3d.Particle has been renamed to v3d.Sprite."), new nl(e)
    }, t.ParticleBasicMaterial = function(e) {
        return console.warn("v3d.ParticleBasicMaterial has been renamed to v3d.PointsMaterial."), new Ol(e)
    }, t.ParticleSystem = function(e, t) {
        return console.warn("v3d.ParticleSystem has been renamed to v3d.Points."), new Bl(e, t)
    }, t.ParticleSystemMaterial = function(e) {
        return console.warn("v3d.ParticleSystemMaterial has been renamed to v3d.PointsMaterial."), new Ol(e)
    }, t.Pass = og, t.Path = mh, t.PerspectiveCamera = la, t.PhysicalMaxToneMapping = Ie, t.Plane = Rr, t.PlaneBufferGeometry = ba, t.PlaneGeometry = Vc, t.PlaneHelper = cp, t.PointCloud = function(e, t) {
        return console.warn("v3d.PointCloud has been renamed to v3d.Points."), new Bl(e, t)
    }, t.PointCloudMaterial = function(e) {
        return console.warn("v3d.PointCloudMaterial has been renamed to v3d.PointsMaterial."), new Ol(e)
    }, t.PointLight = bh, t.PointLightHelper = jf, t.Points = Bl, t.PointsMaterial = Ol, t.PolarGridHelper = Zf, t.PolyhedronBufferGeometry = nc, t.PolyhedronGeometry = Gc, t.PositionalAudio = uf, t.Preloader = _x, t.PropertyBinding = wf, t.PropertyMixer = hf, t.PuzzlesLoader = Sx, t.QuadraticBezierCurve = lh, t.QuadraticBezierCurve3 = ch, t.Quaternion = An, t.QuaternionKeyframeTrack = Ld, t.QuaternionLinearInterpolant = Cd, t.REVISION = Pe, t.RGBADepthPacking = Zt, t.RGBADistancePacking = Qt, t.RGBAFormat = Qe, t.RGBAIntegerFormat = _, t.RGBA_ASTC_10x10_Format = vt, t.RGBA_ASTC_10x5_Format = ft, t.RGBA_ASTC_10x6_Format = pt, t.RGBA_ASTC_10x8_Format = mt, t.RGBA_ASTC_12x10_Format = gt, t.RGBA_ASTC_12x12_Format = _t, t.RGBA_ASTC_4x4_Format = at, t.RGBA_ASTC_5x4_Format = ot, t.RGBA_ASTC_5x5_Format = st, t.RGBA_ASTC_6x5_Format = lt, t.RGBA_ASTC_6x6_Format = ct, t.RGBA_ASTC_8x5_Format = ut, t.RGBA_ASTC_8x6_Format = dt, t.RGBA_ASTC_8x8_Format = ht, t.RGBA_BPTC_Format = yt, t.RGBA_ETC2_EAC_Format = it, t.RGBA_PVRTC_2BPPV1_Format = tt, t.RGBA_PVRTC_4BPPV1_Format = et, t.RGBA_S3TC_DXT1_Format = x, t.RGBA_S3TC_DXT3_Format = b, t.RGBA_S3TC_DXT5_Format = M, t.RGBDEncoding = Yt, t.RGBEEncoding = jt, t.RGBEFormat = w, t.RGBELoader = V_, t.RGBFormat = Ze, t.RGBIntegerFormat = g, t.RGBM16Encoding = Xt, t.RGBM7Encoding = Ht, t.RGB_ETC1_Format = nt, t.RGB_ETC2_Format = rt, t.RGB_PVRTC_2BPPV1_Format = A, t.RGB_PVRTC_4BPPV1_Format = S, t.RGB_S3TC_DXT1_Format = y, t.RGFormat = m, t.RGIntegerFormat = v, t.RawShaderMaterial = hu, t.Ray = tr, t.Raycaster = Cs, t.RectAreaLight = Th, t.RectAreaLightUniformsLib = G_, t.RedFormat = $e, t.RedIntegerFormat = p, t.ReinhardToneMapping = P, t.RenderPass = Sg, t.RenderUtils = Cg, t.RepeatWrapping = U, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = ce, t.RingBufferGeometry = jc, t.RingGeometry = Wc, t.SAH = Vm, t.SRGB8_ALPHA8_ASTC_10x10_Format = Rt, t.SRGB8_ALPHA8_ASTC_10x5_Format = Ct, t.SRGB8_ALPHA8_ASTC_10x6_Format = Lt, t.SRGB8_ALPHA8_ASTC_10x8_Format = Pt, t.SRGB8_ALPHA8_ASTC_12x10_Format = Dt, t.SRGB8_ALPHA8_ASTC_12x12_Format = Ot, t.SRGB8_ALPHA8_ASTC_4x4_Format = xt, t.SRGB8_ALPHA8_ASTC_5x4_Format = bt, t.SRGB8_ALPHA8_ASTC_5x5_Format = Mt, t.SRGB8_ALPHA8_ASTC_6x5_Format = wt, t.SRGB8_ALPHA8_ASTC_6x6_Format = St, t.SRGB8_ALPHA8_ASTC_8x5_Format = At, t.SRGB8_ALPHA8_ASTC_8x6_Format = Tt, t.SRGB8_ALPHA8_ASTC_8x8_Format = Et, t.SSAARenderPass = Ag, t.SSAOPass = Lg, t.Scene = _a, t.SceneBackground = rx, t.SceneUtils = ix, t.ShaderChunk = Ma, t.ShaderLib = wa, t.ShaderMaterial = oa, t.ShaderPass = ug, t.ShadowMaterial = du, t.Shape = vh, t.ShapeBufferGeometry = Hc, t.ShapeGeometry = Xc, t.ShapePath = Uh, t.ShapeUtils = Ec, t.ShortType = a, t.SimplePreloader = yx, t.Skeleton = vl, t.SkeletonHelper = Gf, t.SkinnedMesh = hl, t.SmoothShading = 2, t.Sphere = Yn, t.SphereBufferGeometry = Yc, t.SphereGeometry = qc, t.Spherical = zu, t.SphericalHarmonics3 = Eh, t.Spline = _p, t.SplineCurve = uh, t.SplineCurve3 = gp, t.SpotLight = yh, t.SpotLightHelper = Bf, t.Sprite = nl, t.SpriteMaterial = js, t.SrcAlphaFactor = ge, t.SrcAlphaSaturateFactor = we, t.SrcColorFactor = me, t.StaticCopyUsage = 35046, t.StaticDrawUsage = nn, t.StaticReadUsage = 35045, t.Stats = ax, t.StereoCamera = Qh, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = Pd, t.SubtractEquation = le, t.SubtractiveBlending = Y, t.TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    }, t.TTFLoader = U_, t.TangentSpaceNormalMap = Jt, t.TargetConstraint = Fv, t.TeapotBufferGeometry = su, t.TetrahedronBufferGeometry = Zc, t.TetrahedronGeometry = Qc, t.TextBufferGeometry = Kc, t.TextGeometry = Jc, t.Texture = xn, t.TextureLoader = Hd, t.ToneMapPass = Rg, t.TorusBufferGeometry = $c, t.TorusGeometry = eu, t.TorusKnotBufferGeometry = tu, t.TorusKnotGeometry = nu, t.TrackToConstraint = Xv, t.Triangle = Gr, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = ru, t.TubeGeometry = iu, t.TweenCameraController = Jv, t.TweenLinear = un, t.TweenSpherical = 1, t.UVMapping = o, t.Uint16Attribute = function(e, t) {
        return console.warn("v3d.Uint16Attribute has been removed. Use new v3d.Uint16BufferAttribute() instead."), new li(e, t)
    }, t.Uint16BufferAttribute = li, t.Uint32Attribute = function(e, t) {
        return console.warn("v3d.Uint32Attribute has been removed. Use new v3d.Uint32BufferAttribute() instead."), new ui(e, t)
    }, t.Uint32BufferAttribute = ui, t.Uint8Attribute = function(e, t) {
        return console.warn("v3d.Uint8Attribute has been removed. Use new v3d.Uint8BufferAttribute() instead."), new ai(e, t)
    }, t.Uint8BufferAttribute = ai, t.Uint8ClampedAttribute = function(e, t) {
        return console.warn("v3d.Uint8ClampedAttribute has been removed. Use new v3d.Uint8ClampedBufferAttribute() instead."), new oi(e, t)
    }, t.Uint8ClampedBufferAttribute = oi, t.Uniform = Ef, t.UniformsLib = va, t.UniformsUtils = ra, t.UnsignedByteType = je, t.UnsignedInt248Type = qe, t.UnsignedIntType = He, t.UnsignedShort4444Type = l, t.UnsignedShort5551Type = c, t.UnsignedShort565Type = u, t.UnsignedShortType = We, t.V3DL = sn, t.VSMShadowMap = ee, t.Vector2 = vn, t.Vector3 = Tn, t.Vector4 = Mn, t.VectorKeyframeTrack = Rd, t.Vertex = function(e, t, n) {
        return console.warn("v3d.Vertex has been removed. Use v3d.Vector3 instead."), new Tn(e, t, n)
    }, t.VertexColors = 2, t.VideoTexture = Ul, t.ViewportFitAuto = 3, t.ViewportFitHorizontal = 2, t.ViewportFitNone = ln, t.ViewportFitVertical = 1, t.Visualizer = Qm, t.WebGL1Renderer = Fs, t.WebGLCubeRenderTarget = da, t.WebGLMultisampleRenderTarget = Sn, t.WebGLRenderTarget = wn, t.WebGLRenderTargetCube = function(e, t, n) {
        return console.warn("v3d.WebGLRenderTargetCube(width, height, options) is now WebGLCubeRenderTarget(size, options)."), new da(e, n)
    }, t.WebGLRenderer = Is, t.WebGLUtils = ws, t.WebXRUtils = yf, t.WireframeGeometry = au, t.WireframeHelper = function(e, t) {
        return console.warn("v3d.WireframeHelper has been removed. Use v3d.WireframeGeometry instead."), new Rl(new au(e.geometry), new Ml({
            color: void 0 !== t ? t : 16777215
        }))
    }, t.WrapAroundEnding = Ut, t.XHRLoader = function(e) {
        return console.warn("v3d.XHRLoader has been renamed to v3d.FileLoader."), new zd(e)
    }, t.XZ = kg, t.XZLoader = z_, t.ZeroCurvatureEnding = Bt, t.ZeroFactor = fe, t.ZeroSlopeEnding = zt, t.ZeroStencilOp = 0, t.acceleratedRaycast = ev, t.arrayMax = mi, t.arrayMin = function(e) {
        if (0 === e.length) return 1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] < t && (t = e[n]);
        return t
    }, t.clampArray = yi, t.computeBoundsTree = tv, t.disposeBoundsTree = nv, t.getGlobalScope = Mi, t.isDef = _i, t.loadModule = Si, t.sRGBEncoding = Gt, t.shaderFloatStr = bi, Object.defineProperty(t, "__esModule", {
        value: !0
    })
});